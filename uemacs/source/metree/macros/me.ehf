!   me
!   home
!   MicroEmacs
!   Contents
| home
MicroEmacs 2009
|

| osd-help(3)
    Help on help
| Help Information
    Help commands
| Frequently Asked Questions
    Frequently Asked Questions
| Installation
    Installation
| Contact Information
    Contact Information
| Copyright
    Copyright
|

|
Contents
|

| MainMenu(3)
    Top Main Menu
| Essential Commands
    Essential Commands
| Bindings(2)
    Key Bindings
|

| File Handling Commands
    File Handling
| Dialogs and Menus
    Dialogs and Menus
| Cursor Movement Commands
    Cursor Movement
| Insertion and Deletion Commands
    Insertion and Deletion
| Paragraph and Text Formatting Commands
    Paragraph and Text Formatting
| Capitalization and Transposition Commands
    Capitalization and Transposition
| Searching and Replacing
    Searching and Replacing
| Macro Commands
    Macro Commands
| Buffer Manipulation Commands
    Buffer Manipulation
| Window Commands
    Window Manipulation
|

| Keyboard Binding Commands
    Keyboard Binding
| Operating Modes
    Operating Modes
| Shell and Command Controls
    Shell and Command Controls
| Spelling Commands
    Spelling Commands
| Hilighting, Color and Screen Appearance
    Hilighting, Screen Appearance
| Comparison and Differencing
    Comparison and Differencing
| Short Cuts and Abbreviations
    Short Cuts and Abbreviations
| Message Line Commands
    Message Line Commands
| Printing Commands
    Printing
| Macro Development Commands
    Macro Development
| Registry
    Registry
| Command Line Filters
    Command Line Filters
| MicroEmacs 2009 - Games
    Games
|

|
Glossaries
|

| Command Glossary
    Command Glossary
| Variable Glossary
    Variable Glossary
| Macro Language Glossary
    Macro Language Glossary
| Global Glossary
    Global Glossary
|

|
Miscellaneous Information
|

| languageTemplates(2)
    Language Templates
| fileHooks(2)
    File Hooks
| Editor File Types
    Editor Files
| Compatibility(2)
    Compatibility
| Interfacing(2)
    Interfacing to external components
| MicroEmacs 2009 - Supported File Types
    Supported File Types
| Client-Server(2)
    Client-Server Interface
| RegularExpressions(2)
    Regular Expressions
| Build(2)
    Building the software

cEcEMICROEMACS cEcA


    cDMicroEmacscA, JASSPA Distribution, is defined as follows, refer to lslmme(1)le for
    a description of the command line variables.

    The following sections describe the topics that are available as part of
    the on-line cDMicroEmacscA manual pages.

    lsMicroEmacs - AcknowledgmentslmAcknowledgmentsle, lslmCopyrightle, lsMicroEmacs - HistorylmHistoryle and lslmContact Informationle.
    lslmFrequently Asked Questionsle.

    See lslmHelp!le for some information on using the hypertext manual pages.

        lsInstallation(1)lmInstallation Informationle
        lsPatching(1)lmInstallation Patching Informationle
        lsUserProfiles(2)lmSetting Up A User Profilele
        lsCompanyProfiles(2)lmSetting Up a Company Profilele

        lsMainMenu(3)lmTop Main Menule
        lslmEssential Commandsle
        lslmHelp Informationle
        lsBindings(2)lmKey Bindingsle

        lslmFile Handling Commandsle
        lslmDialogs and Menusle
        lslmCursor Movement Commandsle
        lslmInsertion and Deletion Commandsle
        lslmParagraph and Text Formatting Commandsle
        lslmCapitalization and Transposition Commandsle
        lslmSearching and Replacingle
        lslmMacro Commandsle
        lslmBuffer Manipulation Commandsle
        lslmWindow Commandsle

        lslmKeyboard Binding Commandsle
        lslmOperating Modesle
        lslmShell and Command Controlsle
        lslmSpelling Commandsle
        lslmHilighting, Color and Screen Appearancele
        lsComparison and DifferencinglmComparison and Differencing Commandsle
        lslmShort Cuts and Abbreviationsle
        lslmMessage Line Commandsle
        lslmPrinting Commandsle
        lsmacroWriting(4)lmWriting MicroEmacs Macrosle
        lslmMacro Development Commandsle
        lsRegistrylmRegistry Commandsle
        lslmCommand Line Filtersle
        lsMicroEmacs - GameslmGamesle


cEGlossaries cA


    lslmCommand Glossaryle
    lslmVariable Glossaryle
    lslmMacro Language Glossaryle
    lslmGlobal Glossaryle


cEMiscellaneous Information cA


    The following topics provide more in depth information:-

        lslanguageTemplates(2)lmLanguage Templatesle
        lsfileHooks(2)lmFile Hooksle
        lsEditor File TypeslmEditor Filesle
        lsCompatibility(2)lmCompatibility with the original MicroEMACSle
        lsInterfacing(2)lmInterfacing to external componentsle
        lsMicroEmacs - Supported File TypeslmSupported File Typesle
        lsClient-Server(2)lmClient-Server Interfacele
        lsRegularExpressions(2)lmRegular Expressionsle
        lsBuild(2)lmBuilding the sourcele
!   Help!
cEcEHelp! cEcA


    The on-line manual pages are defined as follows:-

        [logo] cDTitlecA
        [link1][link2]..[linkn]

    The components of the header are defined as follows:-

    cC[logo]cA
        The MicroEmacs Logo in the top left hand corner of the screen exists
        on every page and hides a hypertext link. Selecting this item will
        take you back to the main lslmMicroEmacsle page (Only present on HTML and
        Windows help pages).

    cDTitle cA
        The title identifies the title of the topic that you are viewing.

    cD[link] cA
        The link line provides quick links to other related material in the
        on-line manual pages. Use these to take you to a chosen topic. The
        cD[home]cA link returns to the contents page of the currently viewed
        topic, this is equivalent to the cDContentscA button when viewing
        Microsoft Windows help files.


cESection Numbering cA


    The section numbering conventions used in these pages is defined as
    follows:-

        (1) - Executable command line.
        (2) - Editor built in commands.
        (2m) - Editor built in modes.
        (3) - Editor commands implemented as macros.
        (4) - Editor macro language syntax
        (5) - Editor variables
        (8) - Editor specific file formats
!   Essential Commands
cEcEESSENTIAL COMMANDS cEcA


    The very essential commands which are the most important commands to know
    include:

    lslmabort-command(2)le (cDC-gcA) Abort command
    lslmbackward-char(2)le (cDC-bcA) Move the cursor left
    lslmbackward-delete-char(2)le (cDbackspacecA) Delete the previous character at the
    cursor position
    lslmbackward-line(2)le (cDC-pcA) Move the cursor to the previous line
    lslmfile-browser(3)le (cDf10cA) Browse the file system
    lslmfile-browser-close(3)le Close the file-browser
    lslmfile-browser-swap-buffers(3)le Swap between file-browser windows
    lslmforward-char(2)le (cDC-fcA) Move the cursor right
    lslmforward-delete-char(2)le (cDC-dcA) Delete the next character at the cursor
    position
    lslmforward-line(2)le (cDC-ncA) Move the cursor to the next line
    lslmisearch-forward(2)le (cDC-scA) Search forward incrementally (interactive)
    lslmquick-exit(2)le (cDesc zcA) Exit the editor writing changes
    lslmsave-buffer(2)le (cDC-x C-scA) Save contents of changed buffer to file
    lslmsave-buffers-exit-emacs(2)le (cDesc zcA) Exit the editor prompt user to write
    changes
    lslmundo(2)le (cDC-x ucA) Undo the last edit
!   Cursor Movement Commands
cEcECURSOR MOVEMENT COMMANDS cEcA


    The cursor movement commands control how the cursor is moved around the
    buffer.


cECommands cA


    lslmbackward-char(2)le (cDC-bcA) Move the cursor left
    lslmbackward-line(2)le (cDC-pcA) Move the cursor to the previous line
    lslmbackward-paragraph(2)le (cDesc pcA) Move the cursor to the previous paragraph
    lslmbackward-word(2)le (cDesc bcA) Move the cursor to the previous word
    lslmbeginning-of-buffer(2)le (cDesc <cA) Move to beginning of buffer/file
    lslmbeginning-of-line(2)le (cDC-acA) Move to beginning of line
    lslmdisplay-matching-fence(3)le Display the matching bracket
    lslmend-of-buffer(2)le (cDesc >cA) Move to end of buffer/file
    lslmend-of-line(2)le (cDC-ecA) Move to end of line
    lslmforward-char(2)le (cDC-fcA) Move the cursor right
    lslmforward-line(2)le (cDC-ncA) Move the cursor to the next line
    lslmforward-paragraph(2)le (cDesc ncA) Move the cursor to the next paragraph
    lslmforward-word(2)le (cDesc fcA) Move the cursor to the next word
    lslmgoto-line(2)le (cDesc gcA) Move the cursor to specified line
    lslmgoto-matching-fence(2)le (cDesc C-fcA) Move the cursor to matching fence
    lslmgoto-position(2)le Restore a stored position
    lslmgoto-window(2)le Restore a saved window to the current window (historic)
    lslmlist-commands(2)le (cDC-h ccA) List available commands
    lslmlist-variables(2)le (cDC-h vcA) List defined variables
    lslmpage-file-backward-line(3)le (cDC-pcA) Move backwards one line in paged buffer
    lslmpage-file-beginning-of-buffer(3)le Move to the start of the paged file
    lslmpage-file-end-of-buffer(3)le Move to the end of the paged file
    lslmpage-file-forward-line(3)le (cDC-ncA) Move forwards one line in paged buffer
    lslmpage-file-goto-byte(3)le Page to the buffer byte offset
    lslmpage-file-goto-page(3)le Move to page
    lslmrecenter(2)le (cDC-lcA) Recenter the window (refresh the screen)
    lslmset-position(2)le Store the current position
    lslmset-window(2)le Save the current window for restore (historic)
    lslmuniversal-argument(2)le (cDC-ucA) Set the command argument count


cEVariables cA


    lslm$fmatchdelay(5)le Fence matching delay time
    lslm$pause-time(5)le Length of time to pause for user
!   Insertion and Deletion Commands
cEcEINSERTION AND DELETION COMMANDS cEcA


    Commands that initiate insertion or deletion of text include:


cEDeletion cA


    lslmbackward-delete-char(2)le (cDbackspacecA) Delete the previous character at the
    cursor position
    lslmbackward-delete-tab(2)le (cDS-tabcA) Delete white space to previous tab-stop
    lslmbackward-kill-word(2)le (cDesc backspacecA) Delete the previous word at the
    cursor position
    lslmclean(3)le Remove redundant white spaces from the current buffer
    lslmcopy-rectangle(3)le Copy a rectangular region of text
    lslmdelete-blank-lines(2)le (cDC-x C-ocA) Delete blank lines about cursor
    lslmdelete-indentation(3)le Join 2 lines deleting white spaces
    lslmfold-kill(3)le (cDC-x C-kcA) Delete the fold and all its contents
    lslmforward-delete-char(2)le (cDC-dcA) Delete the next character at the cursor
    position
    lslmforward-kill-word(2)le (cDesc dcA) Delete the next word at the cursor position
    lslmkill-line(2)le (cDC-kcA) Delete all characters to the end of the line
    lslmkill-paragraph(2)le Delete a paragraph
    lslmkill-rectangle(2)le (cDesc C-wcA) Delete a column of text
    lslmkill-region(2)le (cDC-wcA) Delete all characters in the marked region
    lslmyank-rectangle(2)le (cDesc C-ycA) Insert a column of text
    lslmyank-rectangle-overwrite(3)le Insert a column of text with overwrite


cEInsertion cA


    lslmcopy-rectangle(3)le Copy a rectangular region of text
    lslminsert-newline(2)le (cDC-ocA) Insert new line at cursor position
    lslminsert-tab(2)le (cDC-icA) Insert tab(s) into current buffer
    lslmkill-rectangle(2)le (cDesc C-wcA) Delete a column of text
    lslmnormal-tab(3)le Insert a normal tab
    lslmopen-line(3)le (cDC-ocA) Open new line at cursor position
    lslmquote-char(2)le (cDC-qcA) Insert literal character
    lslmreyank(2)le (cDesc ycA) Restore next yank buffer
    lslmtab(2)le (cDtabcA) Handle the tab key
    lslmyank(2)le (cDC-ycA) Paste (copy) kill buffer contents into buffer
    lslmyank-rectangle(2)le (cDesc C-ycA) Insert a column of text
    lslmyank-rectangle-overwrite(3)le Insert a column of text with overwrite


cEVariables cA


    lslm$buffer-tab-width(5)le Buffer tab character interval
    lslm$tab-width(5)le Global displayable tab character width
!   Paragraph and Text Formatting Commands
cEcEPARAGRAPH AND TEXT FORMATTING COMMANDS cEcA


    Commands that operate on paragraphs, and the layout of paragraphs:


cEParagraph cA


    Paragraphs are separated by blank lines. A single paragraph is defined as
    all of the text enclosed between two blank lines, with no intervening
    blank lines.

    lslmbackward-paragraph(2)le (cDesc pcA) Move the cursor to the previous paragraph
    lslmfill-paragraph(2)le (cDesc ocA) Format a paragraph
    lslmforward-paragraph(2)le (cDesc ncA) Move the cursor to the next paragraph
    lslmifill-paragraph(3)le (cDesc qcA) Format a paragraph
    lslmkill-paragraph(2)le Delete a paragraph
    lslmparagraph-to-line(3)le Convert a paragraph to a single line
    lslmwrap-word(2)le Wrap word onto next line


cERegions and Marks cA


    A region is the text located between the cDpointcA (the current cursor
    position) and the cDmarkcA defined by lsset-mark(2)lmset-markle.

    lslmcopy-rectangle(3)le Copy a rectangular region of text
    lslmcopy-region(2)le (cDesc wcA) Copy a region of the buffer
    lslmcount-words(2)le (cDesc C-ccA) Count the number of words in a region
    lslmexchange-point-and-mark(2)le (cDC-x C-xcA) Exchange the cursor and marked
    position
    lslmgoto-alpha-mark(2)le (cDC-x acA) Move the cursor to a alpha marked location
    lslmkill-rectangle(2)le (cDesc C-wcA) Delete a column of text
    lslmkill-region(2)le (cDC-wcA) Delete all characters in the marked region
    lslmset-alpha-mark(2)le (cDC-x C-acA) Place an alphabetic marker in the buffer
    lslmset-mark(2)le (cDesc spacecA) Set starting point of region
    lslmwrite-region(3)le Write contents of region to named (new) file
    lslmyank-rectangle(2)le (cDesc C-ycA) Insert a column of text
    lslmyank-rectangle-overwrite(3)le Insert a column of text with overwrite


cEVariables cA


    lslm$buffer-fill-col(5)le Buffer paragraph mode; right fill column
    lslm$buffer-fill-mode(5)le Buffer paragraph mode; justification method
    lslm$fill-bullet(5)le Paragraph filling bullet character set
    lslm$fill-bullet-len(5)le Paragraph filling bullet search depth
    lslm$fill-col(5)le Global paragraph mode; right fill column
    lslm$fill-eos(5)le Paragraph filling; end of sentence fill characters
    lslm$fill-eos-len(5)le Paragraph filling; end of sentence padding length
    lslm$fill-ignore(5)le Ignore paragraph filling character(s)
    lslm$fill-mode(5)le Global paragraph mode; justification method
!   Short Cuts and Abbreviations
cEcESHORT CUTS cEcA


    Automatic commands, history and automatic formatting modes such as
    lslmindent(2)le.


cECommands cA


    lslmabbrev-list(3)le Create a list of abbreviations
    lslmbuffer-abbrev-file(2)le Set buffers' abbreviation file
    lslmcomment-end(3)le End the current comment
    lslmcomment-line(3)le Comment out the current line
    lslmcomment-restyle(3)le Reformat the current comment
    lslmcomment-start(3)le Start a new comment
    lslmcomment-to-end-of-line(3)le Extend comment to end of line
    lslmencase(3)le Encase a text region with start/end string
    lslmexpand-abbrev(2)le Expand an abbreviation
    lslmexpand-abbrev-handle(3)le (cDesc esccA) Expand an abbreviation handler
    lslmexpand-iso-accents(3)le Expand an ISO accent
    lslmexpand-look-back(3)le Complete a word by looking back for a similar word
    lslmexpand-word(3)le Complete a word by invocation of the speller
    lslmfind-tag(2)le (cDesc tcA) Find tag, auto-load file and move to tag position
    lslmgenerate-tags-file(3)le Generate a tags file
    lslmglobal-abbrev-file(2)le Set global abbreviation file
    lslmindent(2)le Manage the auto-indentation methods
    lslminsert-password(3)le Create and insert a new password string
    lslmiso-accents-mode(3)le ISO accent expansion short-cut mode
    lslmnumber-items(3)le Renumber a vertical list of items
    lslmpassword-to-phonic(3)le Convert a password to phonic string
    lslmread-session(3)le Read in session information
    lslmsave-session(3)le Write session information to session file
    lslmuncomment-line(3)le Uncomment current line


cEVariables cA


    lslm%tag-file(5)le Tag file name
    lslm%tag-option(5)le Tag file search option
    lslm%tag-template(5)le Tag file search string
!   Registry
cEcEREGISTRY cEcA


    The registry commands provide an interface to manage the registry files
    defined by lslmerf(8)le. The registry is a mechanism which allows the binding of
    information to a hierarchical tree node, using a file system metaphor to
    access the data. cDMicroEmacscA uses a reserved root node cGhistorycA to save
    session information (see lslmsave-session(3)le).


cECommands cA


    lslmcopy-registry(3)le Recursive copy of registry subtree
    lslmdelete-registry(2)le Delete a registry tree
    lslmfind-registry(2)le Index search of a registry sub-tree
    lslmlist-registry(2)le Display the registry in a buffer
    lslmmark-registry(2)le Modify the operating mode of a registry node
    lslmread-registry(2)le Read in a registry definition file
    lslmsave-registry(2)le Write a registry definition file
    lslmset-registry(2)le Modify a node value in the registry


cEMacro Functions cA


    lslm&reg(4)le Retrieve a registry value (with default)
!   Command Line Filters
cEcECOMMAND LINE FILTERS cEcA


    MicroEmacs may be invoked from the command line to perform a specific set
    of filtering tasks, under control of a dedicated start up macro, see lslmme(1)le
    and lslmstart-up(3)le. A number of standard macros are provided, most of which
    are invoked automatically from the editor itself when requested by the
    user. Having said that, it has not been unknown for a colleague of mine to
    use the editor as a replacement for a more intelligent cDsed(1)cA filter, with
    12 hours to go and a huge ugly 3-D geometric database to convert, what
    better way than run it through a set of MicroEmacs macros to turn it into
    another database format that can be handled - probably not for the
    uninitiated, but that person did pull it off and went home for tea !!


cEMacro Command Line Filters cA


    lslm2dos(3f)le Convert text files to DOS format files.
    lslm2mac(3f)le Convert text files to Macintosh format files
    lslm2unix(3f)le Convert text files to UNIX format files
    lslm2win(3f)le Convert text files to Windows format files.
    lslmbenchmrk(3f)le Benchmark MicroEmacs macro processor speed
    lslmctags(3f)le Generate a C tags file
    lslmdos2unix(3f)le Convert DOS format files to UNIX format files
    lslmehftools(3f)le Generate a MicroEmacs help file
    lslmemftags(3f)le Generate a MicroEmacs macro tags file
    lslmfiletype(3f)le Determine file type UNIX, DOS or Windows
    lslmgdiff(3f)le Command line graphical file difference
    lslmjavatags(3f)le Generate a C tags file from Java sources
    lslmntags(3f)le Generate a nroff tags file
    lslmprintall(3f)le Formatted print job
    lslmtcltags(3f)le Generate a Tcl/Tk tags file
    lslmtextags(3f)le Generate a LaTeX/BibTeX tags file
    lslmunix2dos(3f)le Convert UNIX format files to DOS format files.
    lslmunix2win(3f)le Convert UNIX format files to Windows format files.


cEMacro Functions cA


    lslmshut-down(3)le Editor exit callback command
    lslmstart-up(3)le Editor startup callback command


cEMacro Variables cA
!   Searching and Replacing
cEcESEARCHING AND REPLACING cEcA


    Text searching and replacing commands:

    lslmfind(3)le Execute built-in find command
    lslmfind-setup(3)le Setup the built-in find and grep commands
    lslmgrep(3)le Search a file for a pattern
    lslmhunt-backward(2)le (cDC-x C-hcA) Resume previous search in backward direction
    lslmhunt-forward(2)le (cDC-x hcA) Resume previous search in forward direction
    lslmisearch-backward(2)le (cDC-rcA) Search backwards incrementally (interactive)
    lslmisearch-forward(2)le (cDC-scA) Search forward incrementally (interactive)
    lslmitem-list(3)le (cDF7cA) Abbreviated search and list buffer contents
    lslmitem-list-close(3)le (cDesc F7cA) Close the item list
    lslmitem-list-find(3)le Find the selected item in the item list
    lslmnarrow-search-backward(3)le (cDC-c rcA) Search for a string in the backward
    direction
    lslmnarrow-search-forward(3)le (cDC-c scA) Search for a string in the forward
    direction
    lslmoccur(3)le Regular expression search for occurrences
    lslmosd-search(3)le Search and annotate the current buffer
    lslmpage-file-isearch-backward(3)le (cDC-rcA) Page search backwards incrementally
    (interactive)
    lslmpage-file-isearch-forward(3)le (cDC-scA) Page search forward incrementally
    (interactive)
    lslmpage-file-search-backward(3)le (cDC-x rcA) Page search for a string in the
    backward direction
    lslmpage-file-search-buffer(3)le Search the page file buffer
    lslmpage-file-search-forward(3)le (cDC-x scA) Page search for a string in the
    forward direction
    lslmquery-replace-all-string(3)le Query replace string in a list of files
    lslmquery-replace-string(2)le (cDesc C-rcA) Search and replace a string - with query
    lslmquery-replace-string-in-files(3)le Conditionally search and replace strings
    across files
    lslmRegularExpressions(2)le Regular Expressions
    lslmreplace-all-pairs(3)le Replace string pairs in a list of files
    lslmreplace-all-string(3)le Replace string with new string in a list of files
    lslmreplace-string(2)le (cDesc rcA) Replace string with new string
    lslmreplace-string-in-files(3)le Search and replace strings across files
    lslmsearch-backward(2)le (cDC-x rcA) Search for a string in the backward direction
    lslmsearch-buffer(2)le Search the current buffer for a string
    lslmsearch-forward(2)le (cDC-x scA) Search for a string in the forward direction
!   Comparison and Differencing
cEcEComparison and Differencing cEcA


    Commands that perform comparisons and differences:-


cECommands cA


    lslmcompare-windows(2)le Compare buffer windows, ignore whitespace
    lslmcompare-windows-exact(3)le Compare buffer windows, with whitespace
    lslmdiff(3)le Difference files or directories
    lslmdiff-changes(3)le Find the differences from a previous edit session
    lslmgdiff(3)le Graphical file difference
    lslmrdiff(3)le Recursively compare files or directories
    lslmxdiff(3)le External graphical file difference


cEVariables cA


    lslm%diff-com(5)le Diff command line
    lslm%gdiff-com(5)le Gdiff command line
    lslm%xdiff-com(5)le xdiff command line
!   Hilighting, Color and Screen Appearance
cEcEHILIGHTING, COLOR AND SCREEN APPEARANCE cEcA


    Commands that change the hilighting, screen color and screen appearance:


cECommands cA


    lslmadd-color(2)le Create a new color
    lslmadd-color-scheme(2)le Create a new color scheme
    lslmchange-font(2)le Change the screen font
    lslmchange-frame-depth(2)le Change the number of lines on the current frame
    lslmchange-frame-width(2)le Change the number of columns on the current frame
    lslmchange-scheme(3)le Change the current highlight scheme
    lslmchange-screen-depth(2)le Change the number of lines on the screen
    lslmchange-screen-width(2)le Change the number of columns on the screen
    lslmdelete-hilight-lines(3)le Delete hilight lines
    lslmhilight(2)le Manage the buffer hilighting schemes
    lslmindent(2)le Manage the auto-indentation methods
    lslmindent-decrease(3)le Decrease the line indentation
    lslmindent-increase(3)le Increase the line indentation
    lslmline-scheme(3)le Apply line annotation in current buffer
    lslmosd-search(3)le Search and annotate the current buffer
    lslmprint-color(2)le Create a new printer color
    lslmprint-scheme(2)le Create a new printer color and font scheme
    lslmrestyle-buffer(3)le Automatically reformat a buffer's indentation
    lslmrestyle-region(3)le Automatically reformat a regions indentation
    lslmscheme-editor(3)le Color Scheme Editor
    lslmshow-region(2)le Show the current copy region


cEVariables cA


    lslm$box-chars(5)le Characters used to draw lines
    lslm$buffer-hilight(5)le Define current buffer hilighting scheme
    lslm$buffer-indent-width(5)le Buffer indentation width in characters
    lslm$buffer-scheme(5)le Buffer color scheme
    lslm$cursor-blink(5)le Cursor blink rate
    lslm$cursor-color(5)le Cursor foreground color
    lslm$frame-depth(5)le Number of lines on the current frame canvas
    lslm$frame-width(5)le Number of columns on the current frame canvas
    lslm$global-scheme(5)le Global buffer color scheme
    lslm$indent-width(5)le Global indentation width in characters
    lslm$line-scheme(5)le Set the current line color scheme
    lslm$mode-line(5)le Mode line format
    lslm$mode-line-scheme(5)le Mode line color scheme
    lslm$mouse-pos(5)le Mouse position information
    lslm$screen-depth(5)le Number of character lines on the screen canvas
    lslm$screen-width(5)le Number of character columns on the screen canvas
    lslm$scroll-bar(5)le Scroll bar configuration
    lslm$scroll-bar-scheme(5)le Scroll bar color scheme
    lslm$show-modes(5)le Select buffer modes to display
    lslm$show-region(5)le Enable the hilighting of regions
    lslm$system(5)le System configuration variable
    lslm$trunc-scheme(5)le Truncation color scheme
    lslm$window-chars(5)le Character set used to render the windows
!   Keyboard Binding Commands
cEcEKEYBOARD BINDING COMMANDS cEcA


    Keyboard binding allows key strokes to be associated with commands and
    macros such that when a bound key stroke sequence is recognized its
    associated (or bound) command is invoked, thereby controlling the editor.
    A set of lsBindings(2)lmDefault Bindingsle exist for MicroEmacs which may be altered using
    the binding commands. There are three types of key bindings:

    cDGlobalcA
        Associates a key-stroke with a command for all buffers. Used to
        establish the standard keyboard controls i.e. cursor movement, search,
        replace etc.

    cDLocalcA
        Associates a key-stroke with a command for a specified buffer only,
        i.e. a binding local to the buffer. Local bindings allow macro
        accelerators to be bound to keys without affecting other buffers
        containing different types of data. Local bindings are used
        extensively in the buffer hook commands.

    cDMessage LinecA
        Associates a key binding for use on the command line only, allowing
        command completion to be diverted etc.

    To bind a command to a key, the command and key names must be known, see
    lslmCommand Glossaryle for a complete list of commands and lskeyNames(2)lmKey Namesle for a
    complete list of key names.

    The binding related commands are defined as follows:


cECommands cA


    lslmbuffer-bind-key(2)le Create local key binding for current buffer
    lslmbuffer-unbind-key(2)le Remove local key binding for current buffer
    lslmcommand-apropos(2)le (cDC-h acA) List commands involving a concept
    lslmdescribe-bindings(2)le (cDC-h bcA) Show current command/key binding
    lslmdescribe-key(2)le (cDC-x ?cA) Report keyboard key name and binding
    lslmexpand-iso-accents(3)le Expand an ISO accent
    lslmglobal-bind-key(2)le (cDesc kcA) Bind a key to a named command or macro
    lslmglobal-unbind-key(2)le (cDesc C-kcA) Unbind a key from a named command or macro
    lslmiso-accents-mode(3)le ISO accent expansion short-cut mode
    lslmml-bind-key(2)le Create key binding for message line
    lslmml-unbind-key(2)le Remove key binding from message line
    lslmosd-bind-key(2)le Create key binding for OSD dialog
    lslmosd-unbind-key(2)le Remove key binding from OSD dialog
    lslmset-char-mask(2)le Set character word mask
    lslmtranslate-key(2)le Translate key


cEVariables cA


cEAlt Key cA


    The cDAlt KeycA has special binding priorities defined as follows:-

        * Direct key binding (e.g. cDA-bcA executes lsfile-browser(3)lmfile-browserle)
        * Main menu hot key (e.g. cDA-fcA opens the File menu)
        * Meta key binding (e.g. cDA-spacecA -> cDesc spacecA -> lsset-mark(2)lmset-markle)

    If the cGALTcA key is to be used strictly as the Emacs Meta key then the
    bindings for the menu should be over-ridden by cCDirect Key BindingscA from
    the user configuration file i.e. to re-map the default MicroEmacs Alt key
    to equivalent cGesccA keys then the following keys should be re-bound.
sB
        global-bind-key forward-word "A-f"      ; Over-ride File menu binding
        :                                       ; For all of the other menu items.
        :
        global-bind-key backward-word "A-b"     ; Over-ride the file browser.
        global-bind-key replace-string "A-r"    ; Over-ride tools binding.

sA
    This creates a higher priority binding which overrides the underlying
    default. The commands that are displaced would have to be re-bound to
    different keys if required.
!   Buffer Manipulation Commands
cEcEBUFFER MANIPULATION COMMANDS cEcA


    A buffer is where MicroEmacs stores text. Normally text is read from a
    file and is visible in an editing lsWindow Commandslmwindowle. The name, associated file and
    operating modes of the buffer, are generally shown in the lsMode Linelmmode linele.

    Commands that deal with buffers include:


cECommands cA


    lslmbuffer-info(2)le (cDC-x =cA) Status information on current buffer position
    lslmbuffer-major-mode(3)le Change the operating mode of a buffer
    lslmchange-buffer-name(2)le (cDesc C-ncA) Change name of current buffer
    lslmchange-file-name(2)le (cDC-x ncA) Change the file name of the current buffer
    lslmdelete-buffer(2)le (cDC-x kcA) Delete a buffer
    lslmdelete-some-buffers(2)le Delete buffers with query
    lslmexecute-buffer(2)le Execute script lines from a buffer
    lslmexecute-line(2)le Execute a typed in script line
    lslmfind-buffer(2)le (cDC-x bcA) Switch to a named buffer
    lslminsert-file-name(2)le (cDC-x C-ycA) Insert filename into current buffer
    lslmlist-buffers(2)le (cDC-x C-bcA) List all buffers and show their status
    lslmnarrow-buffer(2)le Hide buffer lines
    lslmnext-buffer(2)le (cDC-x xcA) Switch to the next buffer
    lslmsave-all(3)le Save all modified files (with query)
    lslmsave-some-buffers(2)le Save contents of all changed buffers to file (with
    query)


cEVariables cA


    lslm$MEBACKUPPATH(5)le Backup file location
    lslm$MEBACKUPSUB(5)le Backup file name modifier
    lslm$buffer-backup(5)le Buffer backup file name
    lslm$buffer-bname(5)le Name of the current buffer
    lslm$buffer-fmod(5)le Buffer file modes (or attributes)
    lslm$buffer-fname(5)le Name of the current buffer's file name
    lslm$buffer-indent-width(5)le Buffer indentation width in characters
    lslm$buffer-mask(5)le Current buffer word class mask
    lslm$buffer-mode-line(5)le Buffer mode line string
    lslm$buffer-names(5)le Filtered buffer name list
    lslm$file-names(5)le Filtered file name list
    lslm$global-fmod(5)le Global file modes (or attributes)
    lslm$indent-width(5)le Global indentation width in characters
    lslm$mode-chars(5)le Mode characters
    lslm$mode-line(5)le Mode line format
    lslm$mode-line-scheme(5)le Mode line color scheme
    lslm$show-modes(5)le Select buffer modes to display
!   Capitalization and Transposition Commands
cEcECAPITALIZATION AND TRANSPOSITION COMMANDS cEcA


    Commands to change the capitalization and transposition of text:

    lslmcapitalize-word(2)le (cDesc ccA) Capitalize word
    lslmlower-case-region(2)le (cDC-x C-lcA) Lowercase a region (downcase)
    lslmlower-case-word(2)le (cDesc lcA) Lowercase word (downcase)
    lslmsort-lines(2)le Alphabetically sort lines
    lslmsort-lines-ignore-case(3)le Alphabetically sort lines ignoring case
    lslmtranspose-chars(2)le (cDC-tcA) Exchange (swap) adjacent characters
    lslmtranspose-lines(2)le (cDC-x C-tcA) Exchange (swap) adjacent lines
    lslmuniq(3)le Make lines in a sorted list unique
    lslmupper-case-region(2)le (cDC-x C-ucA) Uppercase a region (upcase)
    lslmupper-case-word(2)le (cDesc ucA) Uppercase word (upcase)
!   File Handling Commands
cEcEFILE HANDLING COMMANDS cEcA


    Commands to read, write and interact with files:


cECommands cA


    lslmappend-buffer(2)le Write contents of buffer to end of named file
    lslmbrowse(3)le Browse a file or buffer in view mode
    lslmchange-file-name(2)le (cDC-x ncA) Change the file name of the current buffer
    lslmdirectory-tree(2)le Draw the file directory tree
    lslmfile-attrib(3)le Set the current buffers system file attributes
    lslmfile-browser(3)le (cDf10cA) Browse the file system
    lslmfile-browser-close(3)le Close the file-browser
    lslmfile-browser-swap-buffers(3)le Swap between file-browser windows
    lslmfile-op(2)le File system operations command
    lslmfile-tool-setup(3)le Define file browser tools
    lslmfind-bfile(3)le (cDC-x 9cA) Load a file as binary data
    lslmfind-cfile(3)le Load a crypted file
    lslmfind-file(2)le (cDC-x C-fcA) Load a file
    lslmfind-zfile(3)le Compressed file support
    lslmftp(3)le Initiate an FTP connection
    lslminsert-file(2)le (cDC-x C-icA) Insert file into current buffer
    lslminsert-file-name(2)le (cDC-x C-ycA) Insert filename into current buffer
    lslmpage-bfile(3)le Load a large binary file as binary data
    lslmpage-file(3)le Load a large file in page mode
    lslmpage-file-save-buffer(3)le (cDC-x C-scA) Save contents of a page mode buffer to
    file
    lslmread-file(2)le (cDC-x C-rcA) Find and load file replacing current buffer
    lslmreread-all(3)le Reload all files
    lslmreread-file(3)le Reload the current buffer's file
    lslmsave-all(3)le Save all modified files (with query)
    lslmsave-buffer(2)le (cDC-x C-scA) Save contents of changed buffer to file
    lslmsave-some-buffers(2)le Save contents of all changed buffers to file (with
    query)
    lslmset-encryption-key(2)le (cDesc ecA) Define the encryption key
    lslmsuspend-emacs(2)le Suspend editor and place in background
    lslmview-file(2)le (cDC-x C-vcA) Load a file read only
    lslmwatch(3)le Monitor a changing file
    lslmwatch-reset(3)le Reset the watch command counters
    lslmwatch-time(3)le Change the watch command poll time
    lslmwrite-buffer(2)le (cDC-x C-wcA) Write contents of buffer to named (new) file
    lslmwrite-region(3)le Write contents of region to named (new) file
    lslmzfile-setup(3)le Compressed file support setup


cEVariables cA


    lslm$MEINSTALLPATH(5)le MicroEmacs system macros search path
    lslm$MEPATH(5)le MicroEmacs search path
    lslm$MEUSERPATH(5)le MicroEmacs user directory
    lslm$auto-time(5)le Automatic buffer save time
    lslm$file-ignore(5)le File extensions to ignore
    lslm$home(5)le Users `home' directory location
    lslm$kept-versions(5)le Number of backups to be kept
    lslm$search-path(5)le MicroEmacs search path
    lslm$timestamp(5)le Time stamp string
    lslm$user-name(5)le MicroEmacs user name
    lslm$user-path(5)le MicroEmacs user directory
    lslm%ftp-flags(5)le Configure the FTP console
    lslm%http-flags(5)le Configure the HTTP console
    lslm%http-proxy-addr(5)le Set HTTP proxy server address
    lslm%http-proxy-port(5)le Set HTTP proxy server port
    lslmDialogs and Menusle
!   Dialogs and Menus
cEcEDIALOGS AND MENUS cEcA


    Menus and dialogs in the system:


cECommands cA


    lslmalias-path-setup(3)le Define alternative path alias
    lslmbuffer-setup(3)le Configure the current buffer settings
    lslmdescribe-word(3)le Display a dictionary definition of a word
    lslmfile-tool-setup(3)le Define file browser tools
    lslmfile-type-setup(3)le Define file type set
    lslmfind-word(3)le Find a using spelling dictionaries
    lslmgenerate-tags-file(3)le Generate a tags file
    lslminsert-symbol(3)le Insert an ASCII character
    lslmline-scheme(3)le Apply line annotation in current buffer
    lslmMainMenu(3)le The top main menu
    lslmmajor-mode-help(3)le Displays help page for current buffer
    lslmmajor-mode-setup(3)le Configures the current buffer settings
    lslmnotes(3)le Tagged hierarchical database of notes
    lslmnotes-close(3)le Close the notes window
    lslmnotes-context(3)le Create/Access buffer context note
    lslmnotes-file(3)le Open a notes database file
    lslmnotes-import-skwyrul(3)le Import a Skwyrul index file (skwyrul_l.htm)
    lslmnotes-instant(3)le Create quick note
    lslmorganizer(3)le Calendar and address organizer
    lslmosd(2)le Manage the On-Screen Display
    lslmosd-dialog(3)le OSD dialog box
    lslmosd-entry(3)le OSD entry dialog box
    lslmosd-search(3)le Search and annotate the current buffer
    lslmosd-xdialog(3)le OSD Extended dialog box
    lslmprint-setup(3)le Configure MicroEmacs's printer interface
    lslmscheme-editor(3)le Color Scheme Editor
    lslmspell-buffer(3)le Spell check the current buffer
    lslmspell-edit-word(3)le Edits a spell word entry
    lslmspell-word(3)le (cDesc $cA) Spell check a single word
    lslmtoolbar(3)le Toggle tool bar visibility
    lslmtoolbar-close(3)le Close the tool bar
    lslmtoolbar-open(3)le Open the tool bar
    lslmtoolbar-refresh(3)le Update the tool bar
    lslmuser-setup(3)le Configure MicroEmacs for a specific user


cEVariables cA


    lslm$osd-scheme(5)le OSD color scheme
!   Editor File Types
cEcEEDITOR FILE TYPES cEcA


    Different file types used by MicroEmacs:

    lslmeaf(8)le MicroEmacs abbreviation file format
    lslmedf(8)le MicroEmacs spelling dictionary file
    lslmehf(8)le MicroEmacs help file
    lslmemf(8)le MicroEmacs macro file
    lslmenf(8)le Notes database file
    lslmerf(8)le MicroEmacs registry file
    lslmesf(8)le MicroEmacs session file
    lslmetf(8)le MicroEmacs template file format
!   Spelling Commands
cEcESPELLING COMMANDS cEcA


    Commands related to spelling:


cECommands cA


    lslmadd-dictionary(2)le Declare existence of a spelling dictionary
    lslmadd-spell-rule(2)le Add a new spelling rule to the dictionary
    lslmauto-spell(3)le Auto-spell support
    lslmauto-spell-buffer(3)le Auto-spell whole buffer
    lslmauto-spell-ignore(3)le Auto-spell ignore current word
    lslmauto-spell-menu(3)le Auto-spell context menu
    lslmauto-spell-reset(3)le Auto-spell hilight reset
    lslmdelete-dictionary(2)le Remove a spelling dictionary from memory
    lslmdescribe-word(3)le Display a dictionary definition of a word
    lslmedit-dictionary(3)le Insert a dictionary in a buffer
    lslmexpand-word(3)le Complete a word by invocation of the speller
    lslmfind-word(3)le Find a using spelling dictionaries
    lslmrestore-dictionary(3)le Save dictionary user changes
    lslmsave-dictionary(2)le Save changed spelling dictionaries
    lslmspell(2)le Spell checker service provider
    lslmspell-add-word(3)le Add a word to the main dictionary
    lslmspell-buffer(3)le Spell check the current buffer
    lslmspell-edit-word(3)le Edits a spell word entry
    lslmspell-word(3)le (cDesc $cA) Spell check a single word


cEVariables cA


    lslm$find-words(5)le Filtered word list
!   Macro Commands
cEcEMACRO COMMANDS cEcA


    Everyday macro commands used by the user. See lslmMacro Development Commandsle
    for commands related to macro development.


cECommands cA


    lslmend-kbd-macro(2)le (cDC-x )cA) Stop recording keyboard macro
    lslmexecute-buffer(2)le Execute script lines from a buffer
    lslmexecute-file(2)le (cDesc /cA) Execute script lines from a file
    lslmexecute-kbd-macro(2)le (cDC-x ecA) Execute a keyboard macro
    lslmexecute-line(2)le Execute a typed in script line
    lslmexecute-named-command(2)le [cDesc xcA] Execute a named command
    lslminsert-macro(2)le Insert keyboard macro into buffer
    lslmkbd-macro-query(2)le (cDC-x qcA) Query termination of keyboard macro
    lslmname-kbd-macro(2)le Assign a name to the last keyboard macro
    lslmstart-kbd-macro(2)le (cDC-x (cA) Start recording keyboard macro


cEVariables cA


    lslm$debug(5)le Macro debugging flag
!   Macro Development Commands
cEcEMACRO DEVELOPMENT COMMANDS cEcA


    MicroEmacs is based on a macro language which may be extended, refer to
    lsmacroWriting(4)lmWriting MicroEmacs Macrosle to get started with the language.

    Commands used in macro development, and more specialized commands which
    are only invoked from macros. Refer to lslmMacro Commandsle for keyboard macros
    etc.

    An additional set of commands for use with macros is outlined in the
    lslmIntroduction to Variable Functionsle section. The lslmMacro Language Glossaryle
    contains a full list of macro related commands and special variables.


cECommands cA


    lslmadd-file-hook(2)le Declare file name context dependent configuration
    lslmascii-time(3)le Return the current time as a string
    lslmbuffer-info(2)le (cDC-x =cA) Status information on current buffer position
    lslmbuffer-init(3)le Initialize a buffer language template
    lslmbuffer-init-fhook(3)le Initialize the buffer file hooks
    lslmbuffer-init-hooks(3)le Initialize the buffer language template hooks
    lslmcommand-wait(2)le Conditional wait command
    lslmcopy-registry(3)le Recursive copy of registry subtree
    lslmcreate-callback(2)le Create a timer callback
    lslmcreate-frame(2)le (cDC-x 5 1cA, cDC-x 5 2cA) Create a new frame
    lslmdefine-macro-file(2)le Define macro file location
    lslmdelete-frame(2)le (cDC-x 5 0cA) Delete the current frame
    lslmdirectory-tree(2)le Draw the file directory tree
    lslmetfinsrt(3)le Insert template file into current buffer
    lslmexecute-string(2)le Execute a string as a command
    lslmfile-op(2)le File system operations command
    lslmfileHooks(2)le File Hooks
    lslmgoto-position(2)le Restore a stored position
    lslmgoto-window(2)le Restore a saved window to the current window (historic)
    lslmhilight(2)le Manage the buffer hilighting schemes
    lslminsert-space(2)le Insert space(s) into current buffer
    lslminsert-string(2)le Insert character string into current buffer
    lslmlanguageTemplates(2)le File Language Templates
    lslmlocaleSupport(2)le Locale Support
    lslmnewline(2)le (cDreturncA) Insert a new line
    lslmnext-frame(2)le (cDC-x 5 ocA) Change the focus to the next frame
    lslmosd-dialog(3)le OSD dialog box
    lslmosd-entry(3)le OSD entry dialog box
    lslmosd-xdialog(3)le OSD Extended dialog box
    lslmpage-bfile(3)le Load a large binary file as binary data
    lslmpage-file(3)le Load a large file in page mode
    lslmpage-file-backward-line(3)le (cDC-pcA) Move backwards one line in paged buffer
    lslmpage-file-beginning-of-buffer(3)le Move to the start of the paged file
    lslmpage-file-end-of-buffer(3)le Move to the end of the paged file
    lslmpage-file-forward-line(3)le (cDC-ncA) Move forwards one line in paged buffer
    lslmpage-file-goto-byte(3)le Page to the buffer byte offset
    lslmpage-file-goto-page(3)le Move to page
    lslmpage-file-isearch-backward(3)le (cDC-rcA) Page search backwards incrementally
    (interactive)
    lslmpage-file-isearch-forward(3)le (cDC-scA) Page search forward incrementally
    (interactive)
    lslmpage-file-save-buffer(3)le (cDC-x C-scA) Save contents of a page mode buffer to
    file
    lslmpage-file-scroll-down(3)le (cDC-ncA) Scroll paged buffer down
    lslmpage-file-scroll-up(3)le (cDC-pcA) Scroll paged buffer up
    lslmpage-file-search-backward(3)le (cDC-x rcA) Page search for a string in the
    backward direction
    lslmpage-file-search-buffer(3)le Search the page file buffer
    lslmpage-file-search-forward(3)le (cDC-x scA) Page search for a string in the
    forward direction
    lslmpopup-window(2)le Pop-up a window on the screen
    lslmscreen-poke(2)le Immediate write string to the screen
    lslmscreen-update(2)le (cDredrawcA) Force screen update
    lslmsearch-buffer(2)le Search the current buffer for a string
    lslmset-cursor-to-mouse(2)le Move the cursor to the current mouse position
    lslmset-position(2)le Store the current position
    lslmset-scroll-with-mouse(2)le Scroll the window with the mouse
    lslmset-variable(2)le (cDC-x vcA) Assign a new value to a variable
    lslmset-window(2)le Save the current window for restore (historic)
    lslmshow-cursor(2)le Change the visibility of the cursor
    lslmshut-down(3)le Editor exit callback command
    lslmspell(2)le Spell checker service provider
    lslmstart-up(3)le Editor startup callback command
    lslmtoolbar-refresh(3)le Update the tool bar
    lslmunset-variable(2)le Delete a variable
    lslmvoid(2)le Null command


cEVariables cA


    lslm$MEBACKUPPATH(5)le Backup file location
    lslm$MEBACKUPSUB(5)le Backup file name modifier
    lslm$buffer-backup(5)le Buffer backup file name
    lslm$buffer-bhook(5)le Buffer macro hook command name (buffer current)
    lslm$buffer-dhook(5)le Buffer macro hook command name (buffer deletion)
    lslm$buffer-ehook(5)le Buffer macro hook command name (buffer swapped)
    lslm$buffer-fhook(5)le Buffer macro hook command name (buffer creation)
    lslm$buffer-fmod(5)le Buffer file modes (or attributes)
    lslm$buffer-indent(5)le Current buffer indentation scheme
    lslm$buffer-input(5)le Divert buffer input through macro
    lslm$buffer-ipipe(5)le Divert buffer incremental pipe input through macro
    lslm$buffer-names(5)le Filtered buffer name list
    lslm$command-names(5)le Filtered command name list
    lslm$cursor-x(5)le Mouse X (horizontal) position
    lslm$cursor-y(5)le Mouse Y (vertical) position
    lslm$debug(5)le Macro debugging flag
    lslm$file-names(5)le Filtered file name list
    lslm$find-words(5)le Filtered word list
    lslm$global-fmod(5)le Global file modes (or attributes)
    lslm$line-flags(5)le Current buffer line flags
    lslm$mode-names(5)le Filtered mode name list
    lslm$mouse(5)le Mouse configuration variable
    lslm$mouse-x(5)le Mouse X (horizontal) position
    lslm$mouse-y(5)le Mouse Y (vertical) position
    lslm$platform(5)le MicroEmacs host platform identifier
    lslm$progname(5)le Program file name
    lslm$random(5)le Generate a random number
    lslm$result(5)le Various command return values
    lslm$status(5)le Macro command execution status
    lslm$system(5)le System configuration variable
    lslm$temp-name(5)le Temporary file name
    lslm$variable-names(5)le Filtered variable name list
    lslm$version(5)le MicroEmacs version date-code
    lslm$window-flags(5)le Current window setup flags
    lslm$window-mode-line(5)le Window mode line position
    lslm$window-scroll-bar(5)le Window scroll bar (or separator) position
    lslm%company-name(5)le Name of company for template
    lslm.ascii-time.format(5)le Set the format of the date string
    lslm.calc.result(5)le Last calc calculation result
!   Help Information
cEcEHELP INFORMATION cEcA


    Commands to retrieve on-line help information and status.

    lslmabout(2)le Information About MicroEmacs
    lslmcommand-apropos(2)le (cDC-h acA) List commands involving a concept
    lslmdescribe-key(2)le (cDC-x ?cA) Report keyboard key name and binding
    lslmdescribe-variable(2)le (cDC-h vcA) Describe current setting of a variable
    lslmhelp(2)le (cDesc ?cA) Help; high level introduction to help
    lslmhelp-command(2)le (cDC-h C-ccA) Help; command information
    lslmhelp-item(2)le (cDC-h C-icA) Help; item information
    lslmhelp-variable(2)le (cDC-h C-vcA) Help; variable information
    lslminfo(3)le Display a GNU Info database
    lslminfo-goto-link(3)le Display Info on a given link
    lslminfo-on(3)le Display Info on a given topic
    lslmlist-buffers(2)le (cDC-x C-bcA) List all buffers and show their status
    lslmosd-help(3)le GUI based on-line help
!   Operating Modes
cEcEOPERATING MODES cEcA


    cDModescA are switches (or states) that may be applied globally or on a per
    buffer basis whose settings determine how MicroEmacs operates. Modes
    affect operations within a buffer, global modes determine the modes of
    newly created buffers.

    Commands to alter the operating state:

        lslmadd-global-mode(3)le Set a global buffer mode
        lslmadd-mode(3)le Set a local buffer mode
        lslmbuffer-major-mode(3)le Change the operating mode of a buffer
        lslmbuffer-mode(2)le (cDC-x mcA) Change a local buffer mode
        lslmdelete-global-mode(3)le Remove a global buffer mode
        lslmdelete-mode(3)le Remove a local buffer mode
        lslmglobal-mode(2)le (cDesc mcA) Change a global buffer mode
        lslmnamed-buffer-mode(2)le Change a named buffer mode
        lslmunmark-buffer(3)le Remove buffer edited flag


cEModes cA


    The operating modes are defined as follows:

        lslmauto(2m)le Automatic source file line type detection
        lslmautosv(2m)le Automatic file save
        lslmbackup(2m)le Automatic file backup of last edit
        lslmbinary(2m)le Binary editor mode
        lslmcr(2m)le File's carriage return (CR) style
        lslmcrypt(2m)le Encrypted file mode
        lslmctrlz(2m)le File's termination style
        lslmdel(2m)le Flag buffer to be deleted
        lslmdir(2m)le Buffer is a directory listing
        lslmedit(2m)le Buffer has be changed
        lslmexact(2m)le Searching and sorting case sensitivity
        lslmfence(2m)le Auto fence matching mode
        lslmhide(2m)le Hide buffer
        lslmindent(2m)le Automatic indentation
        lslmjustify(2m)le Justification Mode
        lslmlf(2m)le File's line feed style
        lslmlock(2m)le Pipe cursor position lock
        lslmmagic(2m)le Regular expression search
        lslmnact(2m)le Buffer not active
        lslmnarrow(2m)le Buffer contains a narrow
        lslmover(2m)le Over-strike Mode
        lslmpipe(2m)le Incremental Pipe running
        lslmrbin(2m)le Reduced binary editor mode
        lslmsave(2m)le Flag buffer to be saved
        lslmtab(2m)le Tabulation mode
        lslmtime(2m)le File time stamping
        lslmundo(2m)le Retain edit modifications
        lslmusr(2m)le User buffer modes
        lslmview(2m)le Read only
        lslmwrap(2m)le Line wrap entered text


cEMode Line cA


    The buffer modes may be shown on the lsMode Linelmmode linele as single letter mnemonics
    as follows:-

        cDAcAuto, cDacAutosv, cDBcAackup, cDbcAinary, cDccArlf, crcDYcApt, ctrlcDzcA, cDdcAel, cDDcAir, cDecAdit,
        cDEcAxact, cDfcAence, cDHcAide, cDIcAndent, cDJcAustify, loccDkcA, cDMcAagic, cDncAact, cDNcAarrow, cDOcAver,
        cDPcAipe, cDQcAuiet, cDrcAbin, cDScAave, cDTcAab, cDtcAime, cDUcAndo, usrcD1cA, usrcD2cA, usrcD3cA, usrcD4cA,
        usrcD5cA, usrcD6cA, usrcD7cA, usrcD8cA, cDVcAiew, cDWcArap.
!   Shell and Command Controls
cEcESHELL AND COMMAND CONTROLS cEcA


    Operating system and external system call invocations:


cECommands cA


    lslmadd-next-line(2)le Define the searching behavior of command output
    lslmClearCase(3)le MicroEmacs ClearCase interface
    lslmcc-add(3)le MicroEmacs ClearCase interface - add file
    lslmcc-checkin(3)le MicroEmacs ClearCase interface - checkin files
    lslmcc-checkout(3)le MicroEmacs ClearCase interface - checkout files
    lslmcc-delete(3)le MicroEmacs ClearCase interface - delete files
    lslmcc-diff(3)le MicroEmacs ClearCase interface - diff changes
    lslmcc-setup(3)le MicroEmacs ClearCase interface setup
    lslmcc-state(3)le MicroEmacs ClearCase interface - list state of directory files
    lslmcc-update(3)le MicroEmacs ClearCase interface - update directory files
    lslmcompile(3)le Start a compilation process
    lslmcvs(3)le MicroEmacs CVS interface
    lslmcvs-add(3)le MicroEmacs CVS interface - add file
    lslmcvs-checkout(3)le MicroEmacs CVS interface - checkout files
    lslmcvs-commit(3)le MicroEmacs CVS interface - commit changes
    lslmcvs-diff(3)le MicroEmacs CVS interface - diff changes
    lslmcvs-gdiff(3)le MicroEmacs CVS interface - graphical diff changes
    lslmcvs-log(3)le MicroEmacs CVS interface - log changes
    lslmcvs-remove(3)le MicroEmacs CVS interface - remove file
    lslmcvs-resolve-conflicts(3)le MicroEmacs CVS interface - resolve conflicts
    lslmcvs-setup(3)le MicroEmacs CVS interface setup
    lslmcvs-state(3)le MicroEmacs CVS interface - list state of directory files
    lslmcvs-status(3)le MicroEmacs CVS interface - status of files
    lslmcvs-tag(3)le MicroEmacs CVS interface - tag files
    lslmcvs-update(3)le MicroEmacs CVS interface - update directory files
    lslmcygwin(3)le Open a Cygwin BASH window
    lslmdbx(3)le UNIX Debugger
    lslmdiff(3)le Difference files or directories
    lslmdiff-changes(3)le Find the differences from a previous edit session
    lslmexecute-tool(3)le Execute a user defined shell tool
    lslmfilter-buffer(2)le (cDC-x #cA) Filter the current buffer through an O/S command
    lslmgdb(3)le GNU Debugger
    lslmgdiff(3)le Graphical file difference
    lslmgenerate-tags-file(3)le Generate a tags file
    lslmget-next-line(2)le (cDC-x `cA) Find the next command line
    lslmipipe-kill(2)le Kill a incremental pipe
    lslmipipe-shell-command(2)le (cDesc \cA) Incremental pipe (non-suspending
    system call)
    lslmipipe-write(2)le Write a string to an incremental pipe
    lslmishell(3)le Open a Cygwin BASH window
    lslmitem-list(3)le (cDF7cA) Abbreviated search and list buffer contents
    lslmitem-list-close(3)le (cDesc F7cA) Close the item list
    lslmitem-list-find(3)le Find the selected item in the item list
    lslmoccur(3)le Regular expression search for occurrences
    lslmperldb(3)le Perl Debugger
    lslmpipe-shell-command(2)le (cDesc @cA) Execute a single operating system command
    lslmrcs-file(2)le (cDC-x C-qcA) Handle Revision Control System (RCS) files
    lslmrdiff(3)le Recursively compare files or directories
    lslmrgrep(3)le Execute recursive grep command
    lslmshell(2)le [cDC-x ccA] Create a new command processor or shell
    lslmshell-command(2)le Perform an operating system command
    lslmxdiff(3)le External graphical file difference
    lslmxfind(3)le Execute find command
    lslmxgrep(3)le Execute grep command


cEVariables cA


    lslm$ME_ISHELL(5)le Windows ishell command.com
    lslm$ME_PIPE_STDERR(5)le Command line diversion to stderr symbol
    lslm$buffer-ipipe(5)le Divert buffer incremental pipe input through macro
    lslm$file-template(5)le Regular expression file search string
    lslm$line-template(5)le Command line regular expression search string
    lslm$rcs-ci-com(5)le RCS (and SCCS) check in command
    lslm$rcs-cif-com(5)le RCS (and SCCS) check in first command
    lslm$rcs-co-com(5)le RCS (and SCCS) check out command
    lslm$rcs-cou-com(5)le RCS (and SCCS) check out unlock command
    lslm$rcs-file(5)le RCS (and SCCS) file name
    lslm$rcs-ue-com(5)le RCS (and SCCS) unedit file command
    lslm$result(5)le Various command return values
    lslm%compile-com(5)le Default system compile command line
    lslm%cvs-com(5)le CVS Command line
    lslm%cygwin-hilight(5)le Cygwin shell hilight enable flag
    lslm%cygwin-path(5)le Cygwin root directory
    lslm%cygwin-prompt(5)le Cygwin shell prompt
    lslm%diff-com(5)le Diff command line
    lslm%gdiff-com(5)le Gdiff command line
    lslm%man-com(5)le Man Command line
    lslm%xdiff-com(5)le xdiff command line
    lslm%xfind-com(5)le Find command line
    lslm%xgrep-com(5)le Grep command line
!   Message Line Commands
cEcEMESSAGE LINE COMMANDS cEcA


    The message line appears at the bottom of the screen and is used for the
    input of commands and also to receive errors and information (see also
    lslmMode Linele).

    Commands and variables that interact with the message line include:


cECommands cA


    lslmml-bind-key(2)le Create key binding for message line
    lslmml-unbind-key(2)le Remove key binding from message line
    lslmml-write(2)le Write message on message line
    lslmosd-bind-key(2)le Create key binding for OSD dialog
    lslmosd-unbind-key(2)le Remove key binding from OSD dialog


cEVariables cA


    lslm$ml-scheme(5)le Message line color scheme
!   Window Commands
cEcEWINDOW COMMANDS cEcA


    MicroEmacs uses windows to display and allow you to edit the contents of
    lsBuffer Manipulation Commandslmbuffersle. Multiple windows may be present on the lsHilighting, Color and Screen Appearancelmscreenle at once, each is
    separated by a lsMode Linelmmode linele which describes the contents of the window above
    it.

    You can scroll text vertically and horizontally within a window by using
    the lsCursor Movement Commandslmcursorle commands. Note that if a line of text extends beyond the
    boundary of a window, a dollar "cD$cA" sign is displayed instead of the
    first/last visible character.

    Commands that operate on windows are defined as follows:


cECommands cA


    lslmchange-window-depth(2)le Change the depth of the current window
    lslmchange-window-width(2)le Change the width of the current window
    lslmcompare-windows(2)le Compare buffer windows, ignore whitespace
    lslmcompare-windows-exact(3)le Compare buffer windows, with whitespace
    lslmcreate-frame(2)le (cDC-x 5 1cA, cDC-x 5 2cA) Create a new frame
    lslmdelete-frame(2)le (cDC-x 5 0cA) Delete the current frame
    lslmdelete-other-windows(2)le (cDC-x 1cA) Delete other windows
    lslmdelete-window(2)le (cDC-x 0cA) Delete current window
    lslmgrow-window-horizontally(2)le Enlarge current window horizontally (relative)
    lslmgrow-window-vertically(2)le Enlarge the current window (relative change)
    lslmnext-frame(2)le (cDC-x 5 ocA) Change the focus to the next frame
    lslmnext-window(2)le (cDC-x ocA) Move the cursor to the next window
    lslmnext-window-find-buffer(2)le [cDcA] Split the current window and show new buffer
    lslmnext-window-find-file(2)le (cDC-x 4cA) Split the current window and find file
    lslmpage-file-scroll-down(3)le (cDC-ncA) Scroll paged buffer down
    lslmpage-file-scroll-up(3)le (cDC-pcA) Scroll paged buffer up
    lslmprevious-window(2)le (cDC-x pcA) Move the cursor to the previous window
    lslmresize-all-windows(2)le Resize all windows (automatic change)
    lslmresize-window-horizontally(2)le Resize current window horizontally
    (absolute)
    lslmresize-window-vertically(2)le Resize the current window (absolute change)
    lslmscroll-down(2)le (cDC-ncA) Move the window down (scrolling)
    lslmscroll-left(2)le (cDC-x <cA) Move the window left (scrolling)
    lslmscroll-next-window-down(2)le (cDesc C-vcA) Scroll next window down
    lslmscroll-next-window-up(2)le (cDesc C-zcA) Scroll next window up
    lslmscroll-right(2)le (cDC-x >cA) Move the window right (scrolling)
    lslmscroll-up(2)le (cDC-pcA) Move the window up (scrolling)
    lslmshrink-window-horizontally(2)le Shrink current window horizontally
    (relative)
    lslmshrink-window-vertically(2)le Shrink the current window (relative change)
    lslmsplit-window-horizontally(2)le (cDC-x 3cA) Split current window into two
    (horizontally)
    lslmsplit-window-vertically(2)le (cDC-x 2cA) Split the current window into two


cEVariables cA


    lslm$frame-id(5)le Current frame identity
    lslm$scroll(5)le Screen scroll control
    lslm$scroll-bar(5)le Scroll bar configuration
    lslm$window-acol(5)le Window cursor actual column
    lslm$window-aline(5)le Window cursor actual line
    lslm$window-col(5)le Window cursor column (no expansion)
    lslm$window-depth(5)le Number of text lines in a window
    lslm$window-eline(5)le Window end line
    lslm$window-id(5)le Current window identity
    lslm$window-line(5)le Window cursor line
    lslm$window-mark-col(5)le Window mark column
    lslm$window-mark-line(5)le Window mark line
    lslm$window-mode-line(5)le Window mode line position
    lslm$window-scroll-bar(5)le Window scroll bar (or separator) position
    lslm$window-wcol(5)le Window cursor column (historic)
    lslm$window-width(5)le Number of character columns in a window
    lslm$window-wline(5)le Window cursor line (historic)
    lslm$window-x-scroll(5)le Current window X scroll
    lslm$window-xcl-scroll(5)le Current window current line X scroll
    lslm$window-y-scroll(5)le Current window Y scroll
!   Printing Commands
cEcEPRINTING COMMANDS cEcA


    Printing within MicroEmacs is fairly restrictive, the following commands
    are used in conjunction with the print facility.

    lslmprint-buffer(2)le Print buffer, with formatting
    lslmprint-color(2)le Create a new printer color
    lslmprint-region(2)le Print region, with formatting
    lslmprint-scheme(2)le Create a new printer color and font scheme
    lslmprint-setup(3)le Configure MicroEmacs's printer interface
!   Introduction to Variable Functions
cEcEVARIABLE FUNCTIONS cEcA


    Functions can be used to manipulate variables in various ways. Functions
    have in general one, two, or three arguments. These arguments will always
    be placed after the function on the current command line. For example, if
    we wanted to increase the current fill column by two, using MicroEmacs's
    lslmset-variable(2)le (C-x v) command, we would write:

        set-variable $fill-col &add $fill-col 2
            \            \      \       \     \____second operand
             \            \      \       \_________first operand
              \            \      \________________function to execute
               \            \______________________variable to set
                \__________________________________set-variable (C-x v) command


    Functions always begin with an ampersand (cD&cA) character, and are only
    significant to the first 3 characters after the ampersand. Functions will
    normally expect one of three types of arguments, and will automatically
    convert types when needed.

    cD<num>cA
        An ASCII string of digits which is interpreted as a numeric value. Any
        string which does not start with a digit or a minus sign (-) will be
        considered zero.

    cD<str>cA
        An arbitrary string of characters. At the moment, strings are limited
        to 128 characters in length.

    cD<log>cA
        A logical value consisting of a non-zero number for cDTRUEcA (e.g. "cG1cA"),
        anything else is considered cDFALSEcA (e.g. "cG0cA" or "cGfoocA"). This differs
        from earlier versions of MicroEmacs where the strings "cGTRUEcA" and
        "cGFALSEcA" were used.

    A list of the currently available functions follows:

        cDNumeric FunctionscA (returns cC<num>cA)

        lslm&abs(4)le Absolute value of a number
        lslm&add(4)le Add two numbers
        lslm&dec(4)le Pre-decrement variable
        lslm&divide(4)le Division of two numbers
        lslm&inc(4)le Pre-increment variable
        lslm&mod(4)le Modulus of two numbers
        lslm&multiply(4)le Multiply two numbers
        lslm&negate(4)le Negation of two numbers
        lslm&pdec(4)le Post-decrement variable
        lslm&pinc(4)le Post-increment variable
        lslm&sub(4)le Subtract two numbers

        cDBitwise FunctionscA (returns cC<num>cA)

        lslm&band(4)le Bitwise AND operator
        lslm&bnot(4)le Bitwise NOT operator
        lslm&bor(4)le Bitwise OR operator
        lslm&bxor(4)le Bitwise XOR operator

        cDString manipulation functionscA (returns cC<str>cA)

        lslm&cat(4)le Concatenate two strings together
        lslm&left(4)le Return the left most characters from a string
        lslm&len(4)le Return the length of a string
        lslm&mid(4)le Return a portion (middle) of a string
        lslm&right(4)le Return the right most characters from a string
        lslm&slower(4)le Return the string converted to lower case
        lslm&sprintf(4)le Formatted string construction
        lslm&supper(4)le Return the string converted to upper case
        lslm&trboth(4)le Return string trimmed of white chars on both sides
        lslm&trleft(4)le Return string trimmed of white chars on left side
        lslm&trright(4)le Return string trimmed of white chars on right side

        cDList manipulation functionscA (returns cC<str>cA)

        lslm&ldel(4)le Delete list item
        lslm&lfind(4)le Find list item
        lslm&lget(4)le Get list item
        lslm&linsert(4)le Insert list item
        lslm&lset(4)le Set list item

        cDLogical testing functionscA (returns cC<log>cA)

        lslm&and(4)le Logical AND operator
        lslm&equal(4)le Numerical equivalence operator
        lslm&great(4)le Numerical greater than operator
        lslm&isequal(4)le Case insensitive String equivalence operator
        lslm&less(4)le Numerical less than operator
        lslm&not(4)le Logical NOT operator
        lslm&or(4)le Logical OR operator
        lslm&sequal(4)le String equivalence operator
        lslm&sgreat(4)le String greater than operator
        lslm&sless(4)le String less than operator
        lslm&xisequal(4)le Case insensitive regex String equivalence operator
        lslm&xsequal(4)le Regex string equivalence operator

        cDMiscellaneous functionscA

        lslm&atoi(4)le ASCII to integer conversion
        lslm&bmode(4)le Determine buffer mode
        lslm&bstat(4)le Retrieve current buffer statistic
        lslm&cbind(4)le Return the command a key is bound to
        lslm&cond(4)le Conditional expression operator
        lslm&exist(4)le Test if a variable or command exists
        lslm&find(4)le Find a file on the search path
        lslm&gmode(4)le Determine global mode
        lslm&indirect(4)le Evaluate a string as a variable
        lslm&inword(4)le Test for a word character
        lslm&irep(4)le Case insensitive replace string in string
        lslm&isin(4)le Case insensitive test for string in string
        lslm&itoa(4)le Integer to ASCII conversion
        lslm&kbind(4)le Return the key a command is bound to
        lslm&nbind(4)le Return the numerial argument of a binding
        lslm&nbmode(4)le Determine named buffer mode
        lslm&opt(4)le MicroEmacs optional feature test
        lslm&rep(4)le Replace string in string
        lslm&risin(4)le Recursive case insensitive test for string in string
        lslm&rsin(4)le Recursively test for string in string
        lslm&set(4)le In-line macro variable assignment
        lslm&sin(4)le Test for string in string
        lslm&stat(4)le Retrieve a file statistic
        lslm&which(4)le Find a program on the path
        lslm&xirep(4)le Regex case insensitive Replace string in string
        lslm&xrep(4)le Regex replace string in string


cEcESEE ALSO cEcA


    lsMicroEmacs - Macro Language GlossarylmDirectivesle
!   Mode Line
cEcEMODE LINE cEcA


    The cDmodeLinecA is the line of text shown at the bottom of each lsWindow Commandslmwindowle
    identifying the window being displayed. The mode line typically contains
    the name of the lsBuffer Manipulation Commandslmbufferle, the file and operating mode associated with the
    buffer displayed in the window. e.g.

        #*-me (BEI) - 250 foo (foo.txt) ----------------


    cDNotecA that only a sub-set of the modes are visible on the mode line, this
    reduces the cluttering of the mode line. Use the lslmabout(2)le command to
    determine the exact modes that are active.

    The text content and color of the mode line is fully configurable and may
    be defined in the users start-up script. The currently active buffer is
    generally indicated by the state of the mode line, e.g. highlighted color
    (typically red) and/or double line separator characters cD===cA; conversely
    inactive buffers are shown in a dull color with single line separator
    characters cD---cA.

    The mode line may be configured or interrogated using the following
    variables:-

    lslm$buffer-mode-line(5)le Buffer mode line string
    lslm$mode-chars(5)le Mode characters
    lslm$mode-line(5)le Mode line format
    lslm$mode-line-scheme(5)le Mode line color scheme
    lslm$show-modes(5)le Select buffer modes to display
    lslm$window-mode-line(5)le Window mode line position
    lslm$window-scroll-bar(5)le Window scroll bar (or separator) position
!   MicroEmacs Files
cEcEFILE HANDLING COMMANDS cEcA


    Commands to read, write and interact with files:


cECommands cA


    lslmappend-buffer(2)le Write contents of buffer to end of named file
    lslmbrowse(3)le Browse a file or buffer in view mode
    lslmchange-file-name(2)le (cDC-x ncA) Change the file name of the current buffer
    lslmdirectory-tree(2)le Draw the file directory tree
    lslmfile-attrib(3)le Set the current buffers system file attributes
    lslmfile-browser(3)le (cDf10cA) Browse the file system
    lslmfile-browser-close(3)le Close the file-browser
    lslmfile-browser-swap-buffers(3)le Swap between file-browser windows
    lslmfile-op(2)le File system operations command
    lslmfile-tool-setup(3)le Define file browser tools
    lslmfind-bfile(3)le (cDC-x 9cA) Load a file as binary data
    lslmfind-cfile(3)le Load a crypted file
    lslmfind-file(2)le (cDC-x C-fcA) Load a file
    lslmfind-zfile(3)le Compressed file support
    lslmftp(3)le Initiate an FTP connection
    lslminsert-file(2)le (cDC-x C-icA) Insert file into current buffer
    lslminsert-file-name(2)le (cDC-x C-ycA) Insert filename into current buffer
    lslmpage-bfile(3)le Load a large binary file as binary data
    lslmpage-file(3)le Load a large file in page mode
    lslmpage-file-save-buffer(3)le (cDC-x C-scA) Save contents of a page mode buffer to
    file
    lslmread-file(2)le (cDC-x C-rcA) Find and load file replacing current buffer
    lslmreread-all(3)le Reload all files
    lslmreread-file(3)le Reload the current buffer's file
    lslmsave-all(3)le Save all modified files (with query)
    lslmsave-buffer(2)le (cDC-x C-scA) Save contents of changed buffer to file
    lslmsave-some-buffers(2)le Save contents of all changed buffers to file (with
    query)
    lslmset-encryption-key(2)le (cDesc ecA) Define the encryption key
    lslmsuspend-emacs(2)le Suspend editor and place in background
    lslmview-file(2)le (cDC-x C-vcA) Load a file read only
    lslmwatch(3)le Monitor a changing file
    lslmwatch-reset(3)le Reset the watch command counters
    lslmwatch-time(3)le Change the watch command poll time
    lslmwrite-buffer(2)le (cDC-x C-wcA) Write contents of buffer to named (new) file
    lslmwrite-region(3)le Write contents of region to named (new) file
    lslmzfile-setup(3)le Compressed file support setup


cEVariables cA


    lslm$MEINSTALLPATH(5)le MicroEmacs system macros search path
    lslm$MEPATH(5)le MicroEmacs search path
    lslm$MEUSERPATH(5)le MicroEmacs user directory
    lslm$auto-time(5)le Automatic buffer save time
    lslm$file-ignore(5)le File extensions to ignore
    lslm$home(5)le Users `home' directory location
    lslm$kept-versions(5)le Number of backups to be kept
    lslm$search-path(5)le MicroEmacs search path
    lslm$timestamp(5)le Time stamp string
    lslm$user-name(5)le MicroEmacs user name
    lslm$user-path(5)le MicroEmacs user directory
    lslm%ftp-flags(5)le Configure the FTP console
    lslm%http-flags(5)le Configure the HTTP console
    lslm%http-proxy-addr(5)le Set HTTP proxy server address
    lslm%http-proxy-port(5)le Set HTTP proxy server port
!   MicroEmacs - Games
cEcEGAMES cEcA


    The following is a list of all of the games provided by cDMicroEmacscA:

    lslmMahjongg(3)le MicroEmacs 2009 version of the solitaire Mah Jongg game
    lslmMatch-It(3)le MicroEmacs 2009 version of the Match-It game
    lslmMetris(3)le MicroEmacs 2009 version of the falling blocks game
    lslmPatience(3)le MicroEmacs 2009 version of Patience (or Solitaire)
    lslmTriangle(3)le MicroEmacs 2009 version of Triangle patience game
!   MicroEmacs - Supported File Types
cEcESUPPORTED FILE TYPES cEcA


    The file types currently supported by MicroEmacs are defined in the
    following list. Other file types may be supported by definition of an
    appropriate hook function to handle the file, see lslmfileHooks(2)le.

    lslm0-9(9)le UNIX t/nroff file
    lslmada(9)le Ada programming language
    lslmadb(9)le Ada programming language
    lslmads(9)le Ada programming language
    lslmapache(9)le Apache httpd.conf configuration file
    lslmasm(9)le Assembler File
    lslmasn.1(9)le ASN.1 file
    lslmasp(9)le Active Server Pages
    lslmawk(9)le AWK File
    lslmbas(9)le Visual Basic
    lslmbat(9)le MS-DOS Batch File
    lslmbib(9)le TeX Bibliography File
    lslmbnf(9)le Backus-Naur Form
    lslmbtm(9)le 4-DOS Batch File
    lslmc(9)le C programming language
    lslmcbl(9)le Cobol (85) File
    lslmcc(9)le C++ programming language
    lslmcfc(9)le ColdFusion Markup Language
    lslmcfm(9)le ColdFusion Markup Language
    lslmcfml(9)le Adobe Macromedia ColdFusion Markup Language
    lslmcls(9)le Visual Basic
    lslmcpp(9)le C++ programming language
    lslmcsh(9)le C-Shell file
    lslmdef(9)le C or C++ definition file
    lslmdoc(9)le ASCII plain text document file
    lslmehf(9)le MicroEmacs 2009 help file
    lslmemf(9)le MicroEmacs 2009 Macro File
    lslmerf(9)le MicroEmacs 2009 registry file
    lslmf(9)le Fortran File
    lslmf77(9)le Fortran 77 File
    lslmf90(9)le Fortran 90 File
    lslmfvwm(9)le FVWM configuration file
    lslmfvwmrc(9)le FVWM configuration file
    lslmgawk(9)le GNU AWK File
    lslmh(9)le C programming language header
    lslmhpj(9)le MS-Windows Help Project File
    lslmhtm(9)le HyperText Markup Language File
    lslmhtml(9)le HyperText Markup Language File
    lslmhttpd.conf(9)le Apache configuration file
    lslmi(9)le C/C++ preprocessor outpuit file
    lslmimakefile(9)le Make file
    lslminfo(9)le GNU Info file
    lslmini(9)le MS-Windows Initialization File
    lslmjav(9)le Java programming language
    lslmjava(9)le Java programming language
    lslmjst(9)le JASSPA Structred Text
    lslmksh(9)le Korn shell file
    lslml(9)le LEX programming language
    lslmlatex(9)le TeX Documentation
    lslmlogin(9)le Shell user login file
    lslmMetaFont(9)le MetaFont/MetaPost File
    lslmm4(9)le M4 Macro Processor
    lslmmakefile(9)le Make file
    lslmman(9)le UNIX Manual Page
    lslmmf(9)le MetaFont File
    lslmmp(9)le MetaPost File
    lslmnawk(9)le New AWK File
    lslmnroff(9)le UNIX nroff file
    lslmp(9)le Pascal File
    lslmpas(9)le Pascal File
    lslmperl(9)le Practical Extraction and Report Language File
    lslmphp(9)le PHP: Hypertext Preprocessor Language
    lslmphp3(9)le PHP: Hypertext Preprocessor Language
    lslmphp4(9)le PHP: Hypertext Preprocessor Language
    lslmpl(9)le Practical Extraction and Report Language File
    lslmpm(9)le Practical Extraction and Report Language File
    lslmprofile(9)le Shell user profile
    lslmpy(9)le Python Language File
    lslmpython(9)le Python Language File
    lslmrb(9)le Ruby programming language
    lslmrc(9)le Microsoft Developer resource file
    lslmreg(9)le Registry file
    lslmrgy(9)le Registry file
    lslmruby(9)le Ruby programming language
    lslmrul(9)le Install Shield Rules
    lslms(9)le Assembler File
    lslmsamba(9)le Samba smb.conf configuration file
    lslmsch(9)le Scheme File
    lslmscheme(9)le Scheme File
    lslmscm(9)le Scheme File
    lslmsh(9)le Bourne shell file
    lslmsmb.conf(9)le Samba configuration file
    lslmso(9)le UNIX t/nroff include file
    lslmsql(9)le SQL File
    lslmsty(9)le TeX Style File
    lslmtcl(9)le TCL programming language
    lslmtcshrc(9)le T-Shell start up file
    lslmtex(9)le TeX Documentation
    lslmtexi(9)le GNU Texinfo documentation file
    lslmtexinfo(9)le GNU Texinfo documentation file
    lslmtk(9)le TK programming language
    lslmtni(9)le UNIX t/nroff include file
    lslmtroff(9)le UNIX troff file
    lslmtxt(9)le ASCII plain text file
    lslmv(9)le Verilog hardware description language
    lslmvb(9)le Visual Basic
    lslmverilog(9)le Verilog hardware description language
    lslmvhdl(9)le VHDL hardware simulation File
    lslmvrml(9)le VRML File
    lslmwiki(9)le GNU Wiki File
    lslmwish(9)le TCL shell file
    lslmx86(9)le Intel .x86 Assembler File
    lslmxml(9)le Extensible Markup Language
    lslmxsl(9)le Extensible Stylesheet Language
    lslmxul(9)le XML User Interface Language
    lslmy(9)le YACC programming language
    lslmzsh(9)le Z-Shell file
!   MicroEmacs - Command Glossary
!9  Command Glossary - MicroEmacs
cEcECOMMAND GLOSSARY cEcA


    The following is a list of all of the commands (built-in and macro)
    provided by cDMicroEmacscA [See lsMicroEmacs - Split Command Glossarylmsplit listingle]:

    lslmabbrev-list(3)le Create a list of abbreviations
    lslmabort-command(2)le (cDC-gcA) Abort command
    lslmabout(2)le Information About MicroEmacs
    lslmadd-color(2)le Create a new color
    lslmadd-color-scheme(2)le Create a new color scheme
    lslmadd-dictionary(2)le Declare existence of a spelling dictionary
    lslmadd-file-hook(2)le Declare file name context dependent configuration
    lslmadd-global-mode(3)le Set a global buffer mode
    lslmadd-mode(3)le Set a local buffer mode
    lslmadd-next-line(2)le Define the searching behavior of command output
    lslmadd-spell-rule(2)le Add a new spelling rule to the dictionary
    lslmalarm(3)le Set an alarm
    lslmalias-path-setup(3)le Define alternative path alias
    lslmaman(3)le Compile an nroff file into a buffer (UNIX)
    lslmappend-buffer(2)le Write contents of buffer to end of named file
    lslmascii-time(3)le Return the current time as a string
    lslmauto-spell(3)le Auto-spell support
    lslmauto-spell-buffer(3)le Auto-spell whole buffer
    lslmauto-spell-ignore(3)le Auto-spell ignore current word
    lslmauto-spell-menu(3)le Auto-spell context menu
    lslmauto-spell-reset(3)le Auto-spell hilight reset
    lslmbackward-char(2)le (cDC-bcA) Move the cursor left
    lslmbackward-delete-char(2)le (cDbackspacecA) Delete the previous character at the
    cursor position
    lslmbackward-delete-tab(2)le (cDS-tabcA) Delete white space to previous tab-stop
    lslmbackward-kill-word(2)le (cDesc backspacecA) Delete the previous word at the
    cursor position
    lslmbackward-line(2)le (cDC-pcA) Move the cursor to the previous line
    lslmbackward-paragraph(2)le (cDesc pcA) Move the cursor to the previous paragraph
    lslmbackward-word(2)le (cDesc bcA) Move the cursor to the previous word
    lslmbeginning-of-buffer(2)le (cDesc <cA) Move to beginning of buffer/file
    lslmbeginning-of-line(2)le (cDC-acA) Move to beginning of line
    lslmbrowse(3)le Browse a file or buffer in view mode
    lslmbuffer-abbrev-file(2)le Set buffers' abbreviation file
    lslmbuffer-bind-key(2)le Create local key binding for current buffer
    lslmbuffer-info(2)le (cDC-x =cA) Status information on current buffer position
    lslmbuffer-init(3)le Initialize a buffer language template
    lslmbuffer-init-fhook(3)le Initialize the buffer file hooks
    lslmbuffer-init-hooks(3)le Initialize the buffer language template hooks
    lslmbuffer-major-mode(3)le Change the operating mode of a buffer
    lslmbuffer-mode(2)le (cDC-x mcA) Change a local buffer mode
    lslmbuffer-setup(3)le Configure the current buffer settings
    lslmbuffer-unbind-key(2)le Remove local key binding for current buffer
    lslmClearCase(3)le MicroEmacs ClearCase interface
    lslmc-deslashify(3)le C language, remove backslash to end of lines of region
    lslmc-hash-del(3)le Remove C/C++ #define evaluation
    lslmc-hash-eval(3)le Evaluate C/C++ #defines
    lslmc-hash-set-define(3)le Set a C/C++ #define
    lslmc-hash-unset-define(3)le Unset a C/C++ #define
    lslmc-slashify(3)le C language, append backslash to end of lines of region
    lslmc-to-cpp-convert(3)le Convert a C file to C++
    lslmcalc(3)le Integer calculator
    lslmcapitalize-word(2)le (cDesc ccA) Capitalize word
    lslmcc-add(3)le MicroEmacs ClearCase interface - add file
    lslmcc-checkin(3)le MicroEmacs ClearCase interface - checkin files
    lslmcc-checkout(3)le MicroEmacs ClearCase interface - checkout files
    lslmcc-delete(3)le MicroEmacs ClearCase interface - delete files
    lslmcc-diff(3)le MicroEmacs ClearCase interface - diff changes
    lslmcc-setup(3)le MicroEmacs ClearCase interface setup
    lslmcc-state(3)le MicroEmacs ClearCase interface - list state of directory files
    lslmcc-update(3)le MicroEmacs ClearCase interface - update directory files
    lslmchange-buffer-name(2)le (cDesc C-ncA) Change name of current buffer
    lslmchange-file-name(2)le (cDC-x ncA) Change the file name of the current buffer
    lslmchange-font(2)le Change the screen font
    lslmchange-frame-depth(2)le Change the number of lines on the current frame
    lslmchange-frame-width(2)le Change the number of columns on the current frame
    lslmchange-scheme(3)le Change the current highlight scheme
    lslmchange-screen-depth(2)le Change the number of lines on the screen
    lslmchange-screen-width(2)le Change the number of columns on the screen
    lslmchange-window-depth(2)le Change the depth of the current window
    lslmchange-window-width(2)le Change the width of the current window
    lslmcharset-change(3)le Convert buffer between two character sets
    lslmcharset-iso-to-user(3)le Convert buffer from ISO standard to user character
    set
    lslmcharset-user-to-iso(3)le Convert buffer from user to ISO standard character
    set
    lslmcheck-line-length(3)le Check the length of text lines are valid
    lslmclean(3)le Remove redundant white spaces from the current buffer
    lslmcollapse-all(3)le (cDf3cA) (Un)Fold all regions in the current buffer
    lslmcollapse-current(3)le (cDf2cA) (un)Fold a region in the current buffer
    lslmcommand-apropos(2)le (cDC-h acA) List commands involving a concept
    lslmcommand-wait(2)le Conditional wait command
    lslmcompare-windows(2)le Compare buffer windows, ignore whitespace
    lslmcompare-windows-exact(3)le Compare buffer windows, with whitespace
    lslmcompile(3)le Start a compilation process
    lslmcopy-rectangle(3)le Copy a rectangular region of text
    lslmcopy-region(2)le (cDesc wcA) Copy a region of the buffer
    lslmcopy-registry(3)le Recursive copy of registry subtree
    lslmcount-words(2)le (cDesc C-ccA) Count the number of words in a region
    lslmcreate-callback(2)le Create a timer callback
    lslmcreate-frame(2)le (cDC-x 5 1cA, cDC-x 5 2cA) Create a new frame
    lslmcvs(3)le MicroEmacs CVS interface
    lslmcvs-add(3)le MicroEmacs CVS interface - add file
    lslmcvs-checkout(3)le MicroEmacs CVS interface - checkout files
    lslmcvs-commit(3)le MicroEmacs CVS interface - commit changes
    lslmcvs-diff(3)le MicroEmacs CVS interface - diff changes
    lslmcvs-gdiff(3)le MicroEmacs CVS interface - graphical diff changes
    lslmcvs-log(3)le MicroEmacs CVS interface - log changes
    lslmcvs-remove(3)le MicroEmacs CVS interface - remove file
    lslmcvs-resolve-conflicts(3)le MicroEmacs CVS interface - resolve conflicts
    lslmcvs-setup(3)le MicroEmacs CVS interface setup
    lslmcvs-state(3)le MicroEmacs CVS interface - list state of directory files
    lslmcvs-status(3)le MicroEmacs CVS interface - status of files
    lslmcvs-tag(3)le MicroEmacs CVS interface - tag files
    lslmcvs-update(3)le MicroEmacs CVS interface - update directory files
    lslmcygwin(3)le Open a Cygwin BASH window
    lslmdefine-help(2)le Define help information
    lslmdefine-macro(2)le Define a new macro
    lslmdefine-macro-file(2)le Define macro file location
    lslmdelete-blank-lines(2)le (cDC-x C-ocA) Delete blank lines about cursor
    lslmdelete-buffer(2)le (cDC-x kcA) Delete a buffer
    lslmdelete-dictionary(2)le Remove a spelling dictionary from memory
    lslmdelete-frame(2)le (cDC-x 5 0cA) Delete the current frame
    lslmdelete-global-mode(3)le Remove a global buffer mode
    lslmdelete-hilight-lines(3)le Delete hilight lines
    lslmdelete-indentation(3)le Join 2 lines deleting white spaces
    lslmdelete-mode(3)le Remove a local buffer mode
    lslmdelete-other-windows(2)le (cDC-x 1cA) Delete other windows
    lslmdelete-registry(2)le Delete a registry tree
    lslmdelete-some-buffers(2)le Delete buffers with query
    lslmdelete-window(2)le (cDC-x 0cA) Delete current window
    lslmdescribe-bindings(2)le (cDC-h bcA) Show current command/key binding
    lslmdescribe-key(2)le (cDC-x ?cA) Report keyboard key name and binding
    lslmdescribe-variable(2)le (cDC-h vcA) Describe current setting of a variable
    lslmdescribe-word(3)le Display a dictionary definition of a word
    lslmdiff(3)le Difference files or directories
    lslmdiff-changes(3)le Find the differences from a previous edit session
    lslmdirectory-tree(2)le Draw the file directory tree
    lslmdisplay-white-chars(3)le Toggle the displaying of white characters
    lslmdisplay-whitespaces(3)le Toggle the displaying of white characters
    lslmdraw(3)le Simple line drawing utility
    lslmedit-dictionary(3)le Insert a dictionary in a buffer
    lslmend-kbd-macro(2)le (cDC-x )cA) Stop recording keyboard macro
    lslmend-of-buffer(2)le (cDesc >cA) Move to end of buffer/file
    lslmend-of-line(2)le (cDC-ecA) Move to end of line
    lslmetfinsrt(3)le Insert template file into current buffer
    lslmexchange-point-and-mark(2)le (cDC-x C-xcA) Exchange the cursor and marked
    position
    lslmexecute-buffer(2)le Execute script lines from a buffer
    lslmexecute-file(2)le (cDesc /cA) Execute script lines from a file
    lslmexecute-kbd-macro(2)le (cDC-x ecA) Execute a keyboard macro
    lslmexecute-line(2)le Execute a typed in script line
    lslmexecute-named-command(2)le [cDesc xcA] Execute a named command
    lslmexecute-string(2)le Execute a string as a command
    lslmexecute-tool(3)le Execute a user defined shell tool
    lslmexit-emacs(2)le Exit MicroEmacs
    lslmexpand-abbrev(2)le Expand an abbreviation
    lslmexpand-abbrev-handle(3)le (cDesc esccA) Expand an abbreviation handler
    lslmexpand-look-back(3)le Complete a word by looking back for a similar word
    lslmexpand-word(3)le Complete a word by invocation of the speller
    lslmfile-attrib(3)le Set the current buffers system file attributes
    lslmfile-browser(3)le (cDf10cA) Browse the file system
    lslmfile-browser-close(3)le Close the file-browser
    lslmfile-browser-swap-buffers(3)le Swap between file-browser windows
    lslmfile-op(2)le File system operations command
    lslmfile-tool-setup(3)le Define file browser tools
    lslmfile-type-setup(3)le Define file type set
    lslmfill-paragraph(2)le (cDesc ocA) Format a paragraph
    lslmfilter-buffer(2)le (cDC-x #cA) Filter the current buffer through an O/S command
    lslmfind(3)le Execute built-in find command
    lslmfind-bfile(3)le (cDC-x 9cA) Load a file as binary data
    lslmfind-buffer(2)le (cDC-x bcA) Switch to a named buffer
    lslmfind-cfile(3)le Load a crypted file
    lslmfind-file(2)le (cDC-x C-fcA) Load a file
    lslmfind-registry(2)le Index search of a registry sub-tree
    lslmfind-setup(3)le Setup the built-in find and grep commands
    lslmfind-tag(2)le (cDesc tcA) Find tag, auto-load file and move to tag position
    lslmfind-word(3)le Find a using spelling dictionaries
    lslmfind-zfile(3)le Compressed file support
    lslmfold-close(3)le (cDC-f2cA) Close an open fold (in-line)
    lslmfold-create(3)le (cDC-f2cA) Create a new fold
    lslmfold-enter(3)le (cDf3cA) Enter fold
    lslmfold-exit(3)le (cDesc f3cA) Exit a fold
    lslmfold-exit-all(3)le (cDesc C-f3cA) Exit all folds
    lslmfold-kill(3)le (cDC-x C-kcA) Delete the fold and all its contents
    lslmfold-open(3)le (cDf2cA) Open fold (in-line)
    lslmfold-remove(3)le (cDesc C-f3cA) Remove the fold, maintaining content
    lslmforward-char(2)le (cDC-fcA) Move the cursor right
    lslmforward-delete-char(2)le (cDC-dcA) Delete the next character at the cursor
    position
    lslmforward-kill-word(2)le (cDesc dcA) Delete the next word at the cursor position
    lslmforward-line(2)le (cDC-ncA) Move the cursor to the next line
    lslmforward-paragraph(2)le (cDesc ncA) Move the cursor to the next paragraph
    lslmforward-word(2)le (cDesc fcA) Move the cursor to the next word
    lslmftp(3)le Initiate an FTP connection
    lslmgdiff(3)le Graphical file difference
    lslmgenerate-tags-file(3)le Generate a tags file
    lslmget-next-line(2)le (cDC-x `cA) Find the next command line
    lslmglobal-abbrev-file(2)le Set global abbreviation file
    lslmglobal-bind-key(2)le (cDesc kcA) Bind a key to a named command or macro
    lslmglobal-mode(2)le (cDesc mcA) Change a global buffer mode
    lslmglobal-unbind-key(2)le (cDesc C-kcA) Unbind a key from a named command or macro
    lslmgoto-alpha-mark(2)le (cDC-x acA) Move the cursor to a alpha marked location
    lslmgoto-line(2)le (cDesc gcA) Move the cursor to specified line
    lslmgoto-matching-fence(2)le (cDesc C-fcA) Move the cursor to matching fence
    lslmgoto-position(2)le Restore a stored position
    lslmgoto-window(2)le Restore a saved window to the current window (historic)
    lslmgrep(3)le Search a file for a pattern
    lslmgrow-window-horizontally(2)le Enlarge current window horizontally (relative)
    lslmgrow-window-vertically(2)le Enlarge the current window (relative change)
    lslmhelp(2)le (cDesc ?cA) Help; high level introduction to help
    lslmhelp-command(2)le (cDC-h C-ccA) Help; command information
    lslmhelp-item(2)le (cDC-h C-icA) Help; item information
    lslmhelp-variable(2)le (cDC-h C-vcA) Help; variable information
    lslmhilight(2)le Manage the buffer hilighting schemes
    lslmhunt-backward(2)le (cDC-x C-hcA) Resume previous search in backward direction
    lslmhunt-forward(2)le (cDC-x hcA) Resume previous search in forward direction
    lslmifill-paragraph(3)le (cDesc qcA) Format a paragraph
    lslmindent(2)le Manage the auto-indentation methods
    lslmindent-decrease(3)le Decrease the line indentation
    lslmindent-increase(3)le Increase the line indentation
    lslminfo(3)le Display a GNU Info database
    lslminfo-goto-link(3)le Display Info on a given link
    lslminfo-on(3)le Display Info on a given topic
    lslminsert-file(2)le (cDC-x C-icA) Insert file into current buffer
    lslminsert-file-name(2)le (cDC-x C-ycA) Insert filename into current buffer
    lslminsert-macro(2)le Insert keyboard macro into buffer
    lslminsert-newline(2)le (cDC-ocA) Insert new line at cursor position
    lslminsert-password(3)le Create and insert a new password string
    lslminsert-space(2)le Insert space(s) into current buffer
    lslminsert-string(2)le Insert character string into current buffer
    lslminsert-symbol(3)le Insert an ASCII character
    lslminsert-tab(2)le (cDC-icA) Insert tab(s) into current buffer
    lslmipipe-kill(2)le Kill a incremental pipe
    lslmipipe-shell-command(2)le (cDesc \cA) Incremental pipe (non-suspending
    system call)
    lslmipipe-write(2)le Write a string to an incremental pipe
    lslmisearch-backward(2)le (cDC-rcA) Search backwards incrementally (interactive)
    lslmisearch-forward(2)le (cDC-scA) Search forward incrementally (interactive)
    lslmishell(3)le Open a Cygwin BASH window
    lslmkbd-macro-query(2)le (cDC-x qcA) Query termination of keyboard macro
    lslmkill-line(2)le (cDC-kcA) Delete all characters to the end of the line
    lslmkill-paragraph(2)le Delete a paragraph
    lslmkill-rectangle(2)le (cDesc C-wcA) Delete a column of text
    lslmkill-region(2)le (cDC-wcA) Delete all characters in the marked region
    lslmline-scheme(3)le Apply line annotation in current buffer
    lslmlist-buffers(2)le (cDC-x C-bcA) List all buffers and show their status
    lslmlist-commands(2)le (cDC-h ccA) List available commands
    lslmlist-registry(2)le Display the registry in a buffer
    lslmlist-variables(2)le (cDC-h vcA) List defined variables
    lslmlower-case-region(2)le (cDC-x C-lcA) Lowercase a region (downcase)
    lslmlower-case-word(2)le (cDesc lcA) Lowercase word (downcase)
    lslmMahjongg(3)le MicroEmacs 2009 version of the solitaire Mah Jongg game
    lslmMainMenu(3)le The top main menu
    lslmMatch-It(3)le MicroEmacs 2009 version of the Match-It game
    lslmMetris(3)le MicroEmacs 2009 version of the falling blocks game
    lslmmail(3)le Compose and send an email
    lslmmail-check(3)le Check for new email
    lslmmajor-mode-help(3)le Displays help page for current buffer
    lslmmajor-mode-setup(3)le Configures the current buffer settings
    lslmman(3)le UNIX manual page viewer
    lslmman-clean(3)le Clean UNIX manual page
    lslmmark-registry(2)le Modify the operating mode of a registry node
    lslmml-bind-key(2)le Create key binding for message line
    lslmml-unbind-key(2)le Remove key binding from message line
    lslmml-write(2)le Write message on message line
    lslmname-kbd-macro(2)le Assign a name to the last keyboard macro
    lslmnamed-buffer-mode(2)le Change a named buffer mode
    lslmnarrow-buffer(2)le Hide buffer lines
    lslmnarrow-search-backward(3)le (cDC-c rcA) Search for a string in the backward
    direction
    lslmnarrow-search-forward(3)le (cDC-c scA) Search for a string in the forward
    direction
    lslmnewline(2)le (cDreturncA) Insert a new line
    lslmnext-buffer(2)le (cDC-x xcA) Switch to the next buffer
    lslmnext-frame(2)le (cDC-x 5 ocA) Change the focus to the next frame
    lslmnext-window(2)le (cDC-x ocA) Move the cursor to the next window
    lslmnext-window-find-buffer(2)le [cDcA] Split the current window and show new buffer
    lslmnext-window-find-file(2)le (cDC-x 4cA) Split the current window and find file
    lslmnormal-tab(3)le Insert a normal tab
    lslmnotes(3)le Tagged hierarchical database of notes
    lslmnotes-close(3)le Close the notes window
    lslmnotes-context(3)le Create/Access buffer context note
    lslmnotes-file(3)le Open a notes database file
    lslmnotes-import-skwyrul(3)le Import a Skwyrul index file (skwyrul_l.htm)
    lslmnotes-instant(3)le Create quick note
    lslmopen-line(3)le (cDC-ocA) Open new line at cursor position
    lslmorganizer(3)le Calendar and address organizer
    lslmosd(2)le Manage the On-Screen Display
    lslmosd-bind-key(2)le Create key binding for OSD dialog
    lslmosd-dialog(3)le OSD dialog box
    lslmosd-entry(3)le OSD entry dialog box
    lslmosd-help(3)le GUI based on-line help
    lslmosd-search(3)le Search and annotate the current buffer
    lslmosd-unbind-key(2)le Remove key binding from OSD dialog
    lslmosd-xdialog(3)le OSD Extended dialog box
    lslmPatience(3)le MicroEmacs 2009 version of Patience (or Solitaire)
    lslmpage-bfile(3)le Load a large binary file as binary data
    lslmpage-file(3)le Load a large file in page mode
    lslmpage-file-backward-line(3)le (cDC-pcA) Move backwards one line in paged buffer
    lslmpage-file-beginning-of-buffer(3)le Move to the start of the paged file
    lslmpage-file-end-of-buffer(3)le Move to the end of the paged file
    lslmpage-file-forward-line(3)le (cDC-ncA) Move forwards one line in paged buffer
    lslmpage-file-goto-byte(3)le Page to the buffer byte offset
    lslmpage-file-goto-page(3)le Move to page
    lslmpage-file-isearch-backward(3)le (cDC-rcA) Page search backwards incrementally
    (interactive)
    lslmpage-file-isearch-forward(3)le (cDC-scA) Page search forward incrementally
    (interactive)
    lslmpage-file-save-buffer(3)le (cDC-x C-scA) Save contents of a page mode buffer to
    file
    lslmpage-file-scroll-down(3)le (cDC-ncA) Scroll paged buffer down
    lslmpage-file-scroll-up(3)le (cDC-pcA) Scroll paged buffer up
    lslmpage-file-search-backward(3)le (cDC-x rcA) Page search for a string in the
    backward direction
    lslmpage-file-search-buffer(3)le Search the page file buffer
    lslmpage-file-search-forward(3)le (cDC-x scA) Page search for a string in the
    forward direction
    lslmparagraph-to-line(3)le Convert a paragraph to a single line
    lslmpassword-to-phonic(3)le Convert a password to phonic string
    lslmpipe-shell-command(2)le (cDesc @cA) Execute a single operating system command
    lslmpopup-window(2)le Pop-up a window on the screen
    lslmprefix(2)le Key prefix command
    lslmprevious-window(2)le (cDC-x pcA) Move the cursor to the previous window
    lslmprint-buffer(2)le Print buffer, with formatting
    lslmprint-color(2)le Create a new printer color
    lslmprint-region(2)le Print region, with formatting
    lslmprint-scheme(2)le Create a new printer color and font scheme
    lslmprint-setup(3)le Configure MicroEmacs's printer interface
    lslmquery-replace-all-string(3)le Query replace string in a list of files
    lslmquery-replace-string(2)le (cDesc C-rcA) Search and replace a string - with query
    lslmquery-replace-string-in-files(3)le Conditionally search and replace strings
    across files
    lslmquick-exit(2)le (cDesc zcA) Exit the editor writing changes
    lslmquote-char(2)le (cDC-qcA) Insert literal character
    lslmrcs-file(2)le (cDC-x C-qcA) Handle Revision Control System (RCS) files
    lslmrdiff(3)le Recursively compare files or directories
    lslmread-file(2)le (cDC-x C-rcA) Find and load file replacing current buffer
    lslmread-registry(2)le Read in a registry definition file
    lslmread-session(3)le Read in session information
    lslmrecenter(2)le (cDC-lcA) Recenter the window (refresh the screen)
    lslmreplace-all-pairs(3)le Replace string pairs in a list of files
    lslmreplace-all-string(3)le Replace string with new string in a list of files
    lslmreplace-string(2)le (cDesc rcA) Replace string with new string
    lslmreplace-string-in-files(3)le Search and replace strings across files
    lslmreread-all(3)le Reload all files
    lslmreread-file(3)le Reload the current buffer's file
    lslmresize-all-windows(2)le Resize all windows (automatic change)
    lslmresize-window-horizontally(2)le Resize current window horizontally
    (absolute)
    lslmresize-window-vertically(2)le Resize the current window (absolute change)
    lslmrestore-dictionary(3)le Save dictionary user changes
    lslmrestyle-buffer(3)le Automatically reformat a buffer's indentation
    lslmrestyle-region(3)le Automatically reformat a regions indentation
    lslmreyank(2)le (cDesc ycA) Restore next yank buffer
    lslmrgrep(3)le Execute recursive grep command
    lslmsave-all(3)le Save all modified files (with query)
    lslmsave-buffer(2)le (cDC-x C-scA) Save contents of changed buffer to file
    lslmsave-buffers-exit-emacs(2)le (cDesc zcA) Exit the editor prompt user to write
    changes
    lslmsave-dictionary(2)le Save changed spelling dictionaries
    lslmsave-registry(2)le Write a registry definition file
    lslmsave-session(3)le Write session information to session file
    lslmsave-some-buffers(2)le Save contents of all changed buffers to file (with
    query)
    lslmscheme-editor(3)le Color Scheme Editor
    lslmscreen-poke(2)le Immediate write string to the screen
    lslmscreen-update(2)le (cDredrawcA) Force screen update
    lslmscroll-down(2)le (cDC-ncA) Move the window down (scrolling)
    lslmscroll-left(2)le (cDC-x <cA) Move the window left (scrolling)
    lslmscroll-next-window-down(2)le (cDesc C-vcA) Scroll next window down
    lslmscroll-next-window-up(2)le (cDesc C-zcA) Scroll next window up
    lslmscroll-right(2)le (cDC-x >cA) Move the window right (scrolling)
    lslmscroll-up(2)le (cDC-pcA) Move the window up (scrolling)
    lslmsearch-backward(2)le (cDC-x rcA) Search for a string in the backward direction
    lslmsearch-buffer(2)le Search the current buffer for a string
    lslmsearch-forward(2)le (cDC-x scA) Search for a string in the forward direction
    lslmset-alpha-mark(2)le (cDC-x C-acA) Place an alphabetic marker in the buffer
    lslmset-char-mask(2)le Set character word mask
    lslmset-cursor-to-mouse(2)le Move the cursor to the current mouse position
    lslmset-encryption-key(2)le (cDesc ecA) Define the encryption key
    lslmset-mark(2)le (cDesc spacecA) Set starting point of region
    lslmset-position(2)le Store the current position
    lslmset-registry(2)le Modify a node value in the registry
    lslmset-scroll-with-mouse(2)le Scroll the window with the mouse
    lslmset-variable(2)le (cDC-x vcA) Assign a new value to a variable
    lslmset-window(2)le Save the current window for restore (historic)
    lslmshell(2)le [cDC-x ccA] Create a new command processor or shell
    lslmshell-command(2)le Perform an operating system command
    lslmshow-cursor(2)le Change the visibility of the cursor
    lslmshow-region(2)le Show the current copy region
    lslmshrink-window-horizontally(2)le Shrink current window horizontally
    (relative)
    lslmshrink-window-vertically(2)le Shrink the current window (relative change)
    lslmshut-down(3)le Editor exit callback command
    lslmsort-lines(2)le Alphabetically sort lines
    lslmsort-lines-ignore-case(3)le Alphabetically sort lines ignoring case
    lslmspace-rectangle(3)le Adds space(s) vertically
    lslmspell(2)le Spell checker service provider
    lslmspell-add-word(3)le Add a word to the main dictionary
    lslmspell-buffer(3)le Spell check the current buffer
    lslmspell-edit-word(3)le Edits a spell word entry
    lslmspell-word(3)le (cDesc $cA) Spell check a single word
    lslmsplit-window-horizontally(2)le (cDC-x 3cA) Split current window into two
    (horizontally)
    lslmsplit-window-vertically(2)le (cDC-x 2cA) Split the current window into two
    lslmstart-kbd-macro(2)le (cDC-x (cA) Start recording keyboard macro
    lslmstart-up(3)le Editor startup callback command
    lslmstop-mail-check(3)le Disable the check for new email
    lslmstring-rectangle(3)le Add a string vertically
    lslmsuspend-emacs(2)le Suspend editor and place in background
    lslmTriangle(3)le MicroEmacs 2009 version of Triangle patience game
    lslmtab(2)le (cDtabcA) Handle the tab key
    lslmtabs-to-spaces(3)le Converts all tabs to spaces
    lslmtex2nr(3)le Convert a Latex file into nroff
    lslmtime(3)le Command time evaluator
    lslmtoolbar(3)le Toggle tool bar visibility
    lslmtoolbar-close(3)le Close the tool bar
    lslmtoolbar-open(3)le Open the tool bar
    lslmtoolbar-refresh(3)le Update the tool bar
    lslmtranslate-key(2)le Translate key
    lslmtranspose-chars(2)le (cDC-tcA) Exchange (swap) adjacent characters
    lslmtranspose-lines(2)le (cDC-x C-tcA) Exchange (swap) adjacent lines
    lslmundo(2)le (cDC-x ucA) Undo the last edit
    lslmuniq(3)le Make lines in a sorted list unique
    lslmuniversal-argument(2)le (cDC-ucA) Set the command argument count
    lslmunmark-buffer(3)le Remove buffer edited flag
    lslmunset-variable(2)le Delete a variable
    lslmupper-case-region(2)le (cDC-x C-ucA) Uppercase a region (upcase)
    lslmupper-case-word(2)le (cDesc ucA) Uppercase word (upcase)
    lslmuser-setup(3)le Configure MicroEmacs for a specific user
    lslmview-file(2)le (cDC-x C-vcA) Load a file read only
    lslmvm(3)le Email viewer
    lslmvoid(2)le Null command
    lslmwatch(3)le Monitor a changing file
    lslmwatch-reset(3)le Reset the watch command counters
    lslmwatch-time(3)le Change the watch command poll time
    lslmwhich(3)le Program finder
    lslmwrap-word(2)le Wrap word onto next line
    lslmwrite-buffer(2)le (cDC-x C-wcA) Write contents of buffer to named (new) file
    lslmwrite-region(3)le Write contents of region to named (new) file
    lslmxdiff(3)le External graphical file difference
    lslmxfind(3)le Execute find command
    lslmxgrep(3)le Execute grep command
    lslmyank(2)le (cDC-ycA) Paste (copy) kill buffer contents into buffer
    lslmyank-rectangle(2)le (cDesc C-ycA) Insert a column of text
    lslmyank-rectangle-overwrite(3)le Insert a column of text with overwrite
    lslmzfile-setup(3)le Compressed file support setup
!   MicroEmacs - Split Command Glossary
cEcESPLIT COMMAND GLOSSARY cEcA


    The following is a list of all of the built in commands provided by
    cDMicroEmacscA [See lsMicroEmacs - Command Glossarylmmixed listingle]:

    lslmabort-command(2)le (cDC-gcA) Abort command
    lslmabout(2)le Information About MicroEmacs
    lslmadd-color(2)le Create a new color
    lslmadd-color-scheme(2)le Create a new color scheme
    lslmadd-dictionary(2)le Declare existence of a spelling dictionary
    lslmadd-file-hook(2)le Declare file name context dependent configuration
    lslmadd-next-line(2)le Define the searching behavior of command output
    lslmadd-spell-rule(2)le Add a new spelling rule to the dictionary
    lslmappend-buffer(2)le Write contents of buffer to end of named file
    lslmbackward-char(2)le (cDC-bcA) Move the cursor left
    lslmbackward-delete-char(2)le (cDbackspacecA) Delete the previous character at the
    cursor position
    lslmbackward-delete-tab(2)le (cDS-tabcA) Delete white space to previous tab-stop
    lslmbackward-kill-word(2)le (cDesc backspacecA) Delete the previous word at the
    cursor position
    lslmbackward-line(2)le (cDC-pcA) Move the cursor to the previous line
    lslmbackward-paragraph(2)le (cDesc pcA) Move the cursor to the previous paragraph
    lslmbackward-word(2)le (cDesc bcA) Move the cursor to the previous word
    lslmbeginning-of-buffer(2)le (cDesc <cA) Move to beginning of buffer/file
    lslmbeginning-of-line(2)le (cDC-acA) Move to beginning of line
    lslmbuffer-abbrev-file(2)le Set buffers' abbreviation file
    lslmbuffer-bind-key(2)le Create local key binding for current buffer
    lslmbuffer-info(2)le (cDC-x =cA) Status information on current buffer position
    lslmbuffer-mode(2)le (cDC-x mcA) Change a local buffer mode
    lslmbuffer-unbind-key(2)le Remove local key binding for current buffer
    lslmcapitalize-word(2)le (cDesc ccA) Capitalize word
    lslmchange-buffer-name(2)le (cDesc C-ncA) Change name of current buffer
    lslmchange-file-name(2)le (cDC-x ncA) Change the file name of the current buffer
    lslmchange-font(2)le Change the screen font
    lslmchange-frame-depth(2)le Change the number of lines on the current frame
    lslmchange-frame-width(2)le Change the number of columns on the current frame
    lslmchange-screen-depth(2)le Change the number of lines on the screen
    lslmchange-screen-width(2)le Change the number of columns on the screen
    lslmchange-window-depth(2)le Change the depth of the current window
    lslmchange-window-width(2)le Change the width of the current window
    lslmcommand-apropos(2)le (cDC-h acA) List commands involving a concept
    lslmcommand-wait(2)le Conditional wait command
    lslmcompare-windows(2)le Compare buffer windows, ignore whitespace
    lslmcopy-region(2)le (cDesc wcA) Copy a region of the buffer
    lslmcount-words(2)le (cDesc C-ccA) Count the number of words in a region
    lslmcreate-callback(2)le Create a timer callback
    lslmcreate-frame(2)le (cDC-x 5 1cA, cDC-x 5 2cA) Create a new frame
    lslmdefine-help(2)le Define help information
    lslmdefine-macro(2)le Define a new macro
    lslmdefine-macro-file(2)le Define macro file location
    lslmdelete-blank-lines(2)le (cDC-x C-ocA) Delete blank lines about cursor
    lslmdelete-buffer(2)le (cDC-x kcA) Delete a buffer
    lslmdelete-dictionary(2)le Remove a spelling dictionary from memory
    lslmdelete-frame(2)le (cDC-x 5 0cA) Delete the current frame
    lslmdelete-other-windows(2)le (cDC-x 1cA) Delete other windows
    lslmdelete-registry(2)le Delete a registry tree
    lslmdelete-some-buffers(2)le Delete buffers with query
    lslmdelete-window(2)le (cDC-x 0cA) Delete current window
    lslmdescribe-bindings(2)le (cDC-h bcA) Show current command/key binding
    lslmdescribe-key(2)le (cDC-x ?cA) Report keyboard key name and binding
    lslmdescribe-variable(2)le (cDC-h vcA) Describe current setting of a variable
    lslmdirectory-tree(2)le Draw the file directory tree
    lslmend-kbd-macro(2)le (cDC-x )cA) Stop recording keyboard macro
    lslmend-of-buffer(2)le (cDesc >cA) Move to end of buffer/file
    lslmend-of-line(2)le (cDC-ecA) Move to end of line
    lslmexchange-point-and-mark(2)le (cDC-x C-xcA) Exchange the cursor and marked
    position
    lslmexecute-buffer(2)le Execute script lines from a buffer
    lslmexecute-file(2)le (cDesc /cA) Execute script lines from a file
    lslmexecute-kbd-macro(2)le (cDC-x ecA) Execute a keyboard macro
    lslmexecute-line(2)le Execute a typed in script line
    lslmexecute-named-command(2)le [cDesc xcA] Execute a named command
    lslmexecute-string(2)le Execute a string as a command
    lslmexit-emacs(2)le Exit MicroEmacs
    lslmexpand-abbrev(2)le Expand an abbreviation
    lslmfile-op(2)le File system operations command
    lslmfill-paragraph(2)le (cDesc ocA) Format a paragraph
    lslmfilter-buffer(2)le (cDC-x #cA) Filter the current buffer through an O/S command
    lslmfind-buffer(2)le (cDC-x bcA) Switch to a named buffer
    lslmfind-file(2)le (cDC-x C-fcA) Load a file
    lslmfind-registry(2)le Index search of a registry sub-tree
    lslmfind-tag(2)le (cDesc tcA) Find tag, auto-load file and move to tag position
    lslmforward-char(2)le (cDC-fcA) Move the cursor right
    lslmforward-delete-char(2)le (cDC-dcA) Delete the next character at the cursor
    position
    lslmforward-kill-word(2)le (cDesc dcA) Delete the next word at the cursor position
    lslmforward-line(2)le (cDC-ncA) Move the cursor to the next line
    lslmforward-paragraph(2)le (cDesc ncA) Move the cursor to the next paragraph
    lslmforward-word(2)le (cDesc fcA) Move the cursor to the next word
    lslmget-next-line(2)le (cDC-x `cA) Find the next command line
    lslmglobal-abbrev-file(2)le Set global abbreviation file
    lslmglobal-bind-key(2)le (cDesc kcA) Bind a key to a named command or macro
    lslmglobal-mode(2)le (cDesc mcA) Change a global buffer mode
    lslmglobal-unbind-key(2)le (cDesc C-kcA) Unbind a key from a named command or macro
    lslmgoto-alpha-mark(2)le (cDC-x acA) Move the cursor to a alpha marked location
    lslmgoto-line(2)le (cDesc gcA) Move the cursor to specified line
    lslmgoto-matching-fence(2)le (cDesc C-fcA) Move the cursor to matching fence
    lslmgoto-position(2)le Restore a stored position
    lslmgoto-window(2)le Restore a saved window to the current window (historic)
    lslmgrow-window-horizontally(2)le Enlarge current window horizontally (relative)
    lslmgrow-window-vertically(2)le Enlarge the current window (relative change)
    lslmhelp(2)le (cDesc ?cA) Help; high level introduction to help
    lslmhelp-command(2)le (cDC-h C-ccA) Help; command information
    lslmhelp-item(2)le (cDC-h C-icA) Help; item information
    lslmhelp-variable(2)le (cDC-h C-vcA) Help; variable information
    lslmhilight(2)le Manage the buffer hilighting schemes
    lslmhunt-backward(2)le (cDC-x C-hcA) Resume previous search in backward direction
    lslmhunt-forward(2)le (cDC-x hcA) Resume previous search in forward direction
    lslmindent(2)le Manage the auto-indentation methods
    lslminsert-file(2)le (cDC-x C-icA) Insert file into current buffer
    lslminsert-file-name(2)le (cDC-x C-ycA) Insert filename into current buffer
    lslminsert-macro(2)le Insert keyboard macro into buffer
    lslminsert-newline(2)le (cDC-ocA) Insert new line at cursor position
    lslminsert-space(2)le Insert space(s) into current buffer
    lslminsert-string(2)le Insert character string into current buffer
    lslminsert-tab(2)le (cDC-icA) Insert tab(s) into current buffer
    lslmipipe-kill(2)le Kill a incremental pipe
    lslmipipe-shell-command(2)le (cDesc \cA) Incremental pipe (non-suspending
    system call)
    lslmipipe-write(2)le Write a string to an incremental pipe
    lslmisearch-backward(2)le (cDC-rcA) Search backwards incrementally (interactive)
    lslmisearch-forward(2)le (cDC-scA) Search forward incrementally (interactive)
    lslmkbd-macro-query(2)le (cDC-x qcA) Query termination of keyboard macro
    lslmkill-line(2)le (cDC-kcA) Delete all characters to the end of the line
    lslmkill-paragraph(2)le Delete a paragraph
    lslmkill-rectangle(2)le (cDesc C-wcA) Delete a column of text
    lslmkill-region(2)le (cDC-wcA) Delete all characters in the marked region
    lslmlist-buffers(2)le (cDC-x C-bcA) List all buffers and show their status
    lslmlist-commands(2)le (cDC-h ccA) List available commands
    lslmlist-registry(2)le Display the registry in a buffer
    lslmlist-variables(2)le (cDC-h vcA) List defined variables
    lslmlower-case-region(2)le (cDC-x C-lcA) Lowercase a region (downcase)
    lslmlower-case-word(2)le (cDesc lcA) Lowercase word (downcase)
    lslmmark-registry(2)le Modify the operating mode of a registry node
    lslmml-bind-key(2)le Create key binding for message line
    lslmml-unbind-key(2)le Remove key binding from message line
    lslmml-write(2)le Write message on message line
    lslmname-kbd-macro(2)le Assign a name to the last keyboard macro
    lslmnamed-buffer-mode(2)le Change a named buffer mode
    lslmnarrow-buffer(2)le Hide buffer lines
    lslmnewline(2)le (cDreturncA) Insert a new line
    lslmnext-buffer(2)le (cDC-x xcA) Switch to the next buffer
    lslmnext-frame(2)le (cDC-x 5 ocA) Change the focus to the next frame
    lslmnext-window(2)le (cDC-x ocA) Move the cursor to the next window
    lslmnext-window-find-buffer(2)le [cDcA] Split the current window and show new buffer
    lslmnext-window-find-file(2)le (cDC-x 4cA) Split the current window and find file
    lslmosd(2)le Manage the On-Screen Display
    lslmosd-bind-key(2)le Create key binding for OSD dialog
    lslmosd-unbind-key(2)le Remove key binding from OSD dialog
    lslmpipe-shell-command(2)le (cDesc @cA) Execute a single operating system command
    lslmpopup-window(2)le Pop-up a window on the screen
    lslmprefix(2)le Key prefix command
    lslmprevious-window(2)le (cDC-x pcA) Move the cursor to the previous window
    lslmprint-buffer(2)le Print buffer, with formatting
    lslmprint-color(2)le Create a new printer color
    lslmprint-region(2)le Print region, with formatting
    lslmprint-scheme(2)le Create a new printer color and font scheme
    lslmquery-replace-string(2)le (cDesc C-rcA) Search and replace a string - with query
    lslmquick-exit(2)le (cDesc zcA) Exit the editor writing changes
    lslmquote-char(2)le (cDC-qcA) Insert literal character
    lslmrcs-file(2)le (cDC-x C-qcA) Handle Revision Control System (RCS) files
    lslmread-file(2)le (cDC-x C-rcA) Find and load file replacing current buffer
    lslmread-registry(2)le Read in a registry definition file
    lslmrecenter(2)le (cDC-lcA) Recenter the window (refresh the screen)
    lslmreplace-string(2)le (cDesc rcA) Replace string with new string
    lslmresize-all-windows(2)le Resize all windows (automatic change)
    lslmresize-window-horizontally(2)le Resize current window horizontally
    (absolute)
    lslmresize-window-vertically(2)le Resize the current window (absolute change)
    lslmreyank(2)le (cDesc ycA) Restore next yank buffer
    lslmsave-buffer(2)le (cDC-x C-scA) Save contents of changed buffer to file
    lslmsave-buffers-exit-emacs(2)le (cDesc zcA) Exit the editor prompt user to write
    changes
    lslmsave-dictionary(2)le Save changed spelling dictionaries
    lslmsave-registry(2)le Write a registry definition file
    lslmsave-some-buffers(2)le Save contents of all changed buffers to file (with
    query)
    lslmscreen-poke(2)le Immediate write string to the screen
    lslmscreen-update(2)le (cDredrawcA) Force screen update
    lslmscroll-down(2)le (cDC-ncA) Move the window down (scrolling)
    lslmscroll-left(2)le (cDC-x <cA) Move the window left (scrolling)
    lslmscroll-next-window-down(2)le (cDesc C-vcA) Scroll next window down
    lslmscroll-next-window-up(2)le (cDesc C-zcA) Scroll next window up
    lslmscroll-right(2)le (cDC-x >cA) Move the window right (scrolling)
    lslmscroll-up(2)le (cDC-pcA) Move the window up (scrolling)
    lslmsearch-backward(2)le (cDC-x rcA) Search for a string in the backward direction
    lslmsearch-buffer(2)le Search the current buffer for a string
    lslmsearch-forward(2)le (cDC-x scA) Search for a string in the forward direction
    lslmset-alpha-mark(2)le (cDC-x C-acA) Place an alphabetic marker in the buffer
    lslmset-char-mask(2)le Set character word mask
    lslmset-cursor-to-mouse(2)le Move the cursor to the current mouse position
    lslmset-encryption-key(2)le (cDesc ecA) Define the encryption key
    lslmset-mark(2)le (cDesc spacecA) Set starting point of region
    lslmset-position(2)le Store the current position
    lslmset-registry(2)le Modify a node value in the registry
    lslmset-scroll-with-mouse(2)le Scroll the window with the mouse
    lslmset-variable(2)le (cDC-x vcA) Assign a new value to a variable
    lslmset-window(2)le Save the current window for restore (historic)
    lslmshell(2)le [cDC-x ccA] Create a new command processor or shell
    lslmshell-command(2)le Perform an operating system command
    lslmshow-cursor(2)le Change the visibility of the cursor
    lslmshow-region(2)le Show the current copy region
    lslmshrink-window-horizontally(2)le Shrink current window horizontally
    (relative)
    lslmshrink-window-vertically(2)le Shrink the current window (relative change)
    lslmsort-lines(2)le Alphabetically sort lines
    lslmspell(2)le Spell checker service provider
    lslmsplit-window-horizontally(2)le (cDC-x 3cA) Split current window into two
    (horizontally)
    lslmsplit-window-vertically(2)le (cDC-x 2cA) Split the current window into two
    lslmstart-kbd-macro(2)le (cDC-x (cA) Start recording keyboard macro
    lslmsuspend-emacs(2)le Suspend editor and place in background
    lslmtab(2)le (cDtabcA) Handle the tab key
    lslmtranslate-key(2)le Translate key
    lslmtranspose-chars(2)le (cDC-tcA) Exchange (swap) adjacent characters
    lslmtranspose-lines(2)le (cDC-x C-tcA) Exchange (swap) adjacent lines
    lslmundo(2)le (cDC-x ucA) Undo the last edit
    lslmuniversal-argument(2)le (cDC-ucA) Set the command argument count
    lslmunset-variable(2)le Delete a variable
    lslmupper-case-region(2)le (cDC-x C-ucA) Uppercase a region (upcase)
    lslmupper-case-word(2)le (cDesc ucA) Uppercase word (upcase)
    lslmview-file(2)le (cDC-x C-vcA) Load a file read only
    lslmvoid(2)le Null command
    lslmwrap-word(2)le Wrap word onto next line
    lslmwrite-buffer(2)le (cDC-x C-wcA) Write contents of buffer to named (new) file
    lslmyank(2)le (cDC-ycA) Paste (copy) kill buffer contents into buffer
    lslmyank-rectangle(2)le (cDesc C-ycA) Insert a column of text

    The following is a list of documented macro commands provided by
    cDMicroEmacscA:

    lslmabbrev-list(3)le Create a list of abbreviations
    lslmadd-global-mode(3)le Set a global buffer mode
    lslmadd-mode(3)le Set a local buffer mode
    lslmalarm(3)le Set an alarm
    lslmalias-path-setup(3)le Define alternative path alias
    lslmaman(3)le Compile an nroff file into a buffer (UNIX)
    lslmascii-time(3)le Return the current time as a string
    lslmauto-spell(3)le Auto-spell support
    lslmauto-spell-buffer(3)le Auto-spell whole buffer
    lslmauto-spell-ignore(3)le Auto-spell ignore current word
    lslmauto-spell-menu(3)le Auto-spell context menu
    lslmauto-spell-reset(3)le Auto-spell hilight reset
    lslmbrowse(3)le Browse a file or buffer in view mode
    lslmbuffer-init(3)le Initialize a buffer language template
    lslmbuffer-init-fhook(3)le Initialize the buffer file hooks
    lslmbuffer-init-hooks(3)le Initialize the buffer language template hooks
    lslmbuffer-major-mode(3)le Change the operating mode of a buffer
    lslmbuffer-setup(3)le Configure the current buffer settings
    lslmClearCase(3)le MicroEmacs ClearCase interface
    lslmc-deslashify(3)le C language, remove backslash to end of lines of region
    lslmc-hash-del(3)le Remove C/C++ #define evaluation
    lslmc-hash-eval(3)le Evaluate C/C++ #defines
    lslmc-hash-set-define(3)le Set a C/C++ #define
    lslmc-hash-unset-define(3)le Unset a C/C++ #define
    lslmc-slashify(3)le C language, append backslash to end of lines of region
    lslmc-to-cpp-convert(3)le Convert a C file to C++
    lslmcalc(3)le Integer calculator
    lslmcc-add(3)le MicroEmacs ClearCase interface - add file
    lslmcc-checkin(3)le MicroEmacs ClearCase interface - checkin files
    lslmcc-checkout(3)le MicroEmacs ClearCase interface - checkout files
    lslmcc-delete(3)le MicroEmacs ClearCase interface - delete files
    lslmcc-diff(3)le MicroEmacs ClearCase interface - diff changes
    lslmcc-setup(3)le MicroEmacs ClearCase interface setup
    lslmcc-state(3)le MicroEmacs ClearCase interface - list state of directory files
    lslmcc-update(3)le MicroEmacs ClearCase interface - update directory files
    lslmchange-scheme(3)le Change the current highlight scheme
    lslmcharset-change(3)le Convert buffer between two character sets
    lslmcharset-iso-to-user(3)le Convert buffer from ISO standard to user character
    set
    lslmcharset-user-to-iso(3)le Convert buffer from user to ISO standard character
    set
    lslmcheck-line-length(3)le Check the length of text lines are valid
    lslmclean(3)le Remove redundant white spaces from the current buffer
    lslmcollapse-all(3)le (cDf3cA) (Un)Fold all regions in the current buffer
    lslmcollapse-current(3)le (cDf2cA) (un)Fold a region in the current buffer
    lslmcompare-windows-exact(3)le Compare buffer windows, with whitespace
    lslmcompile(3)le Start a compilation process
    lslmcopy-rectangle(3)le Copy a rectangular region of text
    lslmcopy-registry(3)le Recursive copy of registry subtree
    lslmcvs(3)le MicroEmacs CVS interface
    lslmcvs-add(3)le MicroEmacs CVS interface - add file
    lslmcvs-checkout(3)le MicroEmacs CVS interface - checkout files
    lslmcvs-commit(3)le MicroEmacs CVS interface - commit changes
    lslmcvs-diff(3)le MicroEmacs CVS interface - diff changes
    lslmcvs-gdiff(3)le MicroEmacs CVS interface - graphical diff changes
    lslmcvs-log(3)le MicroEmacs CVS interface - log changes
    lslmcvs-remove(3)le MicroEmacs CVS interface - remove file
    lslmcvs-resolve-conflicts(3)le MicroEmacs CVS interface - resolve conflicts
    lslmcvs-setup(3)le MicroEmacs CVS interface setup
    lslmcvs-state(3)le MicroEmacs CVS interface - list state of directory files
    lslmcvs-status(3)le MicroEmacs CVS interface - status of files
    lslmcvs-tag(3)le MicroEmacs CVS interface - tag files
    lslmcvs-update(3)le MicroEmacs CVS interface - update directory files
    lslmcygwin(3)le Open a Cygwin BASH window
    lslmdelete-global-mode(3)le Remove a global buffer mode
    lslmdelete-hilight-lines(3)le Delete hilight lines
    lslmdelete-indentation(3)le Join 2 lines deleting white spaces
    lslmdelete-mode(3)le Remove a local buffer mode
    lslmdescribe-word(3)le Display a dictionary definition of a word
    lslmdiff(3)le Difference files or directories
    lslmdiff-changes(3)le Find the differences from a previous edit session
    lslmdisplay-white-chars(3)le Toggle the displaying of white characters
    lslmdisplay-whitespaces(3)le Toggle the displaying of white characters
    lslmdraw(3)le Simple line drawing utility
    lslmedit-dictionary(3)le Insert a dictionary in a buffer
    lslmetfinsrt(3)le Insert template file into current buffer
    lslmexecute-tool(3)le Execute a user defined shell tool
    lslmexpand-abbrev-handle(3)le (cDesc esccA) Expand an abbreviation handler
    lslmexpand-look-back(3)le Complete a word by looking back for a similar word
    lslmexpand-word(3)le Complete a word by invocation of the speller
    lslmfile-attrib(3)le Set the current buffers system file attributes
    lslmfile-browser(3)le (cDf10cA) Browse the file system
    lslmfile-browser-close(3)le Close the file-browser
    lslmfile-browser-swap-buffers(3)le Swap between file-browser windows
    lslmfile-tool-setup(3)le Define file browser tools
    lslmfile-type-setup(3)le Define file type set
    lslmfind(3)le Execute built-in find command
    lslmfind-bfile(3)le (cDC-x 9cA) Load a file as binary data
    lslmfind-cfile(3)le Load a crypted file
    lslmfind-setup(3)le Setup the built-in find and grep commands
    lslmfind-word(3)le Find a using spelling dictionaries
    lslmfind-zfile(3)le Compressed file support
    lslmfold-close(3)le (cDC-f2cA) Close an open fold (in-line)
    lslmfold-create(3)le (cDC-f2cA) Create a new fold
    lslmfold-enter(3)le (cDf3cA) Enter fold
    lslmfold-exit(3)le (cDesc f3cA) Exit a fold
    lslmfold-exit-all(3)le (cDesc C-f3cA) Exit all folds
    lslmfold-kill(3)le (cDC-x C-kcA) Delete the fold and all its contents
    lslmfold-open(3)le (cDf2cA) Open fold (in-line)
    lslmfold-remove(3)le (cDesc C-f3cA) Remove the fold, maintaining content
    lslmftp(3)le Initiate an FTP connection
    lslmgdiff(3)le Graphical file difference
    lslmgenerate-tags-file(3)le Generate a tags file
    lslmgrep(3)le Search a file for a pattern
    lslmifill-paragraph(3)le (cDesc qcA) Format a paragraph
    lslmindent-decrease(3)le Decrease the line indentation
    lslmindent-increase(3)le Increase the line indentation
    lslminfo(3)le Display a GNU Info database
    lslminfo-goto-link(3)le Display Info on a given link
    lslminfo-on(3)le Display Info on a given topic
    lslminsert-password(3)le Create and insert a new password string
    lslminsert-symbol(3)le Insert an ASCII character
    lslmishell(3)le Open a Cygwin BASH window
    lslmline-scheme(3)le Apply line annotation in current buffer
    lslmMahjongg(3)le MicroEmacs 2009 version of the solitaire Mah Jongg game
    lslmMainMenu(3)le The top main menu
    lslmMatch-It(3)le MicroEmacs 2009 version of the Match-It game
    lslmMetris(3)le MicroEmacs 2009 version of the falling blocks game
    lslmmail(3)le Compose and send an email
    lslmmail-check(3)le Check for new email
    lslmmajor-mode-help(3)le Displays help page for current buffer
    lslmmajor-mode-setup(3)le Configures the current buffer settings
    lslmman(3)le UNIX manual page viewer
    lslmman-clean(3)le Clean UNIX manual page
    lslmnarrow-search-backward(3)le (cDC-c rcA) Search for a string in the backward
    direction
    lslmnarrow-search-forward(3)le (cDC-c scA) Search for a string in the forward
    direction
    lslmnormal-tab(3)le Insert a normal tab
    lslmnotes(3)le Tagged hierarchical database of notes
    lslmnotes-close(3)le Close the notes window
    lslmnotes-context(3)le Create/Access buffer context note
    lslmnotes-file(3)le Open a notes database file
    lslmnotes-import-skwyrul(3)le Import a Skwyrul index file (skwyrul_l.htm)
    lslmnotes-instant(3)le Create quick note
    lslmopen-line(3)le (cDC-ocA) Open new line at cursor position
    lslmorganizer(3)le Calendar and address organizer
    lslmosd-dialog(3)le OSD dialog box
    lslmosd-entry(3)le OSD entry dialog box
    lslmosd-help(3)le GUI based on-line help
    lslmosd-search(3)le Search and annotate the current buffer
    lslmosd-xdialog(3)le OSD Extended dialog box
    lslmPatience(3)le MicroEmacs 2009 version of Patience (or Solitaire)
    lslmpage-bfile(3)le Load a large binary file as binary data
    lslmpage-file(3)le Load a large file in page mode
    lslmpage-file-backward-line(3)le (cDC-pcA) Move backwards one line in paged buffer
    lslmpage-file-beginning-of-buffer(3)le Move to the start of the paged file
    lslmpage-file-end-of-buffer(3)le Move to the end of the paged file
    lslmpage-file-forward-line(3)le (cDC-ncA) Move forwards one line in paged buffer
    lslmpage-file-goto-byte(3)le Page to the buffer byte offset
    lslmpage-file-goto-page(3)le Move to page
    lslmpage-file-isearch-backward(3)le (cDC-rcA) Page search backwards incrementally
    (interactive)
    lslmpage-file-isearch-forward(3)le (cDC-scA) Page search forward incrementally
    (interactive)
    lslmpage-file-save-buffer(3)le (cDC-x C-scA) Save contents of a page mode buffer to
    file
    lslmpage-file-scroll-down(3)le (cDC-ncA) Scroll paged buffer down
    lslmpage-file-scroll-up(3)le (cDC-pcA) Scroll paged buffer up
    lslmpage-file-search-backward(3)le (cDC-x rcA) Page search for a string in the
    backward direction
    lslmpage-file-search-buffer(3)le Search the page file buffer
    lslmpage-file-search-forward(3)le (cDC-x scA) Page search for a string in the
    forward direction
    lslmparagraph-to-line(3)le Convert a paragraph to a single line
    lslmpassword-to-phonic(3)le Convert a password to phonic string
    lslmprint-setup(3)le Configure MicroEmacs's printer interface
    lslmquery-replace-all-string(3)le Query replace string in a list of files
    lslmquery-replace-string-in-files(3)le Conditionally search and replace strings
    across files
    lslmrdiff(3)le Recursively compare files or directories
    lslmread-session(3)le Read in session information
    lslmreplace-all-pairs(3)le Replace string pairs in a list of files
    lslmreplace-all-string(3)le Replace string with new string in a list of files
    lslmreplace-string-in-files(3)le Search and replace strings across files
    lslmreread-all(3)le Reload all files
    lslmreread-file(3)le Reload the current buffer's file
    lslmrestore-dictionary(3)le Save dictionary user changes
    lslmrestyle-buffer(3)le Automatically reformat a buffer's indentation
    lslmrestyle-region(3)le Automatically reformat a regions indentation
    lslmrgrep(3)le Execute recursive grep command
    lslmsave-all(3)le Save all modified files (with query)
    lslmsave-session(3)le Write session information to session file
    lslmscheme-editor(3)le Color Scheme Editor
    lslmshut-down(3)le Editor exit callback command
    lslmsort-lines-ignore-case(3)le Alphabetically sort lines ignoring case
    lslmspace-rectangle(3)le Adds space(s) vertically
    lslmspell-add-word(3)le Add a word to the main dictionary
    lslmspell-buffer(3)le Spell check the current buffer
    lslmspell-edit-word(3)le Edits a spell word entry
    lslmspell-word(3)le (cDesc $cA) Spell check a single word
    lslmstart-up(3)le Editor startup callback command
    lslmstop-mail-check(3)le Disable the check for new email
    lslmstring-rectangle(3)le Add a string vertically
    lslmTriangle(3)le MicroEmacs 2009 version of Triangle patience game
    lslmtabs-to-spaces(3)le Converts all tabs to spaces
    lslmtex2nr(3)le Convert a Latex file into nroff
    lslmtime(3)le Command time evaluator
    lslmtoolbar(3)le Toggle tool bar visibility
    lslmtoolbar-close(3)le Close the tool bar
    lslmtoolbar-open(3)le Open the tool bar
    lslmtoolbar-refresh(3)le Update the tool bar
    lslmuniq(3)le Make lines in a sorted list unique
    lslmunmark-buffer(3)le Remove buffer edited flag
    lslmuser-setup(3)le Configure MicroEmacs for a specific user
    lslmvm(3)le Email viewer
    lslmwatch(3)le Monitor a changing file
    lslmwatch-reset(3)le Reset the watch command counters
    lslmwatch-time(3)le Change the watch command poll time
    lslmwhich(3)le Program finder
    lslmwrite-region(3)le Write contents of region to named (new) file
    lslmxdiff(3)le External graphical file difference
    lslmxfind(3)le Execute find command
    lslmxgrep(3)le Execute grep command
    lslmyank-rectangle-overwrite(3)le Insert a column of text with overwrite
    lslmzfile-setup(3)le Compressed file support setup
!   MicroEmacs - Variable Glossary
!9  Variable Glossary - MicroEmacs
cEcEVARIABLE GLOSSARY cEcA


    The following is an alphabetic list of cDMicroEmacscA variables:-

    lslm$INFOPATH(5)le GNU info files base directory
    lslm$LOGNAME(5)le System user name (UNIX)
    lslm$MEBACKUPPATH(5)le Backup file location
    lslm$MEBACKUPSUB(5)le Backup file name modifier
    lslm$MEINSTALLPATH(5)le MicroEmacs system macros search path
    lslm$MENAME(5)le MicroEmacs user name
    lslm$MEPATH(5)le MicroEmacs search path
    lslm$MEUSERPATH(5)le MicroEmacs user directory
    lslm$ME_ISHELL(5)le Windows ishell command.com
    lslm$ME_PIPE_STDERR(5)le Command line diversion to stderr symbol
    lslm$auto-time(5)le Automatic buffer save time
    lslm$box-chars(5)le Characters used to draw lines
    lslm$buffer-backup(5)le Buffer backup file name
    lslm$buffer-bhook(5)le Buffer macro hook command name (buffer current)
    lslm$buffer-bname(5)le Name of the current buffer
    lslm$buffer-dhook(5)le Buffer macro hook command name (buffer deletion)
    lslm$buffer-ehook(5)le Buffer macro hook command name (buffer swapped)
    lslm$buffer-fhook(5)le Buffer macro hook command name (buffer creation)
    lslm$buffer-fill-col(5)le Buffer paragraph mode; right fill column
    lslm$buffer-fill-mode(5)le Buffer paragraph mode; justification method
    lslm$buffer-fmod(5)le Buffer file modes (or attributes)
    lslm$buffer-fname(5)le Name of the current buffer's file name
    lslm$buffer-hilight(5)le Define current buffer hilighting scheme
    lslm$buffer-indent(5)le Current buffer indentation scheme
    lslm$buffer-indent-width(5)le Buffer indentation width in characters
    lslm$buffer-input(5)le Divert buffer input through macro
    lslm$buffer-ipipe(5)le Divert buffer incremental pipe input through macro
    lslm$buffer-mask(5)le Current buffer word class mask
    lslm$buffer-mode-line(5)le Buffer mode line string
    lslm$buffer-names(5)le Filtered buffer name list
    lslm$buffer-scheme(5)le Buffer color scheme
    lslm$buffer-tab-width(5)le Buffer tab character interval
    lslm$command-names(5)le Filtered command name list
    lslm$cursor-blink(5)le Cursor blink rate
    lslm$cursor-color(5)le Cursor foreground color
    lslm$cursor-x(5)le Mouse X (horizontal) position
    lslm$cursor-y(5)le Mouse Y (vertical) position
    lslm$debug(5)le Macro debugging flag
    lslm$delay-time(5)le Mouse time event delay time
    lslm$file-ignore(5)le File extensions to ignore
    lslm$file-names(5)le Filtered file name list
    lslm$file-template(5)le Regular expression file search string
    lslm$fill-bullet(5)le Paragraph filling bullet character set
    lslm$fill-bullet-len(5)le Paragraph filling bullet search depth
    lslm$fill-col(5)le Global paragraph mode; right fill column
    lslm$fill-eos(5)le Paragraph filling; end of sentence fill characters
    lslm$fill-eos-len(5)le Paragraph filling; end of sentence padding length
    lslm$fill-ignore(5)le Ignore paragraph filling character(s)
    lslm$fill-mode(5)le Global paragraph mode; justification method
    lslm$find-words(5)le Filtered word list
    lslm$fmatchdelay(5)le Fence matching delay time
    lslm$frame-depth(5)le Number of lines on the current frame canvas
    lslm$frame-id(5)le Current frame identity
    lslm$frame-width(5)le Number of columns on the current frame canvas
    lslm$global-fmod(5)le Global file modes (or attributes)
    lslm$global-scheme(5)le Global buffer color scheme
    lslm$home(5)le Users `home' directory location
    lslm$idle-time(5)le System idle event delay time
    lslm$indent-width(5)le Global indentation width in characters
    lslm$kept-versions(5)le Number of backups to be kept
    lslm$line-flags(5)le Current buffer line flags
    lslm$line-scheme(5)le Set the current line color scheme
    lslm$line-template(5)le Command line regular expression search string
    lslm$ml-scheme(5)le Message line color scheme
    lslm$mode-chars(5)le Mode characters
    lslm$mode-line(5)le Mode line format
    lslm$mode-line-scheme(5)le Mode line color scheme
    lslm$mode-names(5)le Filtered mode name list
    lslm$mouse(5)le Mouse configuration variable
    lslm$mouse-pos(5)le Mouse position information
    lslm$mouse-x(5)le Mouse X (horizontal) position
    lslm$mouse-y(5)le Mouse Y (vertical) position
    lslm$osd-scheme(5)le OSD color scheme
    lslm$pause-time(5)le Length of time to pause for user
    lslm$platform(5)le MicroEmacs host platform identifier
    lslm$progname(5)le Program file name
    lslm$quiet(5)le Quiet mode control variable
    lslm$random(5)le Generate a random number
    lslm$rcs-ci-com(5)le RCS (and SCCS) check in command
    lslm$rcs-cif-com(5)le RCS (and SCCS) check in first command
    lslm$rcs-co-com(5)le RCS (and SCCS) check out command
    lslm$rcs-cou-com(5)le RCS (and SCCS) check out unlock command
    lslm$rcs-file(5)le RCS (and SCCS) file name
    lslm$rcs-ue-com(5)le RCS (and SCCS) unedit file command
    lslm$recent-keys(5)le Recent key history
    lslm$repeat-time(5)le Mouse time event repeat time
    lslm$result(5)le Various command return values
    lslm$screen-depth(5)le Number of character lines on the screen canvas
    lslm$screen-width(5)le Number of character columns on the screen canvas
    lslm$scroll(5)le Screen scroll control
    lslm$scroll-bar(5)le Scroll bar configuration
    lslm$scroll-bar-scheme(5)le Scroll bar color scheme
    lslm$search-path(5)le MicroEmacs search path
    lslm$show-modes(5)le Select buffer modes to display
    lslm$show-region(5)le Enable the hilighting of regions
    lslm$status(5)le Macro command execution status
    lslm$system(5)le System configuration variable
    lslm$tab-width(5)le Global displayable tab character width
    lslm$temp-name(5)le Temporary file name
    lslm$time(5)le The current system time
    lslm$timestamp(5)le Time stamp string
    lslm$trunc-scheme(5)le Truncation color scheme
    lslm$user-name(5)le MicroEmacs user name
    lslm$user-path(5)le MicroEmacs user directory
    lslm$variable-names(5)le Filtered variable name list
    lslm$version(5)le MicroEmacs version date-code
    lslm$window-acol(5)le Window cursor actual column
    lslm$window-aline(5)le Window cursor actual line
    lslm$window-chars(5)le Character set used to render the windows
    lslm$window-col(5)le Window cursor column (no expansion)
    lslm$window-depth(5)le Number of text lines in a window
    lslm$window-eline(5)le Window end line
    lslm$window-flags(5)le Current window setup flags
    lslm$window-id(5)le Current window identity
    lslm$window-line(5)le Window cursor line
    lslm$window-mark-col(5)le Window mark column
    lslm$window-mark-line(5)le Window mark line
    lslm$window-mode-line(5)le Window mode line position
    lslm$window-scroll-bar(5)le Window scroll bar (or separator) position
    lslm$window-wcol(5)le Window cursor column (historic)
    lslm$window-width(5)le Number of character columns in a window
    lslm$window-wline(5)le Window cursor line (historic)
    lslm$window-x-scroll(5)le Current window X scroll
    lslm$window-xcl-scroll(5)le Current window current line X scroll
    lslm$window-y-scroll(5)le Current window Y scroll
    lslm%compile-com(5)le Default system compile command line
    lslm%cvs-com(5)le CVS Command line
    lslm%cygwin-hilight(5)le Cygwin shell hilight enable flag
    lslm%cygwin-path(5)le Cygwin root directory
    lslm%cygwin-prompt(5)le Cygwin shell prompt
    lslm%diff-com(5)le Diff command line
    lslm%ftp-flags(5)le Configure the FTP console
    lslm%gdiff-com(5)le Gdiff command line
    lslm%http-flags(5)le Configure the HTTP console
    lslm%http-proxy-addr(5)le Set HTTP proxy server address
    lslm%http-proxy-port(5)le Set HTTP proxy server port
    lslm%man-com(5)le Man Command line
    lslm%tag-file(5)le Tag file name
    lslm%tag-option(5)le Tag file search option
    lslm%tag-template(5)le Tag file search string
    lslm%xdiff-com(5)le xdiff command line
    lslm%xgrep-com(5)le Grep command line
    lslm.calc.result(5)le Last calc calculation result
!   MicroEmacs - Macro Language Glossary
!9  Macro Language Glossary - MicroEmacs
cEcEMACRO LANGUAGE GLOSSARY cEcA


    The following is a list of all of the macro language commands available in
    cDMicroEmacscA, refer to lsmacroWriting(4)lmWriting MicroEmacs Macrosle for information on writing
    macros.


cEFunctions cA


    All functions are denoted by a cD&cA prefix as follows:-

    lslm&abs(4)le Absolute value of a number
    lslm&add(4)le Add two numbers
    lslm&and(4)le Logical AND operator
    lslm&atoi(4)le ASCII to integer conversion
    lslm&band(4)le Bitwise AND operator
    lslm&bmode(4)le Determine buffer mode
    lslm&bnot(4)le Bitwise NOT operator
    lslm&bor(4)le Bitwise OR operator
    lslm&bstat(4)le Retrieve current buffer statistic
    lslm&bxor(4)le Bitwise XOR operator
    lslm&cat(4)le Concatenate two strings together
    lslm&cbind(4)le Return the command a key is bound to
    lslm&cond(4)le Conditional expression operator
    lslm&dec(4)le Pre-decrement variable
    lslm&divide(4)le Division of two numbers
    lslm&equal(4)le Numerical equivalence operator
    lslm&exist(4)le Test if a variable or command exists
    lslm&find(4)le Find a file on the search path
    lslm&gmode(4)le Determine global mode
    lslm&great(4)le Numerical greater than operator
    lslm&inc(4)le Pre-increment variable
    lslm&indirect(4)le Evaluate a string as a variable
    lslm&inword(4)le Test for a word character
    lslm&irep(4)le Case insensitive replace string in string
    lslm&isequal(4)le Case insensitive String equivalence operator
    lslm&isin(4)le Case insensitive test for string in string
    lslm&itoa(4)le Integer to ASCII conversion
    lslm&kbind(4)le Return the key a command is bound to
    lslm&ldel(4)le Delete list item
    lslm&left(4)le Return the left most characters from a string
    lslm&len(4)le Return the length of a string
    lslm&less(4)le Numerical less than operator
    lslm&lfind(4)le Find list item
    lslm&lget(4)le Get list item
    lslm&linsert(4)le Insert list item
    lslm&lset(4)le Set list item
    lslm&mid(4)le Return a portion (middle) of a string
    lslm&mod(4)le Modulus of two numbers
    lslm&multiply(4)le Multiply two numbers
    lslm&nbind(4)le Return the numerial argument of a binding
    lslm&nbmode(4)le Determine named buffer mode
    lslm&negate(4)le Negation of two numbers
    lslm&not(4)le Logical NOT operator
    lslm&opt(4)le MicroEmacs optional feature test
    lslm&or(4)le Logical OR operator
    lslm&pdec(4)le Post-decrement variable
    lslm&pinc(4)le Post-increment variable
    lslm&reg(4)le Retrieve a registry value (with default)
    lslm&rep(4)le Replace string in string
    lslm&right(4)le Return the right most characters from a string
    lslm&risin(4)le Recursive case insensitive test for string in string
    lslm&rsin(4)le Recursively test for string in string
    lslm&sequal(4)le String equivalence operator
    lslm&set(4)le In-line macro variable assignment
    lslm&sgreat(4)le String greater than operator
    lslm&sin(4)le Test for string in string
    lslm&sless(4)le String less than operator
    lslm&slower(4)le Return the string converted to lower case
    lslm&sprintf(4)le Formatted string construction
    lslm&stat(4)le Retrieve a file statistic
    lslm&sub(4)le Subtract two numbers
    lslm&supper(4)le Return the string converted to upper case
    lslm&trboth(4)le Return string trimmed of white chars on both sides
    lslm&trleft(4)le Return string trimmed of white chars on left side
    lslm&trright(4)le Return string trimmed of white chars on right side
    lslm&which(4)le Find a program on the path
    lslm&xirep(4)le Regex case insensitive Replace string in string
    lslm&xisequal(4)le Case insensitive regex String equivalence operator
    lslm&xrep(4)le Regex replace string in string
    lslm&xsequal(4)le Regex string equivalence operator


cEDirectives cA


    The macro directives are denoted by a cD!cA prefix as follows:-

    lslm!abort(4)le Exit macro with a FALSE status
    lslm!bell(4)le Sound audio alarm
    lslm!continue(4)le Restart a conditional loop
    lslm!done(4)le End a conditional loop
    lslm!ehelp(4)le Terminate a help definition
    lslm!elif(4)le Conditional test statement, continuation
    lslm!else(4)le Conditional alternative statement
    lslm!emacro(4)le Terminate a macro definition
    lslm!endif(4)le Conditional test termination
    lslm!force(4)le Ignore command or macro status
    lslm!goto(4)le Unconditional labeled jump
    lslm!if(4)le Conditional test statement
    lslm!jump(4)le Unconditional jump
    lslm!nmacro(4)le Ignore command or macro status
    lslm!repeat(4)le Conditional loop (post testing)
    lslm!return(4)le Exit macro with a TRUE status
    lslm!tgoto(4)le Conditional labeled jump
    lslm!tjump(4)le Unconditional relative branch
    lslm!until(4)le Test a conditional loop
    lslm!while(4)le Conditional loop


cEVariables cA


    The macro variables are denoted by a cD%cA for user variables; cD#cA for a
    register variable and cD@cA for an interactive variable as follows:-

    lslm@0(4)le Macro arguments (macro name)
    lslm@1(4)le Macro arguments (first argument)
    lslm@2(4)le Macro arguments (second argument)
    lslm@?(4)le Macro arguments (numeric argument given)
    lslm@cc(4)le Current command name
    lslm@cck(4)le Current command key
    lslm@cg(4)le Get a command name from the user
    lslm@cgk(4)le Get a key from the user
    lslm@cl(4)le Last command name
    lslm@clk(4)le Last command key
    lslm@cq(4)le Get a quoted command name from the user
    lslm@cqk(4)le Get a quoted key from the user
    lslm@fs(4)le Frame store variable
    lslm@fss(4)le Frame store scheme variable
    lslm@h0(4)le General history string
    lslm@h1(4)le Buffer history string
    lslm@h2(4)le Command history string
    lslm@h3(4)le File history string
    lslm@h4(4)le Search history string
    lslm@#(4)le Macro arguments (numeric argument value)
    lslm@mc(4)le Message line character input request
    lslm@ml(4)le Message line input request
    lslm@mn(4)le Message line input as normal request
    lslm@mna(4)le All input from Message line as normal
    lslm@mx(4)le Message line input by executing command
    lslm@mxa(4)le All input from Message line by executing command
    lslm@p(4)le Macro arguments (calling macro name)
    lslm@s0(4)le Last search's whole match string
    lslm@s1(4)le Last search's first group value
    lslm@s2(4)le Last search's second group value
    lslm@wc(4)le Extract character from the current buffer
    lslm@wl(4)le Extract a line from the current buffer
    lslm@y(4)le Yank buffer variable
    lslmBufferVariables(4)le Buffer variables
    lslmCmdVariables(4)le Command variables
    lslmCommandVariables(4)le Last, current and get a command key/name
    lslmCurrentBufferVariables(4)le Extract information from the current buffer
    lslmHistoryGroupVariables(4)le Last history values
    lslmMacroArguments(4)le Arguments to macros
    lslmMacroNumericArguments(4)le Numeric arguments to macros
    lslmMessageLineVaraibles(4)le Prompt the user for input on message line
    lslmRegisterVariables(4)le Register variables
    lslmSearchGroups(4)le Last search group values
    lslmVariables(4)le User defined macro variables
!   MicroEmacs - Global Glossary
!8  Global Glossary - MicroEmacs
cEcEGLOSSARY cEcA


    The following is a list of all keywords associated with cDMicroEmacscA:

    lslm!abort(4)le Exit macro with a FALSE status
    lslm!bell(4)le Sound audio alarm
    lslm!continue(4)le Restart a conditional loop
    lslm!done(4)le End a conditional loop
    lslm!ehelp(4)le Terminate a help definition
    lslm!elif(4)le Conditional test statement, continuation
    lslm!else(4)le Conditional alternative statement
    lslm!emacro(4)le Terminate a macro definition
    lslm!endif(4)le Conditional test termination
    lslm!force(4)le Ignore command or macro status
    lslm!goto(4)le Unconditional labeled jump
    lslm!if(4)le Conditional test statement
    lslm!jump(4)le Unconditional jump
    lslm!nmacro(4)le Ignore command or macro status
    lslm!repeat(4)le Conditional loop (post testing)
    lslm!return(4)le Exit macro with a TRUE status
    lslm!tgoto(4)le Conditional labeled jump
    lslm!tjump(4)le Unconditional relative branch
    lslm!until(4)le Test a conditional loop
    lslm!while(4)le Conditional loop
    lslm$INFOPATH(5)le GNU info files base directory
    lslm$LOGNAME(5)le System user name (UNIX)
    lslm$MEBACKUPPATH(5)le Backup file location
    lslm$MEBACKUPSUB(5)le Backup file name modifier
    lslm$MEINSTALLPATH(5)le MicroEmacs system macros search path
    lslm$MENAME(5)le MicroEmacs user name
    lslm$MEPATH(5)le MicroEmacs search path
    lslm$MEUSERPATH(5)le MicroEmacs user directory
    lslm$ME_ISHELL(5)le Windows ishell command.com
    lslm$ME_PIPE_STDERR(5)le Command line diversion to stderr symbol
    lslm$auto-time(5)le Automatic buffer save time
    lslm$box-chars(5)le Characters used to draw lines
    lslm$buffer-backup(5)le Buffer backup file name
    lslm$buffer-bhook(5)le Buffer macro hook command name (buffer current)
    lslm$buffer-bname(5)le Name of the current buffer
    lslm$buffer-dhook(5)le Buffer macro hook command name (buffer deletion)
    lslm$buffer-ehook(5)le Buffer macro hook command name (buffer swapped)
    lslm$buffer-fhook(5)le Buffer macro hook command name (buffer creation)
    lslm$buffer-fill-col(5)le Buffer paragraph mode; right fill column
    lslm$buffer-fill-mode(5)le Buffer paragraph mode; justification method
    lslm$buffer-fmod(5)le Buffer file modes (or attributes)
    lslm$buffer-fname(5)le Name of the current buffer's file name
    lslm$buffer-hilight(5)le Define current buffer hilighting scheme
    lslm$buffer-indent(5)le Current buffer indentation scheme
    lslm$buffer-indent-width(5)le Buffer indentation width in characters
    lslm$buffer-input(5)le Divert buffer input through macro
    lslm$buffer-ipipe(5)le Divert buffer incremental pipe input through macro
    lslm$buffer-mask(5)le Current buffer word class mask
    lslm$buffer-mode-line(5)le Buffer mode line string
    lslm$buffer-names(5)le Filtered buffer name list
    lslm$buffer-scheme(5)le Buffer color scheme
    lslm$buffer-tab-width(5)le Buffer tab character interval
    lslm$command-names(5)le Filtered command name list
    lslm$cursor-blink(5)le Cursor blink rate
    lslm$cursor-color(5)le Cursor foreground color
    lslm$cursor-x(5)le Mouse X (horizontal) position
    lslm$cursor-y(5)le Mouse Y (vertical) position
    lslm$debug(5)le Macro debugging flag
    lslm$delay-time(5)le Mouse time event delay time
    lslm$file-ignore(5)le File extensions to ignore
    lslm$file-names(5)le Filtered file name list
    lslm$file-template(5)le Regular expression file search string
    lslm$fill-bullet(5)le Paragraph filling bullet character set
    lslm$fill-bullet-len(5)le Paragraph filling bullet search depth
    lslm$fill-col(5)le Global paragraph mode; right fill column
    lslm$fill-eos(5)le Paragraph filling; end of sentence fill characters
    lslm$fill-eos-len(5)le Paragraph filling; end of sentence padding length
    lslm$fill-ignore(5)le Ignore paragraph filling character(s)
    lslm$fill-mode(5)le Global paragraph mode; justification method
    lslm$find-words(5)le Filtered word list
    lslm$fmatchdelay(5)le Fence matching delay time
    lslm$frame-depth(5)le Number of lines on the current frame canvas
    lslm$frame-id(5)le Current frame identity
    lslm$frame-width(5)le Number of columns on the current frame canvas
    lslm$global-fmod(5)le Global file modes (or attributes)
    lslm$global-scheme(5)le Global buffer color scheme
    lslm$home(5)le Users `home' directory location
    lslm$idle-time(5)le System idle event delay time
    lslm$indent-width(5)le Global indentation width in characters
    lslm$kept-versions(5)le Number of backups to be kept
    lslm$line-flags(5)le Current buffer line flags
    lslm$line-scheme(5)le Set the current line color scheme
    lslm$line-template(5)le Command line regular expression search string
    lslm$ml-scheme(5)le Message line color scheme
    lslm$mode-chars(5)le Mode characters
    lslm$mode-line(5)le Mode line format
    lslm$mode-line-scheme(5)le Mode line color scheme
    lslm$mode-names(5)le Filtered mode name list
    lslm$mouse(5)le Mouse configuration variable
    lslm$mouse-pos(5)le Mouse position information
    lslm$mouse-x(5)le Mouse X (horizontal) position
    lslm$mouse-y(5)le Mouse Y (vertical) position
    lslm$osd-scheme(5)le OSD color scheme
    lslm$pause-time(5)le Length of time to pause for user
    lslm$platform(5)le MicroEmacs host platform identifier
    lslm$progname(5)le Program file name
    lslm$quiet(5)le Quiet mode control variable
    lslm$random(5)le Generate a random number
    lslm$rcs-ci-com(5)le RCS (and SCCS) check in command
    lslm$rcs-cif-com(5)le RCS (and SCCS) check in first command
    lslm$rcs-co-com(5)le RCS (and SCCS) check out command
    lslm$rcs-cou-com(5)le RCS (and SCCS) check out unlock command
    lslm$rcs-file(5)le RCS (and SCCS) file name
    lslm$rcs-ue-com(5)le RCS (and SCCS) unedit file command
    lslm$recent-keys(5)le Recent key history
    lslm$repeat-time(5)le Mouse time event repeat time
    lslm$result(5)le Various command return values
    lslm$screen-depth(5)le Number of character lines on the screen canvas
    lslm$screen-width(5)le Number of character columns on the screen canvas
    lslm$scroll(5)le Screen scroll control
    lslm$scroll-bar(5)le Scroll bar configuration
    lslm$scroll-bar-scheme(5)le Scroll bar color scheme
    lslm$search-path(5)le MicroEmacs search path
    lslm$show-modes(5)le Select buffer modes to display
    lslm$show-region(5)le Enable the hilighting of regions
    lslm$status(5)le Macro command execution status
    lslm$system(5)le System configuration variable
    lslm$tab-width(5)le Global displayable tab character width
    lslm$temp-name(5)le Temporary file name
    lslm$time(5)le The current system time
    lslm$timestamp(5)le Time stamp string
    lslm$trunc-scheme(5)le Truncation color scheme
    lslm$user-name(5)le MicroEmacs user name
    lslm$user-path(5)le MicroEmacs user directory
    lslm$variable-names(5)le Filtered variable name list
    lslm$version(5)le MicroEmacs version date-code
    lslm$window-acol(5)le Window cursor actual column
    lslm$window-aline(5)le Window cursor actual line
    lslm$window-chars(5)le Character set used to render the windows
    lslm$window-col(5)le Window cursor column (no expansion)
    lslm$window-depth(5)le Number of text lines in a window
    lslm$window-eline(5)le Window end line
    lslm$window-flags(5)le Current window setup flags
    lslm$window-id(5)le Current window identity
    lslm$window-line(5)le Window cursor line
    lslm$window-mark-col(5)le Window mark column
    lslm$window-mark-line(5)le Window mark line
    lslm$window-mode-line(5)le Window mode line position
    lslm$window-scroll-bar(5)le Window scroll bar (or separator) position
    lslm$window-wcol(5)le Window cursor column (historic)
    lslm$window-width(5)le Number of character columns in a window
    lslm$window-wline(5)le Window cursor line (historic)
    lslm$window-x-scroll(5)le Current window X scroll
    lslm$window-xcl-scroll(5)le Current window current line X scroll
    lslm$window-y-scroll(5)le Current window Y scroll
    lslm%company-name(5)le Name of company for template
    lslm%compile-com(5)le Default system compile command line
    lslm%cvs-com(5)le CVS Command line
    lslm%cygwin-hilight(5)le Cygwin shell hilight enable flag
    lslm%cygwin-path(5)le Cygwin root directory
    lslm%cygwin-prompt(5)le Cygwin shell prompt
    lslm%diff-com(5)le Diff command line
    lslm%ftp-flags(5)le Configure the FTP console
    lslm%gdiff-com(5)le Gdiff command line
    lslm%http-flags(5)le Configure the HTTP console
    lslm%http-proxy-addr(5)le Set HTTP proxy server address
    lslm%http-proxy-port(5)le Set HTTP proxy server port
    lslm%man-com(5)le Man Command line
    lslm%tag-file(5)le Tag file name
    lslm%tag-option(5)le Tag file search option
    lslm%tag-template(5)le Tag file search string
    lslm%xdiff-com(5)le xdiff command line
    lslm%xfind-com(5)le Find command line
    lslm%xgrep-com(5)le Grep command line
    lslm&abs(4)le Absolute value of a number
    lslm&add(4)le Add two numbers
    lslm&and(4)le Logical AND operator
    lslm&atoi(4)le ASCII to integer conversion
    lslm&band(4)le Bitwise AND operator
    lslm&bmode(4)le Determine buffer mode
    lslm&bnot(4)le Bitwise NOT operator
    lslm&bor(4)le Bitwise OR operator
    lslm&bstat(4)le Retrieve current buffer statistic
    lslm&bxor(4)le Bitwise XOR operator
    lslm&cat(4)le Concatenate two strings together
    lslm&cbind(4)le Return the command a key is bound to
    lslm&cond(4)le Conditional expression operator
    lslm&dec(4)le Pre-decrement variable
    lslm&divide(4)le Division of two numbers
    lslm&equal(4)le Numerical equivalence operator
    lslm&exist(4)le Test if a variable or command exists
    lslm&find(4)le Find a file on the search path
    lslm&gmode(4)le Determine global mode
    lslm&great(4)le Numerical greater than operator
    lslm&inc(4)le Pre-increment variable
    lslm&indirect(4)le Evaluate a string as a variable
    lslm&inword(4)le Test for a word character
    lslm&irep(4)le Case insensitive replace string in string
    lslm&isequal(4)le Case insensitive String equivalence operator
    lslm&isin(4)le Case insensitive test for string in string
    lslm&itoa(4)le Integer to ASCII conversion
    lslm&kbind(4)le Return the key a command is bound to
    lslm&ldel(4)le Delete list item
    lslm&left(4)le Return the left most characters from a string
    lslm&len(4)le Return the length of a string
    lslm&less(4)le Numerical less than operator
    lslm&lfind(4)le Find list item
    lslm&lget(4)le Get list item
    lslm&linsert(4)le Insert list item
    lslm&lset(4)le Set list item
    lslm&mid(4)le Return a portion (middle) of a string
    lslm&mod(4)le Modulus of two numbers
    lslm&multiply(4)le Multiply two numbers
    lslm&nbind(4)le Return the numerial argument of a binding
    lslm&nbmode(4)le Determine named buffer mode
    lslm&negate(4)le Negation of two numbers
    lslm&not(4)le Logical NOT operator
    lslm&opt(4)le MicroEmacs optional feature test
    lslm&or(4)le Logical OR operator
    lslm&pdec(4)le Post-decrement variable
    lslm&pinc(4)le Post-increment variable
    lslm&reg(4)le Retrieve a registry value (with default)
    lslm&rep(4)le Replace string in string
    lslm&right(4)le Return the right most characters from a string
    lslm&risin(4)le Recursive case insensitive test for string in string
    lslm&rsin(4)le Recursively test for string in string
    lslm&sequal(4)le String equivalence operator
    lslm&set(4)le In-line macro variable assignment
    lslm&sgreat(4)le String greater than operator
    lslm&sin(4)le Test for string in string
    lslm&sless(4)le String less than operator
    lslm&slower(4)le Return the string converted to lower case
    lslm&sprintf(4)le Formatted string construction
    lslm&stat(4)le Retrieve a file statistic
    lslm&sub(4)le Subtract two numbers
    lslm&supper(4)le Return the string converted to upper case
    lslm&trboth(4)le Return string trimmed of white chars on both sides
    lslm&trleft(4)le Return string trimmed of white chars on left side
    lslm&trright(4)le Return string trimmed of white chars on right side
    lslm&which(4)le Find a program on the path
    lslm&xirep(4)le Regex case insensitive Replace string in string
    lslm&xisequal(4)le Case insensitive regex String equivalence operator
    lslm&xrep(4)le Regex replace string in string
    lslm&xsequal(4)le Regex string equivalence operator
    lslm.Xdefaults(8)le UNIX Window Manager defaults file
    lslm.ascii-time.format(5)le Set the format of the date string
    lslm.calc.result(5)le Last calc calculation result
    lslm.which.result(5)le Program path
    lslm0-9(9)le UNIX t/nroff file
    lslm2dos(3f)le Convert text files to DOS format files.
    lslm2mac(3f)le Convert text files to Macintosh format files
    lslm2unix(3f)le Convert text files to UNIX format files
    lslm2win(3f)le Convert text files to Windows format files.
    lslm@0(4)le Macro arguments (macro name)
    lslm@1(4)le Macro arguments (first argument)
    lslm@2(4)le Macro arguments (second argument)
    lslm@?(4)le Macro arguments (numeric argument given)
    lslm@cc(4)le Current command name
    lslm@cck(4)le Current command key
    lslm@cg(4)le Get a command name from the user
    lslm@cgk(4)le Get a key from the user
    lslm@cl(4)le Last command name
    lslm@clk(4)le Last command key
    lslm@cq(4)le Get a quoted command name from the user
    lslm@cqk(4)le Get a quoted key from the user
    lslm@fs(4)le Frame store variable
    lslm@fss(4)le Frame store scheme variable
    lslm@h0(4)le General history string
    lslm@h1(4)le Buffer history string
    lslm@h2(4)le Command history string
    lslm@h3(4)le File history string
    lslm@h4(4)le Search history string
    lslm@#(4)le Macro arguments (numeric argument value)
    lslm@mc(4)le Message line character input request
    lslm@ml(4)le Message line input request
    lslm@mn(4)le Message line input as normal request
    lslm@mna(4)le All input from Message line as normal
    lslm@mx(4)le Message line input by executing command
    lslm@mxa(4)le All input from Message line by executing command
    lslm@p(4)le Macro arguments (calling macro name)
    lslm@s0(4)le Last search's whole match string
    lslm@s1(4)le Last search's first group value
    lslm@s2(4)le Last search's second group value
    lslm@wc(4)le Extract character from the current buffer
    lslm@wl(4)le Extract a line from the current buffer
    lslm@y(4)le Yank buffer variable
    lslmabbrev-list(3)le Create a list of abbreviations
    lslmabort-command(2)le (cDC-gcA) Abort command
    lslmabout(2)le Information About MicroEmacs
    lslmada(9)le Ada programming language
    lslmadb(9)le Ada programming language
    lslmadd-color(2)le Create a new color
    lslmadd-color-scheme(2)le Create a new color scheme
    lslmadd-dictionary(2)le Declare existence of a spelling dictionary
    lslmadd-file-hook(2)le Declare file name context dependent configuration
    lslmadd-global-mode(3)le Set a global buffer mode
    lslmadd-mode(3)le Set a local buffer mode
    lslmadd-next-line(2)le Define the searching behavior of command output
    lslmadd-spell-rule(2)le Add a new spelling rule to the dictionary
    lslmads(9)le Ada programming language
    lslmalarm(3)le Set an alarm
    lslmalias-path-setup(3)le Define alternative path alias
    lslmaman(3)le Compile an nroff file into a buffer (UNIX)
    lslmapache(9)le Apache httpd.conf configuration file
    lslmappend-buffer(2)le Write contents of buffer to end of named file
    lslmascii-time(3)le Return the current time as a string
    lslmasm(9)le Assembler File
    lslmasn.1(9)le ASN.1 file
    lslmasp(9)le Active Server Pages
    lslmauto(2m)le Automatic source file line type detection
    lslmauto-spell(3)le Auto-spell support
    lslmauto-spell-buffer(3)le Auto-spell whole buffer
    lslmauto-spell-ignore(3)le Auto-spell ignore current word
    lslmauto-spell-menu(3)le Auto-spell context menu
    lslmauto-spell-reset(3)le Auto-spell hilight reset
    lslmautosv(2m)le Automatic file save
    lslmawk(9)le AWK File
    lslmBindings(2)le Default Key Bindings
    lslmBufferVariables(4)le Buffer variables
    lslmBuild(2)le Build
    lslmbackup(2m)le Automatic file backup of last edit
    lslmbackward-char(2)le (cDC-bcA) Move the cursor left
    lslmbackward-delete-char(2)le (cDbackspacecA) Delete the previous character at the
    cursor position
    lslmbackward-delete-tab(2)le (cDS-tabcA) Delete white space to previous tab-stop
    lslmbackward-kill-word(2)le (cDesc backspacecA) Delete the previous word at the
    cursor position
    lslmbackward-line(2)le (cDC-pcA) Move the cursor to the previous line
    lslmbackward-paragraph(2)le (cDesc pcA) Move the cursor to the previous paragraph
    lslmbackward-word(2)le (cDesc bcA) Move the cursor to the previous word
    lslmbas(9)le Visual Basic
    lslmbat(9)le MS-DOS Batch File
    lslmbeginning-of-buffer(2)le (cDesc <cA) Move to beginning of buffer/file
    lslmbeginning-of-line(2)le (cDC-acA) Move to beginning of line
    lslmbenchmrk(3f)le Benchmark MicroEmacs macro processor speed
    lslmbib(9)le TeX Bibliography File
    lslmbinary(2m)le Binary editor mode
    lslmbnf(9)le Backus-Naur Form
    lslmbrowse(3)le Browse a file or buffer in view mode
    lslmbtm(9)le 4-DOS Batch File
    lslmbuffer-abbrev-file(2)le Set buffers' abbreviation file
    lslmbuffer-bind-key(2)le Create local key binding for current buffer
    lslmbuffer-info(2)le (cDC-x =cA) Status information on current buffer position
    lslmbuffer-init(3)le Initialize a buffer language template
    lslmbuffer-init-fhook(3)le Initialize the buffer file hooks
    lslmbuffer-init-hooks(3)le Initialize the buffer language template hooks
    lslmbuffer-major-mode(3)le Change the operating mode of a buffer
    lslmbuffer-mode(2)le (cDC-x mcA) Change a local buffer mode
    lslmbuffer-setup(3)le Configure the current buffer settings
    lslmbuffer-unbind-key(2)le Remove local key binding for current buffer
    lslmClearCase(3)le MicroEmacs ClearCase interface
    lslmClient-Server(2)le Client-Server Model
    lslmCmdVariables(4)le Command variables
    lslmCommandVariables(4)le Last, current and get a command key/name
    lslmCompanyProfiles(2)le Defining a company profile
    lslmCompatibility(2)le Compatibility with the original MicroEmacs
    lslmCurrentBufferVariables(4)le Extract information from the current buffer
    lslmc(9)le C programming language
    lslmc-deslashify(3)le C language, remove backslash to end of lines of region
    lslmc-hash-del(3)le Remove C/C++ #define evaluation
    lslmc-hash-eval(3)le Evaluate C/C++ #defines
    lslmc-hash-set-define(3)le Set a C/C++ #define
    lslmc-hash-unset-define(3)le Unset a C/C++ #define
    lslmc-slashify(3)le C language, append backslash to end of lines of region
    lslmc-to-cpp-convert(3)le Convert a C file to C++
    lslmcalc(3)le Integer calculator
    lslmcapitalize-word(2)le (cDesc ccA) Capitalize word
    lslmcbl(9)le Cobol (85) File
    lslmcc(9)le C++ programming language
    lslmcc-add(3)le MicroEmacs ClearCase interface - add file
    lslmcc-checkin(3)le MicroEmacs ClearCase interface - checkin files
    lslmcc-checkout(3)le MicroEmacs ClearCase interface - checkout files
    lslmcc-delete(3)le MicroEmacs ClearCase interface - delete files
    lslmcc-diff(3)le MicroEmacs ClearCase interface - diff changes
    lslmcc-setup(3)le MicroEmacs ClearCase interface setup
    lslmcc-state(3)le MicroEmacs ClearCase interface - list state of directory files
    lslmcc-update(3)le MicroEmacs ClearCase interface - update directory files
    lslmcfc(9)le ColdFusion Markup Language
    lslmcfm(9)le ColdFusion Markup Language
    lslmcfml(9)le Adobe Macromedia ColdFusion Markup Language
    lslmchange-buffer-name(2)le (cDesc C-ncA) Change name of current buffer
    lslmchange-file-name(2)le (cDC-x ncA) Change the file name of the current buffer
    lslmchange-font(2)le Change the screen font
    lslmchange-frame-depth(2)le Change the number of lines on the current frame
    lslmchange-frame-width(2)le Change the number of columns on the current frame
    lslmchange-scheme(3)le Change the current highlight scheme
    lslmchange-screen-depth(2)le Change the number of lines on the screen
    lslmchange-screen-width(2)le Change the number of columns on the screen
    lslmchange-window-depth(2)le Change the depth of the current window
    lslmchange-window-width(2)le Change the width of the current window
    lslmcharset-change(3)le Convert buffer between two character sets
    lslmcharset-iso-to-user(3)le Convert buffer from ISO standard to user character
    set
    lslmcharset-user-to-iso(3)le Convert buffer from user to ISO standard character
    set
    lslmcheck-line-length(3)le Check the length of text lines are valid
    lslmclean(3)le Remove redundant white spaces from the current buffer
    lslmcls(9)le Visual Basic
    lslmcollapse-all(3)le (cDf3cA) (Un)Fold all regions in the current buffer
    lslmcollapse-current(3)le (cDf2cA) (un)Fold a region in the current buffer
    lslmcommand-apropos(2)le (cDC-h acA) List commands involving a concept
    lslmcommand-wait(2)le Conditional wait command
    lslmcomment-end(3)le End the current comment
    lslmcomment-line(3)le Comment out the current line
    lslmcomment-restyle(3)le Reformat the current comment
    lslmcomment-start(3)le Start a new comment
    lslmcomment-to-end-of-line(3)le Extend comment to end of line
    lslmcompare-windows(2)le Compare buffer windows, ignore whitespace
    lslmcompare-windows-exact(3)le Compare buffer windows, with whitespace
    lslmcompile(3)le Start a compilation process
    lslmcopy-rectangle(3)le Copy a rectangular region of text
    lslmcopy-region(2)le (cDesc wcA) Copy a region of the buffer
    lslmcopy-registry(3)le Recursive copy of registry subtree
    lslmcount-words(2)le (cDesc C-ccA) Count the number of words in a region
    lslmcpp(9)le C++ programming language
    lslmcr(2m)le File's carriage return (CR) style
    lslmcreate-callback(2)le Create a timer callback
    lslmcreate-frame(2)le (cDC-x 5 1cA, cDC-x 5 2cA) Create a new frame
    lslmcrypt(2m)le Encrypted file mode
    lslmcsh(9)le C-Shell file
    lslmctags(3f)le Generate a C tags file
    lslmctrlz(2m)le File's termination style
    lslmcvs(3)le MicroEmacs CVS interface
    lslmcvs-add(3)le MicroEmacs CVS interface - add file
    lslmcvs-checkout(3)le MicroEmacs CVS interface - checkout files
    lslmcvs-commit(3)le MicroEmacs CVS interface - commit changes
    lslmcvs-diff(3)le MicroEmacs CVS interface - diff changes
    lslmcvs-gdiff(3)le MicroEmacs CVS interface - graphical diff changes
    lslmcvs-log(3)le MicroEmacs CVS interface - log changes
    lslmcvs-remove(3)le MicroEmacs CVS interface - remove file
    lslmcvs-resolve-conflicts(3)le MicroEmacs CVS interface - resolve conflicts
    lslmcvs-setup(3)le MicroEmacs CVS interface setup
    lslmcvs-state(3)le MicroEmacs CVS interface - list state of directory files
    lslmcvs-status(3)le MicroEmacs CVS interface - status of files
    lslmcvs-tag(3)le MicroEmacs CVS interface - tag files
    lslmcvs-update(3)le MicroEmacs CVS interface - update directory files
    lslmcygwin(3)le Open a Cygwin BASH window
    lslmdbx(3)le UNIX Debugger
    lslmdef(9)le C or C++ definition file
    lslmdefine-help(2)le Define help information
    lslmdefine-macro(2)le Define a new macro
    lslmdefine-macro-file(2)le Define macro file location
    lslmdel(2m)le Flag buffer to be deleted
    lslmdelete-blank-lines(2)le (cDC-x C-ocA) Delete blank lines about cursor
    lslmdelete-buffer(2)le (cDC-x kcA) Delete a buffer
    lslmdelete-dictionary(2)le Remove a spelling dictionary from memory
    lslmdelete-frame(2)le (cDC-x 5 0cA) Delete the current frame
    lslmdelete-global-mode(3)le Remove a global buffer mode
    lslmdelete-hilight-lines(3)le Delete hilight lines
    lslmdelete-indentation(3)le Join 2 lines deleting white spaces
    lslmdelete-mode(3)le Remove a local buffer mode
    lslmdelete-other-windows(2)le (cDC-x 1cA) Delete other windows
    lslmdelete-registry(2)le Delete a registry tree
    lslmdelete-some-buffers(2)le Delete buffers with query
    lslmdelete-window(2)le (cDC-x 0cA) Delete current window
    lslmdescribe-bindings(2)le (cDC-h bcA) Show current command/key binding
    lslmdescribe-key(2)le (cDC-x ?cA) Report keyboard key name and binding
    lslmdescribe-variable(2)le (cDC-h vcA) Describe current setting of a variable
    lslmdescribe-word(3)le Display a dictionary definition of a word
    lslmdiff(3)le Difference files or directories
    lslmdiff-changes(3)le Find the differences from a previous edit session
    lslmdir(2m)le Buffer is a directory listing
    lslmdirectory-tree(2)le Draw the file directory tree
    lslmdisplay-matching-fence(3)le Display the matching bracket
    lslmdisplay-white-chars(3)le Toggle the displaying of white characters
    lslmdisplay-whitespaces(3)le Toggle the displaying of white characters
    lslmdoc(9)le ASCII plain text document file
    lslmdos2unix(3f)le Convert DOS format files to UNIX format files
    lslmdraw(3)le Simple line drawing utility
    lslmeaf(8)le MicroEmacs abbreviation file format
    lslmedf(8)le MicroEmacs spelling dictionary file
    lslmedit(2m)le Buffer has be changed
    lslmedit-dictionary(3)le Insert a dictionary in a buffer
    lslmehf(8)le MicroEmacs help file
    lslmehf(9)le MicroEmacs 2009 help file
    lslmehftools(3f)le Generate a MicroEmacs help file
    lslmemf(8)le MicroEmacs macro file
    lslmemf(9)le MicroEmacs 2009 Macro File
    lslmemftags(3f)le Generate a MicroEmacs macro tags file
    lslmencase(3)le Encase a text region with start/end string
    lslmend-kbd-macro(2)le (cDC-x )cA) Stop recording keyboard macro
    lslmend-of-buffer(2)le (cDesc >cA) Move to end of buffer/file
    lslmend-of-line(2)le (cDC-ecA) Move to end of line
    lslmenf(8)le Notes database file
    lslmerf(8)le MicroEmacs registry file
    lslmerf(9)le MicroEmacs 2009 registry file
    lslmesf(8)le MicroEmacs session file
    lslmetf(8)le MicroEmacs template file format
    lslmetfinsrt(3)le Insert template file into current buffer
    lslmexact(2m)le Searching and sorting case sensitivity
    lslmexchange-point-and-mark(2)le (cDC-x C-xcA) Exchange the cursor and marked
    position
    lslmexecute-buffer(2)le Execute script lines from a buffer
    lslmexecute-file(2)le (cDesc /cA) Execute script lines from a file
    lslmexecute-kbd-macro(2)le (cDC-x ecA) Execute a keyboard macro
    lslmexecute-line(2)le Execute a typed in script line
    lslmexecute-named-command(2)le [cDesc xcA] Execute a named command
    lslmexecute-string(2)le Execute a string as a command
    lslmexecute-tool(3)le Execute a user defined shell tool
    lslmexit-emacs(2)le Exit MicroEmacs
    lslmexpand-abbrev(2)le Expand an abbreviation
    lslmexpand-abbrev-handle(3)le (cDesc esccA) Expand an abbreviation handler
    lslmexpand-iso-accents(3)le Expand an ISO accent
    lslmexpand-look-back(3)le Complete a word by looking back for a similar word
    lslmexpand-word(3)le Complete a word by invocation of the speller
    lslmf(9)le Fortran File
    lslmf77(9)le Fortran 77 File
    lslmf90(9)le Fortran 90 File
    lslmfence(2m)le Auto fence matching mode
    lslmfile-attrib(3)le Set the current buffers system file attributes
    lslmfile-browser(3)le (cDf10cA) Browse the file system
    lslmfile-browser-close(3)le Close the file-browser
    lslmfile-browser-swap-buffers(3)le Swap between file-browser windows
    lslmfile-op(2)le File system operations command
    lslmfile-tool-setup(3)le Define file browser tools
    lslmfile-type-setup(3)le Define file type set
    lslmfileHooks(2)le File Hooks
    lslmfiletype(3f)le Determine file type UNIX, DOS or Windows
    lslmfill-paragraph(2)le (cDesc ocA) Format a paragraph
    lslmfilter-buffer(2)le (cDC-x #cA) Filter the current buffer through an O/S command
    lslmfind(3)le Execute built-in find command
    lslmfind-bfile(3)le (cDC-x 9cA) Load a file as binary data
    lslmfind-buffer(2)le (cDC-x bcA) Switch to a named buffer
    lslmfind-cfile(3)le Load a crypted file
    lslmfind-file(2)le (cDC-x C-fcA) Load a file
    lslmfind-registry(2)le Index search of a registry sub-tree
    lslmfind-setup(3)le Setup the built-in find and grep commands
    lslmfind-tag(2)le (cDesc tcA) Find tag, auto-load file and move to tag position
    lslmfind-word(3)le Find a using spelling dictionaries
    lslmfind-zfile(3)le Compressed file support
    lslmfold-close(3)le (cDC-f2cA) Close an open fold (in-line)
    lslmfold-create(3)le (cDC-f2cA) Create a new fold
    lslmfold-enter(3)le (cDf3cA) Enter fold
    lslmfold-exit(3)le (cDesc f3cA) Exit a fold
    lslmfold-exit-all(3)le (cDesc C-f3cA) Exit all folds
    lslmfold-kill(3)le (cDC-x C-kcA) Delete the fold and all its contents
    lslmfold-open(3)le (cDf2cA) Open fold (in-line)
    lslmfold-remove(3)le (cDesc C-f3cA) Remove the fold, maintaining content
    lslmforward-char(2)le (cDC-fcA) Move the cursor right
    lslmforward-delete-char(2)le (cDC-dcA) Delete the next character at the cursor
    position
    lslmforward-kill-word(2)le (cDesc dcA) Delete the next word at the cursor position
    lslmforward-line(2)le (cDC-ncA) Move the cursor to the next line
    lslmforward-paragraph(2)le (cDesc ncA) Move the cursor to the next paragraph
    lslmforward-word(2)le (cDesc fcA) Move the cursor to the next word
    lslmftp(3)le Initiate an FTP connection
    lslmfvwm(9)le FVWM configuration file
    lslmfvwmrc(9)le FVWM configuration file
    lslmgawk(9)le GNU AWK File
    lslmgdb(3)le GNU Debugger
    lslmgdiff(3)le Graphical file difference
    lslmgdiff(3f)le Command line graphical file difference
    lslmgenerate-tags-file(3)le Generate a tags file
    lslmget-next-line(2)le (cDC-x `cA) Find the next command line
    lslmglobal-abbrev-file(2)le Set global abbreviation file
    lslmglobal-bind-key(2)le (cDesc kcA) Bind a key to a named command or macro
    lslmglobal-mode(2)le (cDesc mcA) Change a global buffer mode
    lslmglobal-unbind-key(2)le (cDesc C-kcA) Unbind a key from a named command or macro
    lslmgoto-alpha-mark(2)le (cDC-x acA) Move the cursor to a alpha marked location
    lslmgoto-line(2)le (cDesc gcA) Move the cursor to specified line
    lslmgoto-matching-fence(2)le (cDesc C-fcA) Move the cursor to matching fence
    lslmgoto-position(2)le Restore a stored position
    lslmgoto-window(2)le Restore a saved window to the current window (historic)
    lslmgrep(3)le Search a file for a pattern
    lslmgrow-window-horizontally(2)le Enlarge current window horizontally (relative)
    lslmgrow-window-vertically(2)le Enlarge the current window (relative change)
    lslmHistoryGroupVariables(4)le Last history values
    lslmh(9)le C programming language header
    lslmhelp(2)le (cDesc ?cA) Help; high level introduction to help
    lslmhelp-command(2)le (cDC-h C-ccA) Help; command information
    lslmhelp-item(2)le (cDC-h C-icA) Help; item information
    lslmhelp-variable(2)le (cDC-h C-vcA) Help; variable information
    lslmhide(2m)le Hide buffer
    lslmhilight(2)le Manage the buffer hilighting schemes
    lslmhpj(9)le MS-Windows Help Project File
    lslmhtm(9)le HyperText Markup Language File
    lslmhtml(9)le HyperText Markup Language File
    lslmhttpd.conf(9)le Apache configuration file
    lslmhunt-backward(2)le (cDC-x C-hcA) Resume previous search in backward direction
    lslmhunt-forward(2)le (cDC-x hcA) Resume previous search in forward direction
    lslmInstallation(1)le Installation details for MicroEmacs
    lslmInterfacing(2)le Interfacing to external components
    lslmi(9)le C/C++ preprocessor outpuit file
    lslmifill-paragraph(3)le (cDesc qcA) Format a paragraph
    lslmimakefile(9)le Make file
    lslmindent(2)le Manage the auto-indentation methods
    lslmindent(2m)le Automatic indentation
    lslmindent-decrease(3)le Decrease the line indentation
    lslmindent-increase(3)le Increase the line indentation
    lslminfo(3)le Display a GNU Info database
    lslminfo(9)le GNU Info file
    lslminfo-goto-link(3)le Display Info on a given link
    lslminfo-on(3)le Display Info on a given topic
    lslmini(9)le MS-Windows Initialization File
    lslminsert-file(2)le (cDC-x C-icA) Insert file into current buffer
    lslminsert-file-name(2)le (cDC-x C-ycA) Insert filename into current buffer
    lslminsert-macro(2)le Insert keyboard macro into buffer
    lslminsert-newline(2)le (cDC-ocA) Insert new line at cursor position
    lslminsert-password(3)le Create and insert a new password string
    lslminsert-space(2)le Insert space(s) into current buffer
    lslminsert-string(2)le Insert character string into current buffer
    lslminsert-symbol(3)le Insert an ASCII character
    lslminsert-tab(2)le (cDC-icA) Insert tab(s) into current buffer
    lslmipipe-kill(2)le Kill a incremental pipe
    lslmipipe-shell-command(2)le (cDesc \cA) Incremental pipe (non-suspending
    system call)
    lslmipipe-write(2)le Write a string to an incremental pipe
    lslmisearch-backward(2)le (cDC-rcA) Search backwards incrementally (interactive)
    lslmisearch-forward(2)le (cDC-scA) Search forward incrementally (interactive)
    lslmishell(3)le Open a Cygwin BASH window
    lslmiso-accents-mode(3)le ISO accent expansion short-cut mode
    lslmitem-list(3)le (cDF7cA) Abbreviated search and list buffer contents
    lslmitem-list-close(3)le (cDesc F7cA) Close the item list
    lslmitem-list-find(3)le Find the selected item in the item list
    lslmjav(9)le Java programming language
    lslmjava(9)le Java programming language
    lslmjavatags(3f)le Generate a C tags file from Java sources
    lslmjst(9)le JASSPA Structred Text
    lslmjustify(2m)le Justification Mode
    lslmkbd-macro-query(2)le (cDC-x qcA) Query termination of keyboard macro
    lslmkeyNames(2)le Key Binding Names
    lslmkill-line(2)le (cDC-kcA) Delete all characters to the end of the line
    lslmkill-paragraph(2)le Delete a paragraph
    lslmkill-rectangle(2)le (cDesc C-wcA) Delete a column of text
    lslmkill-region(2)le (cDC-wcA) Delete all characters in the marked region
    lslmksh(9)le Korn shell file
    lslml(9)le LEX programming language
    lslmlanguageTemplates(2)le File Language Templates
    lslmlatex(9)le TeX Documentation
    lslmlf(2m)le File's line feed style
    lslmline-scheme(3)le Apply line annotation in current buffer
    lslmlist-buffers(2)le (cDC-x C-bcA) List all buffers and show their status
    lslmlist-commands(2)le (cDC-h ccA) List available commands
    lslmlist-registry(2)le Display the registry in a buffer
    lslmlist-variables(2)le (cDC-h vcA) List defined variables
    lslmlocaleSupport(2)le Locale Support
    lslmlock(2m)le Pipe cursor position lock
    lslmlogin(9)le Shell user login file
    lslmlower-case-region(2)le (cDC-x C-lcA) Lowercase a region (downcase)
    lslmlower-case-word(2)le (cDesc lcA) Lowercase word (downcase)
    lslmMacroArguments(4)le Arguments to macros
    lslmMacroNumericArguments(4)le Numeric arguments to macros
    lslmMahjongg(3)le MicroEmacs 2009 version of the solitaire Mah Jongg game
    lslmMainMenu(3)le The top main menu
    lslmMatch-It(3)le MicroEmacs 2009 version of the Match-It game
    lslmMessageLineVaraibles(4)le Prompt the user for input on message line
    lslmMetaFont(9)le MetaFont/MetaPost File
    lslmMetris(3)le MicroEmacs 2009 version of the falling blocks game
    lslmm4(9)le M4 Macro Processor
    lslmmacroDebugging(4)le Macro Debugging - A Crash Course
    lslmmacroOverview(4)le MicroEmacs Macro Language at a Glance
    lslmmacroWriting(4)le Writing MicroEmacs Macros
    lslmmagic(2m)le Regular expression search
    lslmmail(3)le Compose and send an email
    lslmmail-check(3)le Check for new email
    lslmmajor-mode-help(3)le Displays help page for current buffer
    lslmmajor-mode-setup(3)le Configures the current buffer settings
    lslmmakefile(9)le Make file
    lslmman(3)le UNIX manual page viewer
    lslmman(9)le UNIX Manual Page
    lslmman-clean(3)le Clean UNIX manual page
    lslmmark-registry(2)le Modify the operating mode of a registry node
    lslmme(1)le MicroEmacs 2009 text editor
    lslmme32.ini(8)le Microsoft Window's Initialization (ini) File
    lslmmemsdev(1)le Microsoft Developer Studio Add-in for MicroEmacs 2009
    lslmmf(9)le MetaFont File
    lslmml-bind-key(2)le Create key binding for message line
    lslmml-unbind-key(2)le Remove key binding from message line
    lslmml-write(2)le Write message on message line
    lslmmp(9)le MetaPost File
    lslmnact(2m)le Buffer not active
    lslmname-kbd-macro(2)le Assign a name to the last keyboard macro
    lslmnamed-buffer-mode(2)le Change a named buffer mode
    lslmnarrow(2m)le Buffer contains a narrow
    lslmnarrow-buffer(2)le Hide buffer lines
    lslmnarrow-search-backward(3)le (cDC-c rcA) Search for a string in the backward
    direction
    lslmnarrow-search-forward(3)le (cDC-c scA) Search for a string in the forward
    direction
    lslmnawk(9)le New AWK File
    lslmne(1)le NanoEmacs 2009 text editor
    lslmnewline(2)le (cDreturncA) Insert a new line
    lslmnext-buffer(2)le (cDC-x xcA) Switch to the next buffer
    lslmnext-frame(2)le (cDC-x 5 ocA) Change the focus to the next frame
    lslmnext-window(2)le (cDC-x ocA) Move the cursor to the next window
    lslmnext-window-find-buffer(2)le [cDcA] Split the current window and show new buffer
    lslmnext-window-find-file(2)le (cDC-x 4cA) Split the current window and find file
    lslmnormal-tab(3)le Insert a normal tab
    lslmnotes(3)le Tagged hierarchical database of notes
    lslmnotes-close(3)le Close the notes window
    lslmnotes-context(3)le Create/Access buffer context note
    lslmnotes-file(3)le Open a notes database file
    lslmnotes-import-skwyrul(3)le Import a Skwyrul index file (skwyrul_l.htm)
    lslmnotes-instant(3)le Create quick note
    lslmnroff(9)le UNIX nroff file
    lslmntags(3f)le Generate a nroff tags file
    lslmnumber-items(3)le Renumber a vertical list of items
    lslmoccur(3)le Regular expression search for occurrences
    lslmopen-line(3)le (cDC-ocA) Open new line at cursor position
    lslmorganizer(3)le Calendar and address organizer
    lslmosd(2)le Manage the On-Screen Display
    lslmosd-bind-key(2)le Create key binding for OSD dialog
    lslmosd-dialog(3)le OSD dialog box
    lslmosd-entry(3)le OSD entry dialog box
    lslmosd-help(3)le GUI based on-line help
    lslmosd-search(3)le Search and annotate the current buffer
    lslmosd-unbind-key(2)le Remove key binding from OSD dialog
    lslmosd-xdialog(3)le OSD Extended dialog box
    lslmover(2m)le Over-strike Mode
    lslmPatching(1)le Patch a MicroEmacs Installation
    lslmPatience(3)le MicroEmacs 2009 version of Patience (or Solitaire)
    lslmp(9)le Pascal File
    lslmpage-bfile(3)le Load a large binary file as binary data
    lslmpage-file(3)le Load a large file in page mode
    lslmpage-file-backward-line(3)le (cDC-pcA) Move backwards one line in paged buffer
    lslmpage-file-beginning-of-buffer(3)le Move to the start of the paged file
    lslmpage-file-end-of-buffer(3)le Move to the end of the paged file
    lslmpage-file-forward-line(3)le (cDC-ncA) Move forwards one line in paged buffer
    lslmpage-file-goto-byte(3)le Page to the buffer byte offset
    lslmpage-file-goto-page(3)le Move to page
    lslmpage-file-isearch-backward(3)le (cDC-rcA) Page search backwards incrementally
    (interactive)
    lslmpage-file-isearch-forward(3)le (cDC-scA) Page search forward incrementally
    (interactive)
    lslmpage-file-save-buffer(3)le (cDC-x C-scA) Save contents of a page mode buffer to
    file
    lslmpage-file-scroll-down(3)le (cDC-ncA) Scroll paged buffer down
    lslmpage-file-scroll-up(3)le (cDC-pcA) Scroll paged buffer up
    lslmpage-file-search-backward(3)le (cDC-x rcA) Page search for a string in the
    backward direction
    lslmpage-file-search-buffer(3)le Search the page file buffer
    lslmpage-file-search-forward(3)le (cDC-x scA) Page search for a string in the
    forward direction
    lslmparagraph-to-line(3)le Convert a paragraph to a single line
    lslmpas(9)le Pascal File
    lslmpassword-to-phonic(3)le Convert a password to phonic string
    lslmperl(9)le Practical Extraction and Report Language File
    lslmperldb(3)le Perl Debugger
    lslmphp(9)le PHP: Hypertext Preprocessor Language
    lslmphp3(9)le PHP: Hypertext Preprocessor Language
    lslmphp4(9)le PHP: Hypertext Preprocessor Language
    lslmphphtml(9)le PHP: Hypertext Preprocessor Language
    lslmpipe(2m)le Incremental Pipe running
    lslmpipe-shell-command(2)le (cDesc @cA) Execute a single operating system command
    lslmpl(9)le Practical Extraction and Report Language File
    lslmpm(9)le Practical Extraction and Report Language File
    lslmpopup-window(2)le Pop-up a window on the screen
    lslmprefix(2)le Key prefix command
    lslmprevious-window(2)le (cDC-x pcA) Move the cursor to the previous window
    lslmprint-buffer(2)le Print buffer, with formatting
    lslmprint-color(2)le Create a new printer color
    lslmprint-region(2)le Print region, with formatting
    lslmprint-scheme(2)le Create a new printer color and font scheme
    lslmprint-setup(3)le Configure MicroEmacs's printer interface
    lslmprintall(3f)le Formatted print job
    lslmprofile(9)le Shell user profile
    lslmpy(9)le Python Language File
    lslmpython(9)le Python Language File
    lslmquery-replace-all-string(3)le Query replace string in a list of files
    lslmquery-replace-string(2)le (cDesc C-rcA) Search and replace a string - with query
    lslmquery-replace-string-in-files(3)le Conditionally search and replace strings
    across files
    lslmquick-exit(2)le (cDesc zcA) Exit the editor writing changes
    lslmquote-char(2)le (cDC-qcA) Insert literal character
    lslmRegisterVariables(4)le Register variables
    lslmRegularExpressions(2)le Regular Expressions
    lslmrb(9)le Ruby programming language
    lslmrbin(2m)le Reduced binary editor mode
    lslmrc(9)le Microsoft Developer resource file
    lslmrcs-file(2)le (cDC-x C-qcA) Handle Revision Control System (RCS) files
    lslmrdiff(3)le Recursively compare files or directories
    lslmread-file(2)le (cDC-x C-rcA) Find and load file replacing current buffer
    lslmread-registry(2)le Read in a registry definition file
    lslmread-session(3)le Read in session information
    lslmrecenter(2)le (cDC-lcA) Recenter the window (refresh the screen)
    lslmreg(9)le Registry file
    lslmreplace-all-pairs(3)le Replace string pairs in a list of files
    lslmreplace-all-string(3)le Replace string with new string in a list of files
    lslmreplace-string(2)le (cDesc rcA) Replace string with new string
    lslmreplace-string-in-files(3)le Search and replace strings across files
    lslmreread-all(3)le Reload all files
    lslmreread-file(3)le Reload the current buffer's file
    lslmresize-all-windows(2)le Resize all windows (automatic change)
    lslmresize-window-horizontally(2)le Resize current window horizontally
    (absolute)
    lslmresize-window-vertically(2)le Resize the current window (absolute change)
    lslmrestore-dictionary(3)le Save dictionary user changes
    lslmrestyle-buffer(3)le Automatically reformat a buffer's indentation
    lslmrestyle-region(3)le Automatically reformat a regions indentation
    lslmreyank(2)le (cDesc ycA) Restore next yank buffer
    lslmrgrep(3)le Execute recursive grep command
    lslmrgy(9)le Registry file
    lslmruby(9)le Ruby programming language
    lslmrul(9)le Install Shield Rules
    lslmSearchGroups(4)le Last search group values
    lslms(9)le Assembler File
    lslmsamba(9)le Samba smb.conf configuration file
    lslmsave(2m)le Flag buffer to be saved
    lslmsave-all(3)le Save all modified files (with query)
    lslmsave-buffer(2)le (cDC-x C-scA) Save contents of changed buffer to file
    lslmsave-buffers-exit-emacs(2)le (cDesc zcA) Exit the editor prompt user to write
    changes
    lslmsave-dictionary(2)le Save changed spelling dictionaries
    lslmsave-registry(2)le Write a registry definition file
    lslmsave-session(3)le Write session information to session file
    lslmsave-some-buffers(2)le Save contents of all changed buffers to file (with
    query)
    lslmsch(9)le Scheme File
    lslmscheme(9)le Scheme File
    lslmscheme-editor(3)le Color Scheme Editor
    lslmscm(9)le Scheme File
    lslmscreen-poke(2)le Immediate write string to the screen
    lslmscreen-update(2)le (cDredrawcA) Force screen update
    lslmscroll-down(2)le (cDC-ncA) Move the window down (scrolling)
    lslmscroll-left(2)le (cDC-x <cA) Move the window left (scrolling)
    lslmscroll-next-window-down(2)le (cDesc C-vcA) Scroll next window down
    lslmscroll-next-window-up(2)le (cDesc C-zcA) Scroll next window up
    lslmscroll-right(2)le (cDC-x >cA) Move the window right (scrolling)
    lslmscroll-up(2)le (cDC-pcA) Move the window up (scrolling)
    lslmsearch-backward(2)le (cDC-x rcA) Search for a string in the backward direction
    lslmsearch-buffer(2)le Search the current buffer for a string
    lslmsearch-forward(2)le (cDC-x scA) Search for a string in the forward direction
    lslmset-alpha-mark(2)le (cDC-x C-acA) Place an alphabetic marker in the buffer
    lslmset-char-mask(2)le Set character word mask
    lslmset-cursor-to-mouse(2)le Move the cursor to the current mouse position
    lslmset-encryption-key(2)le (cDesc ecA) Define the encryption key
    lslmset-mark(2)le (cDesc spacecA) Set starting point of region
    lslmset-position(2)le Store the current position
    lslmset-registry(2)le Modify a node value in the registry
    lslmset-scroll-with-mouse(2)le Scroll the window with the mouse
    lslmset-variable(2)le (cDC-x vcA) Assign a new value to a variable
    lslmset-window(2)le Save the current window for restore (historic)
    lslmsh(9)le Bourne shell file
    lslmshell(2)le [cDC-x ccA] Create a new command processor or shell
    lslmshell-command(2)le Perform an operating system command
    lslmshow-cursor(2)le Change the visibility of the cursor
    lslmshow-region(2)le Show the current copy region
    lslmshrink-window-horizontally(2)le Shrink current window horizontally
    (relative)
    lslmshrink-window-vertically(2)le Shrink the current window (relative change)
    lslmshut-down(3)le Editor exit callback command
    lslmsmb.conf(9)le Samba configuration file
    lslmso(9)le UNIX t/nroff include file
    lslmsort-lines(2)le Alphabetically sort lines
    lslmsort-lines-ignore-case(3)le Alphabetically sort lines ignoring case
    lslmspace-rectangle(3)le Adds space(s) vertically
    lslmspell(2)le Spell checker service provider
    lslmspell-add-word(3)le Add a word to the main dictionary
    lslmspell-buffer(3)le Spell check the current buffer
    lslmspell-edit-word(3)le Edits a spell word entry
    lslmspell-word(3)le (cDesc $cA) Spell check a single word
    lslmsplit-window-horizontally(2)le (cDC-x 3cA) Split current window into two
    (horizontally)
    lslmsplit-window-vertically(2)le (cDC-x 2cA) Split the current window into two
    lslmsql(9)le SQL File
    lslmstart-kbd-macro(2)le (cDC-x (cA) Start recording keyboard macro
    lslmstart-up(3)le Editor startup callback command
    lslmstop-mail-check(3)le Disable the check for new email
    lslmstring-rectangle(3)le Add a string vertically
    lslmsty(9)le TeX Style File
    lslmsuspend-emacs(2)le Suspend editor and place in background
    lslmTriangle(3)le MicroEmacs 2009 version of Triangle patience game
    lslmtab(2)le (cDtabcA) Handle the tab key
    lslmtab(2m)le Tabulation mode
    lslmtabs-to-spaces(3)le Converts all tabs to spaces
    lslmtcl(9)le TCL programming language
    lslmtcltags(3f)le Generate a Tcl/Tk tags file
    lslmtcshrc(9)le T-Shell start up file
    lslmtex(9)le TeX Documentation
    lslmtex2nr(3)le Convert a Latex file into nroff
    lslmtexi(9)le GNU Texinfo documentation file
    lslmtexinfo(9)le GNU Texinfo documentation file
    lslmtextags(3f)le Generate a LaTeX/BibTeX tags file
    lslmtime(2m)le File time stamping
    lslmtime(3)le Command time evaluator
    lslmtk(9)le TK programming language
    lslmtni(9)le UNIX t/nroff include file
    lslmtoolbar(3)le Toggle tool bar visibility
    lslmtoolbar-close(3)le Close the tool bar
    lslmtoolbar-open(3)le Open the tool bar
    lslmtoolbar-refresh(3)le Update the tool bar
    lslmtranslate-key(2)le Translate key
    lslmtranspose-chars(2)le (cDC-tcA) Exchange (swap) adjacent characters
    lslmtranspose-lines(2)le (cDC-x C-tcA) Exchange (swap) adjacent lines
    lslmtroff(9)le UNIX troff file
    lslmtxt(9)le ASCII plain text file
    lslmUserProfiles(2)le Defining a user profile
    lslmuncomment-line(3)le Uncomment current line
    lslmundo(2)le (cDC-x ucA) Undo the last edit
    lslmundo(2m)le Retain edit modifications
    lslmuniq(3)le Make lines in a sorted list unique
    lslmuniversal-argument(2)le (cDC-ucA) Set the command argument count
    lslmunix2dos(3f)le Convert UNIX format files to DOS format files.
    lslmunix2win(3f)le Convert UNIX format files to Windows format files.
    lslmunmark-buffer(3)le Remove buffer edited flag
    lslmunset-variable(2)le Delete a variable
    lslmupper-case-region(2)le (cDC-x C-ucA) Uppercase a region (upcase)
    lslmupper-case-word(2)le (cDesc ucA) Uppercase word (upcase)
    lslmuser-setup(3)le Configure MicroEmacs for a specific user
    lslmusr(2m)le User buffer modes
    lslmVariables(4)le User defined macro variables
    lslmv(9)le Verilog hardware description language
    lslmvb(9)le Visual Basic
    lslmverilog(9)le Verilog hardware description language
    lslmvhdl(9)le VHDL hardware simulation File
    lslmview(2m)le Read only
    lslmview-file(2)le (cDC-x C-vcA) Load a file read only
    lslmvm(3)le Email viewer
    lslmvoid(2)le Null command
    lslmvrml(9)le VRML File
    lslmwatch(3)le Monitor a changing file
    lslmwatch-reset(3)le Reset the watch command counters
    lslmwatch-time(3)le Change the watch command poll time
    lslmwhich(3)le Program finder
    lslmwiki(9)le GNU Wiki File
    lslmwish(9)le TCL shell file
    lslmwrap(2m)le Line wrap entered text
    lslmwrap-word(2)le Wrap word onto next line
    lslmwrite-buffer(2)le (cDC-x C-wcA) Write contents of buffer to named (new) file
    lslmwrite-region(3)le Write contents of region to named (new) file
    lslmx86(9)le Intel .x86 Assembler File
    lslmxdiff(3)le External graphical file difference
    lslmxfind(3)le Execute find command
    lslmxgrep(3)le Execute grep command
    lslmxml(9)le Extensible Markup Language
    lslmxml-backward-tag(3)le Find the previous XML tag
    lslmxml-forward-tag(3)le Find the next XML tag
    lslmxml-goto-matching-tag(3)le Find matching opening/closing XML tag
    lslmxml-verify(3)le Verify syntax of XML file
    lslmxsl(9)le Extensible Stylesheet Language
    lslmxul(9)le XML User Interface Language
    lslmy(9)le YACC programming language
    lslmyank(2)le (cDC-ycA) Paste (copy) kill buffer contents into buffer
    lslmyank-rectangle(2)le (cDesc C-ycA) Insert a column of text
    lslmyank-rectangle-overwrite(3)le Insert a column of text with overwrite
    lslmzfile-setup(3)le Compressed file support setup
    lslmzsh(9)le Z-Shell file
!   MicroEmacs - Acknowledgments
cEcEACKNOWLEDGMENTS cEcA


    The following persons contributed to this release of cDMicroEmacscA over the
    last decade, roughly in the order of participation. This list represents
    the main developers:-

        Dave Conroy (Original Author)
        Daniel M. Lawrence (Original Maintainer)
        Martin House
        cDJon GreencA - cCCurrent MaintainercA
        Callen McNally
        cDSteven PhillipscA - cCCurrent MaintainercA

    Additional contributions have been made as follows, in chrononlogical
    order:-

        Sebastian Bojers
            Finnish support.

        Jeremy Cowgar
            Lua language template.
            X-Windows modifications.

        Pedro Gomes
            Portuguese Dictionary.
            Cobol and Intel x86 language templates.
            Metapost/Meta Font templates.

        Detlef Groth
            Setting up and validating the German environment.
            Latex features and excellent feedback.
            Document support.
            Fixed PERL abbreviations.

        Mike Hopkirk
            Macro execution speed up suggestions.

        Thomas Hundt
            Fixed $frame-width/depth macro operation on the set.
            Fix for XML macros.
            Fix for VM mail searching.

        Matthew Robinson
            Developed the WinConsole version for Windows NT.

        Salman
            Problem reporting and feed-back.

        Peter Smith
            Code optimizations and extensions.

        Gabriel Tabares-Barreiro
            ADA language template.

    Thanks to everybody else that has used and abused it locally feeding back
    comments and preferences, wishes and desires.


cEcEAnd Finally .... cEcA


    Answers to those burning questions that people ask from time to time ...


cEWhere does the name JASSPA come from ? cA


    The current maintainers initials mixed up, padded out to make words, short
    listed and searched on the WWW to find a unique name. This process took
    approximately two months.


cEHow was the JASSPA logo derived ? cA


    The logo was derived from the program initials Me. Given the limited
    number of pixels available in an icon then the 'e' was superimposed in the
    center of the 'M'. With some further refinement the legs of the 'M' were
    later lost leaving a triangular shape - this was then adopted as the
    iconic outline. The colored lines at the top and bottom portray the visual
    appearance of a JASSPA's MicroEmacs from afar when viewing an X-term
    running me within an X-Windows environment. The blue line representing the
    window header color (that I use), the red line representing the MicroEmacs
    mode bar; the screen was typically black with white or yellow characters.
    The icon was incrementally refined over a period of approximately six
    months.
!   MicroEmacs - Copyright
!9  Copyright - MicroEmacs
cEcECOPYRIGHT cEcA


cEGNU General Public License (GPL) cA


    All source and macro code is covered by the GPL.

              GNU GENERAL PUBLIC LICENSE
                 Version 2, June 1991

         Copyright (C) 1989, 1991 Free Software Foundation, Inc.
            59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
         Everyone is permitted to copy and distribute verbatim copies
         of this license document, but changing it is not allowed.

               Preamble

          The licenses for most software are designed to take away your
        freedom to share and change it.  By contrast, the GNU General Public
        License is intended to guarantee your freedom to share and change free
        software--to make sure the software is free for all its users.  This
        General Public License applies to most of the Free Software
        Foundation's software and to any other program whose authors commit to
        using it.  (Some other Free Software Foundation software is covered by
        the GNU Library General Public License instead.)  You can apply it to
        your programs, too.

          When we speak of free software, we are referring to freedom, not
        price.  Our General Public Licenses are designed to make sure that you
        have the freedom to distribute copies of free software (and charge for
        this service if you wish), that you receive source code or can get it
        if you want it, that you can change the software or use pieces of it
        in new free programs; and that you know you can do these things.

          To protect your rights, we need to make restrictions that forbid
        anyone to deny you these rights or to ask you to surrender the rights.
        These restrictions translate to certain responsibilities for you if you
        distribute copies of the software, or if you modify it.

          For example, if you distribute copies of such a program, whether
        gratis or for a fee, you must give the recipients all the rights that
        you have.  You must make sure that they, too, receive or can get the
        source code.  And you must show them these terms so they know their
        rights.

          We protect your rights with two steps: (1) copyright the software, and
        (2) offer you this license which gives you legal permission to copy,
        distribute and/or modify the software.

          Also, for each author's protection and ours, we want to make certain
        that everyone understands that there is no warranty for this free
        software.  If the software is modified by someone else and passed on, we
        want its recipients to know that what they have is not the original, so
        that any problems introduced by others will not reflect on the original
        authors' reputations.

          Finally, any free program is threatened constantly by software
        patents.  We wish to avoid the danger that redistributors of a free
        program will individually obtain patent licenses, in effect making the
        program proprietary.  To prevent this, we have made it clear that any
        patent must be licensed for everyone's free use or not licensed at all.

          The precise terms and conditions for copying, distribution and
        modification follow.

              GNU GENERAL PUBLIC LICENSE
           TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION

          0. This License applies to any program or other work which contains
        a notice placed by the copyright holder saying it may be distributed
        under the terms of this General Public License.  The "Program", below,
        refers to any such program or work, and a "work based on the Program"
        means either the Program or any derivative work under copyright law:
        that is to say, a work containing the Program or a portion of it,
        either verbatim or with modifications and/or translated into another
        language.  (Hereinafter, translation is included without limitation in
        the term "modification".)  Each licensee is addressed as "you".

        Activities other than copying, distribution and modification are not
        covered by this License; they are outside its scope.  The act of
        running the Program is not restricted, and the output from the Program
        is covered only if its contents constitute a work based on the
        Program (independent of having been made by running the Program).
        Whether that is true depends on what the Program does.

          1. You may copy and distribute verbatim copies of the Program's
        source code as you receive it, in any medium, provided that you
        conspicuously and appropriately publish on each copy an appropriate
        copyright notice and disclaimer of warranty; keep intact all the
        notices that refer to this License and to the absence of any warranty;
        and give any other recipients of the Program a copy of this License
        along with the Program.

        You may charge a fee for the physical act of transferring a copy, and
        you may at your option offer warranty protection in exchange for a fee.

          2. You may modify your copy or copies of the Program or any portion
        of it, thus forming a work based on the Program, and copy and
        distribute such modifications or work under the terms of Section 1
        above, provided that you also meet all of these conditions:

            a) You must cause the modified files to carry prominent notices
            stating that you changed the files and the date of any change.

            b) You must cause any work that you distribute or publish, that in
            whole or in part contains or is derived from the Program or any
            part thereof, to be licensed as a whole at no charge to all third
            parties under the terms of this License.

            c) If the modified program normally reads commands interactively
            when run, you must cause it, when started running for such
            interactive use in the most ordinary way, to print or display an
            announcement including an appropriate copyright notice and a
            notice that there is no warranty (or else, saying that you provide
            a warranty) and that users may redistribute the program under
            these conditions, and telling the user how to view a copy of this
            License.  (Exception: if the Program itself is interactive but
            does not normally print such an announcement, your work based on
            the Program is not required to print an announcement.)

        These requirements apply to the modified work as a whole.  If
        identifiable sections of that work are not derived from the Program,
        and can be reasonably considered independent and separate works in
        themselves, then this License, and its terms, do not apply to those
        sections when you distribute them as separate works.  But when you
        distribute the same sections as part of a whole which is a work based
        on the Program, the distribution of the whole must be on the terms of
        this License, whose permissions for other licensees extend to the
        entire whole, and thus to each and every part regardless of who wrote it.

        Thus, it is not the intent of this section to claim rights or contest
        your rights to work written entirely by you; rather, the intent is to
        exercise the right to control the distribution of derivative or
        collective works based on the Program.

        In addition, mere aggregation of another work not based on the Program
        with the Program (or with a work based on the Program) on a volume of
        a storage or distribution medium does not bring the other work under
        the scope of this License.

          3. You may copy and distribute the Program (or a work based on it,
        under Section 2) in object code or executable form under the terms of
        Sections 1 and 2 above provided that you also do one of the following:

            a) Accompany it with the complete corresponding machine-readable
            source code, which must be distributed under the terms of Sections
            1 and 2 above on a medium customarily used for software interchange; or,

            b) Accompany it with a written offer, valid for at least three
            years, to give any third party, for a charge no more than your
            cost of physically performing source distribution, a complete
            machine-readable copy of the corresponding source code, to be
            distributed under the terms of Sections 1 and 2 above on a medium
            customarily used for software interchange; or,

            c) Accompany it with the information you received as to the offer
            to distribute corresponding source code.  (This alternative is
            allowed only for noncommercial distribution and only if you
            received the program in object code or executable form with such
            an offer, in accord with Subsection b above.)

        The source code for a work means the preferred form of the work for
        making modifications to it.  For an executable work, complete source
        code means all the source code for all modules it contains, plus any
        associated interface definition files, plus the scripts used to
        control compilation and installation of the executable.  However, as a
        special exception, the source code distributed need not include
        anything that is normally distributed (in either source or binary
        form) with the major components (compiler, kernel, and so on) of the
        operating system on which the executable runs, unless that component
        itself accompanies the executable.

        If distribution of executable or object code is made by offering
        access to copy from a designated place, then offering equivalent
        access to copy the source code from the same place counts as
        distribution of the source code, even though third parties are not
        compelled to copy the source along with the object code.

          4. You may not copy, modify, sublicense, or distribute the Program
        except as expressly provided under this License.  Any attempt
        otherwise to copy, modify, sublicense or distribute the Program is
        void, and will automatically terminate your rights under this License.
        However, parties who have received copies, or rights, from you under
        this License will not have their licenses terminated so long as such
        parties remain in full compliance.

          5. You are not required to accept this License, since you have not
        signed it.  However, nothing else grants you permission to modify or
        distribute the Program or its derivative works.  These actions are
        prohibited by law if you do not accept this License.  Therefore, by
        modifying or distributing the Program (or any work based on the
        Program), you indicate your acceptance of this License to do so, and
        all its terms and conditions for copying, distributing or modifying
        the Program or works based on it.

          6. Each time you redistribute the Program (or any work based on the
        Program), the recipient automatically receives a license from the
        original licensor to copy, distribute or modify the Program subject to
        these terms and conditions.  You may not impose any further
        restrictions on the recipients' exercise of the rights granted herein.
        You are not responsible for enforcing compliance by third parties to
        this License.

          7. If, as a consequence of a court judgment or allegation of patent
        infringement or for any other reason (not limited to patent issues),
        conditions are imposed on you (whether by court order, agreement or
        otherwise) that contradict the conditions of this License, they do not
        excuse you from the conditions of this License.  If you cannot
        distribute so as to satisfy simultaneously your obligations under this
        License and any other pertinent obligations, then as a consequence you
        may not distribute the Program at all.  For example, if a patent
        license would not permit royalty-free redistribution of the Program by
        all those who receive copies directly or indirectly through you, then
        the only way you could satisfy both it and this License would be to
        refrain entirely from distribution of the Program.

        If any portion of this section is held invalid or unenforceable under
        any particular circumstance, the balance of the section is intended to
        apply and the section as a whole is intended to apply in other
        circumstances.

        It is not the purpose of this section to induce you to infringe any
        patents or other property right claims or to contest validity of any
        such claims; this section has the sole purpose of protecting the
        integrity of the free software distribution system, which is
        implemented by public license practices.  Many people have made
        generous contributions to the wide range of software distributed
        through that system in reliance on consistent application of that
        system; it is up to the author/donor to decide if he or she is willing
        to distribute software through any other system and a licensee cannot
        impose that choice.

        This section is intended to make thoroughly clear what is believed to
        be a consequence of the rest of this License.

          8. If the distribution and/or use of the Program is restricted in
        certain countries either by patents or by copyrighted interfaces, the
        original copyright holder who places the Program under this License
        may add an explicit geographical distribution limitation excluding
        those countries, so that distribution is permitted only in or among
        countries not thus excluded.  In such case, this License incorporates
        the limitation as if written in the body of this License.

          9. The Free Software Foundation may publish revised and/or new versions
        of the General Public License from time to time.  Such new versions will
        be similar in spirit to the present version, but may differ in detail to
        address new problems or concerns.

        Each version is given a distinguishing version number.  If the Program
        specifies a version number of this License which applies to it and "any
        later version", you have the option of following the terms and conditions
        either of that version or of any later version published by the Free
        Software Foundation.  If the Program does not specify a version number of
        this License, you may choose any version ever published by the Free Software
        Foundation.

          10. If you wish to incorporate parts of the Program into other free
        programs whose distribution conditions are different, write to the author
        to ask for permission.  For software which is copyrighted by the Free
        Software Foundation, write to the Free Software Foundation; we sometimes
        make exceptions for this.  Our decision will be guided by the two goals
        of preserving the free status of all derivatives of our free software and
        of promoting the sharing and reuse of software generally.

               NO WARRANTY

          11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
        FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
        OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
        PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
        OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
        MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
        TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
        PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
        REPAIR OR CORRECTION.

          12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
        WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
        REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
        INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
        OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
        TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
        YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
        PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
        POSSIBILITY OF SUCH DAMAGES.

               END OF TERMS AND CONDITIONS

             How to Apply These Terms to Your New Programs

          If you develop a new program, and you want it to be of the greatest
        possible use to the public, the best way to achieve this is to make it
        free software which everyone can redistribute and change under these terms.

          To do so, attach the following notices to the program.  It is safest
        to attach them to the start of each source file to most effectively
        convey the exclusion of warranty; and each file should have at least
        the "copyright" line and a pointer to where the full notice is found.

            <one line to give the program's name and a brief idea of what it does.>
            Copyright (C) <year>  <name of author>

            This program is free software; you can redistribute it and/or modify
            it under the terms of the GNU General Public License as published by
            the Free Software Foundation; either version 2 of the License, or
            (at your option) any later version.

            This program is distributed in the hope that it will be useful,
            but WITHOUT ANY WARRANTY; without even the implied warranty of
            MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
            GNU General Public License for more details.

            You should have received a copy of the GNU General Public License
            along with this program; if not, write to the Free Software
            Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

        Also add information on how to contact you by electronic and paper mail.

        If the program is interactive, make it output a short notice like this
        when it starts in an interactive mode:

            Gnomovision version 69, Copyright (C) year name of author
            Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
            This is free software, and you are welcome to redistribute it
            under certain conditions; type `show c' for details.

        The hypothetical commands `show w' and `show c' should show the appropriate
        parts of the General Public License.  Of course, the commands you use may
        be called something other than `show w' and `show c'; they could even be
        mouse-clicks or menu items--whatever suits your program.

        You should also get your employer (if you work as a programmer) or your
        school, if any, to sign a "copyright disclaimer" for the program, if
        necessary.  Here is a sample; alter the names:

          Yoyodyne, Inc., hereby disclaims all copyright interest in the program
          `Gnomovision' (which makes passes at compilers) written by James Hacker.

          <signature of Ty Coon>, 1 April 1989
          Ty Coon, President of Vice

        This General Public License does not permit incorporating your program into
        proprietary programs.  If your program is a subroutine library, you may
        consider it more useful to permit linking proprietary applications with the
        library.  If this is what you want to do, use the GNU Library General
        Public License instead of this License.


cEGNU Free Documentation License (GFDL) cA


    All documentation is covered by the GFDL.

          GNU Free Documentation License
             Version 1.1, March 2000

         Copyright (C) 2000  Free Software Foundation, Inc.
             59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
         Everyone is permitted to copy and distribute verbatim copies
         of this license document, but changing it is not allowed.

        0. PREAMBLE

        The purpose of this License is to make a manual, textbook, or other
        written document "free" in the sense of freedom: to assure everyone
        the effective freedom to copy and redistribute it, with or without
        modifying it, either commercially or noncommercially.  Secondarily,
        this License preserves for the author and publisher a way to get
        credit for their work, while not being considered responsible for
        modifications made by others.

        This License is a kind of "copyleft", which means that derivative
        works of the document must themselves be free in the same sense.  It
        complements the GNU General Public License, which is a copyleft
        license designed for free software.

        We have designed this License in order to use it for manuals for free
        software, because free software needs free documentation: a free
        program should come with manuals providing the same freedoms that the
        software does.  But this License is not limited to software manuals;
        it can be used for any textual work, regardless of subject matter or
        whether it is published as a printed book.  We recommend this License
        principally for works whose purpose is instruction or reference.

        1. APPLICABILITY AND DEFINITIONS

        This License applies to any manual or other work that contains a
        notice placed by the copyright holder saying it can be distributed
        under the terms of this License.  The "Document", below, refers to any
        such manual or work.  Any member of the public is a licensee, and is
        addressed as "you".

        A "Modified Version" of the Document means any work containing the
        Document or a portion of it, either copied verbatim, or with
        modifications and/or translated into another language.

        A "Secondary Section" is a named appendix or a front-matter section of
        the Document that deals exclusively with the relationship of the
        publishers or authors of the Document to the Document's overall subject
        (or to related matters) and contains nothing that could fall directly
        within that overall subject.  (For example, if the Document is in part a
        textbook of mathematics, a Secondary Section may not explain any
        mathematics.)  The relationship could be a matter of historical
        connection with the subject or with related matters, or of legal,
        commercial, philosophical, ethical or political position regarding
        them.

        The "Invariant Sections" are certain Secondary Sections whose titles
        are designated, as being those of Invariant Sections, in the notice
        that says that the Document is released under this License.

        The "Cover Texts" are certain short passages of text that are listed,
        as Front-Cover Texts or Back-Cover Texts, in the notice that says that
        the Document is released under this License.

        A "Transparent" copy of the Document means a machine-readable copy,
        represented in a format whose specification is available to the
        general public, whose contents can be viewed and edited directly and
        straightforwardly with generic text editors or (for images composed of
        pixels) generic paint programs or (for drawings) some widely available
        drawing editor, and that is suitable for input to text formatters or
        for automatic translation to a variety of formats suitable for input
        to text formatters.  A copy made in an otherwise Transparent file
        format whose markup has been designed to thwart or discourage
        subsequent modification by readers is not Transparent.  A copy that is
        not "Transparent" is called "Opaque".

        Examples of suitable formats for Transparent copies include plain
        ASCII without markup, Texinfo input format, LaTeX input format, SGML
        or XML using a publicly available DTD, and standard-conforming simple
        HTML designed for human modification.  Opaque formats include
        PostScript, PDF, proprietary formats that can be read and edited only
        by proprietary word processors, SGML or XML for which the DTD and/or
        processing tools are not generally available, and the
        machine-generated HTML produced by some word processors for output
        purposes only.

        The "Title Page" means, for a printed book, the title page itself,
        plus such following pages as are needed to hold, legibly, the material
        this License requires to appear in the title page.  For works in
        formats which do not have any title page as such, "Title Page" means
        the text near the most prominent appearance of the work's title,
        preceding the beginning of the body of the text.

        2. VERBATIM COPYING

        You may copy and distribute the Document in any medium, either
        commercially or noncommercially, provided that this License, the
        copyright notices, and the license notice saying this License applies
        to the Document are reproduced in all copies, and that you add no other
        conditions whatsoever to those of this License.  You may not use
        technical measures to obstruct or control the reading or further
        copying of the copies you make or distribute.  However, you may accept
        compensation in exchange for copies.  If you distribute a large enough
        number of copies you must also follow the conditions in section 3.

        You may also lend copies, under the same conditions stated above, and
        you may publicly display copies.

        3. COPYING IN QUANTITY

        If you publish printed copies of the Document numbering more than 100,
        and the Document's license notice requires Cover Texts, you must enclose
        the copies in covers that carry, clearly and legibly, all these Cover
        Texts: Front-Cover Texts on the front cover, and Back-Cover Texts on
        the back cover.  Both covers must also clearly and legibly identify
        you as the publisher of these copies.  The front cover must present
        the full title with all words of the title equally prominent and
        visible.  You may add other material on the covers in addition.
        Copying with changes limited to the covers, as long as they preserve
        the title of the Document and satisfy these conditions, can be treated
        as verbatim copying in other respects.

        If the required texts for either cover are too voluminous to fit
        legibly, you should put the first ones listed (as many as fit
        reasonably) on the actual cover, and continue the rest onto adjacent
        pages.

        If you publish or distribute Opaque copies of the Document numbering
        more than 100, you must either include a machine-readable Transparent
        copy along with each Opaque copy, or state in or with each Opaque copy
        a publicly-accessible computer-network location containing a complete
        Transparent copy of the Document, free of added material, which the
        general network-using public has access to download anonymously at no
        charge using public-standard network protocols.  If you use the latter
        option, you must take reasonably prudent steps, when you begin
        distribution of Opaque copies in quantity, to ensure that this
        Transparent copy will remain thus accessible at the stated location
        until at least one year after the last time you distribute an Opaque
        copy (directly or through your agents or retailers) of that edition to
        the public.

        It is requested, but not required, that you contact the authors of the
        Document well before redistributing any large number of copies, to give
        them a chance to provide you with an updated version of the Document.

        4. MODIFICATIONS

        You may copy and distribute a Modified Version of the Document under
        the conditions of sections 2 and 3 above, provided that you release
        the Modified Version under precisely this License, with the Modified
        Version filling the role of the Document, thus licensing distribution
        and modification of the Modified Version to whoever possesses a copy
        of it.  In addition, you must do these things in the Modified Version:

        A. Use in the Title Page (and on the covers, if any) a title distinct
           from that of the Document, and from those of previous versions
           (which should, if there were any, be listed in the History section
           of the Document).  You may use the same title as a previous version
           if the original publisher of that version gives permission.
        B. List on the Title Page, as authors, one or more persons or entities
           responsible for authorship of the modifications in the Modified
           Version, together with at least five of the principal authors of the
           Document (all of its principal authors, if it has less than five).
        C. State on the Title page the name of the publisher of the
           Modified Version, as the publisher.
        D. Preserve all the copyright notices of the Document.
        E. Add an appropriate copyright notice for your modifications
           adjacent to the other copyright notices.
        F. Include, immediately after the copyright notices, a license notice
           giving the public permission to use the Modified Version under the
           terms of this License, in the form shown in the Addendum below.
        G. Preserve in that license notice the full lists of Invariant Sections
           and required Cover Texts given in the Document's license notice.
        H. Include an unaltered copy of this License.
        I. Preserve the section entitled "History", and its title, and add to
           it an item stating at least the title, year, new authors, and
           publisher of the Modified Version as given on the Title Page.  If
           there is no section entitled "History" in the Document, create one
           stating the title, year, authors, and publisher of the Document as
           given on its Title Page, then add an item describing the Modified
           Version as stated in the previous sentence.
        J. Preserve the network location, if any, given in the Document for
           public access to a Transparent copy of the Document, and likewise
           the network locations given in the Document for previous versions
           it was based on.  These may be placed in the "History" section.
           You may omit a network location for a work that was published at
           least four years before the Document itself, or if the original
           publisher of the version it refers to gives permission.
        K. In any section entitled "Acknowledgements" or "Dedications",
           preserve the section's title, and preserve in the section all the
           substance and tone of each of the contributor acknowledgements
           and/or dedications given therein.
        L. Preserve all the Invariant Sections of the Document,
           unaltered in their text and in their titles.  Section numbers
           or the equivalent are not considered part of the section titles.
        M. Delete any section entitled "Endorsements".  Such a section
           may not be included in the Modified Version.
        N. Do not retitle any existing section as "Endorsements"
           or to conflict in title with any Invariant Section.

        If the Modified Version includes new front-matter sections or
        appendices that qualify as Secondary Sections and contain no material
        copied from the Document, you may at your option designate some or all
        of these sections as invariant.  To do this, add their titles to the
        list of Invariant Sections in the Modified Version's license notice.
        These titles must be distinct from any other section titles.

        You may add a section entitled "Endorsements", provided it contains
        nothing but endorsements of your Modified Version by various
        parties--for example, statements of peer review or that the text has
        been approved by an organization as the authoritative definition of a
        standard.

        You may add a passage of up to five words as a Front-Cover Text, and a
        passage of up to 25 words as a Back-Cover Text, to the end of the list
        of Cover Texts in the Modified Version.  Only one passage of
        Front-Cover Text and one of Back-Cover Text may be added by (or
        through arrangements made by) any one entity.  If the Document already
        includes a cover text for the same cover, previously added by you or
        by arrangement made by the same entity you are acting on behalf of,
        you may not add another; but you may replace the old one, on explicit
        permission from the previous publisher that added the old one.

        The author(s) and publisher(s) of the Document do not by this License
        give permission to use their names for publicity for or to assert or
        imply endorsement of any Modified Version.

        5. COMBINING DOCUMENTS

        You may combine the Document with other documents released under this
        License, under the terms defined in section 4 above for modified
        versions, provided that you include in the combination all of the
        Invariant Sections of all of the original documents, unmodified, and
        list them all as Invariant Sections of your combined work in its
        license notice.

        The combined work need only contain one copy of this License, and
        multiple identical Invariant Sections may be replaced with a single
        copy.  If there are multiple Invariant Sections with the same name but
        different contents, make the title of each such section unique by
        adding at the end of it, in parentheses, the name of the original
        author or publisher of that section if known, or else a unique number.
        Make the same adjustment to the section titles in the list of
        Invariant Sections in the license notice of the combined work.

        In the combination, you must combine any sections entitled "History"
        in the various original documents, forming one section entitled
        "History"; likewise combine any sections entitled "Acknowledgements",
        and any sections entitled "Dedications".  You must delete all sections
        entitled "Endorsements."

        6. COLLECTIONS OF DOCUMENTS

        You may make a collection consisting of the Document and other documents
        released under this License, and replace the individual copies of this
        License in the various documents with a single copy that is included in
        the collection, provided that you follow the rules of this License for
        verbatim copying of each of the documents in all other respects.

        You may extract a single document from such a collection, and distribute
        it individually under this License, provided you insert a copy of this
        License into the extracted document, and follow this License in all
        other respects regarding verbatim copying of that document.

        7. AGGREGATION WITH INDEPENDENT WORKS

        A compilation of the Document or its derivatives with other separate
        and independent documents or works, in or on a volume of a storage or
        distribution medium, does not as a whole count as a Modified Version
        of the Document, provided no compilation copyright is claimed for the
        compilation.  Such a compilation is called an "aggregate", and this
        License does not apply to the other self-contained works thus compiled
        with the Document, on account of their being thus compiled, if they
        are not themselves derivative works of the Document.

        If the Cover Text requirement of section 3 is applicable to these
        copies of the Document, then if the Document is less than one quarter
        of the entire aggregate, the Document's Cover Texts may be placed on
        covers that surround only the Document within the aggregate.
        Otherwise they must appear on covers around the whole aggregate.

        8. TRANSLATION

        Translation is considered a kind of modification, so you may
        distribute translations of the Document under the terms of section 4.
        Replacing Invariant Sections with translations requires special
        permission from their copyright holders, but you may include
        translations of some or all Invariant Sections in addition to the
        original versions of these Invariant Sections.  You may include a
        translation of this License provided that you also include the
        original English version of this License.  In case of a disagreement
        between the translation and the original English version of this
        License, the original English version will prevail.

        9. TERMINATION

        You may not copy, modify, sublicense, or distribute the Document except
        as expressly provided for under this License.  Any other attempt to
        copy, modify, sublicense or distribute the Document is void, and will
        automatically terminate your rights under this License.  However,
        parties who have received copies, or rights, from you under this
        License will not have their licenses terminated so long as such
        parties remain in full compliance.

        10. FUTURE REVISIONS OF THIS LICENSE

        The Free Software Foundation may publish new, revised versions
        of the GNU Free Documentation License from time to time.  Such new
        versions will be similar in spirit to the present version, but may
        differ in detail to address new problems or concerns.  See
        http://www.gnu.org/copyleft/.

        Each version of the License is given a distinguishing version number.
        If the Document specifies that a particular numbered version of this
        License "or any later version" applies to it, you have the option of
        following the terms and conditions either of that specified version or
        of any later version that has been published (not as a draft) by the
        Free Software Foundation.  If the Document does not specify a version
        number of this License, you may choose any version ever published (not
        as a draft) by the Free Software Foundation.

        ADDENDUM: How to use this License for your documents

        To use this License in a document you have written, include a copy of
        the License in the document and put the following copyright and
        license notices just after the title page:

              Copyright (c)  YEAR  YOUR NAME.
              Permission is granted to copy, distribute and/or modify this document
              under the terms of the GNU Free Documentation License, Version 1.1
              or any later version published by the Free Software Foundation;
              with the Invariant Sections being LIST THEIR TITLES, with the
              Front-Cover Texts being LIST, and with the Back-Cover Texts being LIST.
              A copy of the license is included in the section entitled "GNU
              Free Documentation License".

        If you have no Invariant Sections, write "with no Invariant Sections"
        instead of saying which ones are invariant.  If you have no
        Front-Cover Texts, write "no Front-Cover Texts" instead of
        "Front-Cover Texts being LIST"; likewise for Back-Cover Texts.

        If your document contains nontrivial examples of program code, we
        recommend releasing these examples in parallel under your choice of
        free software license, such as the GNU General Public License,
        to permit their use in free software.


cEcELicense History cEcA


    JASSPA MicroEmacs is derived from the MicroEmacs 3.8 source base of 1998.
    As such, all of the software has been under a commercially restrictive
    license. JASSPA has upheld the original license terms laid down my the
    original author and copyright holder Daniel M Lawrence.

    JASSPA is the collective name given to the maintainers of JASSPA
    MicroEmacs. The current maintainers at the 1st January 2002 are Steven
    Phillips and Jon Green.

    On Wednesday 19th January 2001 JASSPA applied for, and was granted,
    permission by Daniel M Lawrence to move to the less restrictive licensing
    terms of GPL. As of 1st January 2002 the JASSPA distribution of MicroEmacs
    shall be supplied under this licensing arrangement. The licence is not
    transferable to earlier versions of the distribution or to the original
    program from which is was derived known as MicroEmacs.


cELicense Terms to 1988 cA


    The following copyrights apply from the original source code of version
    3.8. No explicit copyrights were found with the original distribution
    apart from the following found in the main source code,

        cD(C)opyright 1987 by Daniel M. LawrencecA
        MicroEMACS can be copied and distributed freely for any non-commercial
        purposes. Commercial users may use MicroEMACS inhouse. Shareware
        distributors may redistribute MicroEMACS for media costs only.
        MicroEMACS can only be incorporated into commercial software or resold
        with the permission of the current author.


cELicense Terms 1998-2001 cA


    The following notices apply after 1988 to 31st December 2001

        cDCopyright (C) 1988 - 2001, JASSPAcA
        JASSPA MicroEmacs can be copied and distributed freely for any
        non-commercial purposes. Commercial users may use JASSPA MicroEmacs
        inhouse. Shareware distributors may redistribute JASSPA MicroEmacs for
        media costs only. JASSPA MicroEmacs can only be incorporated into
        commercial software or resold with the permission of the current
        author.


cELicense Terms 2002 and subsequent years cA


    GNU Public License (GPL) for all source material. GNU Free Documentation
    License (GFDL) for all documentation material.
!   MicroEmacs - Contact Information
cESpelling Dictionary Copyrights cA


    The spelling dictionaries are converted from cCispellcA dictionaries, each
    spelling dictionary has it's own copyright which is reproduced within the
    appropriate language spelling macro file.


cENO WARRANTY cA


    THIS PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY FOR THE
    PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN OTHERWISE
    STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES PROVIDE THE
    PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED,
    INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS FOR A PARTICULAR PURPOSE. THE ENTIRE RISK AS TO THE QUALITY
    AND PERFORMANCE OF THE PROGRAM IS WITH YOU. SHOULD THE PROGRAM PROVE
    DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR
    CORRECTION.

    IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING WILL
    ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
    REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
    INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES
    ARISING OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT
    LIMITED TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES
    SUSTAINED BY YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE
    WITH ANY OTHER PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN
    ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.

    cDTHIS NOTICE MUST BE CARRIED IN ALL COPIES OF THE DISTRIBUTIONcA
!7  Contact Information - MicroEmacs


cEcECONTACT INFORMATION cEcA


    The following contact point may be used to report all problems and request
    information:-

        cGEmail:support@jasspa.comcA

    Also visit our web site's on the Internet:-

       cG http://www.jasspa.comcA

    This page carries the latest information and patches on the distribution.


cEE-Mail Reflector cA


    A E-Mail reflector is available onto which questions, suggestions and code
    fragments may be posted. This is an un-moderated E-Mail group. The mailing
    list archives may be found at:-

       cG http://groups.yahoo.com/group/jasspa/cA

    These should be referenced before posting any questions, as an answer may
    have already been given. This mailing list is likely to contain the most
    up-to-date information available, as JASSPA will use this for any
    notifications.

    If you want to join the E-Mail reflector then mail a request, with an
    empty message body to:-

       cG jasspa-subscribe@yahoogroups.comcA

    This should add you to the mailing list. If you want to be subsequently
    removed from the mailing list then mail an empty message to:-

       cG jasspa-unsubscribe@yahoogroups.comcA

    and you will be removed from the lists. There are facilities on the site
    to allow you to receive digests, rather than multiple posts to the group
    once you have subscribed.

    The mailing list is hosted by cDYAHOO! GroupscA. General help information on
    the mailgroup is available at their site:-

       cG http://groups.yahoo.comcA


cEHelp, FAQ and other queries cA


    Please use cDYAHOO! GroupscA help information for any queries about the
    mailing lists, JASSPA have simply registered and E-Mail group at the site
    and have not investigated fully all of the facilities that may be
    available.

    Please check the lslmFrequently Asked Questionsle. list and the home page FAQ
    before you submit any information to JASSPA, your problem may have already
    been addressed in these pages.

    Every effort will be made to deal with your problem as soon as possible.
    Please send mail with the titles indicated below so that it maybe
    filtered. Unless explicitly requested (or appropriate) JASSPA will only
    respond through the FAQ lists on the Internet site. It will not be
    possible to answer individual enquiries and questions.

    Any sites that wish to mirror the JASSPA distribution should contact
    JASSPA first (use PORT), we will then include details of the mirror on the
    home page.


cEReporting Problems cA


    Mail as:-

        cCTitle:cA cDBUGcA
        cCMessage Body:cA Description of the problem ....

    Problems should be reported such that they may be reproduced, this may not
    be that easy. The information that is required is:-

    cDPlatformcA
        The host platform which is exhibiting a problem

    cDVersioncA
        The version of MicroEmacs. Use cGesc-x aboutcA to retrieve the
        information, the format of the date is cGyyyy/mm/ddcA, followed by the
        host system type. e.g.

            cGMicroEmacs 06 - Date 2006/01/10 - sunoscA

    cDDescriptioncA
        A description of the problem. Try to include as much information as
        possible. Include any material necessary to reproduce the problem
        (i.e. macro files, text file that demonstrates problem etc).


cESuggestions cA


    Mail as:-

        cCTitle:cA cDSUGGESTcA
        cCMessage Body:cA Your suggestion, macro code fragment etc.

    We always appreciate suggestions, new macro code fragments etc. We do not
    have support for all languages, e.g. cDPerlcA, cDLatexcA... If you wish have
    developed new macro templates, or games (we get a bit bored with the ones
    that we have developed ourselves) then please mail them to cGSUGGESTcA and we
    will incorporate them into the release.


cEFeedback cA


    Mail as:-

        cCTitle:cA cDFEEDBACKcA
        cCMessage Body:cA Your feedback.

    Any general comments (which are not suggestions), your feelings about this
    version of MicroEmacs or any other non-technical dialogue.


cEPorting cA


    Mail as:-

        cCTitle:cA cDPORTcA
        cCMessage Body:cA Details

    If you wish to port MicroEmacs to another platform and are willing to
    undertake responsibility for maintenance of that platform then we would
    like to here from you. Send us some details.
!   MicroEmacs - History
cEcEHISTORY cEcA


    This version of MicroEmacs is based on an early cCMicroEmacscA release of 3.8
    in 1988, the origins of which are unknown, except to say it was delivered
    on a unmarked 5 1/2" floppy disk.

    The program was originally ported to a Motorola MVME147 UNIX box as an
    alternative to cDvicA. Reliability of the program proved to be a problem as it
    constantly crashed. In an attempt to rectify the problems the development
    of MicroEmacs commenced.

    Development has continued from 1988 through to today, on the whole
    oblivious to further developments of the existing cDMicroEmacscA program. This
    was due to no Internet access. It was not until 1996 the next version of
    cDMicroEmacscA and cDmewincA (Microsoft Windows (TM) port of the same program) was
    downloaded from the Internet and compared. By this time MicroEmacs was
    radically different and we were not about to mesh the two together - that
    would be a step backwards.

    Development of MicroEmacs has been biased towards the UNIX platform, as
    most of the early development was performed in the UNIX domain. The first
    of the window servers was X-Windows, which in turn has shaped the
    implementation of the Microsoft Windows port. Latterly, we have seen the
    resurgence of the IBM-PC platform which is now commonplace. For the return
    port to the DOS environment, and subsequent development of the Microsoft
    Windows port, a UNIX like interface was required. Most existing users
    could not abide the primitive editors found on these machines; Microsoft
    Windows was an alien and hostile environment when compared with UNIX.
    Hence, the MicroEmacs interface utilizes UNIX style cut and paste across
    all platforms.

    For portability, MicroEmacs utilizes character rendering on all platforms
    regardless of the window manager. Under X-Windows and Microsoft Windows,
    the display is still treated as a character based display, the subtle
    difference is that the display pane is re-sizable. This means that the
    scroll bars, fonts etc. are not as slick as they could be, certainly under
    Microsoft Windows MicroEmacs looks positively primitive!! Regardless of
    the look, the goal of a common editor across all working platforms has
    been achieved!


cEDevelopment History cA


    cDPatch Release - 11th October 2009cA
    Release date specified as 2009/10/11.

        * [091011] Patch release of fixes; release date specified as
          2009/10/11.
        * [091011] Fixed kill-rectangle scribble caused by hilight hidden
          characters overrunning the kill buffer.
        * [091011] Fixed debug build error caused by narrow udata change.
          Changed debug fprintf of pointers to use %p to support 64-bit
          version.
        * [091010] Fix for &rep and &irep truncating the resultant string
          prematurely.
        * [091010] Fixes for 64-bit system compilation. Issues with spelling
          pointer arithmetic and undo structure alignment.

    cDPatch Release - 3rd October 2009cA
    Release date specified as 2009/10/03.

        * [091003] Fixed documentation for crlf(2m) which is replaced by
          cr(2m) and lf(2m).
        * [091003] Fixed documentation for quiet(2m) which has been removed
          and replaced with quiet(5).
        * [091003] Bound cross note searching to 'esc s' and esc C-s' and
          removed the 's' & 'r' tree buffer binding. Implemented execution of
          cross note search within cross note search to jump to the next note.
          Changed note rename binding to 'r'
        * [090930] Fixed crash caused by encrypt key being set to '' (i.e.
          disabled) on a reload, resetkey did not check this so crashed trying
          to use NULL.
        * [090930] notes; fixed prompt of encryption key when the notes file
          is already loaded.

    cDPatch Release - September 2009cA
    Release date specified as 2009/09/26.

        * [090926] Fixed Linux X-Window size issue.
        * [090923] Fixed bad characters in Clearcase output window
        * [090917] Fixed Linux makefiles for GCC 4.3 for the detection of
          ncurses.

    cD10th Release - September 2009cA
    Release date specified as 2009/09/09.

        * [090903] lslmfile-browser(3)le improved on Microsoft Windows to perform a
          case change i.e. "test.txt" to "Test.txt".
        * [090903] Added lslmencase(3)le to encase a region with a starting and
          ending string.
        * [090903] Added lslmnumber-items(3)le to perform renumbering on a vertical
          aligned list of numeric digits.
        * [090901] Added template for Inno Setup Script files with extension
          .iss
        * [090831] Changed buffer major setup so all major modes may enable
          abbreviations and templates. The user may create the appropriate
          file if there is no standard file supplied and it will be enacted.
        * [090831] HTML template; indent <div> constructs.
        * [090831] notes; maintain the exact and magic mode settings during a
          notes tree update.
        * [090805] Added support for \i#, \u# & \c# in &xre macro function
        * [090530] Fixed TCL abbreviation file expansion reported by Ferenc
          Deak.
        * [090523] Fix fill-paragraph so standard 'o' and 'a' are supported.
        * [090523] Fix jst paragraph fill so 'o' and 'a' are supported
        * [090523] Bound "esc-`" to enter a very large arg n (99999999)
        * [090213] Improved indent rules so two 'current-line and onward'
          tokens together are both considered on the current line, i.e.
          '</tr></table>' is a double indent.
        * [090201] Fixed the 'No to all' 'o' option to fill paragraph prompt,
          was still 'v' for Never.
        * [090201] Avoided crash caused by moving reg node to itself or one of
          its children.
        * [090121] Better support for encrypted notes files, checks the first
          line and if not '-!- enf...' it assumes its encrypted and will
          prompt for a password.
        * [081204] Fixed get-next-line buffer selection (logic inverted).
        * [081204] Fixed file-tool-menu so it will work in a *find* buffer.
        * [081116] Upped the macro minimum version to 2008-11-10
        * [081111] Added 'Disable' to file-tool-setup, changed 'Default Open'
          to 'Open File' and added 'View File'
        * [081111] Changed the default behaviour of open and view to open a
          menu if more than one Open/View tool matches.
        * [081111] Added alias paths to a '~' auto-completion list.
        * [081111] Fixed compile buffer processor often missing error lines.
        * [081106] Changed file tool mask so if it starts with '^...' the
          whole file name is matched not just the base name (required for
          'http://...' type matching).
        * [081106] Remove file tool setup from the context menu as it is now
          in the file tool menu itself.
        * [081106] Document highlighting; improved the hilighting of http &
          https urls and added file: hilighting.
        * [081106] Added a new 'Find Link' mouse command (use user-setup to
          bind) which will open the file/url clicked on by the mouse
          (typically bind to Ctrl Left mouse)
        * [081106] Added 'File Tool Setup' to the file tool context menu.
        * [081026] Added confirmation prompt if about to save a file which had
          binary chars or inconsistent line endings.
        * [081024] Fixed forward def's for file-tool macros.
        * [081024] Added 'File Tools' item to Advanced menu.
        * [081024] Enhanced file-tool to have the features found in
          shell-tools (namely ability to capture output and save buffers
          with(out) prompt)
        * [081024] Improved the get-next-line file name template to be more
          strict with matching drive letters at the start.
        * [081019] Improved behaviour when ftp reg file is missing.
        * [081019] Ensured large files are handled properly (fails for
          lslmreplace-string-in-files(3)le) and improved error reporting.
        * [081018] Fixed lslmfind-file(2)le so it can load files and directories
          with square brackets (i.e. a[b])
        * [081010] Removed compile highlighting as this is now done
          differently.
        * [081010] Changed favorite file opening to check for a default open
          file-tool and use that instead.
        * [081010] Clearcase; changed ipipe launch of cleartool to make use of
          new no-wrap bit 0x200.
        * [081005] Implemented a more macro orientated interface to
          get-next-line (when n == 0), which only looks in the current buffer,
          if a 'next line' is found it simply changes the cursor location,
          sets next-file & next-line variables and does not pop-open the file.
          Got get-next-line to set :next-line as well as a next-file variable.
        * [081005] find and grep; used new '&bstat o' to check that any loaded
          buffer used (-l) is up-to-date and if not prompt the user.
        * [081005] find and grep; introduced -a option to automatically reread
          all ood buffers (Yes to All) and -o option to never reread the ood
          buffers (NO to all)
        * [081005] Changed shell-tool interface so a tool can run concurrent
          without going to a buffer (uses relatively recent improvements to
          shell-command)
        * [081005] Changed reread-all command so default action only rereads
          out-of-date buffers (uses new &bstat) if 0 arg is given then it
          rereads all as before.
        * [081005] Protected ME from potential crash when homedir is NULL.
        * [081002] File types, fixed abort caused by empty files.
        * [081002] page-file; implemented a new -u/-U option to limit the size
          of a file to be grep'd to 100Mb unless -u is given (unlimited,
          includes -w for find)
        * [081002] When a large file is encountered find & grep now use
          page-file.
        * [081002] Fixed pressing C-g at read-only prompt of
          replace-string-in-files to abort the command.
        * [081002] page-file; Implemented an absolute line counter which works
          as long as the user started from the top (v useful for grep)
        * [081002] page-file; Implemented a macro orientated
          page-file-search-buffer macro.
        * [081002] page-file; Added support for specifying the buffer name to
          be used by page-file (0 numeric arg)
        * [081002] isearch macros now have an 'Yes to All' option when asked
          whether to change page.
        * [081002] Increased the default page size to 1Mb
        * [081002] Restricted the session kill history to only buffers which
          are 1020 chars long or less.
        * [081002] Added @y0 ... @y15 support to directly extract the
          kill-ring buffers.
        * [081002] Added a new &bstat command variable which is similar to
          &stat but for the current buffer, currently only has 'o' for
          'out-of-date' test.
        * [081002] Made double click on a window mode-line delete other
          windows (i.e. maximise the window)
        * [0801002] Fixed opening toolbar when notes was active in the
          session.
        * [081002] tools; added new save-kbd-macro command which makes it easy
          to save a keyboard macro for future use.
        * [081002] xfind; use new 0x200 ipipe flag to not wrap lines, avoids
          get-next-line failures on long file names.
        * [080929] Changed the 0 & +ve args for reyank, now acts as a yank
          yanking out the nth item in the kill ring (i.e. 0 reyank == yank
          (except no external clip check))
        * [080929] Fixed bug in isearch - C-w was not storing status so a
          following backspace could lose the Okay status.
        * [080916] find/grep -& (background) option working with new -f ME
          option.
        * [080916] Added Windows MSVC 8 makefile
        * [080916] Fixed pipe failure problem caused by
          GetConsoleScreenBufferInfo failing (no console) this is a fatal
          problem whe not in piping mode - not checking for failure and
          handling led to use of uninitialized variables.
        * [080724] Fixed spin in ctags caused by a double '; ;'
        * [080724] Added new 'Tag File' option to the generate-tags dialog
        * [080724] Added command line -f option to set .about.arg# variables
        * [080720] Added the session name to the main window title
        * [080720] New schemes contributed by BS.
        * [080720] Implemented $frame-title to partially set the main window
          title text.
        * [080720] Improved delete-some-buffers so bit 0x01 only disables the
          'is modified' test, 0x02 disables the main prompt, added new 'delete
          inactive buffers' prompt with bit 0x04 to disable.
        * [080509] Improved the hilighting of grep output.
        * [080426] Fixed PS scheme (now called Lumina). Update of Charcoal
          scheme.
        * [080330] Enhanced the javadoc highlighting.
        * [080330] PHP; Corrected string case and enhanced the doxygen
          commenting.
        * [080311] Fixed cvs-remove when used in a dir listing (only worked in
          a cvs-state buffer)
        * [080222] Extended 'C' Doxygen highlighting.
        * [080207] Added new 'touch' feature to file-op (bit 0x400)
        * [071125] Fixed file name input crash caused by using completion in a
          dir with files being removed.
        * [071125] C, directory list and latex; Fixed 'o' (no to all) response
          to copy which did not work.
        * [071125] Fixed clearcase -mkbranch files being given '?' status.
        Fixed cc-merge refresh bug.
        * [071103] Build; added -D option to specify a define, e.g. -D
          _USETPARM to use the systems tparm function rather than ME's
        * [070311] 2dos, 2mac, 2unix, 2win; use arg 0 as these are not able to
          prompt from the user if the file is read-only - just do it.
        * [071103] cc-delete; removed bogus 'checking out parent' error
          message.
        * [071021] find; added -& support to replace-sting-in-files and added
          new *replace* output buffer for the command so hte user can see what
          has been done.
        * [071018] Template buffer binding; avoid abort if binding can't be
          made
        * [071013] OSD; fixed line hilight when selection string has regex
          chars
        * [071013] Fixed deletion of symbolic links when they point to
          directories.
        * [070923] Correct a file name when adding it to the history if it has
          a path character (i.e. not just a base name).
        * [070923] Fixed ftp file rename (i.e. 'r' command in ftp dir listing)
        * [070923] Only rename dir-list buffer to *files* if the current
          buffer is called *files* (i.e. browser is being used). Handle a
          dirlist (not called *files*) being displayed in multiple windows.
          Added file being loaded to file history.
        * [070923] jst; Added support for tables being terminated by a ]? on
          the start of the last row, this makes tables far easier to use.
        * [270923] jst; Added support for item-list and collapse. Added 4th
          level titles.
        * [070920] Persist wrap mode in ipipe-rerun and disable compile
          hilighting when wrap is not used as very long compile lines kill
          performance (ME takes a lot of CPU)
        * [070920] Reset hilight and indent buffer variables on a bclear,
          otherwise the hilighting persists in *compile* buffer across
          multiple compiles etc
        * [070920] Added a bit 0x02 to the compile command to run the ipipe
          command without wrap (required if '<filename>:<line>: Error' lines
          are longer than the window width)
        * [070920] Fixed html comment definition (should be <!-- -->)
        * [070920] jst; improved title.
        * [070920] Added new 0x0200 bit to ipip-shell-command to disable wrap,
          similar to raw but still adds the header and exit info. Need this
          for compile when file names are longer than the width of the window
          (breaks goto-next).
        * [070920] Fixed build.sh to build mec when X11 is not available -
          issue raised by TH.
        * [070920] Added capability to 'set-variable @y ...' to set the
          current kill buffer.
        * [070713] Fixed dir-list toolbar tool to handle dirlist with seconds.
        * [070713] Perl template; added '-' to list of allowed hash
          characters.
        * [070713] Build; handle VS8 fatal error compile messages.
        * [070713] Fixed main edit menu's buffer-mode numeric args.
        * [070524] Added a new 0x20 flag to find-buffer to stop the history of
          the outgoing buffer from being incremented - used by new find and
          grep to avoid trashing the buffer history.
        * [070524] Fixed the handling of find-buffer's -ve arg, introducing a
          new 0x10 bit flag to control the forced hiding.
        * [070524] Fixed file name input so trailing '/.' & '/..' have a
          further '/' added, this fixes several file loading problems.
        * [070524] Changed file saving prompts to be like delete-buffer, they
          now given the file name first and then the 'save file' prompt so the
          user can always see the action they are being prompted for.
        * [070524] dded an f3 buffer binding to be the same as v
        * [070524] Improved filetype.emf to report if the last line is missing
          its line termination.
        * [070507] Documentation correction from Bryan for "notes".
        * [070426] Implemented cycling through loaded note files using the
          tree mode-line arrows (like paged tools in toolbar)
        * [070426] Avoid opening the toolbar twice which can cause tool window
          sizing issues.
        * [070425] Fixed cc-state end process cursor positioning prompt, now
          moves the cursor to after the [***....] exit line so the user knows
          its finished.
        * [070424] Fixed a few start-up session restore and notes interaction
          issues.
        * [070424] Fixed startup performance issues caused by testing the
          existence of every file
        * [070424] Clearcase removed the 'Checkout parent' option for move and
          delete.
        * [070424] Tool setup fixed issue with adding a new window tool after
          a paged tool.
        * [070322] Handle file loading errors in find.
        * [070322] Fixed the spelling error scheme.
        * [070212] Fixed large file support on UNIX/Linux.
        * [070211] find and grep -x option also skip ignorable directories.
        * [061206] Fixed issue with the scheme editor.
        * [061206] Fixed the OSD entry character handling.
        * [061205] Changed creferences to replace-all-string commands to new
          (query-)replace-string-in-files commands.
        * [061205] Implemented new (query-)replace-string-in-files commands
          based on new find. Changed default for grep to not use -l (use
          find-setup to do this). Changed -x option so it always ignores
          auto-save files.
        * [061205] Fixed console/window session variable muddle, two run-mode
          variables are now kept separate.
        * [061205] Added new find-setup comand
        * [061205] Added latest Charcoal scheme (thanks to Bruno)
        * [061203] Up-date of Mirkwood scheme (thanks to Bruno)
        * [061119] Corrected minor warning on regular expression evaluation.
        * [061110] Fixed spin on a cyclic symbolic link and added loop limit
          of 10 for chasing a symbolic link.

    cD9th Release / Patch 1 / Build 2 - November 2006cA
    Release date specified as 2006/09/09.

        * [061105] JASSPA MicroEmacs 20060909 patch - build 2.
        * [061105] Linux i386_x64 port corrections - Thanks to Vincenzo.
        * [061105] Correct Java highlighting of package and import
          declarations - Thanks to Bryan Schofield.
        * [061105] SQL template updated, removed bad token - Thanks to Rick
          Owen.
        * [061105] Fixed word wrap horizontal scroll when using a window that
          is a few characters wider than the fill column. Caused next line to
          scroll which is very annoying - this is a very old bug!
        * [061105] Fixed the Win32s Windows build which was using a later day
          Windows construct.
        * [061105] Fixed NanoEmacs Window version under MS-Windows, crashing
          on start up due to accessing curFrame which had not been initialized
          before a screen draw took place from the Window message queue.
          Inhibit screen access during the construction of the frame.
        * [061105] Documentation translate-key examples added - Thanks to
          Thomas Hurdt.
        * [061105] Macros bailing out when the main menu is disabled on
          start-up. osd -1 0 returns FALSE which causes the macro execution to
          terminate. Thanks to Bryan Schofield for identifying this problem.

    cD9th Release - September 2006cA
    Release date specified as 2006/09/09.

    User perspective summary of changes

        * lslmMainMenu(3)le - A more consistent main menu and user dialog
          interaction.
        * lslmfile-browser(3)le - New key bindings to create, delete, copy files and
          directories. lslmfile-tool-setup(3)le allows open actions to be associated
          with file types allowing automatic launching of external tools.
        * Introduction of major modes for management of different file types.
          lslmbuffer-major-mode(3)le assigns a new operating mode to a buffer
          affecting the highlighting, indentation, key binding etc.
          lslmmajor-mode-setup(3)le configures the behavior of the major mode.
        * Introduction of sessions which store the context of editor including
          window layout and loaded files. Multiple sessions may be used, "cDmecA
          cD-ccAcC<sessionName>cA" restores a specific session. lslmsave-session(3)le and
          lslmread-session(3)le handle the restore/saving of sessions. The existing
          history commands have been removed.
        * lslmClearCase(3)le support for IBM Rational ClearCase.
        * lslmcvs(3)le improved support within the lslmfile-browser(3)le.
        * lslmnotes(3)le utility extended, new features allow quick notes to be
          generated with cDnotes-instantcA, notes associated with a file may be
          added with cDnotes-contextcA.
        * lslmrdiff(3)le recursive difference and lslmxdiff(3)le for access to an external
          graphical difference tool. lslmforward-kill-word(2)le inconsistencies
          removed.
        * Highlighting improved, especially for long script files (html / php
          / javascript) where the highlighting used to be lost.
        * lslmjst(9)le - Structured text documents.
        * lslminsert-password(3)le password generation utility for system
          administrators who tire of thinking of new passwords.
        * Fill columns are now defined on a per buffer basis
          lslm$buffer-fill-col(5)le.
        * lslmindent-increase(3)le and lslmindent-decrease(3)le commands introduced to
          change the indentation of a region.
        * The default date format may be specified by the user with
          lslm.ascii-time.format(5)le.
        * Quick directory aliases such as "cD~projcA" or "cD~workcA" etc. may be
          defined to a longer pathname using lslmalias-path-setup(3)le.
        * Language template added for Adobe Macromedia ColdFusion.
        * Bug fixes and enhancements to existing commands and functions.

    cDDevelopment historycA

        * [061005] java - Added missing highlighting tokens reported by Tom
          Hundt. Added new indentation definition and highlighting defined by
          Bryan Schofield.
        * [061005] Fixed the cygwin f3 mode toggling to be the same as ishell.
        * [061004] sessions - Avoided any potential timestamp issues by
          changing the divider to letters.
        * [061004] Changed $timestamp default to be regex compliant (i.e. \\.)
        * [061004] Changed copyrights to 2006
        * [061002] jst - Up-dated jst hook and utils to latest standard.
        * [061002] Changed arg to popup-window from 3 to 4 to resize as well,
          restoring a session on a different machine could easily break things
          otherwise.
        * [061002] browse mode - Added wheel mouse support.
        * [061002] notes - fixed notes-file bug caused by creating a new notes
          file while in notes. Close notes before importing skwurel notes.
        * [061002] Fixed find bug.
        * [061002] Improved the $file-names path/regex division detection and
          checked for '\\<' which can always be used as a divider if required.
        * [060928] Fixed crash caused by ftp login being given a NULL
          password.
        * [060927] Set macro version to cC2006-09-09cA as the release version. Set
          the executable to cC2006-09-09cA as the release version.
        * [060925] Added a 'cGgcA' (goto) to cDsave-some-bufferscA prompt.
        * [060925] Cosmetic changes to cDbuffer-infocA, 2nd Col to 'ACol' and
          printed current character in decimal as well.
        * [060921] Improved the notes display to better preserve the current
          notes file.
        * [060921] Stopped lslmread-session(3)le from trying to restore lock and
          save buffer modes.
        * [060921] Improved the cDquery-replacecA prompt to list letter options
          when the width allows.
        * [060921] Browser. Added seconds to the info given for a file in a
          directory listing. Fixed dir list hooks to handle mod times with
          seconds.
        * [060921] Changed char prompts to have 'cG/cA' dividers.
        * [060921] Added new bit 0x20 to lslmread-file(2)le to discard changes to
          buffer.
        * [060919] Build. Added $MAKEWINDEFS and LIBS to the ME_WINDOW
          defines, removed references to xpm from the makefiles as this is not
          a standard package and moved references out of cCemain.hcA into
          cCunixterm.ccA. Vamped up build shell script to check for X11 & Xpm
          availability. Changed horrid dos style empty string tests in UNIX
          scripts with cD-zcA & cD-ncA test options
        * [060918] Standardized the form of character input prompts and
          improved routine so 'cG?cA' swaps between help and prompt. Added a 'cGN(o)cA
          cGtocA cGallcA' option to lslmsave-some-buffers(2)le and changed lslmfill-paragraph(2)le
          to 'cGNevercA' to 'cGN(o) to allcA'. For cDquery-replace-*cA, changed the help
          for 'cG!cA' to 'cGYes to (a)llcA' and added 'cGacA', changed 'cGicA' to 'cGecA' and
          removed 'cG.cA' option.
        * [060918] Changed debugger 'cG!cA' to 'cGccA', in keeping with other
          debuggers for cCcontinuecA.
        * [060918] Added bit 0x04 to lslm@mc(4)le flag so macro can supply a help
          string
        * [060917] Corrected the X-Windows ordering to allow us to receive
          (Un)Map events on Linux - X-Server behavior is different from Sun
          Solaris.
        * [060917] UNIX. Added XPM colour bitmap support. Just smartens the ME
          icon up in Gnome and makes ME look a bit more 21st century without
          the monochrome icon.
        * [060917] Shell template, addition of missing common commands.
        * [060917] JST, addition of other text insertions.
        * [060917] UNIX. Corrected X-Windows positioning from popup-window.
        * [060917] Added new 48x48 icon for gnome with transparency boarder -
          complaints that existing icons were not Gnome friendly!
        * [060917] UNIX. Corrected X-Windows hints for font size change.
          Requires that the X-Window is unmapped before the size hint may be
          modified and the re-mapped.
        * [060915] Notes. Fixed lslmnext-frame(2)le prefered selection order.
        * [060915] OSD. Sanitised the quick file open and file type buffer
          open menus and changed them to use a scrolled list if more
          files/buffers than lines rather than filling the screen.
        * [060915] In notes find a file that is loaded but out of date, this
          leads to an reread prompt during which the notes ehook/idle callback
          kicks in and changes frame - this breaks the message line of both
          frames. This is a rather horrid fix to a rather grotty problem!
        * [060915] Browser, fixed the sort order to be case sensitive on UNIX,
          insensitive on Windows
        * [060914] User setup. Stopped user-setup's apply from losing the
          current session's override colour scheme
        * [060914] ClearCase. Fixed Describe context menu hotkey overload.
          Used cG-mkpathcA to implement a 'cCcheckout parentcA' for cDcc-addcA.
        * [060913] Notes. Fixed the loosing of edit and crypt mode from the
          main notes buffer due to the setting of the major mode. Fixed notes
          tree context menu hot keys.
        * [060913] Fixed kill-list tool up-date trashing the real kill ring.
        * [060912] Changed session-update to store view mode for a buffer only
          if it was forced on by the user (i.e. the file is not readonly).
          This stops files re-loading in view mode if the permissions have
          changed - this was a problem with ClearCase reported by Enver Haase.
        * [060912] Simplified the new note-setup and fixed the notes buffer
          losing the hide mode (which causes problems for session restore).
        * [060911] Removed the notes 'note' dummy hook in favour of using a
          real hook. Set the default hook to be jst but can be set in the -!-
          enf; major-mode: <hook> -!- header. Added new note-setup which users
          buffer-setup to allow the user to setup the buffer and stores the
          values for that note.
        * [060908] File browser, bound a lslmfile-attrib(3)le based 'Change File
          Attributes' option to 'g'
        * [060908] Changed lslmfile-attrib(3)le to handle directory buffers
          correctly and, with a numeric arg of 0, change the attibutes of a
          given file (i.e. not the current buffer) Implementation changed to
          now have a Cancel button.
        * [060908] File tool, implemented new cG%"...%"cA tag to enable proper
          quoting of arguments.
        * [060907] Fixed startup buffer hilighting issue caused by order of
          session restore.
        * [060905] ColdFusion template, added string highlighting to the SQL
          statements.
        * [060905] File browser, added binary edit, bound to 'b'.
        * [060905] Added basic xml "cG/>cA" single tag support to html and fixed
          xml's insert-attrib to handle this
        * [060905] Changed refences to cCwhite-char*cA to whitespaces (i.e.
          display-white-chars is now display-whitespace) Fixed hide main menu
          to popup an info dialog informing the user how to get it back.
        * [060905] Fixed ftp dialog to conform to new cC<user>.erfcA setup
          standard by adding a new 'Make Default' dialog, and improved the
          behaviour of Enter in the dialog.
        * [060904] Corrected the ColdFusion closing bracket hgilight.
        * [060904] Shortened the document template formating menu text
          strings.
        * [060829] Fixed HTML template cDhtml-insert-tagcA to add the closing "cG/cA"
          on insertion of a "cG<singleTag/>cA". Fixed cDhtml-insert-attribcA to deal
          with attribute insertion into a HTML tag ending in "cG/>cA".
        * [060828] SQL Template. Corrected SQL string hilighting.
        * [060827] New language template for Adobe/MacroMedia ColdFusion (file
          extensions .cfm, .cfml .cfc).
        * [060827] Extended indentation with the 'u' and 'v' indentation
          types.
        * [060822] 2006 Release Candidate 1 (RC1)
        * [060822] Added password commands lslmpassword-to-phonic(3)le and
          lslminsert-password(3)le. [060816] Added settings for fill-col and
          fill-mode to the lslmmajor-mode-setup(3)le.
        * [060816] Added support for a "cG.fhook-???.fill-*cA" variable and
          changed latex over to using this variable rather than burning the
          fill-mode in as 'l'
        * [060816] Crossword - Changed Exit button to Close.
        * [060816] Changed organizer Exit buttons to Close or Cancel.
        * [060812] Additions to the PHP script - missing tags etc.
        * [060812] Corrected sun keysym inclusion - inclusion limited to
          X-Windows build only
        * [060811] Fixed session resize issue and incremented the version.
        * [060811] Added $buffer-fill-* variables to the buffer-setup dialog
        * [060811] Stopped read-session warning about the *server* buffer
          being a process.
        * [060811] Updated to use the new $buffer-fill-* variables -
          simplifies the doc hooks as ehooks and bhooks are no longer
          required.
        * [060811] Incremented the version. MicroEmacs 06 - Date 2006/08/10 -
          sunos
        * [060811] Introduced new $buffer-fill-col and $buffer-fill-mode
          variables to allow every buffer to have its own setting, initialized
          to the global variable value when the buffer is created.
        * [060810] Added 'a' for All option to the save-some-buffers prompt
        * [060810] Added save -> prompt -> delete of all buffers when loading
          another session. If bit 1 in arg is not set (i.e. 0 read-session
          "name") then this is not done and the new session is effectively
          merged into the current.
        * [060810] Added setting of main buffer modes to the buffer-setup osd.
        * [060807] Updated emulation modes to handle the new main menu.
        * [060807] Fixed major mode drop down list to not scroll horizontally
        * [060807] A few tweaks to help with the other editor emulation.
        * [060807] Fixed major-mode-setup so Cancel cancels all changes (was
          50-50)
        * [060807] Removed old buffer-setup file and fixed the makefile
        * [060807] Removed 'correction' of main osd - not needed and wrong.
        * [060807] Tweaks to osd to remove a few annoyances: up on main menu
          now goes to last item of current sub menu, fixed re-frame and focus
          issue on an opened child and made C-g always just close a child even
          if not in focus.
        * [060803] Added new -2 and -3 values for 2nd arg to &lins to insert
          alphabetically and case insensitive alpha.
        * [060803] Added setting of the major mode to the new buffer-setup
        * [060803] Changed osd dialogs to use 'Cancel' or 'Close' rather than
          'Exit'
        * [060803] Closed notes if open when applying changes as this corrupts
          the notes frame.
        * [060803] Made the buffer sub-menu be case insensitively ordered in
          windows and have first letter hotkeys.
        * [060803] Changed frame-id comparison to use seq as should handle
          "ERROR" better.
        * [060803] Fixed notes to handle a reread-file type operation.
        * [060803] Changed osd dialogs to use 'Cancel' or 'Close' rather than
          'Exit'
        * [060802] Added saving the session to save-all and associated a file
          in $user-path with the File->New command.
        * [060801] Set .gz extracted buffer name and file name so its location
          is kept.
        * [060728] Fixed clear-case to handle multi-line comments with SHELL
          set to csh.
        * [060728] Changed "symbol" to "insert-symbol" and "indent-setup" to
          "buffer-setup" as this is what it will become. Fixed a few hot-key
          issues with new main menu.
        * [060728] Improved help page and looked for context-menu binding to
          support esc +.
        * [060728] Moved the location of making CVS and clear-case always
          available into their setup dialog and added a C-x C-q replacement
          option.
        * [060728] Changed backspace in a directory to move to the
          sub-directory in the parent listing.
        * [060728] Fixed notes startup so it returns the user to the same
          place.
        * [060728] Documentation, replaced -ve with negative and +ve with
          positive.
        * [060726] gdiff. Added termcap friendly key bindings to move between
          difference regions.
        * [060726] Added new indent-increase and indent-decrease macros. Added
          indent increase and decrease to format, changed notes binding to f8,
          move shell tools from tools to advanced and setup commands into
          tools.
        * [060726] Fixed setting of scheme when session file does not exist
          (problem hit when old user uses session for first time)
        * [060725] Changed goto commands to not stop the show-region highlight
        * [060725] Major rearrangement of the main menu, replaced the Insert
          and Execute sub-menus with a View and Advanced, re-balanced and
          relocated many items, most notably the setup dialogs out of Help
          into Advanced.
        * [060725] Renamed the existing tool-bar macro to toolbar-open
          (mirrors existing toolbar-close) and introduced a new tool-bar macro
          that toggles state, i.e. closes if opened. This command is more
          useful in key-bindings and menus etc.
        * [060725] Improved error handling of osd based find tag, also adding
          support for tags file being in a parent directory.
        * [060725] Removed command-line validation and relax file selection
          requirement so user can create a tool that does not require a file
          name (e.g. open . in explorer)
        * [060725] Used set/goto-position to store current dot and added <no
          favorites> entry if menu is empty.
        * [060725] Added hot-keys to the file attrib dialog
        * [060725] Changed simply fence matching of quotes and double quotes,
          if match is not found by the end or start of the line it's assumed
          to be a single and ignored.
        * [060725] Changed &mid so the 3rd argument (length) can be -ve to
          mean from the right (as per the &rig etc) - not sure why this was
          not done first time round.
        * [060624] Changed session support to handle both window and console
          environments. Changed startup to only initialize one scheme.
        * [060623] Added file-type-setup to the list of misc setups.
        * [060622] Changed buffer-setup to major-mode-setup, also changed
          buffer-help to major-mode-help etc and fixed comments. Left
          buffer-setup in buffstp as there will be a buffer-setup which really
          does setup up the current buffer. Change me.emf date to 20060606
        * [060620] Stopped session trying to change the frame for a console
          run.
        * [060619] Sessions. Stopped restore buffer's whose file does not
          exist and changed the order of frame size setting so on UNIX the
          depth of windows are maintained correctly
        * [060619] Notes. Fixed current buffer position reset problem caused
          by buffer being shown on hidden notes frame
        * [060619] Changed all ME setup macros to reload the /history registry
          before change the registry and writing it out as soon as the changes
          are accepted to reduce the likelihood of settings (like new alias
          paths) being lost. One except is when the setup is run from within
          user-setup in which case the registry is only read and written by
          user-setup, this could have some unwanted side effects. Added
          session-setup to the user-setup misc page.
        * [060619] Change to allow macros access to inactive buffers broke
          file and ipipe hooks which get executed but the buffer is officially
          made active - fixed by maintaining the BIFNACT internal flag and
          ensuring the algorithm used for inactive buffers is only used wh ere
          appropriate. Found buffer context was not set correctly for session
          buffers whose name was set to 'name<1>' as the BIFNAME flag is not
          set, fixed by removing this flag and using code to assess if the <1>
          should be removed based on the filename.
        * [060619] Fixed read-registry's replace mode which was doing a merge
          as the old node was not removed.
        * [060619] Fixed a bad prompt and added a couple of brackets to
          protect compare order.
        * [060616] Changed the start-up process to not use the history
          commands (which have been removed) but simply use the read-registry
          commands.
        * [060615] Moved the storage of all history type info into the new
          session (esf) files.
        * [060615] $user-name.erf only contains setup info and not often
          edited changed user setup to minimize the likelihood of losing edits
          (at last).
        * [060615] Broken session-setup out into its own macro file and made
          quite a few fixes to the new session support.
        * [060615] Removed the save- and read-history commands the me.emf
          start-up now simply use the read-registry command
        * [060615] Changed find-buffer to allow limited access to inactive
          buffers (allows base getting and setting of variables)
        * [060615] Changed the exit-emacs numeric argument (again) so it can
          be used by meDie (0x28 exit-emacs ~= emergency exit)
        * [060615] Created new $window-mark-line & $window-mark-col to aid
          inactive buffer support (not sure why these were not already there
          as they are usefully in macros)
        * [060615] Enabled availability of save-some-buffers by default
          (quick-exit relies on this!)
        * [060615] Changed the -c command-line option to simply set the
          variable %session-name (relies on session macros)
        * [060615] Changed clipboard support to not mess with it during
          start-up and shut-down
        * [060615] Created new change-scheme command.
        * [060615] ClearCase. Fixed *cc-state* buffer not being in view mode
          when command completes.
        * [060615] Corrected types of exchange-point-and-mark.
        * [060608] Improved OSD search dialog by making the buttons always
          enabled and reporting an error if search string is empty.
        * [060608] Made the existing hidden scheme macro a visible command
          which can be used to change the current color scheme. Set
          .scheme.current to the file name of the current scheme Saved the
          current scheme in a session so a user can create a session with its
          own different scheme.
        * [060526] Sessions. Changed to use new shut-down pseudo key.
        * [060526] Changed shut-down process to call the ehooks for the
          current buffer of all frames and changed the shut-down macro to a
          pseudo key-binding.
        * [060525] Added a new buffer-major-mode command to change the current
          buffer's hook, giving it an arg of -1 or major mode of "" removes
          the hook. No completion list yet. Fixed tab-width setting so all 3
          windows get the same new value.
        * [060525] Changed gdiff to insert the 2 files into temp buffers so if
          the files are already loaded by the user these buffers are not
          effected. Added the ability to set the tab width.
        * [060525] Fixed crash caused by watch refreshing the buffer while
          user is using isearch - stopped watch from refreshing the buffer.
        * [060525] Added a new bit 0x10 to find- read- and view-file to
          disable the context fhook evaluation.
        * [060525] UNIX fix. Call screenUpdate directly after a window resize
          - fixes gdiff update problem.
        * [060523] Sessions. First serious rev of session-load and -save.
        * [060523] Added arg to tool-bar to allow the tool-bar to be
          initialized without re-reading the registry - required by new
          session support.
        * [060523] Changed left click on mode line to change to the window if
          the mouse is not moved.
        * [060523] Fixed C++ '::<function>() ;' indentation bug introduced
          with c++ initialize ': <base-init> ()' indentation support.
        * [060523] Encrypted files. Added file/host to the password prompt so
          on a -c the user should know which password is required.
        * [060523] Fixed UNIX compiler warnings
        * [060516] me.emf. Fixed missing def of file-type-setup &
          shell-tool-setup.
        * [060515] Added new bit 0x2 to arg for change-buffer-name which force
          the buffer to have the given name, changing the name of an existing
          buffer if required.
        * [060512] ClearCase. Fixed cc-setup view deletion, pressing No does
          not remove it. Removed the temporary file created by cc-diff if me's
          diff of gdiff are used, file is still left if xdiff is used.
        * [060512] Added a new $mode-chars variable which returns the letter
          ids of all modes as a string, this variable cannot currently be set.
        * [060512] Changed the numeric arguments for quick-exit and
          save-buffers-exit-emacs to make them simple to use.
        * [060510] Improved the ftp logging so errors get put into the console
          with error numbers rather than just mlwrite'd. Removed the KEEPALIVE
          as ME closes the sockets with 10mins anyway. Fix the ftp kb/s calc.
        * [060510] Dirlist. Fixed context menu so the FTP additions are added
          for any ftp:// listing.
        * [060504] Major addition to notes: a) Added forw/back note. b) added
          notes-instant and notes-context c) implemented notes-session-save
          (not done window layout yet) but not implemented the matching load
          yet. d) fixed a few annoying up-date and behavior problems.
        * [060504] ClearCase. Fixed windows \\r\\n issue with diff -
          constructed predecessor could have the wrong format breaking the
          diff.
        * [060504] Changed reyank numeric arg so if a -ve arg is given reyank
          will fail if at the end of the kill chain rather than loop -
          required for notes-session-save
        * [060504] Found differences between copy and kill-region's handling
          of narrows, particularly if there's no markup line Found I could
          crash ME if only the end part of a narrow-to is killed - buffer line
          number all go wrong. To fix the issues I've created a standard
          function to handle the expansion of narrows over a region and made
          the rule that for a narrow without a markup line to be included in
          the region at least the \\n of the previous line and 1 char of the
          container line must be included, this means that narrows at the top
          and bottom cannot be included.
        * [060504] ClearCase. Fixed cc-merge comment bug.
        * [060504] Added support for a .ascii-time.format variable which
          defines the format for the output using '%' tags as per strftime
          function (supports most tags) - output is unchanged if variable is
          not set. Fixes request by Dick Pierce. Changed the OSD insert time
          function to use the same tokens and made the first format in the
          list be the output of ascii-time.
        * [060503] Provided macro interface to get a list of alpha marks for
          the current buffer.
        * [060427] Fixed context-menu element activation issue caused by
          selected file count being wrong.
        * [060427] Fixed notes and gdiff window resize issues by locking the
          size.
        * [060426] Improved (but not quite fully fixed and I don't think I
          can) the mouse word selection when the word is half hidden at the
          left or right edge of the window.
        * [060425] Fixed bug with setting $window-line, if value is < 1 then
          the goto-line function prompts the user, this is incorrect behavior
          for a set variable command and the cause of a mouse driver spin.
          Fixed mouse left button spin caused by missing the pick event and a
          bug in set-variable for $window-line. Added new horizontal scroll
          feature when user clicks on a $window-char truncated line char.
        * [060421] JSP. Fixed java <%...%> within JavaScript start token
        * [060421] Fixed C++ comment hilighting
        * [060413] Added an abort-command safty trap to reset the
          $buffer-input variable.
        * [060413] JSP. Fixed most JSP hilight and indent issues caused by
          java and javascript confusions.
        * [060412] Bug fix. Put checks in to ensure the hilight/indent to be
          used according to a look-back scheme has been defined - fixes crash
          when viewing JSP files.
        * [060403] DIRECTORY LISTING. Fixed 'not-exist' fix in last commit -
          ftp dir lists can be only a couple of lines Made file/dir copy
          automatically try 3 times before prompting the user (large ftp
          copies will fail at points). Fixed browse mode close problem when
          browse deletes the buffer.
        * [060402] Used an ehook and a callback to auto detect a change in the
          notes frame buffer/window layout, if there is a change the callback
          closes the notes frame. This approach resolves many issues.
        * [060331] Fixed XML magic hook.
        * [060331] Fix annoying find-zfile last buffer history change. Changed
          the buffer & file name of a loaded zfile file to something more
          useful.
        * [060331] Created a '2 find-buffer <file-name>' arg which finds an
          existing buffer via its file name - used to fix annoying find-zfile
          buffer history change.
        * [060330] Fixed CVS & CC context menu placement issues. Fixed cc-add
          to use -mkpath for directories
        * [060330] Change fhook-dir to always detect if its a
          source-controlled dir and call the SC hook, the SC hook can then add
          its own bindings etc. Fixed fhook-dir so loading of ".../not-exist/"
          does not error.
        * [060330] Made the esc = & esc + menu bindings global.
        * [060329] Changed unix start-up mode to favor X over termcap if
          DISPLAY is set, even if term is a vt100.
        * [060329] Fixed mode-line udate bug when all edits are undone -
          reported by Tom Hundt.
        * [060322] Fixed the position of the context menu when opened by mouse
          or menu key. Fixed auto-spell not being available when context menu
          is opened using the menu key.
        * [060322] Improved gdiff-next command to error at the end of the file
          so the use knows they have reached the end. Bound 'menu' to open the
          contex menu and bound 'esc up' & 'esc down' to move between
          unassigned sections.
        * [060322] Bound f10 to close the notes frame and bound C-x k to a new
          notes-delete command
        * [060317] ClearCase. Added new cc-merge command (which uses
          cleartool's findmerge command!). Added new cc-describe command
          (which uses cleartool's describe command), fixed the CC context
          menu.
        * [060317] Directory listing. Increased 2Gb directory file size limit
          to 4Gb by making size variables meUInt.
        * [060317] Fixed '\\' quoting in command-wait example.
        * [060316] Up-dated docs for command-wait, added some meaty examples
          and added cross references to them.
        * [060316] indent fix
        * [060316] Changed describe-word osd dialog so that it has a 'Look Up'
          button which is the default. Also improved the insert description
          process so C-w kills the description inserted.
        * [060316] Improved the behaviour of the enter key in the help osd so
          it does a search or nothing.
        * [060315] Fixed a win32 console crash caused by the new frame
          reposition function. Stopped the messing about of the windows
          console when ME is in piped mode.
        * [060309] Fixed regex \\a -> \\g for bell and added support for \\a &
          \\m to [...] character classes.
        * [060309] Updated *shell-command docs.
        * [060309] Documented &lef, &mid & &rig -ve 2nd arg usage.
        * [060309] Documented insert-string's -ve arg.
        * [060309] Up-dated goto-matching-fence docs
        * [060309] Fixed docs for when no arg is given to forward-kill-word.
        * [060309] Updated jst template to new version. Fixed a couple of bugs
          with tables (empty cells and bad indent) Implemented a table cell
          '!' flag to indicate a start of a row (helps debugging) Fixed bug
          when title variable not set.
        * [060309] ClearCase. Minor improvement to setup layout
        * [060222] Exit handling fixed, saving of modified buffers, history,
          spell dictionaries etc. "**Emergency Exit**" messages removed from
          exit handling.
        * [060214] Corrected user setup mouse defaults - missing wheel mouse
          default bindings.
        * [060214] Improved the php look-back scheme to identify php script
          quicker.
        * [060213] Fixed crash caused by the new hilight look back scheme
          using the indent look back function which used the indent scheme
          rather than the hilight scheme
        * [060210] Improved php hilighting by making use of the new
          look-back-scheme and look-back-only-token features.
        * [060210] Improved the time printout
        * [060210] Benchmark tests. Improved the disptest.
        * [060210] ClearCase. Fixed cc-add when adding just a directory.
        * [060210] Added basic mouse support to browser and honours exit
          bindings
        * [060210] Added look-back-scheme support to hilighting (uses same
          code as indents quick-lookback scheme). Added new 'only use during
          look-back' hilight token (combined 0x800 & 0x200) which can solve
          make multi-line string hilighting issues.
        * [060210] Fixed compiler warning with -m changes
        * [060210] Removed unused variable in new reposition function
        * [060210] Fixed unused variable on NDEBUG build
        * [060209] Made changes to the -m server message option to make it
          usable. a) Process the message using the macro 'token' function so
          \\n is translated to a new-line char. b) If the message is not
          terminated with a \\n then one is added. c) The popup-window message
          it only given when -o option is used
        * [060209] Added support for a server 'M' message command.
        * [060209] Changed the hilight and indent meHilight structure mis-uses
          access the data via #define (added to estruct.h) so the code is
          clean and easy to read and the miss uses can be easily found and
          changed. Changed the storage of the main indent and hilight scheme
          flags to use the ignore field (only 5 bits currently used) so the
          trunc scheme can use the type and the hilight look back can use the
          close (i.e. unlimited).
        * [060209] Fixed clear-case update list on checkin option.
        * [060208] Fixed crash caused by mlGetStringFromUser being called
          recursively - only possible since the introduction of ftp completion
          which can prompt for the user password while inputting a file name.
        * [060207] Added an implementation of meFrameRepositionWindow for
          XTerm, not a very good one as there is not a clear standard between
          WMs.
        * [060207] Fixed obscure crash caused by horizonal scroll mode 2 and
          long lines.
        * [060202] Build script. Fixed MS-Window's typo.
        * [060201] ClearCase + CVS. Fixed hiding of *??-console* buffer and
          closing the window with loading a file from a dir list.
        * [060127] Broke the user-setup 'Tools' 'File Types' and 'EMail' pages
          out into separate independent setup dialogs. Added new Miscellaneous
          page to user-setup with links to these and other setup dialogs (such
          as alias-path and file-tool) Changed the buttons to the more
          standard Okay, Apply Cancel. Slightly changed some of the Mail & VM
          registry settings to make each platform independent (except
          filtering).
        * [060127] ClearCase. Added new cc-delete and alias-path-setup
          commands. Added f4 to diff binding. Moved the window resizing call
          to nearer the end (after the font resize as this could change to a
          smaller font allowing more lines etc).
        * [060127] Fixed quite a few issues with the CVS and clear-case UI
          interfaces. Brought cvs-state into line with CC, implemented
          cc-delete and rationalised the hot-keys and context menus.
        * [060127] Added new alias-path-setup OSD gui.
        * [060127] Added new 3 and 4 arg to popup-window to manipulate the
          main frame window, implemented meFrameRepositionWindow function on
          windows.
        * [060127] Fixed find-reg index in error message.
        * [060127] Moved macro parser's \\a to \\g (bell) and added support
          for \\a - alpha and \\m - alpha-num to hilight and regex.
        * [060125] Changed the default debug for 'deb' abbrev to 2.
        * [060125] Improved the hilighting of html &???; chars - issue raised
          by Tom Hundt
        * [060124] Fixed crash caused by moving right (cursor key) into a
          sub-menu with no active items - bug found by Tom Hundt.
        * [060122] gdiff. Fixed the bugs introduced with the 3rd 'current
          line' window was introduced.
        * [060122] Changed call from saveExitEmacs to exitEmacs to avoid
          compile errors for NE.
        * [060122] Fixed the meDie function to not exit straight after the
          emergency exit message, now autosaves as it should. Change the
          handling of the CLOSE message on windows so it prompts okay/cancel
          if buffers need saving and then exits. Fixed really annoying
          modifier state mismatch problem on windows - reproduce by pressing
          control right-click on title bar to get the system menu and then
          release the control, ME misses the C-drop event so thinks its still
          pressed.
        * [051220] JST extensions.
        * [051219] JST. Added implementation of TOC to html export.
        * [051219] ClearCase. Disable check out of parent dir for cc-add as
          its not implemented
        * [051215] JST. Changed tag highlighting to handle split line tags
          correctly. Implemented support for f and b color export to HTML
          using style.
        * [051215] First commit of new v4 JST format hook and export macros.
        * [051215] Fixed the return value of transpose-lines command which was
          always returning false causing cc-add to fail.
        * [051212] SQL Template. Missing hilight statement causes execution to
          fail - Thanks to Th.
        * [051212] Fixes to old JST before it gets trashed
        * [051125] Fixed regex bug where "[\\s]" incorrectly matches an 's'
        * [051125] ClearCase. Added support for not loaded to cc-state
        * [051123] Added support for alias-paths.
        * [051122] Fixed highlight problems with "^ *$" & "^\\\\s*$" close
          bracket tags, they should match any line containing only
          spaces/white-spaces but they did not work reliably.
        * [051122] ClearCase. Fixed the cc-diff, external diff settings had
          got muddled.
        * [051122] Directory listing. Changed the size ordering to list
          largest first on initial sort.
        * [051118] ClearCase. Implemented the auto get checkout comment and
          removed the temp command-line buffer.
        * [051118] Directory listing window. Added binding of 'f' to toggle
          the filter and changed the 's' and 'S' bindings round (s is far more
          useful)
        * [051118] Improved the horizontal scrolling of gdiff and browse
        * [051110] Make debugger stop at executed !elif & !else will work for
          all macros, may not work when executing a buffer as the line may
          start with a white space.
        * [051110] Stopped osd check-box macros from triggering the debugger
          when $debug is set to 1.
        * [051110] Added some more key translations based on bug report by
          Francesco Abbate.
        * [051104] 2nd and much improved version of cc-setup. Changed to using
          -1 insert-string to allow multi-line comments. Fixed horrid problem
          with cleartool's handling of checking out a file when its been
          hijacked, no command-line option to make it use the hijacked file me
          has to use ipipe-write a send 'yes' at the prompt, but as the prompt
          is not given me must be preempt and send them first, one for each
          file - clear-case is pants and cleartool sucks.
        * [051104] Changed cmd-line construction to use -1 insert-string to
          insert \\n's into the line - not really very nice.
        * [051104] Fixed meGetChar to be like GetString in that if running a
          macro the value has not been given it goes directly to the user
          rather than simply failing, this improves macro reliability and
          eases debugging of macros.
        * [051104] Multi-line shell fix. The new 0x100 flag to shell-command
          has one drawback, you cannot run commands that include newline
          characters as the cmd-line must be on the first line. But CVS and
          clear-case commit comments are often multi-line so this is not
          acceptable. To fix the problem I have added a -ve arg to
          insert-string comment which then performs a literal insertion, i.e.
          every char including a \\n char is inserted are text. This fixes the
          immediate problem but inserting a \\n char in a line can break other
          thing in a very major way (like undo) so it must be used with
          extreme care.
        * [051103] ClearCase. First rev of a CC tool defaults setup in
          cc-setup. Moved CC over to using 0x100 bit in shell-command to
          remove command-line length limit.
        * [051102] Moved multiple-file file-tool executions over to using the
          new 0x100 shell-command flag (first line of buffer) to remove
          command-line length limit in almost all cases (cmd has a 4kb limit)
        * [051102] Introduced a new 0x100 bit for shell commands which means
          the 'cmd-line' given is a buffer names whose first line holds the
          command-line to run.
        * [051028] ClearCase. Fixed cc-diff abort when a file has no
          differences. Added a 'delete line' function to cc-state bound to
          C-k.
        * [051019] Visual basic highlighting - added And Or and Xor operators.
        * [051013] Unix shell window, corrected highlighting of backslash
          escape character outside of a string enclosure.
        * [051011] ClearCase extensions. Added button to cc-checkin to get
          checkout comment. In cc-state - fixed file selection on last empty
          line and mouse selection and added support for mouse drag selection.
        * [051011] Changed dirlist copy/move to preserve the original files
          time stamp.
        * [051011] Fixed windows rename to check the to name is case
          insensitively different.
        * [051011] Implemented file time-stamp preservation in the file-op
          copy and move.
        * [051011] Improved the window-popup on windows, more likely to work
          but can still fail.
        * [051011] Fixed UNIX drag-n-drop, broken by -l l:c addition.
        * [051007] Integrated Ric Yeates command line cD-l <line>:<col>cA
          submission - thanks for the submission.
        * [051007] ClearCase. Removed VOB option from cDcc-statecA as it did not
          work. Made cDcc-consolecA read only and better integrated including
          supporting it as a toolbar tool (like cvs-console).
        * [051007] Fixed bad variable assignment in directory list macros.
        * [051001] Corrected Sun Solaris x86 makefile to use the Sun Native
          compiler.
        * [050930] ClearCase. Fixed cDcc-statecA to check the state of selected
          directories, which requires a double cleartool call (horrid
          command-line) Added support for config-spec viewing and editing.
          Added directory refresh option for checkin/out add etc. Added many
          improvements to cc-state buffer support, hilighting, file listing
          style sorting and selection (i.e. following are bound
          cG1cA,cG2cA,cG3cA,cG+cA,cG-cA,cGucA,cGacA,cG*cA)
        * [050930] cDfile-toolcA, changed the buffer list toolbar tool to keep the
          current line to the current buffer when using cDfind-buffercA etc.
        * [050930] Latest cCMirkwoodcA update from Bruno.
        * [050930] Fixed ftp drag'n'drop copy bug, the source dir needed an
          file: prefix to remove the cGftp://cA of the current buffer. While test
          I blew away my home directory, nasty way to discover that ftp can
          return cG".."cA not cG"../"cA and cG".."cA is not ignored when deleting! Fixed.
        * [050929] File listing, stopped copy, move etc commands from
          accepting cG'../'cA when its the current line Fixed cG'v'cA browse file open
          and close.
        * [050928] browse, removed the delete buffer flag from browse - wrong
          way to do this.
        * [050928] ClearCase, make cDcc-annotatecA work if file is checked out
          (cleartool command-line is awful, why do you have to pay money to
          use this rubbish?)
        * [050928] Added wrap feature to cDbrowsecA mode.
        * [050928] Changed cCMirkwoodcA main OSD scheme to make current focus item
          more visible.
        * [050920] Changed the $debug variable to be bit based as its old
          values just could implement the required functionality.
        * [050920] Latest cCMirkwoodcA highlight scheme - added underlining for
          spelling errors
        * [050920] OAD, added a comment tab to the scheme editor and up-graded
          the scheme selectors to use combo-boxes.
        * [050920] Fixed compile error on macos caused by bad macro
          definition.
        * [050919] Fixed 2 bugs: meRegHead's force could be left set to 1
          which has the side effect of cGC-gcA not hiding the active region. Due
          to last change to cDcommand-waitcA the screen is not up-dated before
          waiting for a key breaking cDgdiffcA.
        * [050919] Readability update to cCMirkwoodcA highlight scheme.
        * [050919] Changed ClearCase cDcc-statecA to handle file names with 'cG[cA's
          in them.
        * [050915] Added Up, Down, Hide window and default open options to the
          cDfile-toolcA setup GUI. Added support for a default open to the
          directory listing, pressing return now checks for a cDfile-toolcA
          default open (explorerish), 'cGocA' for open always loads the file into
          me.
        * [050915] Added support for dbx on sunos. Changed the ipipe input
          mode to be toggled using cGf3cA rather than set via cGf2cA, cGf3cA or cGf4cA.
        * [050915] cDzfilecA, fixed filename -> absolute file name when given as
          an macro arg - should be based off current buffer's path.
        * [050908] Added cDfile-toolcA.
        * [050908] ClearCase, fixed cG%diff-comcA definition problem and
          cDcc-uncheckoutcA buffer update problem. Fixed cDcc-checkoutcA and
          cDcc-checkincA buffer update problems as well.
        * [050908] Improved the diff highlight, more readable and correct.
        * [050908] Added new cCMirkwoodcA highlight scheme.
        * [050806] Added better support for MinGW. Fixed the console color bug
          and most of the compiler warnings. Added support for the MSYS shell
          by creating a unix style cGmingw.gmkcA (uses rm instead of del etc)
          updating the old cGmingw.gmkcA and renamed to cGmingw32.gmkcA and added
          support to the unix build script.
        * [050803] Fixed cDnecA crash when an unbound key is pressed, bug
          introduced with last commits.
        * [050721] Fixed annoying mouse refocus in osd dialog even though
          mouse is not moved - another windows nasty.
        * [050720] File browser, added directory closing binding to 'cGccA' and
          'cG+cA' 'cG-cA' windows compatible bindings.
        * [050720] Pop-up menus, shifted the context menu down one line when
          opened by a key.
        * [050720] Directory listing. Changed the tag file list macro to
          support moving to the closest selected so the user can see which
          files they are deleting! Improved the file-tool so cG\\HcA will see a
          hot-key, 'cG\\cA' chars and 'cG"cA' must be quoted (i.e. 'cG\\\\cA' & 'cG\"cA')
          Bound 'cGtcA' to open the file tool menu directly so tools can be easily
          executed without use of the mouse.
        * [050720] Source code reorganisation. Standardized the # preprocess
          forms, removed 2 uses of #elif and cplusplus and changed odd
          'cGdefined(_BSD)cA' style bracketing which the cDc-hash-evalcA does not
          handle.
        * [050720] Removed unused functionality from NE. Made the following
          available as extended functionality: cDbackward-delete-tabcA,
          cDchange-buffer-namecA, cDchange-file-namecA, cDdefine-macro-filecA,
          cDdelete-blank-linescA, cDdelete-some-bufferscA, cDnamed-buffer-modecA,
          cDsave-some-bufferscA, cDsave-buffers-exit-emacscA, user(cG%cA), buffer(cG:cA) and
          command(cG.cA) variables, cD$buffer-inputcA, cD$kept-versionscA, cD$mouse*cA.
          cD$pause-timecA, cD$MEBACKUPPATHcA. Removed cD-ccA from ne's help page as this
          is not supported. Moved macro regex cD&xseqcA, cD&xrepcA based directives
          and most cD@cA variables to extended functionality.
        * [050719] Organiser address search broken due to recent changes to
          macro argument getting. Fixed by changing the numeric argument which
          was ambiguously defined.
        * [050718] Source code reorganisation. Made the file hook variables
          and HideBuffer function statics. Changed ne to use fixed char groups
          for isUpper etc rather than the large look-up tables as it does not
          have cDset-char-maskcA to configure them anyway.
        * [050718] C template. Fixed and greatly simplified the #if handling
          in the hash eval code. Added support for cG#undefcA.
        * [050715] Source code organisation. Removed unused code when there's
          no ipipe support. Hashed out location functions which are only
          required by socket or ipipe support.
        * [050714] Combined cDcc-logcA and cDcc-annotatecA into a single cDcc-annotatecA
          cammon with GUI. Added cDcc-vtreecA and cDcc-explorercA.
        * [050714] Fixed cDuser-setupcA setting of number of backups and Ignore
          files settings.
        * [050714] Fixed cDfile-opcA copy so the source file's attributes are
          preserved (i.e. remains read only etc). Implemented the 4th
          parameter (attribs) in cD&stat icA Implemented a cDfile-opcA chmod using arg
          bit cG0x200cA.
        * [050712] Corrected NE build under Windows, console build including
          windows calls.
        * [050712] Directory listing, fixed delete copy and move prompts, flag
          cG0x08cA got changed to cG0x04cA in cDfile-opcA.
        * [050712] Implemented a proper ClearCase context diff by recreating
          the old file from the diff and then calling a real diff program.
        * [050712] Changed the diff hilighting to be just one scheme as a CC
          diff could contain a gdiff style for files and diff style for
          directories.
        * [050712] Corrected NE build problem with macro debugging.
        * [050711] Corrected Latex template load error in cGhklatex.emfcA
          (detected with cG$debug=1cA).
        * [050710] Fixed old cG$debugcA interface, found a long forgotton mode 3
          (now 4) which simply prints the current line without waiting, this
          broken the new mode 3.
        * [050709] Removed the cD-dcA command line option - pointless.
        * [050709] Improved the macro command argument handling to get missing
          arguments from the user, i.e. having a macro line of: cDfine-filecA
          Works okay.
        * [050709] Vastly improved the macro debugging, the cD$debugcA value of 1
          is now 2, 2 -> 3, a value of 1 now tells the user of any unhandled
          failures.
        * [050709] Fixed the Windows window resizing behaviour to be a lot
          more usable. The window size now increases in character size steps
          rather than bouncing around and the window is refresh as its
          changed. The Horizontal width limit of the window has effectively
          been removed (set to 400 chars) the depth is still restricted to the
          screen size, issue raised by Tom Hundt.
        * [050709] Added new file tools interface, creating windows explorer
          type file name based tools (e.g. extracting a zip file).
        * [050709] Added ClearCase cDcc-logcA and cDcc-annotatecA (similar to cvs's
          commands)
        * [050709] Stopped the default file hook from creating a bogus tool
          menu and help page.
        * [050709] Fixed the previous-line macro and the kill-word key
          bindings.
        * [050709] Changed the menu items which open a sub dialog to having
          'cG...cA' in their name as per the gui standard, issue raised by Tom
          Hundt.
        * [050708] Changed sub-menu display chars, auto open menus are now '
          cG>cA' and manual are 'cG+cA', issue raised by Tom Hundt.
        * [050708] Got thoroughly fed up with the emacs style cDkill-wordcA -
          useless. Came up with a compromise, if no numeric arg is given then
          it works the old way, if an argument is given (i.e. 1, 2 ...) it
          works in like emacs (which makes sense as you are asking it to kill
          1 word etc.)
        * [050708] Changed cDlist-commandscA and cDcommand-aproproscA to not list
          hidden macros by default. They can be listed if bit 1 of the numeric
          argument is clear (aka cDlist-bufferscA)
        * [050625] Updated mode line letter mnemonics which were out of date,
          issue raised by Tom Hundt.
        * [050625] Stop me crashing when describe-variable is given something
          like "cD&orcA", now restricted to variables of type cG#cA, cG$cA, cG%cA, cG:cA, cG.cA only.
        * [050618] Added support for -ve offests to cD&lefcA, cD&midcA, cD&rigcA functions
          to go from the end of the string.
        * [050618] Created a cCno waitcA option to cDshell-commandcA so processes can
          be launched and forgotten about. Also added support for all the
          other process launch flags present in pipe and ipipe shell commands.
          Removed some very dead code.
        * [050618] Avoided a 'cD&mid -1cA' in display matching fence (cGdmf.emfcA) by
          restructuring the logic a bit.
        * [050616] Revision 3 of ClearCase support.
        * [050614] Second rev of clearcase support. restructured the execution
          of cleartool so ipipes are used (even though the user may not be
          able to edit) giving feedback on progress. Implemented a basic diff
          which can only diff one file at a time and only with its predecessor
          but at least it supports a context output of sorts!
        * [050614] Fixed cDcommand-waitcA when no arg is given to return when a
          callback sets the cG.waitcA variable. Command now returns imediately if
          the cG.waitcA variable is not defined. Fixed windows sleep function
          which was managing to break out before it should.
        * [050612] latex added macros for bold/italic/mono character
          formatting.
        * [050612] nroff region support for character formating.
        * [050612] cD.fhook-xxx.command-ncA syntax added to cDbuffer-initcA to
          simplify comamnd definition.
        * [050610] Removed "cDC-c C-gcA" key binding in document macros and
          replaced with "cDC-c <cA" because of cDC-gcA issue.
        * [050610] CVS added support for a cDcvsco.etfcA checkin template.
        * [050610] First revision of ClearCase support, very incomplete and
          primative but the hooks required in the rest of the system are in
          place.
        * [050609] Changed the directory listing so 'cG.cA' is removed and cG..cA is
          always the first cCfilecA and cannot be selected. Fixed some directory
          display annoying refresh issues.
        * [050609] First implementation of directory deletion, copying and
          moving, including support for ftp directories etc. Areas of concern
          are still copied file's permissions and to a lesser degree
          ownership. Also the copies behaviour with symbolic links, this must
          be tested further.
        * [050609] Fixed file permissions and ftp minor issues a couple of
          major ftp bugs and cD$file-namescA working for ftp directories.
        * [050609] Added new cD&statcA "cGicA" flag and argument bit 4 to cDfile-opcA to
          abort on a problem rather than prompt, it also returns an error code
          in cC$resultcA.
        * [050609] Changed the kill word commands so have the same word
          boundary behaviour as cDforward-wordcA and Emacs (was killing word only
          then whitespaces only etc). Corrected word movement and killing
          command's EOB and BOB error handling.
        * [050608] Added new cDrdiffcA (recursive diff) command
        * [050608] Updated cDstring-rectanglecA and cDspace-rectanglecA to improve its
          usability.
        * [050608] Updated cDdescribe-wordcA setup comment.
        * [050601] Corrected cGne.emfcA, broke Window mode in disabling console
          mode for cDne -RcA option change.
        * [050601] Corrected crash on hilight with alpha-numerics of form
          cG[[:digit:]]cA when spelt incorrectly.

    cD8th Release - May 2005cA
    Release date specified as 2005/05/05.

        * [050508] JASSPA MicroEmacs 8th release - final. Core and macro
          versions 20050505.
        * [050514] Fixed ftp copy lock-up (most noticable on windows) caused
          by the response read at the start of a command also reading (and
          disgarding) the finishing message so ME hangs at the end of the
          command waiting for a response.
        * [050514] Enabled ipipes under cygwin by default.
        * [050514] Fixed win32s build.
        * [050514] Fixed cDmecygwincA interactive MS-DOS and cygwin BASH shells.
        * [050513] Found the UNIX cDwaitpid(-1,...)cA in the sigchild handler
          (which removes any zoombie processes) removes the pipe commands
          process so the pclose call cannot get the process's exit code
          (returns -1).
        * [050509] Changed the name of aix43 make files to aix4 and sunos 55
          and 56 files to a single sunos5 makefile
        * [050509] Added support for cDaix v5cA (tested on aix v5.1)
        * [050507] Added Finnish support to ne.emf.
        * [050506] Improved python collapse and item-list support and added
          eaf and etf for python - thanks to Detlef.
        * [050505] Base version numbers reset for next release.
        * [050429] Added support for keybinding to item-list column ordering,
          function is item-list-order and is bound to 1, 2 and 3 by default.
          Thanks to Bryan Schofield for his submission in this area.
        * [050429] Spelling - protect '.'s in the word with \\.
        * [050428] Corrected TCL hilighting w.r.t. comment at end of line -
          submitted by Bryan Schofield.
        * [050427] Major reworking of main commands in a directory listing
          buffer. Implemented typical features found in an OFM standard
          browser and create standard bindings as well as termcap friendly
          ones. Changed delete binding to delete files rather than close
          browser which is now bound to f10.
        * [050427] osd - Added numeric bit 8 on osd-entry arg to put the text
          above the entry.
        * [050427] Added C-x k support to browser mode to kill the buffer,
          also added hook for the file-browser's view file.
        * [050427] Fixed user-setup to use only one value of $file-ignore &
          $kept-versions per platform rather than one for window and one for
          console based versions.
        * [050427] Shrunk the size of the file-attrib dialog to ensure it fits
          on a termcap screen.
        * [050427] Fixed nasty bug with transpose-line at the end of the
          buffer swapping the last line with the first!
        * [050427] main.c - Fixed minor compiler warnings.
        * [050426] Added a binding for file completion (any key bound to
          insert-tab) so OSD dialogs can do completion (although awkwardly).
        * [050423] Fixed wiki edit mode for Russian keyboards, the 'k' flag
          key mapping was breaking things.
        * [050423] Windows - Fixed windows Ctrl numeric pad keys, now come
          through as C-0 ... C-9 C-* C-+ etc.
        * [050420] Added new Dot/Neato support fhook (for .dot files) - thanks
          to Detlef for the submission.
        * [050420] TCL - Added more hilight tokens from Detlef.
        * [050420] Document macros - fixed cpp->tcl typo - thanks to Detlef
          for spotting this.
        * [050410] Fixed the -R option for DOS box, cursor same as the
          foreground color which is not ideal!
        * [050410] Fixed the SunOS x86 makefile to disabled #pragam warnings
          under GCC.
        * [050409] Release Candidate 2 - MicroEmacs 2005 (RC2)
        * [050408] Added flag to the user-setup Tools to force the rereading
          of the current buffer's file, thanks to Bryan Schofield.
        * [050408] Added new .item-list.width variable to allow control of the
          item window list - submitted by Bryan Schofield.
        * [050408] Moved the generate tags into the sub folder and added a
          compile option to c and cpp - submitted by Bryan Schofield.
        * [050405] Added support for DOS code page 866 (Cyrillic Russion) -
          submitted by Nicholas Kudriavtsev
        * [050331] Added support for the setting of the history in macros via
          @h#.
        * [050325] registry.c - removed compiler warning indicating porting
          problem hilighted under Darwin. Post increment of variable on left
          of assignment and same variable appeared on the right, split out the
          increment to reduce ambiguity of the statement.
        * [050320] UNIX only - add a rule for .dir files found in the X11
          directory. We do not want this files identified as "dir" info root
          file
        * [050320] Added termcap (white) scheme for reverse video operation.
        * [050320] Newuser registry file - added default entry for Apple Mac
          "darwin". Confirmed operation under Mac X-Windows.
        * [050320] Extended ME exit commands to support the discarding of
          modified buffers 'cG0x8 discard modified bufferscA' and 'cG0x10 discard
          modified buffers and create recovery file for changescA'.
        * [050320] Corrected XML syntax for strings "cG...cA" to fix indent and
          hilight anomalies.
        * [050319] Added cD-RcA command line option to reverse the built in video
          schemes - specifically for cDnecA(1) also works with cDmecA(1).
        * [050319] Corrected default mode settings. Recent removal of
          cDletter(2m)cA, cDline(2m)cA etc. changed the mode byte assignment of some
          modes. The built in global mode default was not updated for this
          change in bytes and incorrect global modes appeared as a result -
          specifically cDquiet(2m)cA which has jumped bytes.
        * [050315] LEX/YACC template - Corrected LEX and YACC highlighting.
          Aligned C, C++ and YACC/LEX templates to be consistent.
        * [050315] C/C++ templates - buffer setup modified for GNU Indent
          Style setting.
        * [050315] Added new lslmbrowse(3)le command and binding to f3, changed
          existing collapse-all cDf3cA binding to cDC-f2cA.
        * [050315] Modified ME exit commands to support a bitwise arg n where
          main lslmexit-emacs(2)le has 'cG0x01 PromptcA', 'cG0x02 Save each buffer/reg/dic
          (with prompt if 0x01 set)cA' and 'cG0x04 Prompt for exit code and exit
          ME with that code.cA'
        * [050313] Latex template - Corrected the latex-fill-paragraph. Set
          the fill-mode to 'cDlcA' rather than 'cDLcA' because its a pain when it
          selects centre rather than left and messes things up.
        * [050311] Directory list - changed column sorting so Modified is
          sorted most recent first.
        * [050311] Fixed perldb pipe operation.
        * [050310] OSD simplified the main context menu and moved paste a cvs
          items in the directory context menu
        * [050310] Fixed diff's file name input, was not completing correctly
        * [050310] CVS changed the default setting of the recursive add to
          off.
        * [050310] JASSPA MicroEmacs quick start document released.
        * [050309] Fixed bug in regex multi-line search backwards, searching
          for "cGfoo[^a]cA" is a mult-line as cG[^a]cA matches cG\\ncA, if "cGfoobcA" exists
          at the start of the line isearch-backward refuses to move on.
        * [050309] Catman pages added for ne(1) and me(1) complaints with
          gentoo as missing. Added to the package builds.
        * [050308] Fixed a nasty bug with ftp connect dialog when the host has
          a port. Changed the default path to be nothing which becomes cG/~/cA to
          list the login directory. Change the tab order to not include the
          password as tabbing through the entry will lose the password, must
          now access via mouse or hot key which is not ideal.
        * [050308] Added support for relative ftp browsing via new
          cGftp://???/~/???cA url form. Added file name completion support for ftp
        * [050306] Corrected the docmacrocG http://cA regular expression.
        * [050306] Changed the date format of the cD-VcA command line option to
          include the century, same format as the lslmabout(2)le buffer.
        * [050302] HTLP and PHP - fixed lslmindent(2)le problems.
        * [050302] Perl template - fixed indent problems caused by not
          skipping the cG=~cA type regular expressions.
        * [050302] TCL template - fixed continuation and comment indent bug.
        * [050302] Added support for R/S-plus (.r) files - thanks to Detlef.
        * [050225] HTML template - fixed an indent which was fixed at "cG2cA"
          rather than "cGtcA" and added comment skipping indent rules
        * [050225] lslmdos2unix(3f)le, lslmunix2dos(3f)le and lslmunix2win(3f)le - Removed use
          of cD&sprcA in favor of cD&catcA so cGdos2unixcA etc. work in lslmne(1)le. [050225]
          Tracing a problem with hilighting a token of the form "cGAB*$cA", works
          if there is a 'cGBcA' but fails if there are no 'cGBcA's, i.e. only matches
          "cGAB+$cA". Found that removing the end of line special case code fixes
          the problem. I believe the rest of the code has been improved to
          handle any end-of-line quirks - I hope so!
        * [050225] Removed the 'cGstart-upcA' macro function compile option so all
          versions support this - "cGnecA" can now do a "cG@dos2unixcA"
        * [050225] Regular expressions - extended replacement string syntax.
          Added support for "cG\c#cA" "cG\l#cA" and "cG\u#cA" to change the case of
          groups, where "cG\c#cA" is capitalise, "cG\l#cA" is lower "cG\u#cA" is upper and
          "cG#cA" is the group number (cG0-9cA, cG&cA)
        * [050225] Regular expressions - changed syntax of "cG\s?cA" and "cG\S?cA" in
          favor of Perl's simpler "cG\scA" and "cG\ScA" for a whitespace char class.
          Added new character classes "cG\dcA" = digits, "cG\DcA" != digits "cG\hcA" =
          hexdigits "cG\HcA" != hexdigits "cG\lcA" = lowercase "cG\LcA" != lowercase "cG\ucA"
          = uppercase and "cG\UcA" != uppercase. These changes were made to both
          the main regex search engine and the lslmhilight(2)le token matching
          engine. Added support for char classes within the main regex cG[...]cA
          character class, i.e. now supports regexs like "cG[\l\u_]cA" for any
          lower, upper or 'cG_cA' char. This is not supported in the hilight which
          currently has a more simplistic "cG[...]cA" char class support.
        * [050225] Regular expressions - changed use of "cG\s cA", "cG\s-cA", "cG\S cA"
          and "cG\S-cA" classes to simply "cG\scA" and "cG\ScA" which is perl regex
          compliant (ditching Emacs "cG\scA" syntax as it is cumbersome and not
          very useful). The only nasty side effect is hilight's miss-use of
          "cG\S1cA" - "cG\S9cA" to mean not "cG\1cA" - "cG\9cA" group char, changed to "cG\!1cA" -
          "cG\!9cA"
        * [050224] lslmne(1)le set to not auto-save or create backups by default.
        * [050224] Added "cG-acA" and "cG-BcA" command line options to enable and
          disable auto-save lslmauto(2m)le and lslmbackup(2m)le modes.
        * [050224] Tcl template - some more fixes to the item list from Detlef
        * [050224] lslmwatch(3)le improved the refresh rate of a type 2 or 3 watch
          by ignoring the cG:watch-timecA and just look at the cG:watch-sizecA. Fixed
          the split line issue with type 2 of 3 watching caused by last line
          not being complete.
        * [050224] cDM-xcA cDftpcA - stripped 'cGftp://cA' and any trailing 'cG/cA' of the
          users entered host name as these break ftp. Improved the dialog's
          handling of passwords, the user can now tell if a password has been
          set.
        * [050224] Added standard binding for mark-function
        * [050224] Fixed the ME token hilighting in the C hook
        * [050224] Removed recently added cG%no_backupcA variable to disable
          backup create as new cD-BcA option is a much better way of doing it.
        * [050224] cGedef.hcA - Removed definition of non-existant variable
        * [050224] Fixed failure when trying to load "cGhttp://www.jasspa.comcA",
          there is an implicit trailing 'cG/cA' which MicroEmacs now adds.
        * [050224] Tcl template - major improvement - courtesy of Detlef.
        * [050224] Fixed cDcollapsecAto support the file hooks .exact setting (set
          to -1 means case insensitive)
        * [050224] Added new cDbeginning-of-functioncA, cDend-of-functioncA,
          cDgoto-function-linecA and cDmark-function macroscA - thanks to Detlef.
        * [050223] Windows MS-dev 6 project - corrected project settings for
          cG_URLSUPPcA to cG_SOCKETcA in keeping with the socket dynamic library
          loading.
        * [050223] Added exec of wish to the tcl magic hook
        * [050223] Fixed lslm$window-chars(5)le - added OSD default button chars.
        * [050222] Fixed lslm$user-path(5)le being more that 35 chars breaking the
          lslmuser-setup(3)le dialog.
        * [050222] Directory listing - call cGfhook-htmlcA when file is acG http://cA
          file - this is never a directory listing.
        * [050222] Stopped loading of files in dir listing when clicking way
          to the right, must click on the name (MicroEmacs kept loading files
          when just trying to raise the window to the front - annoying).
        * [050222] If 0 given to lslmwatch(3)le call watch-time, this preserves the
          old interface.
        * [050222] Added backup file disabling for lslmdos2unix(3f)le macros via
          command line defineable variable.
        * [050221] Changed the new Windows process tree killing to use
          cGLoadLibrary()cA to detect whether the OS supports this feature (and NT
          does not). Also moved the URL support over to cGLoadLibrary()cA so we
          can remove the cD-ucA builds.
        * [050220] Added UNIX Shell and Makefile hilighting to lslmnotes(3)le).
        * [050219] Fixed GNU GCC warnings in Makefiles for #pragma in X11
          files under Sun Solaris and uninitialized variables.
        * [050219] lslmosd(2)le. Removed dialog 'cGFcA' flag as it was not documented,
          did not work and only used in one obscure place. Fixed cDC-gcA and cDDelcA
          so they close up to the previous dialog but does close the main menu
          down in one call - was annoying.
        * [050219] Release Candidate 1 - MicroEmacs 2005 (RC1)
        * [050218] Corrected UNIX lsClient-Server(2)lmclient-serverle socket file check -- bad test
          on existence of connection file, using wrong variable with wrong
          test sense.
        * [050218] Added site delete button to cDftp-connectcA dialog.
        * [050218] Fixed abbreviation and exec-string "cG\\pcA" and "cG\\PcA" store
          and goto position problem when the cGC-xcA cGC-acA or cGC-xcA a keys are
          rebound. Fixed by replacing with 'cDesccA cDxcA cDset-alpha-markcA cDPcA' (where
          cDesc-xcA is a safe internal special key).
        * [050218] Updated lslmwatch(3)le interface and made public. Created new
          lslmwatch-time(3)le command and prompt user for watch type when no
          argument is given.
        * [050218] Removed the use of bit cG0x1000cA in Ada string hilight as this
          is unlikely to be wanted (probably copied from Pascal).
        * [050218] Changed the registry parser to abort on error rather than
          trying to carry on (a very painful process for a badly decrypted
          registry file).
        * [050218] Fixed highlighting minor issues. lslmhilight(2)le scheme now
          returns back to EOL scheme after a bracket. A branch tag on an EOL
          line removes the EOL flag so it hilights correctly. Branch tag now
          supports the cG0x1000cA single line hilight. Lookback now supports cG0x800cA
          on a branch tag.
        * [050217] HTML highlighting. Fixed some really grizzly scripted html
          page highlighting issues, predominantly with php.
        * [050217] Change ftp so it opens the cDftp-connectcA dialog if the
          current buffer is cG*ftp-files*cA.
        * [050217] Fixed ftp dir list column detection and highlighting issue
          with windows ftp servers (time given as cG9:15cA not cG09:15cA)
        * [050217] Fixed bug in lslmset-variable(2)le and lslmunset-variable(2)le when
          lslm&sprintf(4)le is used to create a variable name.
        * [050217] Watch command (watch.emf). Improved the watch command, made
          'cG0cA cGwatchcA' call cDwatch-resetcA, changed cDwatch-resetcA so with an argument
          of cG0cA it removes all watches otherwise it resets the main watch
          counter and reports to the user which buffers are watched. Added new
          'cG2cA cGwatchcA' and 'cG3 watchcA' which compares the file size, doing the
          following: cDa)cA file on disk is smaller than last watch - reloads
          whole file. cDb)cA file size is the same - does nothing. cDc)cA file on disk
          is larger - appends to the end of the buffer the tail of the file
          (cGfile_sizecA cG-cA cGwatch_file_sizecA bytes). This assumes that the files is
          always being appended (reasonable assumption in most cases. The only
          difference between 2 and 3 is that 2 forces a complete reread of the
          file on the first file change (ensuring the buffer is correct), 3
          does not which allows the user to trash the first gigabyte of the
          buffer before starting the watch.
        * [050217] Shell template - added local and function keywords and
          fixed a few string highlighting problems.
        * [050216] Made the dir-listing's (Filtered) label on line 2
          pick-able, changing the filter status when picked Made CVS's
          CVS-Quick label pick-able doing a full reread when picked.
        * [050216] Fixed a couple of silly register bugs introduced with last
          lslmfind-registry(2)le concat root and sub-key change. Improved behavior
          when ftp erf file is missing, now create a new one in memory and
          flags as changed so should be saved on exit.
        * [050216] Do not abort cGme.emfcA execution if ftp erf file is missing or
          bad.
        * [050216] Fixed by removing the 'cGstartupcA' function, the main init now
          uses dofile directly and it checks for either a NULL or cG""cA as a
          filname and replaces with "cDmecA" or ("cDnecA" and does not complain) if
          found to be empty. This means that give lslmexecute-file(2)le an empty
          string executes either "cDmecA" or "cDnecA", i.e. resets me - nice side
          effect. Changed 'cGdofile()cA' to cGexecFile()cA and changed cGexecFile()cA to
          cGexecuteFile()cA (as is function for command cDexecute-file(2)cA) and
          change the other exec command function names for consistency.
        * [050216] Fixed an annoyance reported by Bruno, ne should not
          complain if it fails to find cGne.emfcA - fair enough.
        * [050215] Fixed crash caused by using cG-ccA option with all files hidden
          (comment when browsing ftp dirs as cache dir lists are hidden) The
          startup process knows the history created buffers but the
          replacement was none of these and due to the toolbar it was a buffer
          without a file name and bang! Fixed in 2 ways, first check the
          replacement has a file name, second do not put hidden files into the
          history - they're hidden.
        * [050210] Improved movement between items using the cursor in the
          search dialog.
        * [050210] Fixed cvs dialog default settings.
        * [050210] Corrected search path expansion, incorrectly handling a
          cGPATH_CHARcA at the start of the string.
        * [050209] Up-dated lslmuser-setup(3)le platform page to new style and added
          lslmyank-rectangle(2)le binding.
        * [050209] Fixed no-color termcap lslm$window-chars(5)le variable setting
        * [050209] Fixed hot keys (were 3 'U's) in cGosdmisc.emfcA.
        * [050209] Added new cCBraceStatementcA lslmindent(2)le value to support GNU C
          indentation style.
        * [050209] Fixed the cGosdDisp()cA function required a cGTTflush()cA otherwise
          the cursor is left in the wrong position on termcap systems.
        * [050209] Fixed the default lslm$window-chars(5)le variable setting.
        * [050209] Fixed the DOS home directory setting and compiler warnings.
        * [050208] Changed the C indent definition to be the same format as
          the existing indent definitions i.e. uses flag & indent value, this
          makes it more flexible and extendible. Updated macro files.
        * [050205] Password generation macros added to cGcontribcA directory.
        * [050205] Added JavaDoc highlighting to Java template. Enablement via
          lslmbuffer-setup(3)le. Removed the existing "cGmycA" extensions from contrib.
        * [050205] Added cDDoxygen(1)cA, cC<stdint.h>cA and error highlighting to
          C/C++ templates. Enablement via lslmbuffer-setup(3)le. Removed the
          existing "cGmycA" extensions from cGcontribcA.
        * [050204] osd - Fixed problems with the cCcursor shows current itemcA
          feature of osd caused by the cursor position going outside of the
          window.
        * [050202] Added an initial item number to the favorite and buffer
          menus.
        * [050203] Standardized narrow anchor and line flag movement behaviors
          with respect to deleting and inserting text. Enforced to effectively
          exist at character column -1 and been strict about maintaining a
          protected line. Made undo cope with markup lines that are lost.
          These changes may be a little to severe - we'll see.
        * [050202] Fixed cDC-gcA close osd dialog crash.
        * [050202] Directory listing - fixed nasty bug cause by the directory
          changing on disk before the hook has managed to do anything leading
          to a failure - this has been annoying Jon for some time!
        * [050127] cGhkemf.emfcA - Fixed cG!untilcA indent rule.
        * [050127] First revision of cDnotescA.
        * [050127] Fixed positional problems with mouse rectangle regions and
          added a mouse rectangle yank to user-setup.
        * [050127] cvs - Set the initial osd dialog item to be the first item
          rather than the Okay button (with is still the default button).
        * [050127] Fixed cG*scratch*cA hook assignment issues, initial startup
          buffer and only buffer delete problem.
        * [050127] Added process tree killing for windows, tested on win98, 2k
          & XP, would be good to test on win95 (which should work) and NT
          which should not work but hopefully will be no worse than current
          version.
        * This is a process tree killing for ipipes, in win32 killing the
          process we create is simply not good enough, all child processes
          continue unaffected. For example, run compile, kill the buffer in
          mid compile and it carries on behind your back!
        * For Unix we use a new group and kill the group, DOS does not support
          ipipe. We could have used the new Job concept in ME but this is only
          present in win2000 & XP and the binaries are unlikely to run on
          win98 etc. This should run on every win32 platform although it is
          unlikely to do anything positive on an NT box (works in win2k)
        * [050126] Changed the location of the cDfhook-defaultcA macro so its only
          defined if using cDbuffinitcA (i.e. if running main cGme.emfcA)
        * [050126] Fixed osd button repeat issue when current focus is an
          entry.
        * [050126] Changed cDinsert-file-namecA to insert buffer name if a -ve arg
          is given, bound to cDC-x ycA on the mode line, this replaces ml-lines
          cDesccA cDycA feature.
        * [050123] Fixed a crash caused by too many closed fences, the
          recursive nature of the cGfindfence()cA function triggers a stack crash
          at around 22000 on windows. Set limit to 256 nested fences.
        * [050122] Fixed lslmdir(2m)le mode loss on a directory re-read, this caused
          a number of side effects including loss of highlighting and user
          prompt to reload the directory when it had changed.
        * [050119] Removed the "cCsub-keycA" argument from all registry related
          calls (see lslm&reg(4)le and lslmset-registry(2)le). The registry calls used to
          comprise two arguments "cCrootcA" and "cCsub-keycA", the "cCsub-keycA" is really
          redundant and the same effect may be achieved by a simple string
          concatenation of the "cCsub-keycA" to the "cCrootcA".
        * [050119] Added "cGmy-*hook-alwayscA" macro checks in the buffer hook
          switching of lslmbuffer-init(3)le to permit global file hooks to be
          defined, this allows a file hook to operate on all buffers.
          "cGmy-*hook-alwayscA" is executed after the language file hooks of
          "cG*hook-XXXcA" and "cGmy-*hook-XXXcA".
        * [050116] Added "cGTODOcA" highlighting rule for Makefile comments.
        * [050114] Fixed lslmnarrow-buffer(2)le type numeric argument not processed
          correctly.
        * [050113] Added tool bar tool mouse select region command.
        * [050113] Added bindings for the cvs and ftp console tools.
        * [050113] Fixed lslmorganizer(3)le duplicate index bug.
        * [050111] Deleted the cDget-registry(2)cA command, this has been
          depreciated and lslm&reg(4)le should be used instead.
        * [050111] Extended the lslmread-registry(2)le and lslmsave-registry(2)le commands
          to permit reading and writing from a buffer based registry (rather
          than file).
        * [050111] Extended lslmlist-registry(2)le to permit listing of specific
          nodes, the output buffer of the registry listing may be specified.
          Added a invisible flag to a registry node which hides the node
          completely (but can be toggled).
        * [050111] Fixed windows server command file polling of up to 60 times
          a second by making the adder of the command responsible for 'waking'
          MicroEmacs by sending a cGWM_USERcA message. This is not a problem for
          UNIX as it is possible to wait on file input and cGEOFcA is not
          reported.
        * [050105] Fixed several narrow-to lslmnarrow-buffer(2)le usability issues,
          with these fixes the top and bottom narrow cannot be removed without
          a markup line and the order cannot get muddled.
        * [050105] Fixed a problem with the anchor position up-date when
          inserting a whole line.
        * [050105] Changed the osd entry mouse handling to always refocus,
          this allows the user to change location in the current entry using
          the mouse.
        * [050105] Fixed. lslminsert-macro(2)le undo location was incorrect causing
          a crash.
        * [050103] Spelling dialog. Changed the Ignore button to Continue if
          word becomes correct without changing (word added or language
          changed).
        * [050103] Fixed. CVS osd dialog with bad hot-key.
        * [050102] Added setting of lslm$recent-keys(5)le variable.
        * [041231] Variable cD$fmatchdelay(5)cA renamed to lslm$pause-time(5)le.
          cC$pause-timecA is now used for other MicroEmacs delay times when the
          user is prompted for information.
        * [041224] Fixed several usability issues in the search replace
          dialog.
        * [041224] Up-graded printer-setup dialog to new style OSD.
        * [041224] CVS dialog - added read-only option to checkout and update.
        * [041224] Fixed lslmgoto-line(2)le offset which as always going to the
          previous line (one out). cDucA [041221] Added support for proper kill
          buffer use in message line, i.e. lslmset-mark(2)le, lslmkill-region(2)le,
          lslmcopy-region(2)le, lslmyank(2)le and lslmreyank(2)le all work in the same way as a
          normal buffer.
        * [041221] Fixed registry node deletion when the node is modified.
        * [041221] Removed lslmosd(2)le cGosd 0cA 'cCdcA' flag and added 'cCIcA' initial item
          and 'cCDcA' default button flags, existing osd dialogs which use 'cCdcA'
          will fail to load and need are migrated to use the cCDcA and cCIcA flags.
        * [041218] lslmauto-spell(3)le key bindings are promoted to global so its
          easy to enable in any buffer.
        * [041218] Corrected setting of the lslm$home(5)le environment variable to
          handle MS-Windows 'cG\\cA's, auto terminate with 'cG/cA'.
        * [041210] Added Enable/Disable Auto-Spell to the context menu.
        * [041210] Rearranged the lslmorganizer(3)le dialog to be a little easier to
          navigate through.
        * [041210] Fixed nedit emulation insert binding.
        * [041210] Removed cDml-clear(2)cA command, replaced with lslmml-write(2)le
          option "cG0 ml-writecA".
        * [041210] Removed the cDchange-directory(2)cA command, a change in
          directory is achieved by changing the lslm$buffer-fname(5)le value such
          that the path defines the location of the command. All macros
          operated relative to the buffer location and never explicitly
          changed the directory location.
        * [041210] Fixed CUA emulation insert binding.
        * [041210] Deleted cDletter(2m)cA mode. Use the default binding of
          lslmforward-delete-char(2)le for letter mode off, where single deleted
          characters are to be added to the kill buffer then the existing
          cDletter(2m)cA mode may be achieved by binding as "cG1
          forward-delete-charcA". Similarly for backspace,
          lslmbackward-delete-char(2)le.
        * [041210] Deleted cDline(2m)cA mode. Use a binding with lslmkill-line(2)le of
          "cG1 kill-linecA" to mimic the line mode enabled and "cGkill-linecA" for
          line mode disabled.
        * [041210] Deleted cDcmode(2m)cA. Electric-c is now configured with
          lslmindent(2)le. C and C++ indent styles can be different, can also have a
          GNU C style etc, can change the indent width as new indent rule
          supports 'cCtcA', consistent lslm$buffer-indent(5)le interface.
        * [041210] Created new osd file "cGosdmisc.emfcA" for miscellaneous OSD
          macros, this removes the OSD dependency when the MicroEmacs is
          executed in special start up modes with startup files. Moved search
          and new cDindent-setup(3)cA commands out of "cGsearch.emfcA" and
          "cGformat.emfcA" into a new "cGosdmisc.emfcA" as they cause problems with
          utils that do not run "cGme.emfcA" (e.g. "cGehftools.emfcA")
        * [041210] Introduced a GNU emacs emulation mode, emulation file is
          "cGmeemacs.emfcA".
        * [041209] Fixed cDnewusercA "cG$user-name.emfcA" conflict issue with an
          existing macro (e.g. cGzaurus.emfcA) by testing for it and prefixing a
          digit to make the file unique.
        * [041209] Added cGesc C-\cA binding to lslmrestyle-buffer(3)le.
        * [041209] Fixed some issues with the Tools user-setup dialog.
        * [041128] Added MinGW makefile posted to JASSPA group by Patrick
          Anderson, forms part of the release makefiles.
        * [041126] Added 'cGkcA' keyboard setup to lslmset-char-mask(2)le which is used
          to translates foreign keys to a latin char.
        * [041126] Changed the internal LEADER byte to cG0x1ccA as cG0xffcA is a valid
          Russian char and it badly breaks cC$varscA and cCmacroscA.
        * [041126] Fixed spell dump word which was not translating the words
          to the users char-set.
        * [041126] Added support for Russian language.
        * [041126] Improved the aff ispell conversion routines (almost works
          automatically).
        * [041126] Stopped lslmauto-spell(3)le from triggering the no dictionaries
          error, leave it to lslmspell-buffer(3)le etc.
        * [041125] Fixed OSD multi-line cGC-kcA cDkill-linecA behavior and implemented
          "cG-1cA cGkill-linecA" support.
        * [041125] Added basic support for Verilog programming language.
        * [041123] Fixed ftp OSD (auto entering entries broke the password
          field) and modernized.
        * [041028] Fixed. cG*find*cA buffer exhibits the same behavior as cG*grep*cA
          buffer. i.e. the cG*find*cA buffer remains on screen and a pop-up window
          is used to show the file.
        * [041028] Fixed. cG*grep*cA buffer does not load file when selected with
          cG<RETURN>cA.
        * [041027] Spruced up old "cGapache.confcA" highlighting rules and added
          to release.
        * [041022] Fixed very obscure cvs load-up bug.
        * [041122] Updated schemes to set 'cCShow cursor in osdcA' suitably and to
          make sure the cursor is not red as this conflicts with the match
          fence display.
        * [041120] Fixed lslmtranspose-lines(2)le crash when lslmundo(2m)le mode is
          disabled.
        * [041120] Removed the OSD explicit tab order value as this was not
          constructively used and causes many item order problems.
        * [041119] Many improvements to OSD dialog user interface following
          suggestions for news group. Updated most of the osd dialogs to use
          the new cG[*]cA check-box chars. Fixed tabbing orders and moved some
          items over to combo-boxes. Added osd-cursor visibility support to
          scheme-edit. Made the displaying of the cursor in an osd dialog a
          lslm$system(5)le bit set by the highlight scheme and fixed the position
          when in a child dialog.
        * [041118] Added a macro recursion depth limit of 20 to avoid blowing
          up MicroEmacs when the user has created an infinitely recursive
          macro.
        * [041112] Added Paul Boekholt's suggested GNU Emacs key bindings.
        * [041107] lslmkill-paragraph(2)le, lslmfill-paragraph(2)le, lslmforward-paragraph(2)le
          and lslmbackward-paragraph(2)le commands redefined. cDkill-paragraphcA now
          kills forward and backward rather than control the kill buffer.
          Paragraph movement now defined blank-line to blank-line rather than
          the first/last paragraph line.
        * [041105] Fixed lslmkill-line(2)le, lslmforward-kill-word(2)le and
          lslmbackward-kill-word(2)le numerical argument implementation.
        * [041104] Removed cDregex-forward(3)cA and cDregex-backward(3)cA macros and
          moved uses of them over to lslmsearch-buffer(2)le.
        * [041104] Added lslmsearch-buffer(2)le command which replaces the macro
          commands cDregex-forward(3)cA and cDregex-backward(3)cA. Simplifies macro
          processing of searching by providing a search that explicitly sets
          the lslmexact(2m)le and lslmmagic(2m)le modes. The default is to respect buffers
          exact and magic mode and flags must have cGEcA or cGMcA to ensure they are
          disabled.
        * [041104] Changed any use of lslmkill-line(2)le to "cG1cA cGkill-linecA" as this
          should maintain its required behavior. A cDkill-linecA with no numeric
          argument kills to the end of the line but excludes the end of line
          character (GNU Emacs compatibility). The default binding is the "cG1cA
          cGkill-linecA" form, re-bind the key to "cGkill-linecA" if the end of line
          is not to be killed.
        * [041104] Removed cDline(2m)cA and cDletter(2m)cA buffer modes as these can
          be done using numerical arguments to bindings. See the the
          lslmkill-line(2)le binding which replaces cClinecA mode. See
          lslmforward-delete-char(2)le and lslmbackward-delete-char(2)le binding which
          replaces cClettercA mode.
        * [041104] Changed the lslmforward-kill-word(2)le and lslmbackward-kill-word(2)le
          commands to be more consistent with GNU Emacs.
        * [041102] Moved winterm over to using cGaddKeyToBufferOnce()cA for mouse
          move and time, also done same for UNIX mouse time event. This
          minimizes the number of mouse moved events that are processed by the
          system.
        * [041101] MS Windows. Fixed mouse cursor disappearing after using a
          cCShiftcA or cCControlcA mouse button event.
        * [041101] Auto reload the directory even if it is changed
          (cGhkdirlst.emfcA).
        * [041030] MS-Windows. Removed the "cGWM_INPUTLANGCHANGEcA" message
          handler as this did the wrong thing (use cGAlt-ShiftcA to change between
          two different keyboards e.g. US and Russian)
        * [041030] MS-Windows. Changed the method used to get the APPDATA path
          to use cGSHGetSpecialFolderLocation()cA as this is available in all
          versions of Windows.
        * [041030] UNIX. Fixed the mouse movement which caused a rendering
          anomaly. Mouse moved commands are only added to the key buffer if
          the key is not already present in the key queue. This alleviates a
          large build up of redundant mouse move keys on the queue. (Added
          function cGaddKeyToBufferOnce()cA),
        * [041030] Added mouse rectangle region selection methods,
          lslmcopy-rectangle(3)le and lslmkill-rectangle(2)le.
        * [041029] Hardened lslmcpp(9)le C++ commenting on cG//cA alignment when the
          previous line is a solid cG//////////cA when re-styling buffer.
        * [041029] Fixed lslmfind(3)le "cG*find*cA" buffer operation so that it operates
          like "cG*grep*cA" on file selection. Keyboard file section enabled
          within the "cG*grep*cA" and "cG*find*cA" buffer.
        * [041026] Spruced up old "cGsmb.confcA" highlighting rules, brought them
          up to date with latest keywords and added to release.
        * [041026] Fixed cDindent-setup(3)cA osd dialog.
        * [041024] Macro/source compatibility macro and source versions
          updated to "cG20041001cA".
        * [041024] Fixed the lslmcvs-diff(3)le options, local with HEAD was not
          correct.
        * [041024] lslmlatex(9)le template extended. Buffer bindings for underscore
          and quote keys. Search tools to determine current context.
        * [041023] Extended the buffer setup for the lslmindent(2)le mechanism. May
          now specify the default buffer cCindent-widthcAand cCtabsizecA in the
          lslmbuffer-setup(3)le dialog.
        * [041022] Revised indentation implementation. The templates now
          define indent width independent rules. The lslmindent(2)le command
          'cCindentcA' parameter may be defined as an absolute indentation or
          using a 'cGtcA' notation. The syntax is "cG[-][[indent][/indent]]tcA" which
          defines a vulgar fraction of 'cGtcA' which is the indent width (or
          tabsize) as specified by lslm$buffer-indent-width(5)le defined below.
        * The global variables cD$tabsize(5)cA renamed lslm$indent-width(5)le and
          controls the global indentation size. cD$tabwidth(5)cA renamed
          lslm$tab-width(5)le and controls the display size of a literal TAB
          character.
        * The indentation is now specified on a buffer basis, the variables
          lslm$buffer-indent-width(5)le and lslm$buffer-tab-width(5)le define the
          indentation and TAB width on a per buffer basis. These are seeded
          from the aforementioned global variables.
        * [041022] Fixed spelling mistake in user interface of XML macros.
        * [041022] Removed CVS "cGLog:cA" field from all of the template files -
          undesirable.
        * [041022] Added HTTP highlighting to the text document template.
        * [041021] Enhanced Wiki language template.
        * [041021] Added Windows CUA emulation mode.
        * [041019] Fixed insert binding for Nedit emulation mode
        * [041019] Fixed lslmperl(9)le highlighting rules. Using incorrect syntax.
        * [041016] Fixed UNIX make files for building NE in debug mode.
        * [041016] Fixed termcap entry for cD^@cA key (cGC-spacecA). (Thanks to Bob
          Paddock for noting ommission)
        * [041016] Added cDM-%cA binding to lslmquery-replace-string(2)le as built in
          binding. (Thanks to Bob Paddock)
        * [041016] Added Ruby programming language support.
        * [041015] Corrected problem with directory listing loosing
          highlighting (a lslm@mna(4)le problem).
        * [041014] Within OSD, fixed spelling mistake. cCLoosecA -> cCLosecA.
        * [041014] Fixed lslmdelete-hilight-lines(3)le failure when buffer file has
          changed.
        * [041009] Fixed osd entry scheme as the cursor was not visible in MS
          Dev-Studio Colors.
        * [041009] Added Wiki language template
        * [041003] Wheel mouse binding added as default.
        * [041003] Catch long lines from cut and paste, resolve crash.
        * [041002] Added X-Windows drag and drop support using cDxdndcA.
        * [040930] Added HTML, XML and SGML close bracket auto expansion.
        * [040930] Added XML and HTML verification macro. Added XML utilities
          macros to allow next and previous tag to be matched. The XML
          utilities are also used by SGML.
        * [040930] Added cGxxxx-pre-expand-abbrevcA hook so that macros may add
          their own expansion methods.
        * [040917] Added cG<...>cA as supported fences.
        * [040917] Fixed the cG-1cA lslmadd-next-line(2)le ignore line feature.
        * [040915] lslmcvs-add(3)le looks for a Tags file in the CVS directory and
          sets the GUI state appropriately. Added server to the lslmcvs-state(3)le
          line mangling.
        * [040909] lslmcvs(3)le GUI updated with new features. Added repository set
          up to the UI. Reduced wait time on long commands by using ipipe.
          Allowed cG-zcA option to be used with lslm%cvs-com(5)le.
        * [040828] lsabout(2)lmAboutle page includes the century in the date (suggested by
          -Th).
        * [040824] Fix for man page hyper-link when includes cG-/./_cA characters.
        * [040814] Linux manual page formatting fixes.

    cDMinor Patch - July 2004cA

        * [040728] Released patches.
        * [040728] Corrected Linux kernel 2.6 pty allocation.
        * [040630] Linux manual page formatting fixes.
        * [040518] Comment definition corrections for C, C++ and java, notable
          Doxygen comment formation omitted.
        * [040518] Corrected block comment formatting, adding an extra space
          at the end of the comment.

    cD7th Release - March 2004cA

        * [040326] Release wrapped - public release tag is cD20040301cA for
          executable and macros.
        * [040326] Support for MAC O/S Darwin image. Console only (no build
          machine available for X-11 version).
        * [040326] Introduction of UPX on Windows and DOS executables for cDnecA
          only.
        * [040326] Support for MS-DOS long name under DJGPP v2.0. For version
          2.0 then the DJGPP functions must be invoked rather than the MS-DOS
          BIOS calls otherwise the modified short name is returned. DJGPP v1
          is still supported original definitions maintained.
        * [040326] Added lslmfiletype(3f)le macro to determine the file type of
          MS-DOS, Windows or UNIX.
        * [040322] cC$mousecA variables configured under console modes to allow
          pseudo mouse operations to be performed.
        * [040322] Fixed the cDwin32scA build and emain.h definitions. Mouse was
          not supported under cCwin32scA through incorrect configuration
          definition.
        * [040322] Key bindings for the file browser. cGENTERcA now handled on the
          reserved fields to sort. cGBACKSPACEcA now moves up a directory level.
        * [040322] Changed the interface to cDcvscA, cDftpcA and cDfile-browsercA command
          so that if a numeric argument of cG0cA is given then the directory tree
          window is not opened, just the cG*files*cA buffer.
        * [040322] AutoIt hook. Thanks to Dr Detlef Groth.
        * [040322] Added CSS template. Thanks to Gabriel Tabares-Barreiro.
        * [040318] Fix to Microsoft Windows clipboard when operating with VNC.
        * [040317] Macro and source release set to "cG20040301cA".
        * [040317] Added lslmfind(3)le command to macro set.
        * [040317] Corrected lslmrgrep(3)le to use the lslm%xfind-com(5)le to specify the
          cDfind(1)cA command.
        * [040310] Fix to graphical diff - lslmgdiff(3)le. Occasions where all
          changes had been accepted and the changes could not be saved. gdiff
          incorrectly prompted user to accept all changes first.
        * [040310] Support for multiple comment styles in the same language
          template. Additional comment styles are defined in the "cGhkXXX.emfcA"
          file with the syntax "cG.fhook-XXX.comment-NcA" where "cGNcA" is an integer
          starting for cC1cA to cCncA, the number of different comment styles.
          Templates updated to use multiple comment styles where appropriate
          (C, C++ and SQL).
        * [040310] Support the 'cCrcA' flag in "cG.fhook-XXX.commentcA" flag field.
          Causes the key binding to "cGesc-ocA" and "cGesc-qcA" to restyle the
          comment. All templates updated to include the flag where
          appropriate.
        * [040310] lslmcvs(3)le operates asynchronously using ipipes. Refresh
          problems resolved.
        * [040310] lslmnarrow-search-forward(3)le bound to "cGC-c scA",
          lslmnarrow-search-backward(3)le bound to "cGC-c rcA".
        * [040308] lslmipipe-shell-command(2)le includes additional flag to run in
          "cCraw modecA" where the buffer is not annotated and wrap is disabled.
          Additional argument added to command to allow the lslm$buffer-ipipe(5)le
          macro to be defined when the pipe is defined. Corrected operation of
          lslmpipe-shell-command(2)le where cCipipecA automatically degrades to a cCpipecA
          (Windows only), if degraded then the lslm$buffer-ipipe(5)le macro is still
          invoked on completion.
        * [040226] Deleted "cGcygnus.emfcA" added "cGcygwin.emfcA" for lslmcygwin(3)le BASH
          shell support under Windows. Corrected the shell operation with
          macro layer for echo and completion.
        * [040224] Add new cCnarrow out unhilighted linescA feature.
        * [040223] Add new buffer tab list toolbar tool for rapid access to
          buffers via a top or bottom toolbar.
        * [040223] Add cG<>cA buttons to tool-bar mode lines to scroll left and
          right.
        * [040223] Fixed. Calender day is off by one when going backwards to
          before 2004.
        * [040223] Fixed. Executing 'me' (cDuser-setupcA cD->cA cDCurrentcA) breaks
          lslmauto-spell(3)le until a main spell command , lslmspell-word(3)le or
          lslmspell-buffer(3)le is executed.
        * [040223] lslmcvs(3)le directory listing file loss solved. Differences
          between CVS command line operations and directory list operations
          resolved, both now produce the same results.
        * [040229] Fixed UNIX signal lock synchronization, solves problems
          with read failing following FTP or HTTP command.
        * [040223] Add new lslmnarrow-search-forward(3)le and
          lslmnarrow-search-backward(3)le commands.
        * [040220] Mouse wheel operation fixed. Added new cDmouse-wup-scrollcA
          commands that should be used instead.
        * [040218] Added 'cCInvert SelectioncA' to context menu.
        * [040218] Add 'cGf5cA' refresh binding to a dir list buffer.
        * [040218] Fixed. Need some way of opening the right mouse button menu
          using a key. Also need so termcap bindings to open main and context
          menus. Created new context-menu command, bound to cGS-f1cA and the
          windows 'menu' key (aka windows) and created binds to open main menu
          (cDesc =cA) and context menu (cDesc +cA) on termcap platforms.
        * [040217] Fixed. cD2cA lslmpopup-window(2)le does not work on an XTerm, no
          implementation in function cGmeFrameXTermMakeCurcA.
        * [040217] Fixed. CVS status of directories is not shown. Also add 'cGbcA'
          and 'cGocA' file type flags.
        * [040216] Fixed. ME cDbuild.bat -lcA options do not work in standard
          cmd/command as there use 4DOS 'cG>>&cA' extension. Changed to using cG2>&1cA
          which works on cmd & 4nt but breaks 4Dos and command.
        * [040216] Fixed bottom Toolbar window grows when CVS is opened,
          lslmchange-window-depth(2)le does not respect bit 2 of lslm$window-flags(5)le.
        * [040214] Added cD.speccA template for RedHat RPM package file
          specification.
        * [040214] Added cD.psfcA template for HP-UX depot product file
          specification.
        * [040214] Recognize cG-*- makefile -*-cA and cG-*- sh -*-cA.
        * [040213] Fixed reframe cCcvs-consolecA better so the exit status can be
          easily seen from a small window.
        * [040213] PHP script can be started with 'cG<?cA' tag in a php file.
        * [040213] Corrected UNIX ishell operation when "cDsucA" to another user.
          Locking up or generally behaving badly (termio not initialized).
          Affects all UNIX platforms.
        * [040213] Documented the create/delete/next-frame keys.
        * [040210] Fixed toolbar Directory File List does not contain "cG../cA" -
          UNIX only.
        * [040210] Fixed. On UNIX only the lslm$progname(5)le may not be fully
          expanded (has just "me") which may lead to a ctags generation error
          and an alternate fix to lslm$search-path(5)le.
        * [040210] Fixed. On UNIX, lslmfind-file(2)le of a symbolic link which
          points to a directory results in a bad dir listing. The list of
          files is correct but the statistics are all wrong (found on SunOS
          5.8).
        * [040210] Fix subtle ftp bug with alias ftp addressed. Create an ftp
          site "cGftp://test/cA" say with user name foo and password bar and then
          load in "cGftp://test/dir1/cA" the buffer file name is correctly set as
          "cGftp://test/dir1/cA" but the 'Directory listing of:' line is set to
          "cGftp://foo@test/dir1/cA". Firstly the user may wish the 'cCfoocA' to be
          hidden but secondly with the introduction of being able to click on
          the 'cCDirectorycA cClisting of:cA' line this has introduced a subtle
          inefficiency/bug, if I click on the 'cGfoo@testcA' ME will load
          "cGftp://foo@test/cA" not "cGftp://test/cA" which to ME is a completely
          different file. This can in turn lead to "cGftp://foo@test/dir1/cA"
          being loaded so you can end up with 2 copies of every dir being
          loaded! The fix is to make the 'cCDirectory listing of:cA' line the
          same, i.e. "cGftp://test/dir1/cA"
        * [040208] Fixed. "cD-ncA" command line option to a console build causes a
          option failure and the executable does not run.
        * [040208] Corrected UNIX jasspa tree search when executable is in CWD
          and there is no executable path.
        * [040206] cDRC4 - Release Candidate 4 - MicroEmacs '04cA
        * [040206] Fixes for tool-bar Buffer Item List update problem. Thanks
          to Dr. Detlef Groth.
        * [040206] Added template support for XML. Thanks to Dr. Detlef Groth.
        * [040204] Re-worked Microsoft Windows lslmme32.ini(8)le file specification.
          Order revised and lookup simplified.
        * [040203] "cCuser-setupcA" changed name to "cCRebind Home KeyscA" for
          re-binding of cGhomecA and cGendcA keys to start/end of line. Removed "cGC-vcA"
          binding that existed with old "cCMS keys" labelcA.
        * [040203] Reworked all user defined defined directory save locations,
          ftp, spell, etc..
        * [040203] Corrected osf1, openBSD and zaraus emf files.
        * [040203] Added lslm%cvs-com(5)le variable to define the CVS command.
        * [040203] XML template extended to include javascript.
        * [040130] 2nd iteration of prototype and near final revision of new
          user setup.
        * Following an internal review of RC3 then it has been decided to
          address the issues of user configuration prior to a full release.
          This specifically addresses the location of user MicroEmacs
          configuration directories and search paths. User configuration has
          traditionally required the setting of external environment variables
          such as "$MEPATH" and for the user to create a private directory to
          store user settings. This is proving difficult for new users who
          just want to run the editor. RC4 and subsequent releases will
          address these problems by determining the correct location for
          configuration files and create the appropriate files and directories
          under user control.
        * The net result of these changes should significantly simplify
          installation and setup as follows:
        * All platforms will be able to run without any manual user setup or
          the requirement for specific MicroEmacs environment variables.
        * User defined directories and configuration files will be created
          under editor control on detecting a new user.
        * Existing installations using cG$MEPATHcA will be backwards compatible
          with the new build.
        * All platforms now support a searching jasspa sub-directory structure
          of cDcompanycA / cDspellingcA / cDmacroscA. This was traditionally limited to
          the Windows Install Shield installation but has been extended across
          all platforms.
        * Two new environment variables are provided for user or system
          administrator use. lslm$MEINSTALLPATH(5)le defines the location of the
          MicroEmacs standard macros and allows the built in search path to be
          overridden. lslm$MEUSERPATH(5)le defines the location of the user private
          configuration directory and allows the user to locate their private
          directory in different location. In a standard install neither of
          these variables will be required.
        * The Microsoft Windows system defined application path will be used
          for user configuration files. This is applicable for roaming users
          where the application directory is stored on a server.
        * The use of the lslmme32.ini(8)le file on MicroSoft Windows environments is
          not required, but is still supported.
        * The UNIX path searching is improved. cG/usr/local/microemacscA will be
          depreciated and replaced with cG/usr/local/jasspacA in addition other
          standard path locations are supported on a per-platform basis.
        * On UNIX then the directory cG~/.jasspacA shall contain the user
          configuration files. Optionally the cDcompanycA, cDspellingcA and cDmacroscA
          sub-directories may be included in this directory where access to
          the system directory locations by the user is not permitted.
        * Concept of guest has been removed. cGguest.emfcA and cGguest.erfcA removed
          replaced with cCnewusercA. lslmuser-setup(3)le no longer supports setting of
          name.
        * Internal variables lslm$user-name(5)le and lslm$user-path(5)le are defined.
        * [040128] Fixed re-style for C/C++ comments in vertical alignment.
        * [040123] "cCuser-setupcA" mouse button selection fixed.
        * [040123] cGC-x 3cA mapped to lslmsplit-window-horizontally(2)le, cGC-x 5cA mapped
          to lslmcreate-frame(2)le.
        * [040122] Added support for Zaurus, thanks to Pierre Gaston
        * [040122] Fixes for non-US keyboards under X-Windows, thanks to
          Pierre Gaston and Dr. Detlef Groth
        * [040122] Added support for OSF1, thanks to Dr. Detlef Groth
        * [040122] Added support for OpenBSD
        * [040122] lslmml-bind-key(2)le supports new binding for next/previous file,
          history search uses cGupcA/cGdowncA cGC-pcA/cGC-ncA, prompted by Gabriel.
        * [040122] New key bindings for lslmcreate-frame(2)le.
        * [040119] cDRC3 - Release Candidate 3 - MicroEmacs '04cA
        * [040119] Fast exit out of fold fixed.
        * [040119] Added lslmcopy-rectangle(3)le and lslmyank-rectangle-overwrite(3)le
          commands.
        * [040119] Collapse line format now includes the end token so that
          indent operates correctly following a fold.
        * [040119] lslmnarrow-buffer(2)le numeric argument and command line options
          extended for mark-up lines.
        * [040119] cGspawn.ccA compilation warnings removed.
        * [040119] Updated templates for Python and AsmX86 - thanks to Pedro
          Gomes.
        * [040119] Added "cG*compile*cA" hilighting and cGENTERcA selects error file
          and line - prompted by Salman Khilji.
        * [040119] Fixed the cDc-eval-definescA region hilighting problem.
        * [040119] Updated the Lau HTML processing tags - thanks to Jeremy
          Cowgar.
        * [040116] Latex "item-list" and "template" updated - thanks to Dr.
          Detlef Groth for diagnosing problems
        * [040116] Perl and TCL abbreviation files - thanks to Dr. Detlef
          Groth
        * [040115] lslmopen-line(3)le added for correct binding of "cGC-ocA".
        * [040113] lslmrestyle-buffer(3)le fix when mode defined - thanks to Pedro
          Gomes.
        * [040113] lslmcreate-frame(2)le canvas size fix on creating internal frame
        * [040112] Highlighting fix for tool-bar Dir Files list with symbolic
          links
        * [040109] cDRC2 - Release Candidate 2 - MicroEmacs '04cA
        * [040109] PHP template added.
        * [040108] cDRC1 - Release candidate 1 - MicroEmacs '04cA
        * [040108] Shrink line crash on SunOS and IRIX fixed
        * [040108] Fixed rendering anomalies of menus and pop-ups on Windows
          XP ClearType when anti-aliasing is enabled.
        * [040106] Fixed comment re-styling for single start of line comments
          (REM in MS-DOS)
        * [040104] Macro execution speed-ups - Thanks Hops for analysis.
        * [040104] Code optimizations and extensions - Thanks Peter Smith.
        * [040104] Lua language template - Thanks Jeremy Cowgar.
        * [040104] SGML language template.
        * [040104] lslmstring-rectangle(3)le command added - Suggested by Salman.
        * [040104] C++ re-style fixes - Problems reported by Salman.
        * [031221] X-Window fixes - Thanks Jeremy Cowgar.
        * [031120] Added new highlight schemes "cCLemon JellycA" and "cCBrowniecA".
        * [031120] CVS. Fixed several issues with the why the cvs dir list
          processed the missing and added files.
        * [031120] HTML Template. Improved indentation.
        * [031120] Toolbar. Added "trunc-sheme" reset to force a redraw if
          required.
        * [031120] Fixed the games to cope with the toolbar by closing it.
        * [031120] cGbuffer.ccA. Changed the 'cCncA' arg to list buffer so user can
          select hidden or verbose etc. Added check after exec of "ehook" to
          catch nasties, not fool proof but catches attempts to close tool bar
          etc.
        * [031120] Fixed a lslmgoto-line(2)le bug shown when using grep on a single
          lined file (like CVS/Root).
        * [031120] cGhilight.ccA. Changed indent line count to use the close so
          values of greater that 256 can be used.
        * [031120] cGinput.ccA Added support for EOB & BOB keys & fixed fwd/bck
          word movement across lines.
        * [031026] Fixed -ve re-center bug found by Alexander Doktorovich.
        * [031026] Last commit to search fixed a lslm&xsequal(4)le failure on
          start-up, was not setting the internal flags correctly. Fix go a
          little messy as it should not affect the hunt commands.
        * [031026] Minor restyle.
        * [031026] Fixed a nasty buffer reload bug.
        * [031026] Fixed lookback highlight bug.
        * [031026] Fix for Sunos Xterm function keys.
        * [031026] Added support for a look-back indent scheme which can be
          used to get the correct indent scheme to use.
        * [031026] Fixed history line numbers (were one line out for
          non-current buffers).
        * [031026] Changed the cGmldeletecA to respect the "scrollFlag" setting,
          if smooth scroll enabled then delete text smoothly.
        * [031026] Fixed narrow look back highlight bug.
        * [031026] Added ADA file hook - thanks to Gabriel Tabares-Barreiro.
        * [031026] Nroff template. Removed unused variable.
        * [031026] HTML Template. Major shake-up for HTML base files including
          major enhancements to indentation and current script auto-detection.
        * [031026] Toolbar. Added support for the new "cD:chookcA" current file
          type variable and got toolbar and buffer tool menu to call the
          update command (toolbar only on a "cGC-lcA").
        * [031026] CVS. Fixed UNIX checkout path and implemented cvs remove.
        * [031026] lslmpage-file(3)le. Fixed backward isearch blow out.
        * [031026] Perl Template. Updated the perl.eaf to <FOLD>.
        * [031026] Abbreviations. Added support for the new "cD:chookcA" current
          file type variable and added support for an INCLUDE tag.
        * [031026] Abbreviations. Improved the look-back abbrev to expand to
          one before if exec'd again.
        * [030917] HTML Template. Fixed a hilighting and indent problem caused
          by embedded script.
        * [030917] OSD. Changed OSD hot-key 'cD&cA' to new style 'cD\HcA'. Changed
          user-setup dialog to use new Combo-box.
        * [030917] CVS. Major revamp of CVS support including an OSD dialog
          for each tool.
        * [030917] Changed the CHAR defines and add defines for the LEADER and
          TRAIL bytes used for special chars. Re-implemented OSD hot-keys to
          use "cD\\HcA" instead of "cD&cA" and added new "cD\\{cA" and "cD\\}cA" to stop and
          start current item hilighting. Added support for C++ private public
          and protected token indentation. Added new Check-box chars to the
          extended chars (1,2,3,4,19 & 20) and improved the drawing of some of
          the others Fixed windows "close while minimized" test so only
          prompted if something has changed.
        * [030917] Fixed a cGbuild.batcA not setting MAKE to nmake problem.
        * [030917] Added support for new Check-box chars in extended chars.
        * [030827] Added use default printer setting.
        * [030827] lslmpage-file(3)le. Fixed header and added isearch support.
        * [030821] Rationalized the buffer sizes, increased the keyboard macro
          and search string buffer sizes. Removed the GNU regex code - not
          used or tested in years. Part one of Jon's Xterm key lookup fix to
          get the key pad working.
        * [030710] User setup. Updated osd calls due to the change in 'cDdcA' flag
          behaviour and changed the items with drop down menus to use the new
          combo-box.
        * [030710] ODS. Updated osd calls due to the change in 'cDdcA' flag
          behavior.
        * [030710] Added new define for the number of history types and added
          new lslm@h0(4)le history variable.
        * [030710] Added support to lslm@mn(4)le and lslm@mna(4)le in the "cGmeGetKeycA"
          routine
        * [030710] Added new undo type for line reordering undo's, used by
          lslmsort-lines(2)le and lslmtranspose-lines(2)le.
        * [030710] Changed some define names to make them compatible. Changed
          the calls to "meGetUserKey" to "meGetKey" so a macro can give a list
          of keys Added new 0 argument which quits at the EOB rather than
          going to the top of the buffer etc (used in lslmpage-file(3)le "isearch").
        * [030710] Changed the logic of the 'cDdcA' flag so that it disables the
          displaying of the item type, changed button rendering so that it
          adheres to this so a single char button can be created Added new 'cDOcA'
          combo box item type which is a mixture between an entry box and a
          sub-menu item.
        * [030710] Improved the special char drawing routines so that they
          remain inside the char space and triangles look good regardless of
          size.
        * [030710] Fixed a nasty bug to do with file hooks that load other
          files and the find-file command manipulating the buffHistNo
          incorrectly so the wrong buffer is shown - obscure!
        * [030625] Added macro release makefile.
        * [030625] MicroEmacs 3.8 compatibility. Fixed isearch emulation.
        * [030625] First revision of lslmpage-file(3)le.
        * [030625] CVS. Removed debug line.
        * [030610] Changed cGTABcA and cDBELLcA to safer defines. Optimized the
          fill-para function so that it keeps one of the existing spaces
          between the words, this also help preserve the position of anchors.
        * [030610] Package making files for SunOS.
        * [030608] Changed the mouse default behavior to do a move yank.
        * [030608] Tools. Removed superfluous endif.
        * [030608] Toolbar. Only update the tool-bar if its the top level
          command, i.e. the screen-update is not required due to spell-buffer
          (say).
        * [030608] MS-Shift region. Check for lslmkill-rectangle(2)le and treat like
          we do the lslmkill-region(2)le.
        * [030608] Added new -ve argument to lslminsert-file(2)le which inserts only
          a section of the file. Optimized the lslmfile-op(2)le move command to try
          just moving the file first.
        * [030608] Changed the addLine function so it always flags the line as
          changed, this avoids some bizarre issues when macros delete an
          insert lines of text (best shown by the buffer-info tool-bar tool).
        * [030608] Added new macro oriented buffer-info numeric argument.
          Fixed bug in the ignore white-space buffer compare.
        * [030608] Fixed default printer selection issues - not complete.
        * [030608] Fixed a minor debug build issue in undo.c.
        * [030608] Changed the history so it always removes any duplicate
          entries.
        * [030608] Added lslm$window-eline(5)le and moved the aline into extended
          version.
        * [030608] Changing the addLine function to always set the changed
          flag meant all macros became hidden, use different bits.
        * [030608] Fixed a minor compile warnings.
        * [030608] Fixed buffer reload a file while displayed in another
          window problems.
        * [030519] Fixed minor compiler warning in search.c by removing
          pointless static initialization.
        * [030519] Fixed poke over-writing cursor on win32 console.
        * [030516] C Template. Changed C #define evaluation to use new
          protected narrows.
        * [030516] Stopped the Organizer Find exit quitting the organizer
          itself.
        * [030516] VM Mail. Fixes from Tom Hundt fixes message separator
          problem.
        * [030516] Made MS-DOS redraw the cursor on a poke as well.
        * [030515] Organizer. Fixed bugs with creating new addresses and
          indexing etc.
        * [030515] Printer. Store the windows device information in the
          print-history as well.
        * [030514] JST Template. Fixed jst magic hook and added Imakefile one.
          Changed jst magic hook variable setting setup to use the new $result
          variable.
        * [030514] HTML Template. Changed cDhtml-foldcA cD->cA cDcollapsecA, reported
          goto-matching-tag failure.
        * [030514] Buffer initialization. Changed the fold-setup call so that
          it gets called if likely to be required - use the new buffer-fhook
          lslm$result(5)le setting to help in determining this.
        * [030514] Folding. Changed the fold-setup so a setup string can be
          passed in rather than searching for one in the buffer, aimed at
          utilizing the new buffer-fhook lslm$result(5)le setting.
        * [030514] Set lslm$result(5)le to the magic fhook string so the fhook macro
          does not have to search for it again in buffer.c.
        * [030514] Fixed "cD\xbcA" bad regex bug.
        * [030513] Search. Added region line hilighting support.
        * [030513] Changed auto-spell hilighting scheme to a new spell-error
          scheme to avoid printing issues.
        * [030513] Removed old cGhkfold.emfcA fold implementation. Moved cGfold.emfcA
          to cGcollapse.emfcA and added a real folding editor support macros to a
          new cGfold.emfcA, based loosely on "cCfuecA".
        * [030513] Abbreviation, Changed copy-region call to not expand the
          narrows.
        * [030513] Latex Template. Added latex chars etc to the cG.eafcA file.
        * [030513] Search. Changed to handle the fold-open and fold-close
          split.
        * [030513] OSD. Improved the Edit narrow commands to take advantage of
          the new protected narrow support.
        * [030513] Tools. Fixed dummy tool removal and changed position
          setting to use alpha mark.
        * [030513] VM Mail. Regex protected the boundary id string.
        * [030513] Utils. simplified the str-to-regex by using &xrep.
        * [030513] User setup. Changed cDfold -> collapse.cA
        * [030513] HTML Template. Fixed script indent problem, improved the
          fence matching and added close tag feature.
        * [030513] Buffer setup. Changed cDfold -> collapsecA and added proper
          folding setup entries.
        * [030513] Commenting. Fixed silly "cG\x80cA" alpha char label bug.
        * [030513] File Dialogue. Added tab ordering to dialog.
        * [030513] Folding all templates. Changed the function folding
          commands to collapse to avoid confusion with real folding.
        * [030513] XML Template, Added indent rules for "cG<? ... ?>cA".
        * [030513] Mouse. Changed the column setting to use alpha marks.
        * [030513] Color Schemes. Split the fold scheme into fold-close and
          fold-open.
        * [030512] Fixed display matching fence issue with poke screen hiding
          the cursor on Unix X-Windows. May need to be done on MS-DOS as well.
        * [030512] Fixed horrid crash caused in search.c by buffer change in
          macro followed by query replace and toolbar up-date changing the
          regex variables.
        * [030512] Fixed fill-paragraph when no arg is given but at the
          beginning of para still move forward.
        * [030512] Fixed compiler warning in spawn.c.
        * [030512] Latest versions of build.txt, cygwin.txt, faq.txt and
          readme.txt.
        * [030512] Build fix for SunOS.
        * [030512] Ipipe fix for SunOS.
        * [030512] Changedthe line flag implementation to be more flexible and
          variable in size so UE has a smaller memory usage and ME has line
          flags available.
        * [030512] Improvedthe AMark setting and deleting.
        * [030512] Added a Protected Line flag and vastly improved the
          narrowing. Renamed most function in cGline.ccA to make them more
          readable.
        * [030512] Big return value change to get functions consistent - found
          that the return values of low level line functions where different
          to high level functions making the code hard to read and dangerous.
          Also needed a consistent triple value return (true false and error)
          so change cGmeABORTcA to -1 across the board.

    cD6th Release - December 2002cA

        * [021216] Removed cG.cvsignorecA from source release.
        * [021216] Fixed "cDnecA" Unix build for a window build
        * [021216] Fixed Perl abbreviations - Thanks to Dr. Detlef Groth.
        * [021216] Fixed "$frame-width"/"depth" macro operation on the set -
          Thanks to Th.
        * [021216] Confirmed Sun Solaris 2.6 PTY operation OK.
        * [021208] Filed build file for cygwin, pushed cygwin binaries and
          re-released source.
        * [021208] Added UNIX icons for CDE environment to meicons.tgz
          (me.t.pm, me.m.pm, me.l.pm)
        * [021204] Fix for UNIX terminal resize with frames.
        * [021204] Fix for Sun Solaris PTY creation and setup.
        * [021204] Fix for VM mail searching - Thanks to Th.
        * [021204] Fix for XML macros - Thanks to Th.
        * [021203] Fix for frame resize crash.
        * [021013] Fix for printing of *printer* buffer crash.
        * [021013] Added PL/SQL file support.
        * [021013] Updated mode change to use just a buffer type change flag.
        * [021013] Added lslm@mna(4)le to all find-files incase there are problems.
        * [021013] Broke the tool-bar tools out of the abbrev eaf file into
          there own tool eaf file.
        * [021013] Added item-list and tag generation support to VB, fixed a
          few hilight issues.
        * [021013] Shrunk the combo button size now that osd works better.
        * [021013] Added "cD!forcecA"s to all "unbind"'s to avoid bells.
        * [021013] Made manual sub-menus have the .. And added Occurrences to
          the right button mouse menu.
        * [021013] Updated macros for osd sub-menu position changes.
        * [021013] Added new find and refresh tool toolbar options.
        * [021013] Added Hot key for Microsoft friendly keys option.
        * [021013] Added Finnish support - thanks to Sebastian Bojers.
        * [021012] Fixed new frame ml junk text - new problem with line
          changes.
        * [021006] Saved 3 bytes per line by using the rounded bytes and
          changing the length to an unused size. Fixed some minor Unix compile
          warnings.
        * [020919] Changed the way manual sub-menus are opened and closed to
          improve usability (particularly for the combo box). Added auto side
          placement of sub-menus remove the 'e' 'w' and 'n' flags.
        * [020912] Added crypting of registry files and Microsoft friendly key
          bindings.
        * [020912] Fixed several html -> vb indent and hilight issues,
          re-implemented the mode change to be toolbar aware.
        * [020912] Changed the "msshift" key list to a macro list which checks
          the non-shifted key is bound first. Added "cGC-homecA" and "cGC-endcA".
        * [020912] Added lslm$window-id(5)le.
        * [020912] Added crypting support to registry files - crypt key is
          auto-generated.
        * [020912] Fixed an odd win98 shell-command start-up dir bug and
          handled bogus consol sizes being returned (running "me -n" in me).
        * [020912] Fixed a reload fhook bug and added code to handle the fhook
          deleting the buffer!
        * [020912] Fixed windows -p lock-up bug caused by reading from stdin
          fp when no file is piped.
        * [020830] VM Added code to handle empty multi message end section.
        * [020723] New revamped Html support with toolbar support.
        * [020723] Added right and bottom toolbars, and a paged tool concept,
          fixed quite a few problems found with the toolbar. Added a new
          Buffer Tools tool which loads the cGhk???.eafcA file so that the abrev
          cG???.eafcA file can be left as solely an abbrev file.
        * [020723] Changed the interface to regexStrcmp to give better
          control. Added support for the "cG@s#cA" variables after a lslm&xsequal(4)le,
          re-implemented the buffer context initialization to not use iscanner
          so it no longer need to swap buffers also changed the location of
          the fhook exec to earlier, where it was the window count was
          incorrect for the old current buffer and this could lead to a crash
          if the fhook deletes this buffer (found in CVS mode).
        * [020723] Fixed a couple of goto-position problems.
        * [020723] Fixed item-list search strings.
        * [020723] Directory list - check for and fail on urls!
        * [020723] Added new "cG\\LcA" -> x-line, "cG\\XcA" -> x-command special keys
          to improve eaf file read and portability.
        * [020711] Added a system clipboard interaction disable flag to
          lslm$system(5)le so the tool-bar can stop messing up the clipboard
          whenever it updates.
        * [020711] Fixed an uninitialized variable bug breaking the FTP logoff
          operation of lslmfile-op(2)le.
        * [020629] HTML Added table creation and external preview commands.
        * [020629] Fixed system clipboard being trashed problem by disabling
          interaction with it during tool-bar updates.
        * [020629] Changed the List Functions to List Items in buffer setup.
        * [020629] Added new kill list tool to the tool-bar.
        * [020629] Added drag and drop support to directory view. Can now use
          this to load and copy/move files.
        * [020629] Changed the FOLDER tags to FOLD and improved the eaf files.
        * [020629] Added support for item-lists to C++ and added support for
          classes to C as the header is commonly used.
        * [020629] Fixed nasty pick -> drop local buffer override problem.
        * [020605] Added support for the toolbar and the initial frame size
          being set in the history.
        * [020605] Pascal. Added "cG(* .. *)cA" and "cG//cA" comment hilighting.
        * [020605] Macros - broke the setup default and standard tools into
          separate files. Improved the update flags for better control.
        * [020605] New osd-find-buffer popup menu using the user-setup file
          types, based on Dr. Detlef Groth's.
        * [020605] Fixed minor bug in file handling found by BC compiler.
        * [020605] Fixed isearch so the next command will be executed in the
          correct frame.
        * [020605] Updated makefile to new style which supports NE.
        * [020605] Fixed NT and win2000 mouse cursor not staying hidden,
          caused by dubious mouse move events.
        * [020523] CVS - added 'U'pdate file flag support.
        * [020523] Modified to support lslm$window-flags(5)le and window resize
          changes.
        * [020523] Added new "cG<-cA" and "cG->cA" truncate chars to lslm$window-chars(5)le.
        * [020523] Fixed mutli-frame console crash, window depth resize jump
          bug. Fixed drag-n-drop so it won't use a locked window. Fixed a
          nasty no-update bug involving the ERASEBKGND message. Added the
          drawing of a "cG<-cA" char to "0x08" (Backspace).
        * [020523] Fixed a nasty multi-line regex search failing at end of
          buffer problem.
        * [020523] Removed the ANSI and APRAM macros - redundant.
        * [020523] Combined the shrink and enlarge window commands into a
          single lslmchange-window-width(2)le and lslmchange-window-depth(2)le command.
        * [020523] Changed interface to frame resizing functions, numerical
          arg is now a delta change.
        * [020523] Added left and right truncate chars to lslm$window-chars(5)le,
          fix ABORT string value.
        * [020523] Added extra parameter to HideBuffer flagging whether to
          hide the buffer if the window buffer lock is set. Changed
          lslmfind-buffer(2)le numerical arg so -1 hides all but lock windows, -2 or
          less hides all.
        * [020430] Improved the 'closest window match' algorithm so it gets
          the closest window!
        * [020430] Windows - fixed an new compile problem and a frame loop bug
          in the font setup (frameCur == NULL for first call).
        * [020428] Name changes (screen -> frame) due to frame support, new
          toolbar support, new lslmabbrev-list(3)le and lslmexpand-look-back(3)le, new
          filter on normal browser, auto-spell ignore, perldb sub-func fix,
          tables added to jst, fixes to bullet list in lslmifill-paragraph(3)le.
        * [020428] Changed the ipipe wrap line length to be the 'term-size',
          using the frame size causes problems, particularly with the toolbar.
        * [020427] Major edit! Added frame support, standardized many of the
          structure and function names, introduced $window-flags (not the size
          lock yet). Also fixed abbrev word boundary bug.
        * [020427] US Letter support added by Th.
        * [020301] CVS - added support for adding binary files.
        * [020301] Added new JST support.
        * [020301] Minor fix to the html processing and link following.
        * [020301] Added latex template file.
        * [020301] Mouse - changes required for changes to scroll commands
          which now abort at the top and bottom.
        * [020301] Minor search fix to handle get-next-line requiring user
          input (out-of-date buffer etc).
        * [020301] Major changes to create NanoEmacs! Made macro getting of
          keys for binding very strict, no superfluous chars allowed Changed
          mlwrite so that when aborting and no !force is used it will write
          message even with a MWEXCEL. Made printing optionally quiet for JST
          insert printing. Minor changes to scroll commands to abort when at
          the top or bottom. Small change to numerical interface to
          suspend-emacs.

    cDExperimental Release - January 2002cA

        * [020124] Split source code with conditional compilation into
          functional blocks.
        * [020124] Added LATEX abbreviation file and updated template to load
          abbreviation file.
        * [020124] JASSPA Structured Text (still prototyping - jst). Macros to
          convert structured text into other formats.
        * [020124] Reworked the build files to build the multitude of debug,
          console and window variants.
        * [020124] Added binary add mode to the CVS menu.

    cD5th Release - January 2002cA

        * [011230] Applied GPL License to code base. Transition to GPL
          following permission from Daniel M Lawrence.
        * [011220] Fix to comment-restyle in comment.emf - stops a spin.
        * [011220] nroff makefile full target building the txt files.
          (internal).
        * [011220] Added support for a $CURSOR$ tag to the etf files which
          sets the initial cursor position, and included h.etf as an example
          (thats been annoying me for some time).
        * [011220] Moved the template etfinsrt calls into the
          buffer-initialize macro.
        * [011220] Fixed the exec fhook-cpp not working .
        * [011220] Fixes to ctags for C++ function call initializers.
        * [011220] Fixed Windows Console <RETURN> key keyboard mapping,
          returning incorrect binding.
        * [011219] Fixed Termcap <TAB> key translation.
        * [011219] Fixed Termcap tparm() to use a default stack argument if
          not specified by default.
        * [011219] Added cygwin support to the build file.
        * [011219] Added extra argument to buffer-initialise.
        * [011218] Added support for Euphoria language.
        * [011217] Italian spelling dictionary.
        * [011217] Added scheme support for fence matching colors.
        * [011217] Removed global binding of TAB key from unixterm.emf and
          build in translation.
        * [011215] Fixed cygwin makefile for latest version, added cygwin
          macros.
        * [011215] Fixed remaining termcap crash under cygwin.
        * [011214] Merged prototype cygwin code base into release, use poll()
          following select().
        * [011123] Fence matching added to user sertup (user-setup -> Platform
          -> Fence Display).
        * [011115] Reworked the buffer hooks such that mybhook/myehook can be
          defined.
        * [011031] Fixed a corking crash! (load random.c and do 2222
          replace-string "\n" "").
        * [011029] hklatex.emf item-list support (hit "f7").
        * [011028] hklatex.emf has a greatly improved pseudo highlighting.
        * [011028] Tweaked the "@fs" variable to improve its usability.
        * [011028] set-position can now store the mark position.
        * [011028] Fixes to windows file times.
        * [011016] New caps-lock, num-lock, scroll-lock and pause key support
          for win32 & unix. The "*-lock" implementation to be more like
          "S-pick" and "C-pick" as the keys are automatically supported (like
          the shift) so there are no default binds to void, the keys are only
          generated if there are bound. Could not implement this on MS-DOS.
        * [011016] which command built in i.e. "M-x which". Used for command
          utilities.
        * [011026] A new Hide value feature when inputting strings, this is
          now used be the crypt and ftp Password entry. The string is shown as
          '*'s.
        * [011025] Utilized the latest screen-update improvements to make the
          gdiff screen update rock solid.
        * [011025] mlGetChar fix. The key "return" was the 78th special char,
          i.e. "SKEY_SPEC"|'N' and as the mlGetChar did not check the
          "SKEY_SPEC" bits, pressing return was like pressing 'N' so on a
          "Y/N" prompt try pressing return, its like saying No! .
        * [011016] Spelling dictionaries renamed with ISO naming scheme.
          Because of the language changes, you need to rename your personal
          dictionary to lsdpengb.edf for British and lsdpenus.edf for
          American.
        * [011016] Highlighting brackets/braces as requested from user base.
          The highlight braces required some other subtle changes to
          screen-update and show-region and the addition of the "rbin" mode
          means that this version is incompatible with the last in quite a few
          areas.
        * [011016] Fixed mouse handler (turns out that if the pick event was
          lost (use "@cg" or an error) then me would lock!).
        * [011016] Extended control on indent tab and return behavior (can
          disable the tab behavior).
        * [011016] C++ name space indentation support.
        * [011016] New language support interface so spelling is not required
          for a language to be supported (may only want the basic alphabet
          setup etc).
        * [011016] Changed file loading interface so all commands (like
          view-file) can load in "bin", "crypt" or "rbin" mode.
        * [010123] Reduced binary mode added (rbin).

    cD4th Release - August 2001cA

        * [010813] OSD bug fix for fixed size dialog boxes.
        * [010812] Inclusion of occur regexp function.
        * [010812] List function for summarizing file contents ("F7" /
          "Esc-F7" to close).
        * [010810] Rendered character for the scroll bar - improves clarity.
        * [010810] Modified the printer registry file location.
        * [010801] New Guest default color scheme.

    cD3rd Release - Minor Updates July 14th 2001 onwardscA

        * [010718] LaTeX template includes incorrect bindings - fixed.
        * [010716] Corrected Windows Install Shield "Company Entry" +
          "Registry entry fields".
        * [010716] Minor macros modification to font selection for schemes.
          Default guest setup font selection for cleaner 'first' page.
        * [010716] CVS macro update. Changed "cvs-diff" to "cvs-gdiff" and
          introduced a new "cvs-diff" which just gives the "diff" output and
          fixed several bugs when running with a CVS server. Also added
          support for the CVS/Template file when committing.
        * [010716] Minor update to the CVS help page for the aforementioned
          (Affected all help files).

    cD3rd Release - July 2001cA

        * [010713] New style WWW JASSPA Pages.
        * [010712] Added comment and menu support for MS-DOS and M4
          (hkdos.emf/hkm4.emf).
        * [010711] Added hpux11 support.
        * [010711] Fixed windows erase when file doesn't exist problems.
        * [010710] Removed cbox - replaced by generic comment implementation
          (cbox.emf/me.ehf).
        * [010710] Added a 'Plain Text' char set which only uses plain letters
          (charset.emf).
        * [010710] Fixed many little comment formatting bugs and annoyances
          (comment.emf).
        * [010710] Changes required to build on MS-DOS using DJGPP v1.
        * [010705] Bug fix for windows rendering crash.
        * [010630] Minor reorder to X-Windows initialization for cygwin
          X-Server.
        * [010507] Added generic commands for the creation, deletion and
          reformatting of comments now used by most of the file hooks.
        * [010412] Added new generic buffer setup, menu and help macros,
          creating the new lslmbuffer-setup(3)le command. Ported all existing file
          hooks to this new interface greatly reducing the buffer hook size
          while increasing its functionality and consistency.
        * [010402] Added support for new lslm$buffer-backup(5)le variable for
          setting the back-up file location.
        * [010312] Support for new key bindings allowing CU emulations. Nedit
          bindings provided as example. Major work to enable the complete
          re-binding of all keys so the user interface to MicroEmacs can be
          completely changed, this allows for example a Windows feel to be
          created. This required many internal ghosts to be exorcized and add
          new macro functions.
        * [010308] User buffer configuration menu added.
        * [010308] Improved Python support (Contribution PG).
        * [010304] Bug fixes to hilighting logic.
        * [010228] Improved dialog box for search/replace.
        * [010210] Revised programming language templates; simplified the
          common elements used in configuring the templates.
        * [010202] Added new lslmcommand-wait(2)le command to enable macros to wait
          for user dependent completion, used in "gdiff".
        * [010202] Changed buffer variables to except the form
          "cG:<buffer-name>:<variable>cA", like command variables. This allows
          macros to access variable not defined in the current buffer.
        * [010126] File "autosave" location changes. Control save name and
          location.
        * [001005] OSD speedups.
        * [001005] Improved and increased the file system operations via the
          new lslmfile-op(2)le command, created better menus in the lslmfile-browser(3)le.
        * [001010] Revamped the main ftp GUI to make it work much more
          rationally.
        * [001010] Improved lslmipipe-shell-command(2)le efficiency on Windows by
          introducing a new thread approach to listen for activity.
          Implemented a shell command-line in an ipiped environment so
          lslmishell(3)le command is now usable on Windows platforms.
        * [001010] Added new lslmset-position(2)le which can be used to store all
          information about the current window and lslmgoto-position(2)le which will
          then restore them. Allowed macros to use non-letter characters for
          alpha marks and positions so they no longer need to clobber user
          ones.
        * [001010] Added new "-k" and "-u" command-line options and improved
          "-s" option.
        * [000922] Added GUI for tag dialogue for tags generation.
        * [000922] Recursive tags support (i.e. nested directory tag
          traversal).
        * [000810] emain.h "#define"'s properly supported again so MicroEmacs
          can be successfully compiled without options like SPELL and OSD etc.
          This can reduce the binary size by up to 37%.
        * [000718] Source trees now maintained under CVS.
        * [000719] Improved TCL/TK and Perl template support.
        * [000704] Improved FTP and HTTP support.
        * [000620] Java tags support.
        * [000503] Revised printer support.
        * [000503] Color printer support (Lexmark).

    cD2nd Release - Alpha patch - March 2000cA

        * [000322] FIRST PUBLIC RELEASE OF RENDERED FONT SUPPORT .
        * [000322] Alpha build revision contains version information for
          2000/03/22
        * [000322] Internal reorganization of platform option selection.
        * [000322] Minor fixes X-Windows color selection.
        * [000322] Minor fixes in the OSD.
        * [000322] Reviewed the documentation mode. A text description of the
          using the documentation modes is included in the distribution in the
          text directory.
        * [000322] Minor modifications to support Borland 5.5 compiler
          (win32b55.mak).
        * [000322] Support for Openstep 4.2 / NeXT Motorola 040 (Termcap
          only).
        * [000322] Support for BSD 4.2/4.3.
        * [000322] Revised UNIX Termcap support.
        * [000322] New font rendering, supporting bold, italic, underline etc.
          All platforms modified to cope with font scheme definitions.
          Platforms optimized for speed.
        * [000126] Beta build revision contains version information for
          2000/01/26.
        * [000126] Directory file copy. Within this release files in the
          directory listings may be selected for copy and pasting from the
          menu. Use the right mouse button to pop-up a menu in the directory
          buffers. Copy and paste to/from a ftp directory buffer to a local
          drive buffer may be used to initiate an ftp transfer. (This is how
          these pages are uploaded).
        * [000126] New command ftp opens a ftp connection using a dialog. Use
          may save the host connection information in a registry file. Note
          that the password information is exposed so be careful where this is
          used - if in doubt do not enter the password and you will be
          prompted.
        * [000126] New command lslmuniq(3)le operates as the UNIX of the same name.
          used with sort, and reduces to unique lines.
        * [000126] Character translation; addition of character translation
          macros when moving between character sets. Accessible from Menu ->
          Format -> Change Buffer Char Set.
        * [000126] Support for additional character sets, Windows GREEK,
          Windows TURKISH.
        * [000126] Line highlighting selection with the use of the mouse and
          auto search. When using the mouse selection to set up the line
          highlighting when invoked from a cGright-mouse -> Hilight Line ->
          color/removecA selection; the macro determines the mouse selected
          region and makes an appropriate decision as to how the line
          highlighting scheme is to be applied. The following rules apply to
          the mouse selection:-

            * Point in line selected (i.e. mark == point) Highlight the line
              only.
            * Region in the line selected. Both point and mark are on the same
              line. Extract the selected text and hilight all lines that match
              the search pattern. The color "remove" is also pattern matched
              to selectively remove lines.
            * Region selected mark & point on different lines Block up the
              region with appropriate highlight.
            * Note that line highlighting may be safely used in a folded
              buffer.


        * [000126] Addition of special rendered space character. You may
          toggle this from the keyboard using a macro in your user.emf as
          follows:-

            ; Macro to enable the display of TAB/CR. Note that we
            ; force the screen to be updated.
            define-macro tab-display
            set-variable $system &bxor $system 0x80000
            screen-update
            !emacro
            global-bind-key "tab-display" "f11"

        *
        [000126] Documentation update on new features (contained in me.ehf).
        * [000114] Fixed font selection bug in 000112 beta.
        * [000112] Revised color hilighting schemes, reduced the number of
          colors in a number of schemes. Introduction of the Sherwood Forest
          color scheme (green theme obviously !!).
        * [000112] Small revision to the user interface with respect to font
          selection. In order to make character set selection easier then the
          multiple choices for the box characters have been removed from Menu
          -> Help -> User Setup. These have been replaced with a new check box
          Extended Char Set. This box should be checked to enable the special
          rendering characters and enable the box characters - this is
          typically enabled on X-Windows and MS-Windows.
        * [000112] Provision for directory list sorting on name, modification
          time and size. Selecting the directory column title performs a
          re-sort based on the selection, a further selection reverses the
          order of the list.
        * [000112] Addition of ftp support (meu build on Windows, enabled by
          default on UNIX). Enables files to be edited via ftp, (read and
          write supported). Transfer to another system using
          ftp://[<user>[:<password]@]><host>[:<port>]/<pathname>.
        * [000112] Improved source code provision for foreign languages,
          various internal problems. Support for Russian (Windows and Cyrillic
          koi8-r).
        * [000112] Y2K problems with time stamping and mode line date.
        * [000112] New spelling rules for number sequences and specialized
          wild card sequences. Within the rule file (i.e. americar.emf,
          britishr.emf, etc.) then the following spelling rules may be added
          to cope with numeric sequences. The addition of these rules will
          spell check hexadecimal sequences and validate numeric sequences
          such as 1st, 2nd, 3rd etc. A spelling of "1nd" would generate a
          spelling error. This has not been performed for other languages so
          submissions for other language equivalents would be appreciated.

            ; Add some special word rules to make life easier.
            ; These are for 1st, 2nd 3rd etc.
            add-spell-rule "*" "\\([0-9]*[02-9]\\)?1\\(st\\|ST\\)"
            add-spell-rule "*" "\\([0-9]*[02-9]\\)?2\\(nd\\|ND\\)"
            add-spell-rule "*" "\\([0-9]*[02-9]\\)?3\\(rd\\|RD\\)"
            add-spell-rule "*" "[0-9]*1[0-9]\\(th\\|TH\\)"
            add-spell-rule "*" "[0-9]*[04-9]\\(th\\|TH\\)"
            add-spell-rule "*" "0[xX][[:xdigit:]]+"
            ; Spell rules for unit definitions.
            ; These are for 50Mb, 10Kg, -45.56cm 12ft 10.00am 16.00pm etc.
            add-spell-rule "*" "-?\\([0-9]*.\\)?[0-9]+\\(Kg\\|Kb\\|Gb\\|Tb ...
            \\|Mb\\|mm\\|cm\\|m\\|Km\\|ft\\|inch\\|mph\\|lb\\|am\\|pm\\)"

        *
        [000112] Box selection copy and paste. Bindings are defined as cGEsc C-wcA
        lslmkill-rectangle(2)le cGEsc C-ycA lslmyank-rectangle(2)le.
        * [000112] Enhanced info file hilighting (Thanks to Dr. Detlef Groth
          for this).
        * [000112] New copy-file command, typically used by the macro language
          for moving files around.
        * [000112] Error reporting of bad command line arguments in Microsoft
          Windows environment (Thanks to Pedro Gomes for this).

    cD2nd Release - November 1999cA

        * [991101] Enhanced the latex support macros following various
          contributions from users.
        * [991101] Added Favorites to the File pull down menu. This is a
          simple mechanism to allow the user to add a file to a favorites
          list.
        * [991101] Ground up implementation of the regular expression pattern
          matcher, following licensing problems with the GNU regex. The
          resultant pattern matcher is now a little faster than GNU regex and
          is capable of all of the standard regular expression pattern
          matches. The pattern matcher has diverged from GNU in that double
          backslashes are required in the character classes [..] to allow for
          escape sequence short cuts such as '\n' (newline), '\t' (tab) etc.
          It was felt that this compromise was better than having to quote the
          more obscure search characters.
        * [991101] Changed the hilighting and indenting syntax to be GNU regex
          compliant.
        * [991101] Modified compare-windows to ignore white space by default,
          compare-windows-exact performs an exact character for character
          comparison.
        * [991101] Enhanced the tags support to handle multiple tags and
          recursive directory tree searching.
        * [991101] Implemented osd-help, a gui front end to the on-line help.
          Required changes to the help system which gives macros access to the
          on-line help buffer, needed for the index and search.
        * [991101] Over-hauled the highlighting scheme files and editor to
          support the disabling of buffer highlighting.
        * [991101] Many bugs fixed on all platforms, in particular unix
          cutting and pasting (crashes exceed) and focus problems and NT exit
          delay.
        * [991101] Added tab and newline character printing in buffers.
        * [991101] Introduced message line variables "@mx" and "@mxa".
        * [991101] New Games - Crossword cracker. The ideal way to cheat at
          crosswords. Uses the spelling dictionary to guess at the word, given
          a number of known letters.
        * [991101] Hook file protection against globally bound keys - prevents
          re-binding of user defined keys within the macro.
        * [991101] Search/Replace fix for exact mode. Environment variable
          search path fix.
        * [991101] hkm4.emf added back into the release (seemed to have gone
          missing).
        * [991101] Cut and paste fix when running the UNIX version through an
          X-Server such as Exceed in the Windows environment.
        * [991101] Plain text printer device added.
        * [991101] Obscure OSD fix.
        * [991101] New OSD help search facility Menu->Help->General Help.
        * [991101] Fix for NT hang-up on shut down (typically encountered when
          running a source debugger).
        * [991101] Fix for NT process spawning with spaces in the names.
        * [991101] Metris macro fix, OSD bug fix, NT display fix.
        * [991101] New - color scheme, GVim look.
        * [991101] New - Unix/Linux support for Wheel Mouse (mouse.emf).
        * [991101] New - Color schemes, Plain; for those that do not care for
          an abundance of colors.
        * [991101] Modified the numeric key-pad behavior to be consistent on
          all platforms. Problems were noted with the UNIX number lock
          orientation which was reversed.
        * [991101] New - Color scheme variables which allow the hkXXX files to
          determine the level of hilighting to apply to their templates.
        * [991101] Line length fix; more graceful behavior (i.e. does not
          crash) when the line length exceeds 64K.
        * [991101] Intercept the windows 105 keyboard application key
          (typically right hand side of keyboard next to the control key). The
          key is called "menu". By default this is bound in win32.emf, however
          users may bind it as a prefix for their own key combinations in much
          the same way as "Alt" or "C-x" if required.
        * [991101] New; OMG's IDL language template added.
        * [991101] Fix for windows short name in next-buffer.

    cD2nd Release - Beta #1 - May 1999.cA

        * [990501] Bug fixes with multi-language support and spelling
          dictionaries.
        * [990501] Fixed fill-paragraph such that it retains the cursor
          position in the paragraph when invoked without arguments.
        * [990501] Moved to GNU regex for search/replace engine.
        * [990501] Enhanced isearch such that it operates in *shell[990501
          buffers (again).
        * [990501] gdiff macro implementation of a graphical diff to allow
          color annotation of differences and difference selection. Uses the
          output of a standard cDdiff(1)cA utility.
        * [990501] 2nd port to IBM AIX.

    cD1999cA

        * [990101] Introduction of the address and date organizer (replacing
          the existing cal interface).
        * [990101] Generic buffer folding using lslmnarrow-buffer(2)le.
        * [990101] Rendered cursor support on all platforms. Smooth scrolling
          mode.
        * [990101] Win32s port, for Microsoft 3.1/3.11 O/S.
        * [990101] Re-worked "translate-tcap-key" to generic "translate-key"
          to solve many of the foreign language problems.
        * [990101] Re-worked the ALT key mapping to allow conventional Emacs
          meta key bindings.
        * [990101] Implemented Auto-Spell utility.
        * [990101] Introduction of private macro variables of the form ".name"
          and ".macro.name".
        * [990101] Port to Sun Solaris Intel platform (2.6).
        * [990101] Merged the init-hilight and hilight-token into the single
          highlight command. Similarly for indent.
        * [990101] Enhanced the regexp support in hilight tokens, vastly
          improving it capability and usability. Similarly for indent tokens.
        * [990101] Reorganized the highlighting files. Introduction of the
          scheme-editor and Highlight Search OSD's.
        * [990101] Implemented box character override support ($system bit
          0x10000) on Win32 and Xterm platforms.
        * [990101] Microsoft Windows native console support.

    cDMinor Patch - October 1998cA

        * [981001] Enhanced the operation of the Window pipes.
        * [981001] Undo past the last save operation.
        * [981001] Added Tabbed entries to OSD.
        * [981001] Enhanced user setup using OSD.

    cD1st Release - September 1998cA

        * [980901] Support True-type fonts under windows, font selection
          dialog.

    cD1998cA

        * [981231] Registry features for configuration.
        * [981231] Re-implementation of OSD.
        * [981231] Re-implementation of termcap extended key support.
        * [981231] Narrow support.
        * [981231] Re-implementation of the session history.
        * [981231] Re-implemented the speller based on ispell dictionaries.
        * [981231] Re-worked the printer interface for Windows.
        * [981231] Rationalized mouse key bindings.
        * [981231] Added $system variable to configure MicroEmacs.
        * [981231] Added random hilight-token addition and removal support.

    cD1997cA

        * [971231] Re-implementation of ipipes to enable terminal support.
        * [971231] Initial Directory-Tree support.
        * [971231] First implementation of the On Screen Display (OSD) menus
          and dialogues.
        * [971231] Horizontal split window support.
        * [971231] Scroll bar support.
        * [971231] Added menu bar.
        * [971231] Cursor position correction for hilights with invisible
          character.
        * [971231] Indentation scheme support.
        * [971231] Ported to Microsoft NT.
        * [971231] Ipipes supported on NT.

    cD1996cA

        * [961231] Ported to Slackware Linux.
        * [961231] First menu system (implemented in macros).
        * [961231] Undo support.
        * [961231] First ported to Microsoft Windows 95.
        * [961231] Re-implementation of get-next-line.
        * [961231] Auto mode support.
        * [961231] Magic file hooks added.
        * [961231] Proper key name support.
        * [961231] Key bindings support numeric arguments.

    cD1995cA

        * [951231] Integral speller.
        * [951231] Ported to HP-UX.
        * [951231] Multiple ipipes supported on Unix.
        * [951231] Poke-screen support.
        * [951231] Call-back macro support.
        * [951231] Metris created.
        * [951231] Abbreviation and completion.
        * [951231] First implementation of mailing and View Mail.
        * [951231] Isearch expanded to support magic mode.
        * [951231] Session history support.
        * [951231] First ported to X-Terminal.
        * [951231] Mouse support.
        * [951231] Initial printer support.

    cD1994cA

        * [941231] DOS built with djgpp, allowed large files to be edited.
        * [941231] Color hi-lighting.
        * [941231] Re-implemented the macro language. Allowed separately named
          macros.
        * [941231] Get-next-line support.
        * [941231] File hooks added.
        * [941231] Implemented Electric C.
        * [941231] RCS support.
        * [941231] Re-implemented backups and auto-saves.
        * [941231] Re-implemented lsisearch-forward(2)lmisearchle.
        * [941231] Re-implemented of keyboard macros.
        * [941231] Binary file reading support.

    cD1992-1993cA

        * [921231] Ported to IBM AIX.
        * [921231] Ported to Silicon Graphics

    cD1988-1999cA

        * [881231] Ported to MVME147, UNIX using curses.
        * [881231] Fire fighting to get a stable version.
        * [881231] Expanded regular expression syntax.

    cDDaniel M. Lawrence - Microemacs V3.8 distribution.cA

        * Daniel Lawrence turned MicroEmacs into an editor for the masses, it
          is his work that ultimately made MicroEmacs so popular. Daniel did a
          tremendous amount of work, both adding features and supporting other
          platforms resulting in the MicroEmacs v3.8 release on which JASSPA's
          MicroEmacs is based.

    cDLate 1985/early 1986cA

        * Dave Conroy, the original author, first developed the original code
          base for private use. Various people asked Dave for a copy of the
          program and it was distributed without concern for copyrights or
          ownership as was the custom of that era.


cEWork In Progress or Planned cA


    Development of MicroEmacs is an on-going process, follows is a list of
    work items which is currently being undertaken or planned:-

        * Horizontal scroll bars.
        * On-line tutorial to help beginners get up and running.
        * Native printer support for the generation of postscript.
        * Inclusion of cDzlib(1)cA to allow compressed file reading.


cERelease History cA


    cDSeptember 2009cA
        10th Major Release - MicroEmacs 2009.

    cDAugust 2006cA
        9th Major Release - MicroEmacs '06.

    cDMay 2005cA
        8th Major Release - MicroEmacs '05.

    cDJanuary 2004cA
        7th Major Release - MicroEmacs '04.

    cDDecember 2002cA
        6th Major Release - MicroEmacs '02.

    cDJanuary 2002cA
        5th Major Release - MicroEmacs '02.

    cDAugust 2001cA
        Patch Release for MicroEmacs '01.

    cDJuly 2001cA
        3rd Major release - MicroEmacs '01.

    cDMarch 2000cA
        2nd Release alpha patch.

    cDMay 1999cA
        2nd Major Release - MicroEmacs '99.

    cDOctober 1998cA
        Minor patch to MicroEmacs '98 to correct a font problem on Windows
        platforms.

    cDSeptember 1998cA
        1st Major Release - MicroEmacs '98.

    cD1988cA
        Daniel M. Lawrence - Microemacs V3.8 distribution.

        Daniel Lawrence turned MicroEmacs into an editor for the masses, it is
        his work that ultimately made MicroEmacs so popular. Daniel did a
        tremendous amount of work, both adding features and supporting other
        platforms resulting in the MicroEmacs v3.8 release on which JASSPA's
        MicroEmacs is based.

    cDLate 1985/early 1986cA
        Dave Conroy, the original author, first developed the original code
        base for private use. Various people asked Dave for a copy of the
        program and it was distributed without concern for copyrights or
        ownership as was the custom of that era.


cEDocumentation cA


    The documentation is all written in UNIX cDnroff(1)cA and converted to HTML,
    Microsoft Windows Help File format and MicroEmacs Help file format.
!   Frequently Asked Questions
cEcEFAQ cEcA


    This page contains frequently asked questions submitted to JASSPA.

    lsFAQs(0f)lmFAQsle - FAQ Contact information
    lsfaq00(0f)lmfaq00le - New functionality; what is useful to me as an old MicroEmacs user
    ??
    lsfaq01(0f)lmfaq01le - Languages; Are any foreign languages supported other than English
    ??
    lsfaq02(0f)lmfaq02le - C++ is not default, C is - how do I change this ??
    lsfaq03(0f)lmfaq03le - GNU Emacs; are there any GNU Emacs bindings. ?
    lsfaq04(0f)lmfaq04le - Icons are not displayed correctly in Microsoft Windows
    environments !!
    lsfaq05(0f)lmfaq05le - ipipes not working on Microsoft Windows network drives ?
    lsfaq06(0f)lmfaq06le - Language not supported - will it be ??
    lsfaq07(0f)lmfaq07le - Language file is incomplete
    lsfaq08(0f)lmfaq08le - Input locked up and not accepting keys; how do I unlock ?
    lsfaq09(0f)lmfaq09le - MicroEmacs Bindings; How do I get the original MicroEmacs bindings
    ?
    lsfaq10(0f)lmfaq10le - Microsoft Windows Locks up after killing an ipipe.
    lsfaq11(0f)lmfaq11le - Mouse support under Microsoft windows is strange !!
    lsfaq12(0f)lmfaq12le - Scroll bars too narrow !!
    lsfaq13(0f)lmfaq13le - Tab key; Why does the tab key not operate in some windows ??
    lsfaq14(0f)lmfaq14le - Termcap; On a color terminal why is there no color ??
    lsfaq15(0f)lmfaq15le - Termcap; Some of the keys do not work - how can I bind them ?
    lsfaq16(0f)lmfaq16le - Timestamp; Format incorrect, how can I change to MMDDYY.hhmm ?
    lsfaq17(0f)lmfaq17le - Windows; Component characters rendered incorrectly, how do I fix ?
    lsfaq18(0f)lmfaq18le - Windows Autosave and Backup files; are these potentially a problem
    ?
    lsfaq19(0f)lmfaq19le - Printing; Why in Windows does the output come out in a buffer ??
    lsfaq20(0f)lmfaq20le - Printing; On Windows which font should I use ??
    lsfaq21(0f)lmfaq21le - Printing; My printer is not supported ?
    lsfaq22(0f)lmfaq22le - Alt key maps to the Menu, how do I change ?
    lsfaq23(0f)lmfaq23le - me32.ini - Where does it go, how do I know it's being processed ??
    lsfaq24(0f)lmfaq24le - Windows - Where is app850.fon ?
    lsfaq25(0f)lmfaq25le - Time; mode line is showing the date in DD/MM/YY format how do I
    change ?
    lsfaq26(0f)lmfaq26le - C or C++ indentation and effects; how can I turn off ?
    lsfaq27(0f)lmfaq27le - fill-paragraph function does not fill ??
    lsfaq28(0f)lmfaq28le - Key modifier which acts as the ESC key; what is it ?
    lsfaq29(0f)lmfaq29le - find-file start location; where is it ?
    lsfaq30(0f)lmfaq30le - Re-using a MicroEmacs session; how to ??
    lsfaq31(0f)lmfaq31le - Drag and Drop; is it supported ??
    lsfaq32(0f)lmfaq32le - Cut and Paste to/from other applications; is it supported ??
    lsfaq33(0f)lmfaq33le - Fonts; how can I change the font ??
    lsfaq34(0f)lmfaq34le - Colors; how can I change screen colors ??
    lsfaq35(0f)lmfaq35le - File Types; how do I interchange between UNIX, Windows and DOS
    files ??
    lsfaq36(0f)lmfaq36le - Non-English Languages; What font should I select ??
    lsfaq37(0f)lmfaq37le - MicroEmacs '99; How do I up-grade from MicroEmacs'98 ??
    lsfaq38(0f)lmfaq38le - Some keys on my foreign keyboard do not work properly, how do I
    get them working ??
    lsfaq39(0f)lmfaq39le - Tabs; How to change the tab width ??
    lsfaq40(0f)lmfaq40le - Windows/DOS; Where do I get grep/diff etc. ??
    lsfaq41(0f)lmfaq41le - Home/End Keys; How do I change the default bindings ??
    lsfaq42(0f)lmfaq42le - tags; How do I generate a MicroEmacs compatible tags file ??
    lsfaq43(0f)lmfaq43le - ne; how can I enable line wrapping in NE ??
! 0ffaq00
cEcEQUESTION (00) cEcA


    New functionality; what is useful to me as an old MicroEmacs user ??


cEcEANSWER cEcA


    There are a lot of new features in this distribution. Assuming that you
    just want to use the editor (and have cottoned onto the fact that there
    are now scroll bars etc.) then the most frequent commands that we use
    are:-

        * lslmgrep(3)le - May need to set up in cC<user>.emfcA.
        * lslmdiff(3)le - May need to set up in cC<user>.emfcA.
        * lslmcompile(3)le - May need to set up in cC<user>.emfcA.
        * lslmclean(3)le - cleans a buffer, removing spaces etc.
        * lslmrestyle-buffer(3)le - Reformats 'C' + known languages.
        * lslmspell-buffer(3)le - For documentation work, spells the buffer.
        * cDC-scA - lslmisearch-forward(2)le incremental search.
        * cDC-x ucA or cGC-_cA - lslmundo(2)le undoes edits.
        * cDF10cA - lslmfile-browser(3)le allows the file system to be browsed

    Other useful macros include:-

        * lslmtabs-to-spaces(3)le - Good for sorting out the mess made by Microsoft
          Developer Studio.
        * lslmsort-lines(2)le - Two versions of this, allows marked lines to be
          sorted alphabetically.

    Be wary of:-

        * cDesc-ocA - lslmfill-paragraph(2)le. The default mode is an automatic mode
          which attempts to guess at the format required. It works most of the
          time. Also works in 'C'.

    Most of the other new features are in the background, such as the macro
    processor, indentation control, color hilighting, indentation control,
    auto-saving etc.

    lsFrequently Asked Questionslm[FAQ Index]le.
! 0ffaq01
cEcEQUESTION (01) cEcA


    Languages; Are any foreign languages supported other than English ??


cEcEANSWER cEcA


    Unfortunately as we started with V3.8 as a base many years ago, we missed
    the distribution with foreign language extensions. We have not
    incorporated them into the release.

    The May 1999 release improves the language support by supporting the
    ISO-Latin character sets.

    We do have spelling dictionaries for French, Spanish, Portuguese and
    German. Other languages may be supported by transforming native cDispell(1)cA
    dictionaries.

    If there is enough interest in this release from people with foreign
    languages then we may consider including support for foreign language(s).
    However we would be very much reliant on external help for local testing
    and translation. We would be open to suggestions.

    lsFrequently Asked Questionslm[FAQ Index]le.
! 0ffaq02
cEcEQUESTION (02) cEcA


    C++ is not default, C is - how do I change this ??


cEcEANSWER cEcA


    If your main programming language is C++, then you will require the cG.defcA
    and cG.hcA files to be loaded in C++ mode by default, rather than 'C'. To
    modify this hen the order of the file hooks has to be re-defined.

    Within your cC<user>.emfcA, over-ride the default ordering by including the
    line:-
sB
        add-file-hook ".h .def"                                     fhook-cpp

sA
    This adds a newer binding for "cG.hcA" and "cG.defcA" to C++, over-riding the
    existing 'C' binding.

    lsFrequently Asked Questionslm[FAQ Index]le.
! 0ffaq03
cEcEQUESTION (03) cEcA


    GNU Emacs; are there any GNU Emacs bindings. ?


cEcEANSWER cEcA


    No not at the moment. The GNU Emacs bindings would be added as a
    compatibility file (meemacs.emf) in much the same way that the me3.8
    bindings are added, see meme3_8.emf.

    From the user-setup(3), the user would then ask for "gnu" compatibility.

    We would welcome submissions for a gnu compatibility file, gnu.emf, to add
    to the release.

    The cDMetacA key (typically cGAltcA) may be bound to key strokes, as opposed to
    the menu short-cut from the lslmuser-setup(3)le as follows:-

        cDToolscA -> cDUser SetupcA -> cDGeneralcA -> cDAlt Action: Main Menu Hot-keyscA = N
        cDToolscA -> cDUser SetupcA -> cDGeneralcA -> cDAlt Action: Esc PrefixcA = Y

    lsFrequently Asked Questionslm[FAQ Index]le.
! 0ffaq04
cEcEQUESTION (04) cEcA


    Icons are not displayed correctly in Microsoft Windows environments !!


cEcEANSWER cEcA


    After installing on Microsoft platforms, the Icons in the Explorer window
    may not be showing correctly. To remedy the situation then the following
    steps may be taken.

    cDWindows '95cA
        Try re-starting the system first. If the icons are still incorrect
        then re-start in Safe mode and delete the file:

        cGc:\windows\ShellIconCachecA

        Restart and the Icons should be correct.

    cDWindow '98cA
        Try re-starting the system first. If the Icons are still incorrect
        then re-start in Safe mode, this should re-generate the Icon cache.
        Restart windows.

    cDNTcA
        Restart the system.

    lsFrequently Asked Questionslm[FAQ Index]le.
! 0ffaq05
cEcEQUESTION (05) cEcA


    ipipes not working on Microsoft Windows network drives ?


cEcEANSWER cEcA


    We are aware of a problem with the ipipe commands with '95 and '98 (not
    sure about NT) when the current drive is a Novel network drive.

    Although we have not been ably to fully characterize the problem, we know
    that:-

        * Old Novel Clients prior to 2.2 - Does not work
        * Novel Intranetware Client 2.2 - Does not work.
        * Novel Network Client 2.5 - Does work.
        * Novel Client 3.01 - Does work.

    Any other information in this area would be appreciated to fully
    characterize the problem.

    To get around the problem then disable ipipes using lslm$system(5)le. From
    within your cC<user>.emfcA knock off bit 0x800 from lslm$system(5)le. This will
    enable regular pipes, which will work, albeit not in the background.

    lsFrequently Asked Questionslm[FAQ Index]le.
! 0ffaq06
cEcEQUESTION (06) cEcA


    Language not supported - will it be ??


cEcEANSWER cEcA


    We only support the (programming) languages that we have come into contact
    with. If you are using a language that we are not supporting then you will
    need to write a new cGhk<language>.emfcA file. See lslanguageTemplates(2)lmLanguage Templatesle on how
    to map a new programming language. The list of currently supported file
    types is defined in lsMicroEmacs - Supported File TypeslmSupported File Typesle.

    Jasspa would appreciate any new templates that people define for standard
    file types so that we can add them to the distribution.

    For Microsoft Windows, any associated "me" icons types would also be
    appreciated.

    lsFrequently Asked Questionslm[FAQ Index]le.
! 0ffaq07
cEcEQUESTION (07) cEcA


    Language file is incomplete


cEcEANSWER cEcA


    For a number of the (programming) language templates we have only provided
    a sub-set of the commands, this is typically because we only use a sub-set
    ourselves.

    For a number of templates, there is no indent support (see lslmindent(2)le and
    lsMicroEmacs - Supported File TypeslmSupported File Typesle).

    Note that when extending the template then only standard words should be
    added. Words which are local extensions should be added to a cGmyXXX.emfcA.

    Jasspa would appreciate completed template definitions.


cEcESEE ALSO cEcA


    lsfaq06(0f)lmFAQ06le

    lsFrequently Asked Questionslm[FAQ Index]le.
! 0ffaq08
cEcEQUESTION (08) cEcA


    Input locked up and not accepting keys; how do I unlock ?


cEcEANSWER cEcA


    This sometimes happens if a macro has been aborted badly. Typically a few
    "Ctrl-G"s (see lslmabort-command(2)le) will terminate the macro and return
    control back to the caller.

    lsFrequently Asked Questionslm[FAQ Index]le.
! 0ffaq09
cEcEQUESTION (09) cEcA


    MicroEmacs Bindings; How do I get the original MicroEmacs bindings ?


cEcEANSWER cEcA


    From lslmuser-setup(3)le set the Emulation to "cGMicroEmacs v3.8cA". On re-starting
    (or Current) the macro file cGmeme3_8.emfcA is executed and the bindings
    loaded. This file should restore your familiar execution set.

    lsFrequently Asked Questionslm[FAQ Index]le.
! 0ffaq10
cEcEQUESTION (10) cEcA


    Microsoft Windows Locks up after killing an ipipe.


cEcEANSWER cEcA


    This is a known problem for '95/'98 (not NT), on killing an ipipe.
    Sometimes the "Winoldapp" locks up, if this is the case use "Alt-Ctrl-Del"
    to bring up the "cDClose ProgramcA" dialogue, kill off the "cGWinOldAppcA" if it
    is not responding.

    MicroEmacs will then come back. We are looking for ways around this
    problem at the moment. From the programming perspective Windows is just
    not as nice as UNIX - which just works !!

    lsFrequently Asked Questionslm[FAQ Index]le.
! 0ffaq11
cEcEQUESTION (11) cEcA


    Mouse support under Microsoft windows is strange !!


cEcEANSWER cEcA


    The mouse operation under Microsoft windows (and DOS) is biased towards a
    3-button mouse operation (Logitech is ideal !!), operating in a similar
    way to UNIX. i.e. <select> operation gets text <Middle button> yanks text
    back.

    This stems from the fact that we all came from UNIX backgrounds. We have
    had a number of comments about this already and do plan to address this
    issue.

    cDNote:-cA Those of you that have already had a little dip into the operation
    of the mouse will have probably worked out that the whole of the visible
    mouse/screen interaction is driven through macros, so this functionality
    is actually a macro change.

    lsFrequently Asked Questionslm[FAQ Index]le.
! 0ffaq12
cEcEQUESTION (12) cEcA


    Scroll bars too narrow !!


cEcEANSWER cEcA


    You can change the width of the scroll bars to double width from
    lslmuser-setup(3)le "Wide Scroll Bars". Alternatively, you may do this yourself
    from cG<user>.emfcA by:-
sB
        set-variable $scroll-bar &bor $scroll-bar 1

sA
    See lslm$scroll-bar(5)le.

    Remember if you have enabled wide scroll bars, under windows, or
    X-Windows, you may want to change your start-up screen width to cG82cA
    characters rather than cG80cA - see lslmchange-frame-width(2)le.

    lsFrequently Asked Questionslm[FAQ Index]le.
! 0ffaq13
cEcEQUESTION (13) cEcA


    Tab key; Why does the tab key not operate in some windows ??


cEcEANSWER cEcA


    In buffers with indentation information the tab key re-computes the
    indentation of the line. This behavior may be changed from the user-setup.

    Refer to documentation for lslm$system(5)le and lslmuser-setup(3)le.

    lsFrequently Asked Questionslm[FAQ Index]le.
! 0ffaq14
cEcEQUESTION (14) cEcA


    Termcap; On a color terminal why is there no color ??


cEcEANSWER cEcA


    MicroEmacs has to be enabled to show color by default. From lslmuser-setup(3)le
    enable "Termcap Color". This will give you basic colors.

    You may also try enabling "With Bold" - this may increase the range of
    colors.

    lsFrequently Asked Questionslm[FAQ Index]le.
! 0ffaq15
cEcEQUESTION (15) cEcA


    Termcap; Some of the keys do not work - how can I bind them ?


cEcEANSWER cEcA


    In your user setup <user>.emf add the new keys. You have to be careful as
    to the environment and probably need to do something like the following:-
sB
        ; First check we are not an Xterm
        !if &not $use-x
            ; Quick check on the terminal type. We probably need to
            ; distinguish between terminal types for different bindings
            !if &seq $TERM "myterm"
                translate-key "<from>" "<to>"
                ...
                translate-key "<from>" "<to>"
            !endif
        !endif

sA
    See lslmtranslate-key(2)le for details of translating termcap keys. See
    lslmdescribe-key(2)le to help identify the key.

    lsFrequently Asked Questionslm[FAQ Index]le.
! 0ffaq16
cEcEQUESTION (16) cEcA


    Timestamp; Format incorrect, how can I change to MMDDYY.hhmm ?


cEcEANSWER cEcA


    From within your cC<user.emf>cA set the time stamp default format i.e.
sB
        set-variable $timestamp "<%M%D%Y.%h%m>"

sA
    See lslm$timestamp(5)le.

    lsFrequently Asked Questionslm[FAQ Index]le.
! 0ffaq17
cEcEQUESTION (17) cEcA


    Windows; Component characters rendered incorrectly, how do I fix ?


cEcEANSWER cEcA


    If some of the components of the windows are rendered incorrectly,
    typically caused by local variations of character sets, then new window
    component characters may be defined. See lslm$window-chars(5)le for details on
    how to define new character replacements.

    lsFrequently Asked Questionslm[FAQ Index]le.
! 0ffaq18
cEcEQUESTION (18) cEcA


    Windows Autosave and Backup files; are these potentially a problem ?


cEcEANSWER cEcA


    For windows '95 up until OEM service release 2, the OS could not
    distinguish the difference between the files:-

        .xxx
        .xxx~


    on a read, we have managed to find a work around for this, however we
    would advise that the 3 letter extension is adhered to for these releases.
    For releases of '95 OEM service release 2 and greater, '98 and NT we have
    not found a problem with any of the auto save and backup naming.

    Obviously, the backup naming will depend on the native file system. For
    instance if your system administrator has not enabled long file names on
    your Novel server.

    lsFrequently Asked Questionslm[FAQ Index]le.
! 0ffaq19
cEcEQUESTION (19) cEcA


    Printing; Why in Windows does the output come out in a buffer ??


cEcEANSWER cEcA


    Use the cDFilecA -> cDPrinter SetupcA dialog and change the destination to the
    "cDDirect to printercA".

    lsFrequently Asked Questionslm[FAQ Index]le.
! 0ffaq20
cEcEQUESTION (20) cEcA


    Printing; On Windows which font should I use ??


cEcEANSWER cEcA


    We suggest that "cDCourier NewcA" is used as the print font. This scales well
    and supports the full character set. Problems have been reported with
    networked postscript printers when used in conjunction with fixed fonts.

    lsFrequently Asked Questionslm[FAQ Index]le.
! 0ffaq21
cEcEQUESTION (21) cEcA


    Printing; My printer is not supported ?


cEcEANSWER cEcA


    We are in the process of providing native postscript generation - UNIX
    users can stream their output through "a2ps" and then into their standard
    printer queues.

    Windows, the support is already built in.

    For DOS then you need to get your printer manual out and sort out how to
    map the printer codes onto fonts. The printer codes are added to
    "cGprinter.erfcA". We have already provided support for the HP DeskJet printer
    (PCL), look at this printer definition for some help as to the type of
    information that you need to set up. It's all a bit fiddley, but you do
    not get much choice if you want more than plain ASCII out.

    lsFrequently Asked Questionslm[FAQ Index]le.
! 0ffaq22
cEcEQUESTION (22) cEcA


    Alt key maps to the Menu, how do I change ?

    A-f opens the main File menu instead of executing forward-word (esc f).
    How do I make the Alt key act like the Meta key all the time?


cEcEANSWER cEcA


    The cDMetacA key (typically cGAltcA) may be bound to key strokes, as opposed to
    the menu short-cut from the lslmuser-setup(3)le as follows:-

        cDToolscA -> cDUser SetupcA -> cDGeneralcA -> cDAlt Action: Main Menu Hot-keyscA = N
        cDToolscA -> cDUser SetupcA -> cDGeneralcA -> cDAlt Action: Esc PrefixcA = Y

    lsFrequently Asked Questionslm[FAQ Index]le.
! 0ffaq23
cEcEQUESTION (23) cEcA


    me32.ini - Where does it go, how do I know it's being processed ??


cEcEANSWER cEcA


    Question posed as:-

        > 1)  Am I right in assuming that for NT the file me32.ini goes
        >     into  %windir%, i.e. into c:


    Yes, this is where the other .ini files are.

        > 2)  How do I know me32.ini is being processed?  Creating one,
        >     as described in the readme.txt file doesn't seem to have
        >     any visible effect.


    From within the editor, if you show the variable lslm$MEPATH(5)le, then it
    should echo the paths that you have defined in the me32.ini file.

        esc-x describe-variable
        $MEPATH


    See: lslmme32.ini(8)le, lsInstallation(1)lmInstallation Informationle, lsUserProfiles(2)lmSetting Up A User Profilele.

        > 3) What does the "fontfile" statement do ?


    For releases after May 1999 then the cCfontfilecA statement may be omitted as
    typically cDLucida ConsolecA or cDCourier NewcA is used. If you want to use the
    fixed OEM fonts then cCfontfilecA should be defined as cDapp860.foncA (or local
    language equivalent), this forces the font to be loaded as a resource,
    prior to use.

    lsFrequently Asked Questionslm[FAQ Index]le.
! 0ffaq24
cEcEQUESTION (24) cEcA


    Windows - Where is app850.fon ?


cEcEANSWER cEcA


    "app850.fon" is the font file used for the DOS window under '95/'95/NT.
    You should find it in your c: hidden. If you search from the
    Explorer->Tools->Find "app850.fon" it should be found in the fonts
    directory. There is nothing to be done - the file exists and is in the
    correct location.

    If you do not have this file then, you might have "appXXX.fon", or some
    other fixed font. You can locate the file that you want as follows:-

        Start->Settings->Control Panel->Fonts

    Display the font list as 'details'. Within that list you should find a
    "MS-DOS CPXXX" entry. It will be a red font (if you are in monochrome then
    it will have a 'A' in the box rather than a 'Tt'). This is a fixed font
    and will be a good alternative to "app850.fon", you can also try the
    "Fixedsys" font file which has some weird name.

    To be honest I do not know what Microsoft are currently shipping. Most of
    the Windows platforms that I have used have been upgrades or been abused
    by so many people you never know what is original !!

    We would be interested in any details of other fixed fonts, which support
    the full OEM character set that are better alternatives to the DOS ones.

    lsFrequently Asked Questionslm[FAQ Index]le.
! 0ffaq25
cEcEQUESTION (25) cEcA


    Time; mode line is showing the date in DD/MM/YY format how do I change ?


cEcEANSWER cEcA


    From within your user setup, over-ride the default mode line setting with
    the modifications you require. i.e. to change the date format to MM/DD/YY
    use:-
sB
        set-variable $mode-line "%s%r%u%k %b %l - %h:%m %M/%D/%Y (%e) - (%f) "

sA

cEcESEE ALSO cEcA


    lslm$mode-line(5)le.

    lsFrequently Asked Questionslm[FAQ Index]le.
! 0ffaq26
cEcEQUESTION (26) cEcA


    C or C++ indentation and effects; how can I turn off ?


cEcEANSWER cEcA


    The C mode indentation is supposed to make editing 'C' easier, by forcing
    the user to follow a preset editing convection. The layout is pretty
    standard, following a 4 space indent, writing either K&R or standard
    'Pascal' type layout, with braces aligning vertically.

    The problem most new users have is the inability of the tab key to
    function, or more simply do not want to be 'forced' to write in a
    particular style (GNU writers will probably not like this either -
    conversely they will be using GNU emacs !!). However the constrained
    layout can be configured to create most styles and does help in a project
    situation, whereby most of the authored code roughly adheres to the same
    sort of layout conventions. For C++ users then edit "cGhkcpp.emfcA" rather
    than "cGhkc.emfcA".


cETo turn off all automatic 'C' layout cA


    To disable ALL automatic layout in C and C++ files then from the menu

        help -> Buffer Setup -> Setup Auto Indent


    Or from the command line cDesc x buffer-setupcA and disable through the
    dialogue.

    Restart the editor.


cETo re-enable the <tab> key cA


    To retain the 'C' layout aid, but re-enable the tab key operation then
    disable the cDTab To IndentcA option in lslmuser-setup(3)le i.e.

        cDToolscA -> cDUser SetupcA -> cDGeneralcA -> cDTab To IndentcA

    This enables the use of the TAB key in all column positions with the
    exception of column 0. A <tab> in Column 0 will still enable the automatic
    line re-formatting.

    If you want real <Tabs> then disable the cDtabcA mode using lslmuser-setup(3)le i.e.

        cDToolscA -> cDUser SetupcA -> cDGeneralcA -> cDTabcA


cETo change the 'C' Indentation Layout cA


    The 'C' layout indentation is controlled from the lslmindent(2)le command (see
    cGhkc.emfcA), the indentation level is controlled by the variables
    lslm$buffer-indent-width(5)le and lslm$buffer-indent(5)le these may be changed in the
    cDBuffer SetupcA dialog.

    lsFrequently Asked Questionslm[FAQ Index]le.
! 0ffaq27
cEcEQUESTION (27) cEcA


    fill-paragraph function does not fill ??

    I can't seem to get the fill-paragraph function to fill the following
    paragraph:

        This is a very
        poorly formed paragraph
        which refuses to fill
        properly!


cEcEANSWER cEcA


    The default justification mode is Auto which tries to work out the mode
    required for each paragraph. Its fairly smart at maintaining a documents
    indentation, e.g. consider the example right hand justified:

                                                            This is a very
                                                   poorly formed paragraph
                                                     which refuses to fill
                                                                 properly!


    It will maintain this indentation. The problem comes when the detected
    form is not the required form as in the example. The detected paragraph
    justification to be used is "none" because the lines are short. There are
    2 ways to solve this problem:

        * You can change the lslm$fill-mode(5)le to left or both (in fhook-doc mode
          use C-c l or C-c b) and then use fill-paragraph as normal.
        * Manually concatenate the first few lines into one to create a longer
          first line and then use the fill-paragraph a normal, i.e. change the
          paragraph to:

        cGThis is a very poorly formed paragraph which refuses to fillcA cGproperly
        !cA

        and then fill. This works because the longer line will lead to a
        different assessment of what's required.

    lsFrequently Asked Questionslm[FAQ Index]le.
! 0ffaq28
cEcEQUESTION (28) cEcA


    Key modifier which acts as the ESC key; what is it ?

    What is the modifier key which acts as the ESC key ? Having to type ESCAPE
    and then f to move one word forward is very boring.

    With Gnu Emacs (on Unix systems), there is a "meta" modifier key which is
    a shortcut for pressing ESCAPE followed by the command key. The "meta" key
    should be the "Alt" key.


cEcEANSWER cEcA


    The "meta" key is the "Alt" key. But 'F' is the Main menu hot-key for the
    'File' sub-menu so by default 'A-f' will open the File sub-menu. This can
    be disabled by clearing bit 0x2000 in the $system variable. This option
    can now be set using user-setup (Alt -> Main Menu).

    lsFrequently Asked Questionslm[FAQ Index]le.
! 0ffaq29
cEcEQUESTION (29) cEcA


    find-file start location; where is it ?


cEcEANSWER cEcA


    The lslmfind-file(2)le start location is defined as follows:-

        * cG*scratch*cA is current buffer; the current working directory.
        * cGfilecA is current buffer; the directory location containing cCfilecA.

    Running under Microsoft Windows or UNIX, using an icon launch, then it may
    become frustrating that the start location is always cGC:\ProgramcA
    cGFiles\JASSPA\MicroEmacscA (Microsoft windows) or cG/usr/local/bincA (UNIX) this
    is simply resolved by starting the executable with the cD-ccA option, as
    defined by lslmme(1)le. The cD-ccA option starts the editor with the last editing
    session, this is typically where a user will want to commence an editing
    session.

    If the cD-ccA approach is not acceptable, then it is worth defining the
    environment variable cG$HOMEcA within the start up script, or in the users
    environment. Using cDfind-filecA with tilde (cG~cA) implies that the directory
    start path is cG$HOMEcA.

    lsFrequently Asked Questionslm[FAQ Index]le.
! 0ffaq30
cEcEQUESTION (30) cEcA


    Re-using a MicroEmacs session; how to ??


cEcEANSWER cEcA


    A MicroEmacs editing session may be re-used, such that the current editor
    is prompted to load a new file externally. This is typically invoked from
    a short-cut launch from a file manager i.e. cDExplorer(1)cA, cDTkdesk(1)cA etc.

    In order to facilitate the re-use of the session, then lslmme(1)le is invoked
    with the cD-ocA option, this locates the active editor session and passes the
    file load request. If an existing session does not exist then a new
    session is started.

    In order for this mechanism to operate, then the lsClient-Server(2)lmClient-Server Interfacele
    must be enabled from the lslmuser-setup(3)le i.e.

        [cDToolscA -> cDUser SetupcA -> cDPlatformcA -> cDClient ServercA = cGYcA]

    lsFrequently Asked Questionslm[FAQ Index]le.
! 0ffaq31
cEcEQUESTION (31) cEcA


    Drag and Drop; is it supported ??


cEcEANSWER cEcA


    MicroEmacs 2009 supports Microsoft and UNIX XDND (Gnome/KDE) cCdrag-and-dropcA
    interaction. Multiple files and directories may be dragged from Microsoft
    Explorer, Nautilus (or other application) and dropped into a buffer
    window. The destination buffer window is the window in which the dropped
    file(s) are displayed.

    cDNotecA if the user is currently on the command line, then the command line
    operation is aborted in order to facilitate the cCdroppedcA files.

    lsFrequently Asked Questionslm[FAQ Index]le.
! 0ffaq32
cEcEQUESTION (32) cEcA


    Cut and Paste to/from other applications; is it supported ??


cEcEANSWER cEcA


    MicroEmacs 2009 supports cCcut and pastecA operations on all platforms.

    To copy a region from MicroEmacs 2009 to another application
        Select a region (with the mouse or keys) - there is no need to invoke
        a copy operation. All selected text is immediately available to other
        applications.

        Move to the new application and paste, as dictated by the platform.

    To copy a region from another application to MicroEmacs 2009
        Select the region in the application into the clipboard, as dictated
        by the platform.

        Move to MicroEmacs 2009, position the cursor and lslmyank(2)le (cGC-ycA or
        typically the middle mouse button) the clipboard text.

    lsFrequently Asked Questionslm[FAQ Index]le.
! 0ffaq33
cEcEQUESTION (33) cEcA


    Fonts; how can I change the font ??


cEcEANSWER cEcA


    The currently selected font may be modified from the lslmuser-setup(3)le.

        cDToolscA -> cDUser SetupcA -> cDPlatformcA

    The font selection depends upon the platform, in all cases a fixed font
    should be selected, otherwise rendering anomalies will result.

    If you are running on Microsoft platforms ensure that the cDOEM/ANSIcA flag
    matches the settings of the cDDisplay Font SetcA entry.

    lsFrequently Asked Questionslm[FAQ Index]le.
! 0ffaq34
cEcEQUESTION (34) cEcA


    Colors; how can I change screen colors ??


cEcEANSWER cEcA


    The screen colors are selected from the lslmuser-setup(3)le.

        cDToolscA -> cDUser SetupcA -> cDPlatformcA -> cDColor SchemecA

    The default setting is cCWhite on BlackcA, the cCBlack on CreamcA is the most
    popular setting.

    lsFrequently Asked Questionslm[FAQ Index]le.
! 0ffaq35
cEcEQUESTION (35) cEcA


    File Types; how do I interchange between UNIX, Windows and DOS files ??


cEcEANSWER cEcA


    MicroEmacs 2009 facilitates the editing of the standard file types on all
    platforms. All files retain their line ending type through edits. i.e. if
    a DOS file is edited on a UNIX system, the file is still written as a DOS
    file. When new files are created, they are created with the standard
    attributes of the host O/S.

    The line ending of the file may be modified from the menu

        cDfilecA -> cDattributescA

    This brings up a dialog that allows the file type and attributes to be
    modified.

    Note that the only ending that is NOT preserved are files whose lines end
    in cG<CR>cA's only. The line format is correctly interpreted on reading, but
    is not retained on the write.

    lsFrequently Asked Questionslm[FAQ Index]le.
! 0ffaq36
cEcEQUESTION (36) cEcA


    Non-English Languages; What font should I select ??


cEcEANSWER cEcA


    MicroEmacs 2009 has only been tested with Western Lanuguages only. Within
    the Microsoft Windows environment an ANSI type font should be selected,
    assuming of course that the characters required are in the ISO-Latin
    character set. UNIX typically supports ISO-Latin character sets.

    lsFrequently Asked Questionslm[FAQ Index]le.
! 0ffaq37
cEcEQUESTION (37) cEcA


    MicroEmacs '99; How do I up-grade from MicroEmacs'98 ??


cEcEANSWER cEcA


    Backup your current version!

    Follow the MicroEmacs'99 installation procedure to install and get
    MicroEmacs'99 running.

    Due to the great improvement to lslmuser-setup(3)le it is advised that the user
    creates a new setup using cDuser-setupcA and then migrates required macro code
    changes from the old release into the new.

    lsFrequently Asked Questionslm[FAQ Index]le.
! 0ffaq38
cEcEQUESTION (38) cEcA


    Some keys on my foreign keyboard do not work properly, how do I get them
    working ??


cEcEANSWER cEcA


    The most common problem are with foreign keyboards where the <AltGr> key
    is used to generate some characters in a similar fashion to the <Shift>
    key. For example, on a Belgian keyboard the '9' key produces a '{'
    character when the <AltGr> key is also pressed.

    The quickest and best solution is to use the cDKeyboardcA setup on the
    Start-Up page of lslmuser-setup(3)le. This however may not provide the solution
    as not all keyboards are currently supported. If you are using an
    unsupported keyboard please send configuration information back to JASSPA
    for inclusion in the next release. The keyboard configuration information
    is stored in the macro file cGkeyboard.emfcA.

    If cDuser-setupcA does not currently support your keyboard, or you wish to
    remap some keys, then the command lslmtranslate-key(2)le should be used.
    cDtranslate-keycA remaps generated key stroke(s) into another key at a low
    level so the mapping is supported in all areas. If a macro and key binding
    were used instead, while they would work in the main text windows, they
    would not work in the message line. See help on cDtranslate-keycA for more
    information.

    Note that some <AltGr> keys can produce 2 keys, for example on a Belgian
    keyboard '<AltGr>-9' produces the key 'A-C-9' first, immediately followed
    by 'A-C-{'. This is an unfortunate side effect of windows, it is better to
    have two keys rather than none. But this does add confusion to the
    problem! Again, see cDtranslate-keycA for more information.

    lsFrequently Asked Questionslm[FAQ Index]le.
! 0ffaq39
cEcEQUESTION (39) cEcA


    Tabs; How to change the tab width ??


cEcEANSWER cEcA


    lslm$tab-width(5)le controls the size of the displayed tab character (number of
    spaces) and the simulated tab character size, where the user entered tab
    character is replaced by a number of space characters. The latter is only
    used when lslmtab(2m)le mode is enabled (it is typically enabled by default).

    To change the tab character width then the lslmset-variable(2)le command is
    used:

        esc x set-variable


    You will then be prompted for the remaining arguments. cG<TAB>cA is the
    completion so:-

        esc x set-v<TAB>
        $tab-width<TAB>
        2


    If this is the setting that you always want to use then it is easier if
    you put this in your <user.emf> as:-
sB
        set-variable $tab-width 2

sA
    then whenever you start a new session you will always have the $tab-width
    defined as you want it.

    If you are reading in a file with TAB's embedded then you can convert all
    of the <TAB>'s to spaces using lslmtabs-to-spaces(3)le:

        esc x tabs-to-spaces


    lsFrequently Asked Questionslm[FAQ Index]le.
! 0ffaq40
cEcEQUESTION (40) cEcA


    Windows/DOS; Where do I get grep/diff etc. ??


cEcEANSWER cEcA


    For windows and DOS users the UNIX tools may be obtained from:-

        ftp://ftp.cdrom.com/pub/garbo/garbo_pc/unix/uxutl23a.zip (238 Kb)
        ftp://ftp.cdrom.com/pub/garbo/garbo_pc/unix/uxutl23b.zip (227 Kb)
        ftp://ftp.cdrom.com/pub/garbo/garbo_pc/unix/uxutl23c.zip (221 Kb)
        ftp://ftp.cdrom.com/pub/garbo/garbo_pc/unix/uxutl23d.zip (160 Kb)


    comments for this at:

        http://www.geocities.com/SiliconValley/Lakes/1401/softlib1.htm


    One awk-port; the Gnuish project has 16 bit and 32 bit versions of cDgawk(1)cA
    in:

        ftp://mirrors.aol.com/pub/simtelnet/gnu/gnuish/gawk303x.zip (1997, 495K)


    Acknowledgment: cDDGcA - 99/07/02

    lsFrequently Asked Questionslm[FAQ Index]le.
! 0ffaq41
cEcEQUESTION (41) cEcA


    Home/End Keys; How do I change the default bindings ??


cEcEANSWER cEcA


    Some users prefer the cGHOMEcA and cGENDcA keys to map to the beginning and end of
    the line, rather than beginning/end of the buffer, respectively. Within
    the cC<user>.emfcA the following global bindings may be applied to re-assign
    the key mappings:-
sB
        global-bind-key "beginning-of-buffer" "C-home"
        global-bind-key "end-of-buffer"       "C-end"
        global-bind-key "end-of-line"         "end"
        global-bind-key "beginning-of-line"   "home"

sA
    Acknowledgment: cDDGcA - 99/07/02

    lsFrequently Asked Questionslm[FAQ Index]le.
! 0ffaq42
cEcEQUESTION (42) cEcA


    tags; How do I generate a MicroEmacs compatible tags file ??


cEcEANSWER cEcA


    A cDtagscA file is used by the lslmfind-tag(2)le command. This is used to hypertext
    to the cCtaggedcA definition or variable. The standard cDctags(1)cA format is used
    by MicroEmacs. The cDtagscA file itself may be generated by MicroEmacs 2009
    from the menu (cCTools->XX Tools->Create Tags FilecA). Alternatively a cDtagscA
    file may be generated by the cDctags(1)cA utility. This is typically standard
    on UNIX platforms. For Windows and DOS platforms then the cDExuberant CtagscA
    is recommended, this is available from:-

       cG http://darren.hiebert.comcA

    A MicroEmacs 2009 compatible tags file may be generated using the command
    line "cGctags -N --format=1 ."cA cataloging the current directory. To generate
    cDtagscA for a directory tree then use "cGctags -NR --format=1 .cA". Refer to the
    cDExuberant CtagscA documentation for a more detailed description of the
    utility.

    The user variable lslm%tag-option(5)le may be used to enable lslmfind-tag(2)le to
    locate a recursivelly generated cDtagscA file from a parent directory.

    lsFrequently Asked Questionslm[FAQ Index]le.
! 0ffaq43
cEcEQUESTION (43) cEcA


    ne; how can I enable line wrapping in NE ??


cEcEANSWER cEcA


    The line wrapping feature is controlled by the wrap buffer-mode in ME but
    this feature is omitted in NE. To get the size of NE down many features
    have to be disabled including the wrap mode and fill-paragraph.

    To enable then you have to build your own version of NE with this enabled
    by changing the 2nd MEOPT_WORDPRO settings in "emain.h" to 1.
    Alternatively rename your ne.emf to me.emf and use 'me' instead of ne.

    Once it is built and you want to edit a text file then you need to enable
    WRAP and INDENT mode in the buffer for it to behave correctly. WRAP does
    the wrap to the next line and INDENT maintains the left indentation.
    fill-paragraph is present.

    lsFrequently Asked Questionslm[FAQ Index]le.
! 0fFAQs
!3  faqs - FAQ Contact information
cEcEFREQUENTLY ASKED QUESTIONS - Contact Information cEcA


    This document contains frequently asked questions submitted to JASSPA. Use
    the E-Mail reflector and associated logs, described in the lsMicroEmacs - Contact InformationlmContactln
    lnInformationle section, alternatively questions may be submitted to:-

        cGEmail:support@jasspa.comcA

    We cannot promise to resolve all questions, but will endeavor to answer
    most. We would also appreciate comments on how to improve the readability
    of the documentation or suggestions for improvements where you think the
    documentation is deficient.

    lsFrequently Asked Questionslm[FAQ Index]le.
! 1 me
cEcENAME cEcA


    me - MicroEmacs 2009 text editor


cEcESYNOPSIS cEcA


    cDmecA [cCoptionscA] [cCfiles ...cA]

    cDmecA [cD@cAcCstartupFilecA] [cD-cA] [cD-acA] [cD-bcA cCfilecA] [cD-BcA] [cD-ccA[cCsessionNamecA]] [cD-hcA] [cD-icA]
    [cD-kcA[cCkeycA] cCfilecA] [cD-lcAcClineNocA[cD:cAcCcolumncA]] [cD-mcAcCcommandcA] [cD-ncA] [cD-ocA] [cD-0cAcCfilecA] [cD-pcA [cD-PcA]
    ] [cD-RcA] [cD-rcA] [cD-scAcCstringcA] [cD-ucAcCusernamecA] [cD-vcAcCvariable=stringcA] [cD-VcA] [cD-xcA] [cD-ycA
    cCfilecA] cCfiles...cA


cEcEDESCRIPTION cEcA


    cDMicroEmacs 2009cA is a cut down version of the EMACS text editor, based on
    Danial Lawrences MicroEmacs. cDMicroEmacs 2009cA is a tool for creating and
    changing documents, programs, and other text files. It is both relatively
    easy for the novice to use, but also very powerful in the hands of an
    expert. MicroEmacs 2009 can be extensively customized for the needs of the
    individual user.

    cDMicroEmacs 2009cA allows multiple files to be edited at the same time. The
    screen may be split into different windows and screens, and text may be
    moved freely from one window on any screen to the next. Depending on the
    type of file being edited, cDMicroEmacs 2009cA can change how it behaves to
    make editing simple. Editing standard text files, program files and word
    processing documents are all possible at the same time.

    There are extensive capabilities to make word processing and editing
    easier. These include commands for string searching and replacing,
    paragraph reformatting and deleting, automatic word wrapping, word move
    and deletes, easy case controlling, and automatic word counts.

    For complex and repetitive editing tasks editing macros can be written.
    These macros allow the user a great degree of flexibility in determining
    how cDMicroEmacs 2009cA behaves. Also, any and all the commands can be used by
    any key stroke by changing, or re-binding, what commands various keys
    invoke.

    Special features are also available to perform a diverse set of operations
    such as file encryption, automatic backup file generation, en-tabbing and
    de-tabbing lines, executing operating system commands and filtering of
    text through other programs.

    The command line options to cDMicroEmacs 2009cA are defined as follows:-

    cD@cAcCstartFilecA
        Initialize MicroEmacs 2009 using cCstartFilecA[cD.emfcA]. The default when
        omitted is cDme.emfcA. See lslmstart-up(3)le and lslmCommand Line Filtersle for more
        information.

    cD-cA
        Pipe cCstdincA into buffer cD*stdin*cA, when the buffer is saved the output is
        written cCstdoutcA. Following is a simple example which changes 'cGacA's to
        'cGbcA's:
sB
                define-macro start-up
                    find-buffer "*stdin*"
                    beginning-of-buffer
                    replace-string "a" "b"
                    save-buffer
                    quick-exit
                !emacro

sA
        This can be used in the following manner:

                me "@testpipe.emf" < foo.a > foo.b


    See cD-pcA for disabling user interaction and the help page for command
    lslmml-write(2)le for a further example.

    cD-acA
        Toggle the auto-save mode, this toggles the lslmauto(2m)le mode.

        cDNote:cA that NanoEmacs disables auto save mode by default and MicroEmacs
        enables auto save mode by default. The behavior of cD-acA is therefore
        different between the two editors.

    cD-bcA
        Load next file as a binary file (binary editor mode, uses lslmbinary(2m)le
        buffer mode).

    cD-BcA
        Toggle the backup mode, this toggles the lslmbackup(2m)le mode.

        cDNote:cA that NanoEmacs disables backup mode by default and MicroEmacs
        enables backup mode by default. The behavior of cD-BcA is therefore
        different between the two editors.

    cD-ccA[cCsessionNamecA]
        Continuation mode. Load the cDMicroEmacs 2009cA last edit session,
        restoring the buffers to their previous loaded state when history mode
        is enabled. The cD-ccA option is generally used with windowing interfaces
        (X-Windows/Microsoft Windows) as the shortcut icon invocation.

        If the optional session name cCsessionNamecA is specified then the session
        file cCsessionNamecAcD.esfcA is loaded restoring the previous editing session
        including the buffer window size, position and layout, the buffer mark
        and cursor location, main window size. When the cCsessionNamecA includes
        space characters then the command line option should be bracketed e.g.
        cG"-cFoo Bar"cA. On a session restore then no additional files to load
        should be included on the command line as this will not enable the
        original window configuration to be restored as the window
        configuration will change. See lslmread-session(3)le for further
        information.

        If the cCsessionNamecA is omitted then the default session file
        cCusernamecAcD.esfcA is loaded (see lslmesf(8)le) restoring the previously loaded
        buffers however the window layout and position is not restored. The
        default cCsessionNamecA is the login name lslm$MENAME(5)le.

    cD-hcA
        Show the help page (does not start the editor).

    cD-icA
        MS-DOS versions of cDMicroEmacs 2009cA only. Insert the contents of the
        current screen into the cD*scratch*cA buffer

    cD-kcA[cCkeycA]
        Load next file as an encrypted file (uses lslmcrypt(2m)le buffer mode). The
        optional adjoining argument can be used to specify the decrypting key,
        if this argument is not specify the user will be prompted for it on
        start-up.

    cD-lcAcClineNocA[cD:cAcCcolumncA]
        Go to line cClineNocA in the next given file and optionally to the
        specified column number. The column may be omitted if not required.
        Typically used with utilities such a cDmore(1)cA where an external editor
        may be invoked from other viewer.

    cD-mcAcCcommandcA
        Sends a lsClient-Server(2)lmclient-serverle command to an existing MicroEmacs session. The
        command takes the form "cDC:cAcC<client>cAcD:cAcC<command>cA" i.e. to write "cGHellocA
        cGWorldcA" on the message line then a client may issue the command:-

            ; launch server
            me &
            ; send message
            me -m "C:ME:ml-write \"Hello world\"


        Note that the cC<command>cA is a MicroEmacs macro command, the escape
        sequences must be adhered to. The cCclient-servercA interface is typically
        used to load a file, this may be performed as follows:-

            me -m "C:myutility:find-file \"/path/foo.bar\""


        The absolute path is specified in this type of transaction as the
        current working directory of the active MicroEmacs session is unknown.
        The cD-mcA option de-iconize's the existing editor session and bring it to
        the foreground.

    cD-ncA
        UNIX X-Windows environments only and MicroSoft Windows NT console
        versions. Execute cDMicroEmacs 2009cA using termcap rather than X-Windows
        for UNIX; typically used within an cDxtermcA shell to fire up cDMicroEmacs
        2009cA for a quick edit. For Microsoft Windows, a console window is
        started as opposed to a GUI window.

    cD-ocAcC<file>cA
        Use already running version of MicroEmacs 2009 to load the cC<file>cA, if
        it exists, otherwise start a new editor session. This uses the
        cCclient-servercA interface to push the new file into the existing editor
        session. Refer to the lsClient-Server(2)lmClient-Server Interfacele for details.

    cD-pcA
        Used with the cD-cA which inputs from cCstdincA and disables user interaction
        within MicroEmacs. To debug then the cD-PcA option may be used to enable
        debug on cCstderrcA. See the help pages for commands lslmml-write(2)le and
        lslmcommand-wait(2)le for examples of this option's use.

    cD-PcA
        Used with the cD-pcA option and is used for debugging the pipe mode,
        lslmml-write(2)le messages are displayed on cCstderrcA.

    cD-RcA
        Reverse the default video color scheme. The default foreground color
        becomes the background color and vice versa. This only affects the
        built in scheme and not any schemes defined in any start-up file.

    cD-rcA
        Read-only, all buffers will be in view mode

    cD-scAcCstringcA
        Search for string "cCstringcA" in the current buffer. e.g. cGme -sfoo barcA
        starts cDMicroEmacs 2009cA, loads file cGbarcA and initiates a search for cCfoocA.
        The cursor is left at the end of the string if located, otherwise at
        the top of the buffer.

    cD-ucAcCusernamecA
        Set the current user name lslm$user-name(5)le to cCusernamecA before MicroEmacs
        is initialized.

    cD-vcAcCvariable=stringcA
        Assign the MicroEmacs 2009 cCvariablecA with cCstringcA. The assignment is
        performed before the buffers are loaded. Typically used to change the
        start-up characteristics of the startup file(s).

    cD-VcA
        Print the name and version of MicroEmacs. i.e.

        cGorac% me -VcA
        cGMicroEmacs 06 - Date 2006/08/10 - sunoscA

    cD-xcA
        UNIX environments. Disable the capture of signals. cDMicroEmacs 2009cA by
        default captures an handles all illicit signal interrupts. The option
        is enabled when debugging the source code allowing exception
        conditions to be trapped within the debugger.

    cD-ycA
        Load next file as a reduced binary file (uses lslmrbin(2m)le buffer mode).


cEcEENVIRONMENT cEcA


    The following environment variables are used by cDMicroEmacs 2009cA.

    cDDISPLAYcA
        UNIX environments running X-Windows only. The identity of the
        X-Windows server. Typically set to cDunix:0.0cA, refer to the X-Windows
        documentation for details of this environment variable.

    cDMENAMEcA
        lslm$MENAME(5)le is used to override the identity of the user lslm$user-name(5)le.
        The variable may be used to determine which start-up configuration to
        use in the initialization of cDMicroEmacs 2009cA (cC$user-namecA.erf). This is
        ignored if the cD-ucA option is specified on the command line.

        Non-UNIX platforms usually need to explicitly set the cD$MENAMEcA
        environment variable to identify the aforementioned files. for MS-DOS
        and early versions of Microsoft Windows this is typically performed in
        the cGAUTOEXEC.BATcA file.

    cDPATHcA
        The cD$PATHcA environment variable is used on most operating systems as a
        search path for executable files. This cD$PATHcA environment variable must
        be defined with cDMicroEmacs 2009cA on the search path. Under UNIX this is
        set in the cG.logincA, cG.cshrccA or cG.profilecA file i.e.

            export PATH $PATH:/usr/name/me

        Within MS-DOS or Microsoft Windows environments it is defined in the
        cGAUTOEXEC.BATcA file. e.g.

            set PATH=%PATH%;c:\me

        cDMicroEmacs 2009cA utilizes information in the cD$PATHcA environment variable
        to locate the start-up files, dictionaries etc.

    cDTERMcA
        The terminal identification sting. In UNIX environments the
        environment variable cD$TERMcA is set to "cGvt...cA", in this case it is
        assumed that the machine is a server, and the host cannot support X
        (see command line option cD-ncA).

        In MS-DOS the environment variable is usually set to define the
        graphics adapter mode. cD%TERMcA is assigned a string, understood by the
        cGme.emfcA start-up file, to set the graphics mode. Predefined strings
        include:-

        cDE80x50cA
            Initiates an 80 column by 50 line screen.

        cDE80x25cA
            Initiates an 80 column by 25 line screen.

        cCuserDefinedcA
            A user defined string to set an explicit graphics card mode. The
            operation is dependent upon the support offered by the graphics
            adapter.

    cDMEINSTALLPATHcA
        lslm$MEINSTALLPATH(5)le is an environment variable that overrides any
        internally defined search path for MicroEmacs system macros and
        defines the root directory(s) of the MicroEmacs system macros. The
        presence of the environment variable affects lslm$search-path(5)le.

    cDMEUSERPATHcA
        lslm$MEUSERPATH(5)le is an environment variable that defines the users
        private directory where user configuration files such as
        ls$user-name(5)lm$user-namelecD.emfcA, ls$user-name(5)lm$user-namelecD.erfcA and personal spelling dictionaries are
        stored. This is an absolute directory path. The environment variable
        sets the MicroEmacs variable lslm$user-path(5)le.

    cDMEPATHcA
        lslm$MEPATH(5)le is an environment variable that may be used to define the
        absolute search path for MicroEmacs macro files and affects the
        setting of cD$search-pathcA. The path should include the system macros
        location(s) and should include the user directory location
        lslm$user-path(5)le as the first path when the environment variable
        lslm$MEUSERPATH(5)le is not defined. If cD$MEUSERPATHcA is defined then this
        path name appears before the cD$MEPATHcA variable to define the user
        directory location. cD$MEPATHcA is not searching, so ALL directories to be
        searched must be included in the path specification.

        lslm$MEUSERPATH(5)le is the preferred method used to defined the user
        directory.

    cDINFOPATHcA
        MicroEmacs 2009 uses the environment variable cG$INFOPATHcA as the
        directory(s) used to search for GNU cDInfocA files. Within the UNIX
        cG$INFOPATHcA is a semi-colon separated list of directories which are used
        to search for the MicroEmacs 2009 macro files. The path is searched
        from left to right. The environment variable is typically defined in
        the in the cG.logincA, cG.cshrccA or cG.profilecA file i.e.

            export INFOPATH /usr/local/info:$HOME/info

        The default when omitted is cG/usr/local/infocA.

        Within MS-DOS or Microsoft Windows environments it is defined in the
        cGAUTOEXEC.BATcA file. e.g.

            set MEPATH=c:\usr\local\info

        There is no default location in these environments. For Microsoft
        Windows environments refer to lslmme32.ini(8)le for a method of setting up
        the cG$INFOPATHcA from the windows configuration file.


cEcEFILES cEcA


    All of the macro files and dictionaries are located in the cDMicroEmacscA home
    directory. The standard file extensions that are utilized are:-

    cD.eafcA
        cDMicroEmacs 2009cA abbreviation file, defines completion definitions for
        buffer dependent text expansion.

    cD.edfcA
        A cDMicroEmacs 2009cA spelling dictionary. cC<language>cAcD.edfcA provide language
        specific dictionaries; cC$LOGNAMEcAcD.edfcA is personal spelling dictionary.

    cD.ehfcA
        cDMicroEmacs 2009cA help file information. On-line help information for
        emacs, the main file is cGme.ehfcA.

    cD.emfcA
        A cDMicroEmacs 2009cA macro file. The following classes of macro file
        exist:

        cDme.emfcA
            The default startup file.

        cC<platform>.emfcA
            A platform specify startup file, these include UNIX generic
            (cGunixterm.emfcA), UNIX specific (cGirix.emfcA, cGhpux.emfcA, cGunixwr1.emfcA,
            cGlinux.emfcA, cGsunos.emfcA etc), Microsoft Windows (cGwin32.emfcA), MS-DOS
            (cGdos.emfcA).

        cDhkcAcCxxxxxxcAcD.emfcA
            Buffer context specific hook files to initialize a buffer with
            macros and highlighting appropriate to the contents of the file
            type. e.g. 'C' language editing (cGhkc.emfcA), N/Troff typesetting
            (cGhknroff.emfcA), UNIX Manual page display (cGhkman.emfcA), Makefiles
            (cGhkmake.emfcA), etc.

    cD.erfcA
        Registry files, used to retain personal information, users history in
        the file etc.

    cD.etfcA
        Template files used to seed new files. Typically contains standard
        header information, copyright notices etc. that are placed at the head
        of files. The 'C' programming language is called cGc.etfcA


cEcEMICROSOFT WINDOWS cEcA


    Microsoft Windows environments should refer to lslmme32.ini(8)le for a method of
    setting up the environment variables without editing the cGAUTOEXEC.BATcA
    configuration file.

    Drag and drop support is provided in the Windowing version of MicroEmacs.
    The editor window is brought into focus following the drop.


cEcEUNIX cEcA


    Xdnd drag and drop support is provided in the X-Windows version of
    MicroEmacs. The editor window is not raised or brought into focus
    following the drop as expected in the UNIX environment.


cEcESESSIONS cEcA


    Reading a session is generally performed when a MicroEmacs session is
    started using the "cD-ccA" command line option rather than from the mode line
    or main menu, see lslmread-session(3)le. Invoking

        cDme -ccAcC<mySessionName>cA

    where cC<mySessionName>cA is the name of the session (the lslm$MENAME(5)le or system
    login name) will restore all of of the buffers, windows layout, point and
    mark positions, main window size etc. at the point of the last shut down.
    e.g. given a system login name of cCjasspacA then

        cDme -ccAcCjasspacA

    restores the session to the state when cCjasspacA last exited MicroEmacs. When
    the session name is specified then no other files should be specified, so
    the command line

        cDme -ccAcCjasspacA cGmorefiles.txtcA

    restores the buffers but does not restore the window layout because this
    has been destroyed by the introduction of the new file "cGmorefiles.txtcA".
    This type of command with another file behaves as the old "cGme -ccA" command
    prior to the 2006 release that did not support sessions. If
    cC<mySessionName>cA is not specified then the buffers are restored but the
    window layout is not restored.


cEcEHISTORY cEcA


    The 2006 release removed the cG-dcA command line option for debugging (not
    used) and added session support by extending the cG-ccA option with an
    optional cCsessionNamecA argument.


cEcESEE ALSO cEcA


    lslmread-session(3)le, lslm$MEINSTALLPATH(5)le, lslm$MENAME(5)le, lslm$MEPATH(5)le,
    lslm$MEUSERPATH(5)le, lslmemf(8)le, lslmerf(8)le, lslmesf(8)le, lslm$home(5)le, cDemacs(1)cA [GNU], cDmore(1)cA,
    lslmne(1)le, cDvi(1)cA.
    lsClient-Server(2)lmClient-Server Interfacele.
    lslmCommand Line Filtersle.
! 1 memsdev
cEcENAME cEcA


    memsdev - Microsoft Developer Studio Add-in for MicroEmacs 2009


cEcESYNOPSIS cEcA


    cDmemsdev.dllcA


cEcEDESCRIPTION cEcA


    cDmeMsdevcA is a Microsoft Visual Studio Add-In that allows MicroEmacs 2009 to
    be integrated as the default text editor. It will be used instead of the
    Visual Studio built in editor when you double click on a file or press F4.

    cDmeMsdevcA may not be supplied built and should be built using Microsoft
    Developer Studio.


cEcEINSTALLATION cEcA


    cD1)cA Copy mesdev.dll into the MicroEmacs directory i.e.

        c:/Program Files/JASSPA/MicroEmacs


    cD2)cA Edit the lslmme32.ini(8)le file in your Windows directory and identify the
    location of the MicroEmacs executable. The executable name is used to
    spawn MicroEmacs if it is not already running. The entry takes the form:-

        ; Identify the location of the MicroEmacs executable so that the
        ; Developer Studio "Add-In" can locate the executable
        [Location]
        exe=c:\Program Files\JASSPA\MicroEmacs\me32.exe


    Change the cCexecA entry to match the location and name of your executable.

    cD3)cA For MS-DEV V5.0 only; from a DOS box, register the DLL using
    cDregsvr32.exe(1)cA i.e.

        > cd c:/Program Files/JASSPA/MicroEmacs
        > regsvr32 memsdev.dll


    For MS-DEV V6.0 it is not necessary to perform this registration step.

    cD4)cA Start Visual Studio and goto:-

        Tools
            Customize...
                Add-Ins and Macro Files


    cD5)cA Click on cCBrowsecA and point Visual Studio to your cDmemsdev.dllcA file.

    cD6)cA Click the check box to indicate that you want to use the Add-In, and
    close the Customize dialog box.

    cD7)cA You should notice the MicroEmacs tool bar showing the MicroEmacs Icon.
    This invokes a dialog that allows you to attach and detach MicroEmacs as
    the default editor.


cEcEUSING meMsdev cEcA


    Clicking on the MicroEmacs Tool bar shows the meMsdev configuration
    dialog. Check the boxes when MicroEmacs edit session is required as
    default; uncheck the boxes if you wish to revert to the built-in dialog.

    Use Visual Studio as normal, and MicroEmacs should almost always bring
    MicroEmacs to the foreground to edit the document. If a MicroEmacs is
    already running then "meMsdev" will attach to an existing session and will
    load the file. If MicroEmacs is not detected then a new version is spawned
    off and then an attachment is made.


cEcERUNNING A DEBUG SESSION cEcA


    cDmeMsdevcA does not currently provide any debugging capability (but we are
    working on it !!). To start debugging it is suggested that the Editor is
    decoupled cC(MicroEmacs Dialogue -> Uncheck Boxes)cA and work within the
    Developer studio.

    When you have finished debugging and wish to move back to an edit session
    then re-enable MicroEmacs cC(MicroEmacs Dialogue -> Check Boxes)cA AND close
    any windows that are open within the MS-Dev environment (
    cCWindow->Windows...->Select AllcA and cCClose All WindowscA). Then commence
    editing again.

    While MicroEmacs is attached, selecting any of the find file lines,
    compilation error lines etc within the response panes will take MicroEmacs
    to the specified line.


cEcEBUGS cEcA


    cDmeMsdevcA works by hooks exposed by Visual Studio. Most of the functionality
    works from the OpenDocument (look it up in VS 5) hook. So...If a document
    is ALREADY open in Visual Studio, and you double click the file in the
    File Browser...Emacs will NOT come to the foreground. Since the document
    was open in the Visual Studio editor, the OpenDocument event never
    occurred.


cEcEACKNOWLEDGEMENTS cEcA


    cDmeMsdevcA is based on the initial work from cDVisEmacscA performed by
    cDChristopher PaynecA cC<payneca@sagian.com>cA for GNU Emacs. This software comes
    under the GNU General Public License, as such, meMsdev is covered by the
    same licensing.

    Many thanks to Christopher for putting together this technology, this
    manual page is derived from the documentation supplied with cCVisEmacscA.


cEcELICENSING cEcA


    meMsdev is free software; you can redistribute it and/or modify it under
    the terms of the GNU General Public License as published by the Free
    Software Foundation; either version 2, or (at your option) any later
    version.

    meMsdev is distributed in the hope that it will be useful, but WITHOUT ANY
    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
    FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
    details.

    You should have received a copy of the GNU General Public License along
    with GNU Emacs; see the file COPYING. If not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.


cEcESEE ALSO cEcA


    cCMicrosoft Developer Studio Add-In DocumentationcA
! 1 ne
cEcENAME cEcA


    ne - NanoEmacs 2009 text editor


cEcESYNOPSIS cEcA


    cDnecA [cCoptionscA] [cCfiles ...cA]

    cDnecA [cD@cAcCstartupFilecA] [cD-acA] [cD-bcA cCfilecA] [cD-BcA] [cD-ccA] [cD-hcA] [cD-kcA[cCkeycA] cCfilecA]
    [cD-lcAcClineNocA[cD:cAcCcolumncA]] [cD-RcA] [cD-rcA] [cD-scAcCstringcA] [cD-ucAcCusernamecA] [cD-vcAcCvariable=stringcA]
    [cD-VcA] [cD-xcA] [cD-ycA cCfilecA] cCfiles...cA


cEcEDESCRIPTION cEcA


    cDNanoEmacs 2009cA is a cut down version of cDMicroEmacs 2009cA EMACS text editor,
    based on Danial Lawrences MicroEmacs.

    cDNanoEmacs 2009cA provides the basic EMACS editor functions, allowing
    multiple files to be edited at the same time. The screen may be split into
    different windows and screens, and text may be moved freely from one
    window on any screen to the next. The editor typically runs in a console
    mode and is set up for basic system administration work or system bring
    up, macro files are not expected to be present, the system is still
    capable of running a macro file (with limited capability), the default
    start-up file is cGne.emfcA and is executed at start-up if present.

    The command line options to cDNanoEmacs 2009cA are defined as follows:-

    cD@cAcCstartFilecA
        Initialize NanoEmacs 2009 using cCstartFilecA[cD.emfcA]. The default when
        omitted is cDne.emfcA. See lslmstart-up(3)le and lslmCommand Line Filtersle for more
        information.

    cD-acA
        Toggle the auto-save mode, this toggles the lslmauto(2m)le mode.

        cDNote:cA that NanoEmacs disables auto save mode by default and MicroEmacs
        enables auto save mode by default. The behavior of cD-acA is therefore
        different between the two editors.

    cD-bcA
        Load next file as a binary file (binary editor mode, uses lslmbinary(2m)le
        buffer mode).

    cD-BcA
        Toggle the backup mode, this toggles the lslmbackup(2m)le mode.

        cDNote:cA that NanoEmacs disables backup mode by default and MicroEmacs
        enables backup mode by default. The behavior of cD-BcA is therefore
        different between the two editors.

    cD-ccA
        Continuation mode. Load cDNanoEmacs 2009cA last edit session, restoring
        the buffers to their previous loaded state and position. Note that
        history mode must be enabled. The cD-ccA option is generally used with
        windowing interfaces (X-Windows/Microsoft Windows) as the shortcut
        icon invocation.

    cD-hcA
        Show the help page (does not start the editor).

    cD-kcA[cCkeycA]
        Load next file as an encrypted file (uses lslmcrypt(2m)le buffer mode). The
        optional adjoining argument can be used to specify the decrypting key,
        if this argument is not specify the user will be prompted for it on
        start-up.

    cD-lcAcClineNocA
        Go to line cClineNocA in the next given file and optionally to the
        specified column number. The column may be omitted if not required.
        Typically used with utilities such a cDmore(1)cA where an external editor
        may be invoked from other viewer.

    cD-ncA
        UNIX X-Windows environments only and MicroSoft Windows NT console
        versions. Execute cDMicroEmacs 2009cA using termcap rather than X-Windows
        for UNIX; typically used within an cDxtermcA shell to fire up cDMicroEmacs
        2009cA for a quick edit. For Microsoft Windows, a console window is
        started as opposed to a GUI window. This option is not present if a
        console version of the application has been built.

    cD-RcA
        Reverse the default video color scheme. The default foreground color
        becomes the background color and vice versa. This only affects the
        built in scheme and not any schemes defined in any start-up file.

    cD-rcA
        Read-only, all buffers will be in view mode

    cD-scAcCstringcA
        Search for string "cCstringcA" in the current buffer. e.g. cGne -sfoo barcA
        starts cDMicroEmacs 2009cA, loads file cGbarcA and initiates a search for cCfoocA.
        The cursor is left at the end of the string if located, otherwise at
        the top of the buffer.

    cD-ucAcCusernamecA
        Set the current user name lslm$user-name(5)le to cCusernamecA before NanoEmacs
        is initialized.

    cD-vcAcCvariable=stringcA
        Assign the MicroEmacs 2009 cCvariablecA with cCstringcA. The assignment is
        performed before the buffers are loaded. Typically used to change the
        start-up characteristics of the startup file(s).

    cD-VcA
        Print the name and version of NanoEmacs. i.e.

        cGorac% ne -VcA
        cGNanoEmacs 05 - Date 2005/02/24 - sunoscA

    cD-xcA
        UNIX environments. Disable the capture of signals. cDMicroEmacs 2009cA by
        default captures an handles all illicit signal interrupts. The option
        is enabled when debugging the source code allowing exception
        conditions to be trapped within the debugger.

    cD-ycA
        Load next file as a reduced binary file (uses lslmrbin(2m)le buffer mode).


cEcEENVIRONMENT cEcA


    The following environment variables are used by cDNanoEmacs 2009cA.

    cDDISPLAYcA
        UNIX environments running X-Windows only. The identity of the
        X-Windows server. Typically set to cDunix:0.0cA, refer to the X-Windows
        documentation for details of this environment variable.

    cDMENAMEcA
        lslm$MENAME(5)le is used to override the identity of the user lslm$user-name(5)le.
        The variable may be used to determine which start-up configuration to
        use in the initialization of cDMicroEmacs 2009cA (cC$user-namecA.erf). This is
        ignored if the cD-ucA option is specified on the command line.

        Non-UNIX platforms usually need to explicitly set the cD$MENAMEcA
        environment variable to identify the aforementioned files. for MS-DOS
        and early versions of Microsoft Windows this is typically performed in
        the cGAUTOEXEC.BATcA file.

    cDPATHcA
        The cD$PATHcA environment variable is used on most operating systems as a
        search path for executable files. This cD$PATHcA environment variable must
        be defined with cDMicroEmacs 2009cA on the search path. Under UNIX this is
        set in the cG.logincA, cG.cshrccA or cG.profilecA file i.e.

            export PATH $PATH:/usr/name/ne

        Within MS-DOS or Microsoft Windows environments it is defined in the
        cGAUTOEXEC.BATcA file. e.g.

            set PATH=%PATH%;c:\ne

        cDMicroEmacs 2009cA utilizes information in the cD$PATHcA environment variable
        to locate the start-up files, dictionaries etc.

    cDTERMcA
        The terminal identification sting. In UNIX environments the
        environment variable cD$TERMcA is set to "cGvt...cA", in this case it is
        assumed that the machine is a server, and the host cannot support X
        (see command line option cD-ncA).

        In MS-DOS the environment variable is usually set to define the
        graphics adapter mode. cD%TERMcA is assigned a string, understood by the
        cGme.emfcA start-up file, to set the graphics mode. Predefined strings
        include:-

        cDE80x50cA
            Initiates an 80 column by 50 line screen.

        cDE80x25cA
            Initiates an 80 column by 25 line screen.

        cCuserDefinedcA
            A user defined string to set an explicit graphics card mode. The
            operation is dependent upon the support offered by the graphics
            adapter.

    cDMEINSTALLPATHcA
        lslm$MEINSTALLPATH(5)le is an environment variable that overrides any
        internally defined search path for NanoEmacs system macros and defines
        the root directory(s) of the NanoEmacs system macros. The presence of
        the environment variable affects lslm$search-path(5)le.

    cDMEUSERPATHcA
        lslm$MEUSERPATH(5)le is an environment variable that defines the users
        private directory where user configuration files such as
        ls$user-name(5)lm$user-namelecD.emfcA, ls$user-name(5)lm$user-namelecD.erfcA and personal spelling dictionaries are
        stored. This is an absolute directory path. The environment variable
        sets the NanoEmacs variable lslm$user-path(5)le.

    cDMEPATHcA
        lslm$MEPATH(5)le is an environment variable that may be used to define the
        absolute search path for NanoEmacs macro files and affects the setting
        of cD$search-pathcA. The path should include the system macros location(s)
        and should include the user directory location lslm$user-path(5)le as the
        first path when the environment variable lslm$MEUSERPATH(5)le is not
        defined. If cD$MEUSERPATHcA is defined then this path name appears before
        the cD$MEPATHcA variable to define the user directory location. cD$MEPATHcA is
        not searching, so ALL directories to be searched must be included in
        the path specification.

        lslm$MEUSERPATH(5)le is the preferred method used to defined the user
        directory.


cEcEFILES cEcA


    All of the macro files and dictionaries are located in the cDNanoEmacscA home
    directory. The standard file extensions that are utilized are:-

    cD.emfcA
        A cDMicroEmacs 2009cA macro file. The following classes of macro file
        exist:

        cDne.emfcA
            The default startup file.


cEcEMICROSOFT WINDOWS cEcA


    Microsoft Windows environments should refer to lslmme32.ini(8)le for a method of
    setting up the environment variables without editing the cGAUTOEXEC.BATcA
    configuration file.


cEcESEE ALSO cEcA


    lslm$MEINSTALLPATH(5)le, lslm$MENAME(5)le, lslm$MEPATH(5)le, lslm$MEUSERPATH(5)le, lslmemf(8)le,
    cDemacs(1)cA [GNU], cDmore(1)cA, lslmme(1)le, cDvi(1)cA.
    lslmCommand Line Filtersle.
! 2 abort-command
cEcENAME cEcA


    abort-command - Abort command
$a


cEcESYNOPSIS cEcA


    cDabort-commandcA (cDC-gcA)


cEcEDESCRIPTION cEcA


    Aborts the current command, when in trouble, this command will usually
    limit the damage. If you find yourself in a position where you do not want
    to be then this command will usually take you back to a sane state. This
    command rings the bell and stops keyboard macros.

    Avoid re-binding this key where possible as it is used in other places.

    When cDabort-commandcA is invoked a warning is automatically given alerting
    the user, this may be an audible or a visual warning depending on the
    global state of the ls$quiet(5)lmquiet(5)le global variable.


cEcESEE ALSO cEcA


    lslmbuffer-mode(2)le, ls$quiet(5)lmquiet(5)le.
! 2 add-color
! 2 add-color-scheme
cEcENAME cEcA


|add-color
    add-color - Create a new color
|add-color-scheme
    add-color-scheme - Create a new color scheme
$a


cEcESYNOPSIS cEcA


    cDadd-colorcA "cCcol-nocA" "cCredcA" "cCgreencA" "cCbluecA"
    cCncA cDadd-color-schemecA "cCschemeNumcA" "cCforecA" "cCbackcA" "cCcurrent-forecA" "cCcurrent-backcA"
            "cCselected-forecA" "cCselected-backcA"
            "cCcurrent-selected-forecA" "cCcurrent-selected-backcA"
            [ "cCfm-forecA" "cCfm-backcA" "cCfm-cur-forecA" "cCfm-cur-backcA"
            "cCfm-sel-forecA" "cCfm-sel-backcA"
            "cCfm-cur-sel-forecA" "cCfm-cur-sel-backcA" ]


cEcEDESCRIPTION cEcA


    cDadd-colorcA creates a new color and inserts it into MicroEmacs 2009 colors
    table, where cCredcA, cCgreencA and cCbluecA are the color components and cCcol-nocA is
    the MicroEmacs 2009 color table number. The color table contains 256
    entries indexed by cCcol-nocA in the range 0-255.

    On some platforms (DOS and UNIX termcap) the number of colors is
    physically limited by the hardware to less than 256 (typically 16), in
    this case all 256 colors can be defined and for each created color the
    closest system color is used.

    By default, only color 0 (white) and 1 (black) are defined. Once created,
    the colors may be used to create color schemes, this is the sole use of
    colors.

    cDadd-colorcA may be used to modify an existing cCcol-nocA index by re-assignment,
    the existing color definition is over-written with the new color
    definition. cDadd-color-schemecA creates a color scheme entry used by
    lslmhilight(2)le, lslmscreen-poke(2)le, lslmosd(2)le and variables such as
    lslm$global-scheme(5)le, lslm$buffer-scheme(5)le, lslm$ml-scheme(5)le.

    The command takes an index number "cCschemeNumcA" and eight color values
    (defined by cDadd-colorcA) alternating between foreground and background
    colors. The 8 colors represent the 4 color paired states of foreground and
    background that may appear in a text buffer. The paired states correspond
    to current and selected lines (or permutations thereof). If an argument cCncA
    is given to the command then cCschemeNumcA is set to a duplicate of the cCncAth
    scheme, no other arguments are required.

    cCschemeNumcA is the identifying index that is used to recognize the scheme.
    By default only two color schemes are defined at initialization, they are
    a monochrome scheme and inverse scheme with indices 0 and 1 using white as
    foreground and black as background, selected text is inverted. When
    defining a color scheme, if an existing cCschemeNumcA index is used then that
    scheme is modified.

    The next eight arguments must be given, they specify foreground and
    background color pairs for the four different situations, as follows:-

    Default
        Color combination used when none of the following three are
        applicable.

    Current
        Color combination used when the text is on the same line as the
        cursor. It is also used by the lslm$mode-line-scheme(5)le for the current
        window's mode line and for the current selection on an lslmosd(2)le dialog.

    Selected
        Color combination used when the text is in the current selected
        region, but is not on the current line. Also used by cDosdcA for
        non-current item Hot keys.

    Current-selected
        Color combination used when the text is on the current line and in the
        current selected region. Also used by cDosdcA for the current item's Hot
        key.

    The following 8 arguments set up fonts and are optional, any missing
    arguments are defaulted to 0. Each argument is a bitmask indicating which
    font should be enabled, where each bit is as follows:

        cG0x01cA Enable bold font.
        cG0x02cA Enable italic font.
        cG0x04cA Enable light font.
        cG0x08cA Enable reverse font.
        cG0x10cA Enable underlining.

    Normally only the foreground value is used, i.e. the first, third, fifth
    and seventh values. But lslmscreen-poke(2)le can be used to draw reversed color
    scheme in which case the background values are used.


cEcEEXAMPLE cEcA


    The color palette is typically created at start-up via the configuration
    file cDschemecAcCXcAcD.emfcA. These files are not easily read as they are
    automatically generated via the lslmscheme-editor(3)le dialog. A more readable
    form of "cGschemed.emfcA" would be as follows:-
sB
        ; Standard colors
        add-color &set .white     0 200 200 200
        add-color &set .black     1 0   0   0
        add-color &set .red       2 200 0   0
        add-color &set .green     3 0   200 0
        add-color &set .yellow    4 200 200 0
        add-color &set .blue      5 0   0   200
        add-color &set .magenta   6 200 0   200
        add-color &set .cyan      7 0   200 200
        ; Light colors
        add-color &set .lwhite    8 255 255 255
        add-color &set .lblack    9 75  75  75
        add-color &set .lred     10 255 0   0
        add-color &set .lgreen   11 0   255 0
        add-color &set .lyellow  12 255 255 0
        add-color &set .lblue    13 0   0   255
        add-color &set .lmagenta 14 255 0   255
        add-color &set .lcyan    15 0   255 255
        ; Selection color
        add-color &set .sel-col  16 91  78  131
        ; Set the required cursor-color
        set-variable $cursor-color .col12
        ; Set up the standard schemes for the text, mode line message line, scroll bar and osd.
        add-color-scheme $global-scheme  .white .black .lwhite .black ...
            ... .white .sel-col .lwhite .sel-col 0 8 1 9 8 0 9 1
        add-color-scheme $ml-scheme  .white .black .lwhite .black ...
            ... .white .sel-col .lwhite .sel-col 0 8 1 9 8 0 9 1
        add-color-scheme $mode-line-scheme  .white .red .lwhite .lred ...
            ... .white .red .lwhite .red 8 0 9 1 0 8 1 9
        add-color-scheme $scroll-bar-scheme .white .lblack .lwhite .lblack ...
            ...  .lblack .white .lblack .lwhite 8 0 9 1 0 8 1 9
            .
            .

sA

cEcENOTES cEcA


    Color schemes can be created and altered using the lslmscheme-editor(3)le
    dialog, the created color scheme can then the used from start-up by using
    the lslmuser-setup(3)le dialog. Therefore direct use of these commands is
    largely redundant.

    The existence of a color or scheme index is checked as each entry is
    submitted, therefore any color or scheme used must have been previously
    been created, otherwise a default value is substituted.

    Changing any existing color definitions causes all references to the color
    from a scheme to adopt the new color.

    Changing any existing color-scheme definitions changes the rendered color
    of any lslmhilight(2)le etc., that was using that color-scheme.

    A negative color scheme value (i.e. cC-ncA) uses the previous 'cCncA'th entry that
    is defined in the color block. i.e. if cCcurrent-forecA was specified as -2
    then it would inherit the cCforecA field color.

    Not all UNIX terminals support all the above fonts.

    On some telnet packages color is not directly supported and some of the
    termcap display attributes such as bold and italic are represented by a
    color (e.g. italic text is shown in green). Using this translation it is
    possible to achieve reasonable color support on a VT100 terminal - it is a
    little awkward but is worth while if you have to use this type of
    connection frequently.


cEcESEE ALSO cEcA


    lslmscheme-editor(3)le, lslmuser-setup(3)le, lslmchange-font(2)le, lslmhilight(2)le,
    lslmscreen-poke(2)le, lslm$buffer-hilight(5)le, lslm$cursor-color(5)le, lslm$global-scheme(5)le,
    lslm$trunc-scheme(5)le, lslm$ml-scheme(5)le, lslm$osd-scheme(5)le, lslm$mode-line-scheme(5)le,
    lslm$scroll-bar-scheme(5)le, lslm$system(5)le.
! 2 add-dictionary
cEcENAME cEcA


    add-dictionary - Declare existence of a spelling dictionary
$a


cEcESYNOPSIS cEcA


    cCncA cDadd-dictionarycA "cCfilecA"


cEcEDESCRIPTION cEcA


    cDadd-dictionarycA adds the given dictionary (specified by the given cCfilecA) to
    the dictionary list. Note that the cCfilecA may omit the cD.edfcA extension, this
    is automatically added.

    The command accepts a numeric argument 'cCncA' which determines the actions to
    be undertaken. When cCncA is omitted then the dictionary is marked for loading
    (on demand) - this is the standard invocation used in the start up files.

    If an argument of cD0cA is given the dictionary is created but it is not
    marked for loading, this can be used to create an empty dictionary.

    If an argument of cD-1cA is given the contents of the dictionary are dumped
    into the current buffer, used for dictionary maintenance. The two main
    uses of this command are discussed below.


cEDictionary Loading cA


    A call to cDadd-dictionarycA with no numeric argument does not perform an
    immediate load of the dictionary, instead the dictionary is only loaded on
    demand, i.e. when a call to lslmspell(2)le (usually via lslmspell-word(3)le or
    lslmspell-buffer(3)le) is made, this ensures that the start up time for
    MicroEmacs does not become too long. When the dictionary is loaded it is
    checked for efficiency, if found to be inefficient it is automatically
    optimized and flagged as changed. On exiting MicroEmacs, the user is
    prompted to save any dictionary that has be altered or optimized.

    The spelling search order is made from the last dictionary added to the
    first, as soon as a word is found in a dictionary the search is halted.
    This implies that if a word has been defined incorrectly in one
    dictionary, but correct in another, the order in which the dictionaries
    are added determines the result.

    The number of dictionaries allowed is unlimited but note that any words
    added are always added to the LAST dictionary. The size of the dictionary
    is restricted to about 16Mb, the size is NOT tested when words are added
    and if this size is exceeded the results are undefined. However, it is
    unlikely that this limit will be reached, the largest dictionary created
    to date is 0.8Mb.

    A new main dictionary may be created as follows:-

    cD1)cA
        Find a file containing an cDispell(1)cA compatible list of words.

    cD2)cA
        lslmexecute-file(2)le spellutl.emf to define macro lslmspell-add-word(3)le.

    cD3)cA
        Start up MicroEmacs 2009 and execute the command cDadd-dictionarycA giving
        an appropriate new dictionary name.

    cD4)cA
        Load up the file containing the words and execute the command
        lslmspell-add-word(3)le with a very large argument so all the words are
        added.

    cD5)cA
        Save the dictionary by either executing the command lslmsave-dictionary(2)le
        or exiting.


cEDictionary Dump cA


    A call to cDadd-dictionarycA with a numeric argument cCncA of -1 causes the
    contents of the given dictionary to be dumped into the current buffer
    (make sure you are in an empty buffer or cD*scratch*cA) where:

        cGxxxxcA - Good word cGxxxxcA with no spell rules allowed
        cGxxxx/abccA - Good word cGxxxxcA with spell rules cGabccA allowed
        cGxxxx>yyyycA - Erroneous word with an auto-replace to cGyyyycA

    The dump of the dictionary may be edited, allowing erroneous entries to be
    removed. The macro file cGspellutl.emfcA contains macros lslmedit-dictionary(3)le
    and lslmrestore-dictionary(3)le which enable the user to edit a dictionary.


cEcENOTES cEcA


    MicroEmacs 2009 is supplied with a dictionaries for American and British
    English, it is strongly suggested that these dictionaries are cDNOTcA modified
    in anyway. Ensure that the dictionary is protected by loading the base
    dictionaries first, followed by a personal dictionary. New words added
    during spelling will then be added to the personal dictionary rather than
    the main dictionary.


cEcEEXAMPLE cEcA


    The MicroEmacs 2009 start-up file cDme.emfcA executes cDlanguage.emfcA which in
    turn executes the user language setup file, for example cDamerican.emfcA,
    which adds the main language dictionaries and rules. cDlanguage.emfcA then
    adds the user's dictionary, this process can be simplified to:-
sB
        ; add the main American dictionary
        add-dictionary "lsdmenus"

        ; reset the spell rules
        0 add-spell-rule
        ; Now add the American spell rules
        -2 add-spell-rule "A" "" "" "re" ; As in enter > reenter
        -2 add-spell-rule "I" "" "" "in" ; As in disposed > indisposed
            .
            .
        ; Now add the user dictionary
        add-dictionary $MENAME

sA

cEcESEE ALSO cEcA


    lslmadd-spell-rule(2)le, lslmsave-dictionary(2)le, lslmspell-add-word(3)le,
    lslmedit-dictionary(3)le, lslmspell-buffer(3)le.
! 2 add-file-hook
cEcENAME cEcA


    add-file-hook - Declare file name context dependent configuration
$a


cEcESYNOPSIS cEcA


    cCncA cDadd-file-hookcA "cCextensionscA" "cCfhook-namecA"


cEcEDESCRIPTION cEcA


    cDadd-file-hookcA defines a macro binding between a file name or file type and
    a set of macros. This binding enables file type dependent screen
    highlighting and key bindings to be performed. For a higher level
    introduction refer to lsfileHooks(2)lmFile Hooksle.

    cDadd-file-hookcA operates in two different modes to establish the type of
    file:-

        * Content recognition, by examination of the contents of the file.
        * File extension recognition.

    Content recognition has the highest priority and is used in preference to
    the file extension.

    cDadd-file-hookcA is called multiple times to add new recognition rules. The
    rules are interrogated in last-in-first-out (LIFO) order, hence the
    extension added last has a greater precedence than those added first. This
    ordering allows default rules to be over-ridden.


cEInitialization cA


    cDadd-file-hookcA must be initialized prior to the first call, using an
    invocation of the form:-
sB
        0 add-file-hook

sA
    with a numeric argument cCncA of 0, and no arguments. This invocation resets
    the file hooks by deleting all of the installed hooks.


cEFile Extension Recognition cA


    cDadd-file-hookcA with no numerical argument cCncA allows the extension of a file
    (or the base file name if there is no extension) to be used to determine
    which user defined setup macro is to be executed. The cCextensionscA argument
    is a space separated list of cCfile endingscA (as opposed to true extensions)
    and is usually specified with the extension separator. For example, the
    extension "cG.doccA" may indicate that the file is a document and therefore
    the lsindent(2m)lmindentle, lswrap(2m)lmwraple and lsjustify(2m)lmjustifyle buffer modes are required. This may be
    performed automatically by defining a macro which adds these modes and
    adding a file hook to automatically execute this macro whenever a file
    "cG*.doccA" is loaded.

    The command arguments are defined as follows:-

    cCextensionscA
        A space separated list of file extensions, which are to be checked,
        this list includes the extension separator (typically dot ('cG.cA'). It
        should be noted that the extension search is actually a comparison of
        the tail of the string, as such files such as cCmakefilecA, which do not
        have an extension, are specified literally.

    cCfhook-namecA
        The name of the file hook to execute. This is the name of the macro to
        execute that initializes the buffer.

    As an example:-
sB
        define-macro fhook-doc
            1 buffer-mode "indent"
            1 buffer-mode "wrap"
            1 buffer-mode "justify"
        !emacro

        add-file-hook ".doc" "fhook-doc"

sA
    It is quite possible that the same macro should be executed for a text
    file, i.e. "cG*.txtcA" this is achieved by a single cDadd-file-hookcA as the space
    (' ') character is used as an extension separator, e.g.
sB
        add-file-hook ".doc .txt" "fhook-doc"

sA
    There are three special file hooks, which are cDfhook-binarycA, cDfhook-rbincA and
    cDfhook-defaultcA, these are not predefined, but if the user defines them then
    they are executed whenever a file is loaded in lsbinary(2m)lmbinaryle or lsrbin(2m)lmreduced binaryle
    mode (see lslmbuffer-mode(2)le) or the extension does not match any of those
    defined.

    Considering the cGfhook-XXXcA prefix, the initial 'cDfcA' character must be
    present as this is changed to a 'cDbcA' and an 'cDecA' when looking for the enter
    (begin) buffer and exit buffer hooks. These hooks are executed whenever
    the user swaps to or from a buffer (including creating and deleting). So
    for the given example, if the fill ignore characters are to be changed
    then this operation this is performed by defining the cGbhook-XXXcA and
    cGehook-XXXcA macros, e.g.:-
sB
        ; Begin hook - entering the buffer - save the current fill-ignore characters
        define-macro bhook-java
            !if &exi .fhook-java.fill-ignore
                set-variable .fhook-java.ofill-ignore $fill-ignore
                set-variable $fill-ignore .fhook-java.fill-ignore
            !endif
        !emacro

        ; End hook - leaving the buffer - restore the fill-ignore characters
        define-macro ehook-java
            !if &exi .fhook-java.fill-ignore
                set-variable $fill-ignore .fhook-java.ofill-ignore
            !endif
        !emacro

        ; Fix up the $fill-mode so that we wrap java doc parameters. Do this by
        ; removing the "@" from the $fill-ignore variable.
        !if &sin "@" $fill-ignore
            set-variable .fhook-java.fill-ignore $fill-ignore
            set-variable .fhook-java.fill-ignore &rep .fhook-java.fill-ignore "@" ""
        !endif

sA
    File hooks are often used to setup the desired cCbuffer modescA, cChilightingcA,
    cClocal key bindingscA, cCabbreviation filecA, etc.

    Buffer hooks are usually used to set and restore conflicting global
    variables.


cEFile Content Recognition cA


    cDadd-file-hookcA with a non-zero numerical argument cCncA defines a macro binding
    between the content in a file and a set of macros. This binding enables
    file type dependent screen hi-lighting and key binding to be performed.
    For a full description of file hooks refer to lsfileHooks(2)lmFile Hooksle, for file
    extension dependent hooking refer to lslmadd-file-hook(2)le.

    The content defined file hooks interrogate the contents of a file on
    loading and search for a cCmagiccA string identifier embedded in the text
    which uniquely identifies the file type.

    The recognition process performs a search of the first cCncA (numerical
    argument) non-blank lines of the file, searching for the regular
    expression specified by the cCextensionscA argument. The sign of the numerical
    argument cCncA is interpreted as follows:-

        * cD-vecA - Case insensitive search
        * cD+vecA - Case sensitive search

    The command arguments are defined as follows:-

    cCextensionscA
        A regular expression string defining the text to be searched for.

    cCfhook-namecA
        The name of the file hook to execute. This is the name of the macro to
        execute that will initialize the buffer.

    The search commences from the first non-blank line in the file, if the
    regular expression, defined by cCextensionscA is located then the file hook
    cCfhook-namecA is invoked. This is typically used to identify files which do
    not have file extensions i.e. UNIX shell script files. To identify a shell
    script file which commences with:-

        #!/bin/sh


    The following file hook is used:-

        cD1 add-file-hookcA "cD#!/.*shcA" "cDfhook-shellcA"

    Note that "cG.*shcA" also matches cG/bin/cshcA, cG/usr/local/bin/zshcA etc, so care
    should be taken to ensure that the regular expression string is
    sufficiently well specified to recognize the file type.

    The second class of embedded text are explicit identifiers embedded into
    the text. The embedded strings take the form:

        cG-*-cA cCmodecA cG-*cA
        cG-*-cA cDMode:cA cCmodecA; ... cG-*-cA
        cG-!-cA cCmodecA cG-!-cA

    The cG-*-cA notation belongs to GNU Emacs, but MicroEmacs 2009 recognizes the
    construct and extracts the string correctly. The cG-!-cA notation is
    MicroEmacs 2009 specific and is provided so as not to cause conflict with
    GNU Emacs. MicroEmacs 2009 searches for either construct on the first
    non-blank line of the file.

    The explicit strings are defined with a negative numerical argument cCncA,
    which identifies them as cDexplicitcA rather than cDmagiccA text strings. The
    cCstringcA should be defined in lower case and matches a case insensitive
    string take from the file. e.g. to define a file hook for a make file:

        #_____________________________-!-Makefile-!-________________________________
        #
        # Make file for MicroEmacs using the Microsoft MSCV 2.0/4.0 development kit.
        #
        # Author      : Jon Green
        # Created     :  020197.1002
        # Last Edited : <150297.1942>
        # File        : makefile.w32
        ....


    might be defined as:

        -1 cDadd-file-hookcA "-!-[ \t]*makefile.*-!-" fhook-make


cEcENOTES cEcA


cEAutomatic Macro File Loading cA


    cDadd-file-hookcA performs an automatic load of a macro file if the cDfhookcA
    macro is not present in memory. The file name of the command file
    containing the macro is automatically derived from the cCnamecA component of
    the cDfhookcA macro name. The cDfhook-cA part of the name is stripped off and
    prepended with cDhkcA and suffixed with cD.emfcA. Hence, macro cDfhook-doccA would be
    searched for in file cGhkdoc.emfcA within the MicroEmacs 2009 directory. The
    command file is automatically loaded and executed.

    In cases where the fhook macro is not located in an equivalent hook file,
    the file location of the macro may be explicitly defined for auto loading
    via a lslmdefine-macro-file(2)le invocation.

    As an example, consider the C-mode file hook, used to load cG.ccA files. The
    loading of a C header file (cG.hcA) utilizes the same highlighting modes, but
    it's startup sequence is slightly different when handling new files. In
    this case the cDfhook-cmodecA for cG.ccA and cDfhook-hmodecA for cG.hcA files are located
    in the same hook file namely cGhkcmode.emfcA.
sB
        define-macro-file hkcmode fhook-hmode

        add-file-hook ".c .cc .cpp .def .l .y .i .ac"   "fhook-cmode"
        add-file-hook ".h .hpp"                         "fhook-hmode"

sA
    In this case the lsdefine-macro-file(2)lmdefine-macro-filele has been used to inform MicroEmacs 2009
    of the location of the cDfhook-hmodecA macro thereby overriding the automatic
    load of a file called cDhkhmode.emfcA. The cDfhook-cmodecA macro requires no such
    definition as it is located in a hook file that matches the mode name,
    cGhkcmode.emfcA.


cEExtending a standard hook definition cA


    The standard file hook files cDhkcAcCXXXcAcD.emfcA should not be modified. The
    standard file hooks may be extended with local definitions by defining a
    file cDmycAcCXXXcAcD.emfcA, which is an extension to the hook file cDhkcAcCXXXcAcD.emfcA. This is
    automatically executed after cDhkcAcCXXXcAcD.emfcA. Refer to sections lslanguageTemplates(2)lmLanguageln
    lnTemplatesle and lsfileHooks(2)lmFile Hooksle for details.


cEFile Extensions cA


    The file extensions are specified as a space separated list of file name
    endings. Back-up file endings such as tilde (cG~cA) are not classed as correct
    file endings and are skipped by the file hook search, hence a file ending
    "cG.c~cA" invokes the same hook function as a "cG.ccA" file. It is therefore not
    necessary to add the backup and auto-save endings to the file hook
    definition.

    The extension separator, usually dot (cG.cA), is typically added to the
    cCextensionscA list, they may be omitted with effect where a file always ends
    in the same set of characters. A notable example is "cGmakefilecA" which
    includes no extension, as such, MicroEmacs 2009 applies the same hook
    function to a file called cGImakefilecA as the endings are the same.


cEBinary Files cA


    It is sometimes useful to associate file types as binary files, so that
    they are immediately loaded in binary. In this case, both file extension
    and content recognition methods (i.e. of a magic string) are applicable.
    In both cases the file is bound to the well known hook cGfhook-binarycA which
    automatically loads the file in a binary mode.

    Note, that for the content recognition process for a binary hook, the load
    time is doubled as the file is initially loaded in the default text mode,
    the binary hook function forces a second load operation in binary.


cEcESUMMARY cEcA


    cDadd-file-hookcA is summarized as follows:-

        * Binds one or more extensions to a macro called fhook-cCxxxxcA.
        * Extensions are typically specified with the dot (cG.cA) separator.
        * Multiple extensions are specified as a space separated list.
        * Binds a regular expression search string to a macro called
          fhook-cCxxxxcA.
        * The absolute value of the numerical argument determines the number
          of lines in the file over which the regular expression search is
          made.
        * The sign of the numerical argument determines if the regular
          expression search is case (in)sensitive.
        * When one of the files with a known file extension, or recognized
          content, is loaded macro cDfhook-xxxxcA is executed.
        * cDfhook-xxxxcA, if undefined, is automatically searched for in file
          cDhkcAcCxxxxcAcD.emfcA.
        * When the buffer containing the known file is entered (i.e. gains
          focus), then entry macro cDbhook-xxxxcA is executed.
        * When the buffer containing the known file is exited (i.e. looses
          focus), then the exit macro cDehook-xxxxcA is executed.


cEcEEXAMPLE cEcA


    The standard set of supported file types by MicroEmacs 2009, at the time
    of writing, is defined as:-
sB
        ; reset the file hook list
        0 add-file-hook
        ; Add file extension hooks.
        ; Files loaded in binary mode do not need hook as fixed
        add-file-hook "*help* *info* .ehf"                            fhook-ehf
        add-file-hook "*bindings* *commands* *variables*"             fhook-lists
        add-file-hook "*buffers*"                                     fhook-blist
        add-file-hook "/ *directory* *files*"                         fhook-dir
        add-file-hook "*registry*"                                    fhook-reg
        add-file-hook "*icommand* *shell* *gdb* *dbx*"                fhook-ipipe
        add-file-hook ".emf"                                          fhook-emf
        add-file-hook ".doc .txt"                                     fhook-doc
        add-file-hook ".1 .2 .3 .4 .5 .6 .7 .8 .9 .so .tni .sm"       fhook-nroff
        add-file-hook ".c .h .def .l .y .i"                           fhook-c
        add-file-hook ".cc .cpp .hpp .rc"                             fhook-cpp
        add-file-hook "Makefile makefile .mak"                        fhook-make
        add-file-hook "Imakefile imakefile"                           fhook-imake
        add-file-hook ".sh .ksh .csh .login .cshrc .profile .tcshrc"  fhook-shell
        add-file-hook ".bat .btm"                                     fhook-dos
        add-file-hook ".man"                                          fhook-man
        add-file-hook ".dmn"                                          fhook-dman
        add-file-hook ".ini .hpj .reg .rgy"                           fhook-ini
        add-file-hook ".htm .html"                                    fhook-html
        add-file-hook ".htp .hts"                                     fhook-hts
        add-file-hook ".tcl"                                          fhook-tcl
        add-file-hook ".rul"                                          fhook-rul
        add-file-hook ".awk .nawk .gawk"                              fhook-awk
        add-file-hook ".p .pas"                                       fhook-pascal
        add-file-hook ".vhdl .vhd"                                    fhook-vhdl
        add-file-hook ".fvwm .fvwm2rc"                                fhook-fvwm
        add-file-hook ".java .jav"                                    fhook-java
        add-file-hook ".nsr"                                          fhook-nsr
        add-file-hook ".erf"                                          fhook-erf
        ; Add magic hooks
         1 add-file-hook "^#!/.*sh"               fhook-shell ; UNIX shell files
         1 add-file-hook "^#!/.*wish"             fhook-tcl
         1 add-file-hook "^#!/.*awk"              fhook-awk
         1 add-file-hook "^#VRML"                 fhook-vrml
        -4 add-file-hook "<html>"                 fhook-html
        -1 add-file-hook "-[*!]-[ \t]*c.*-[*!]-"         fhook-c     ; -*- C -*-
        -1 add-file-hook "-[*!]-[ \t]*c\\+\\+.*-[*!]-"   fhook-cpp   ; -*- C++ -*-
        -1 add-file-hook "-[*!]-[ \t]nroff.*-[*!]-"      fhook-nroff ; -*- nroff -*-
        -1 add-file-hook "-!-[ \t]*shell.*-!-"           fhook-shell ; -!- shell -!-
        -1 add-file-hook "-!-[ \t]*msdos.*-!-"           fhook-dos   ; -!- msdos -!-
        -1 add-file-hook "-!-[ \t]*makefile.*-!-"        fhook-make  ; -!- makefile -!-
        -1 add-file-hook "-!-[ \t]*document.*-!-"        fhook-doc   ; -!- document -!-
        -1 add-file-hook "-!-[ \t]*fvwm.*-!-"            fhook-fvwm  ; -!- fvwm -!-
        -1 add-file-hook "-!-[ \t]*erf.*-!-"             fhook-erf   ; -!- erf -!-
        -1 add-file-hook "-!-[ \t]*fold:.*-!-"           fhook-fold  ; -!- fold:... -!-

sA

cEcEOBSCURE INFORMATION cEcA


    This section includes some low-level information which is so obscure it is
    not relevant to the typical user.


cEResolving Loading Order Problems cA


    There is a potential loading order problem involving auto-loading of file
    libraries and the setting up of cDbhookcA and cDehookcA. E.g. if the main fhook
    function has been defined as a lslmdefine-macro-file(2)le, but the bhook or
    ehooks have not the when a buffer is created as only the fhook is define,
    only the fhook is set, the rest remain disabled even though the execution
    of the macro file will define these extra hooks.

    To solve this problem simply define the bhook/ehooks as well. Note that
    automatically loaded hooks do not suffer from this problem as the macro
    file is executed before the hooks are assigned, thereby ensuring the all
    the hooks are defined.


cEcESEE ALSO cEcA


    lsfileHooks(2)lmFile Hooksle, lslanguageTemplates(2)lmLanguage Templatesle, lslm$buffer-bhook(5)le, lslm$buffer-ehook(5)le,
    lslm$buffer-fhook(5)le.
! 2 osd-bind-key
! 2 osd-unbind-key
cEcENAME cEcA


|osd-bind-key
    osd-bind-key - Create key binding for OSD dialog
|osd-unbind-key
    osd-unbind-key - Remove key binding from OSD dialog
$a


cEcESYNOPSIS cEcA


    cDosd-bind-keycA cCncA "cCcommandcA" "cCkeycA"
    cDosd-unbind-keycA cCncA "cCkeycA"


cEcEDESCRIPTION cEcA


    cDosd-bind-keycA creates a local key binding for a given lsosd(2)lmosd dialogle, binding
    the command cCcommandcA to the keyboard input cCkeycA. Only the current root
    dialog's local bindings are used, local bindings of included dialogs or
    other root dialogs currently displayed are ignored.

    Osd local bindings take priority over default osd bindings, local bindings
    created using lslmml-bind-key(2)le are also used, but any current buffer local
    bindings created using lslmbuffer-bind-key(2)le are ignored.


cEcENOTES cEcA


    The prefix commands cannot be rebound with this command.

    Key response time linearly increases with each osd binding added.

    As only the root dialog's bindings are used, creating note-book page
    specific bindings can be awkward. Typically all required keys are bound to
    the same command which, depending on the page that is currently being
    displayed, checks if the key pressed is bound on the current page and if
    so calls the required command. See lslmorganizer(3)le, defined in cGorganize.emfcA
    for an example of this operation.


cEcESEE ALSO cEcA


    lslmosd(2)le, lslmglobal-bind-key(2)le, lslmml-bind-key(2)le, lslmbuffer-bind-key(2)le,
    lslmglobal-unbind-key(2)le.
! 2 global-mode
! 3 add-global-mode
! 3 delete-global-mode
cEcENAME cEcA


|global-mode
    global-mode - Change a global buffer mode
|add-global-mode
    add-global-mode - Set a global buffer mode
|delete-global-mode
    delete-global-mode - Remove a global buffer mode
$a


cEcESYNOPSIS cEcA


    cCncA cDglobal-modecA "cCmodecA" (cDesc mcA)
    cDadd-global-modecA "cCmodecA"
    cDdelete-global-modecA "cCmodecA"


cEcEDESCRIPTION cEcA


    cDglobal-modecA changes the state of one of the hereditary global modes. A
    buffer's modes are initialized to the global modes when first created.
    This command is very useful in changing some of the default behavior such
    as case sensitive searching (see the example below). See lslmOperating Modesle
    for a full list and description of modes. Also see lslmbuffer-mode(2)le for a
    full description of the use of the argument cCncA.

    The lslmabout(2)le command gives a list of the current global and buffer modes.

    cDadd-global-modecA and cDdelete-global-modecA are macros defined in meme3_8.emf
    which use global-mode to add or remove a global mode. They are defined for
    backward compatibility with MicroEMACS v3.8 and for ease of use; they are
    simple macros, add-global-mode is defined as follows:
sB
        define-macro add-global-mode
            ; Has the require mode been given as an argument, if so add it
            !force 1 global-mode @1
            !if &not $status
                ; No - use 1 global-mode to add a mode
                !nma 1 global-mode
            !endif
        !emacro

sA

cEcEEXAMPLE cEcA


    The following example globally disables lslmexact(2m)le and lslmmagic(2m)le modes, if
    these lines are copied to the user setup file then are searches will be
    simple and case insensitive by default:
sB
        -1 global-mode "exact"
        -1 global-mode "magic"

sA

cEcENOTES cEcA


    Globally adding lslmbinary(2m)le, lslmcrypt(2m)le and lslmrbin(2m)le modes is strongly
    discouraged as any file loaded would be assigned these modes. Instead use
    the numeric argument of command lslmfind-file(2)le or commands lslmfind-bfile(3)le and
    lslmfind-cfile(3)le.

    lslmauto(2m)le, lslmautosv(2m)le, lslmbackup(2m)le, lslmexact(2m)le, lslmmagic(2m)le, ls$quiet(5)lmquiet(5)le, lslmtab(2m)le
    and lslmundo(2m)le modes are present on all platforms by default. On Windows and
    DOS platforms lslmcr(2m)le and lslmlf(2m)le is also present and on DOS lslmctrlz(2m)le is
    also present.


cEcESEE ALSO cEcA


    lslmOperating Modesle, lslmbuffer-mode(2)le, lslmfind-bfile(3)le, lslmfind-cfile(3)le, lslmabout(2)le.
! 2 buffer-mode
! 2 named-buffer-mode
! 3 add-mode
! 3 delete-mode
! 3 unmark-buffer
cEcENAME cEcA


|buffer-mode
    buffer-mode - Change a local buffer mode
|named-buffer-mode
    named-buffer-mode - Change a named buffer mode
|add-mode
    add-mode - Set a local buffer mode
|delete-mode
    delete-mode - Remove a local buffer mode
|unmark-buffer
    unmark-buffer - Remove buffer change flag
$a


cEcESYNOPSIS cEcA


    cCncA cDbuffer-modecA "cCmodecA" (cDC-x mcA)
    cCncA cDnamed-buffer-modecA "cCbuffer-namecA" "cCmodecA"
    cDadd-modecA "cCmodecA"
    cDdelete-modecA "cCmodecA"
    cDunmark-buffercA


cEcEDESCRIPTION cEcA


    cDbuffer-modecA changes the state of a given buffer mode, affecting only the
    current buffer. A buffer's mode affects the behavior of MicroEmacs 2009.
    The lslmabout(2)le command gives a list of the current global and buffer modes.
    Refer to lslmOperating Modesle for a description of the buffer modes.

    The argument cCncA when given, has the following meaning:

        Delete    Add    toggle    Mode

          -1       1         0     Use "mode"
          -2       2       130     autosv
          -3       3       131     backup
          -4       4       132     binary
          -5       5       133     cr
          -6       6       134     crypt
          -7       7       135     ctrlz
          -8       8       136     edit
          -9       9       137     exact
          -10      10      138     fence
          -11      11      139     hide
          -12      12      140     indent
          -13      13      141     justify
          -14      14      142     lf
          -15      15      143     lock
          -16      16      144     magic
          -17      17      145     nact
          -18      18      146     narrow
          -19      19      147     over
          -20      20      148     pipe
          -21      21      149     rbin
          -22      22      150     tab
          -24      24      152     time
          -25      25      153     undo
          -26      26      154     view
          -27      27      155     wrap


    Note that when omitted the default argument is 0, i.e. prompt for and
    toggle a mode.

    cDnamed-buffer-modecA changes the state of a given buffer mode for a given
    buffer which may not be the current buffer.

    cDadd-modecA and cDdelete-modecA are macros which use buffer-mode to add and
    remove a buffer mode. cDunmark-buffercA is also a macro which removes the edit
    flag from the current buffer. They are defined for backward compatibility
    with MicroEMACS v3.8 and can be found in meme3_8.emf; add-mode is defined
    as follows:
sB
        define-macro add-mode
            ; Has the require mode been given as an argument, if so add it
            !force 1 buffer-mode @1
            !if &not $status
                ; No - use 1 buffer-mode to add a mode
                !nma 1 buffer-mode
            !endif
        !emacro

sA

cEcENOTES cEcA


    When a buffer is created it inherits the current global mode state.


cEcESEE ALSO cEcA


    lslmOperating Modesle, lslmglobal-mode(2)le, lslmabout(2)le, lslm&bmode(4)le.
! 2 add-next-line
cEcENAME cEcA


    add-next-line - Define the searching behavior of command output
$a


cEcESYNOPSIS cEcA


    cCncA cDadd-next-linecA "cCbuffer-namecA" [ "cCstringcA" ]


cEcEDESCRIPTION cEcA


    cDadd-next-linecA is used to set up the cCnext-linecA functionality which is used
    by the lslmget-next-line(2)le command. The cCnext-linecA feature is aimed at giving
    the user easy access to file locations which are stored in another buffer.
    This buffer may typically be the output from the cDgrep(1)cA command or a
    compiler (e.g. cDcc(1)cA) and needs to contain the file name and line number
    of the required location.

    As long as the format of the buffer is consistent and there is a maximum
    of one location per line, the cCnext-linecA feature can be successfully
    configured.

    The first argument, "cCbuffer-namecA", gives the name the aforementioned
    buffer, this is "cD*grep*cA" for the lslmgrep(3)le command etc. There is no limit on
    the number of next-line formats, nor on the number of cDadd-next-linecA
    strings which are given. While there is no real need to initialize each
    new type, it is advised that the first cDadd-next-linecA is called with a
    numerical argument of zero, e.g.:
sB
        0 add-next-line "*grep*"
        add-next-line "*grep*" "....."

sA
    This tells MicroEmacs to reinitialize the type by freeing off any strings
    currently stored, note that the "cCstringcA" argument is not used in this
    case. Resetting the next-line type safe guards against duplicate strings
    being added to it, a common problem if MicroEmacs is reinitialized.

    Following is a typical output from grep:

        foo.c: 45:      printf("hello world\n") ;
        foo.c: 46:      printf("hello again\n") ;


    If we replace the file name with "cG%fcA" and the line number with "cG%lcA", this
    becomes:

        %f: %l:      printf("hello world\n") ;


    lsget-next-line(2)lmget-next-linele works on a left to right basis, as soon as it has enough
    information from the line it does not need to continue. Therefore the
    previous example can be reduced to just "cG%f: %l:cA". This is the string
    argument that should be given for the above example, i.e.:
sB
        add-next-line "*grep*" "%f: %l:"

sA
    lsget-next-line(2)lmget-next-linele takes the given string and replaces the "cG%fcA" with
    lslm$file-template(5)le and the "cG%lcA" with the lslm$line-template(5)le and then uses
    the resultant string as a regular expression search string to find the
    next location. Crudely these could be set to "cGfoo.ccA" and "cG45cA" respectively
    to find the first example, but this would fail to find any other. As a
    result the templates are usually magic search strings which will match any
    file and line number.

    Similarly, following is an example output of the cDgcc(1)cA compiler:

        basic.c:522: warning: `jj' might be used uninitialized in this command
        display.c:833: warning: implicit declaration of function `ScreenPutChar'


    In this case the cDadd-next-linecA given needs to be:
sB
        add-next-line "*compile*" "%f:%l:"

sA
    If a negative numerical argument is given to cDadd-next-linecA the given
    'next-line' is ignored, this can be useful when some warnings are to be
    ignored. For example a common warning from gcc is given when a variable
    might be used uninitialized, given as follows:

        bind.c:578: warning: `ssc' might be used uninitialized in this function


    These warnings can be ignored using the following:
sB
        -1 add-next-line "*compile*" ...
            ... "%f:%l: warning: `.*' might be used uninitialized in this function"

sA
    Some versions of cDgrep(1)cA give the file name first and then the lines on
    the following lines. This is not a major problem as cDget-next-linecA
    remembers the last file name. The only problem occurs when skipping some
    parts of the list at which point the last file name parsed may not be the
    current file. Following is an example output of such a cDgrepcA and the setup
    required:

        File foo.c:
        Line 45:      printf("hello world\n") ;
        Line 46:      printf("hello again\n") ;


    The configuration to locate the lines is defined as:
sB
        0 add-next-line "*grep*"
        add-next-line "*grep*" "File %f:"
        add-next-line "*grep*" "Line %l:"

sA

cEcENOTES cEcA


    The reinitialize command format of this command changed in January 2001,
    the format changed from:
sB
        add-next-line "*grep*" ""

sA

cEcESEE ALSO cEcA


    lslm$file-template(5)le, lslm$line-template(5)le, cDcc(1)cA, lslmcompile(3)le, lslmget-next-line(2)le,
    cDgrep(1)cA, lslmgrep(3)le.
! 2 save-registry
cEcENAME cEcA


    save-registry - Write a registry definition file
$a


cEcESYNOPSIS cEcA


    cCncA cDsave-registrycA ["cCrootcA" "cCfilecA"]


cEcEDESCRIPTION cEcA


    cDsave-registrycA saves a registry tree, defined by cCrootcA, to a registry file
    cCfilecA in the lslmerf(8)le format. By default the user is prompted for the
    registry cCrootcA to save, which must already exist. If the cCfilecA given is the
    empty string cG""cA, the registry node cCrootcA must be a root node with an
    associated file name stored, this file name is used.

    The argument cCncA may be used to control the effect of the command, cCncA is a
    bit based flag defined as follows:-

    cD0x01cA
        Enables prompting before saving, only used when saving all registries.

    cD0x02cA
        Save all changed registries except the history node which should be
        saved using the command lslmsave-session(3)le.


cEcENOTES cEcA


    This command is called to save all registry changes whenever MicroEmacs is
    exited.


cEcESEE ALSO cEcA


    lslmcopy-registry(3)le, lslmdelete-registry(2)le, lslmlist-registry(2)le, lslmmark-registry(2)le,
    lslmread-registry(2)le, lslmsave-session(3)le, lslmset-registry(2)le, lslm&reg(4)le, lslmerf(8)le.
! 2 command-apropos
cEcENAME cEcA


    command-apropos - List commands involving a concept
$a


cEcESYNOPSIS cEcA


    cCncA cDcommand-aproposcA "cCstringcA" (cDC-h acA)


cEcEDESCRIPTION cEcA


    cDcommand-aproposcA compiles a list of all commands with cCstringcA in their name,
    also giving their current key bindings. Only commands that are not hidden
    are displayed, if a numeric argument of 0 is supplied then all commands
    are displayed, irrespective of their visibility.


cEcEEXAMPLE cEcA


    To find all of the commands with "cGcommandcA" in their name space then issue
    the command "cGC-h a commandcA" which generates a list of commands such as:-

        abort-command ................. "C-g"
                                        "esc C-g"
                                        "C-x C-g"
        command-apropos ............... "C-h a"
        command-complete
        execute-named-command ......... "esc x"
        help-command .................. "C-h C-c"
        ipipe-shell-command ........... "esc \\"
        list-commands ................. "C-h c"
        pipe-shell-command ............ "esc !"
                                        "esc @"
                                        "C-x @"
        shell-command


cEcESEE ALSO cEcA


    lslmdescribe-bindings(2)le.
! 2 forward-char
! 2 backward-char
cEcENAME cEcA


|forward-char
    forward-char - Move the cursor right
|backward-char
    backward-char - Move the cursor left
$a


cEcESYNOPSIS cEcA


    cCncA cDforward-charcA (cDC-fcA)
    cCncA cDbackward-charcA (cDC-bcA)


cEcEDESCRIPTION cEcA


    cDbackward-charcA moves the cursor cCncA characters to the left. Move to the end
    of the previous line if the cursor was at the beginning of the current
    line.

    cDforward-charcA moves the cursor cCncA characters to the right. Move to the
    beginning of the next line if the cursor was already at the end of the
    current line.


cEcENOTES cEcA


    cDbackward-charcA is also bound to cDleftcA.
    cDforward-charcA is also bound to cDrightcA.


cEcESEE ALSO cEcA


    lslmforward-line(2)le, lslmbackward-line(2)le.
! 2 start-kbd-macro
! 2 end-kbd-macro
cEcENAME cEcA


|start-kbd-macro
    start-kbd-macro - Start/stop recording keyboard macro
|end-kbd-macro
    end-kbd-macro - Stop recording keyboard macro
$a


cEcESYNOPSIS cEcA


    cDstart-kbd-macrocA (cDC-x (cA)
    cDend-kbd-macrocA (cDC-x )cA)


cEcEDESCRIPTION cEcA


    A keyboard macro is a short hand way to repeat a series of characters. In
    effect, a cCrecordingcA is made of the sequence of keys that you hit while
    defining a keyboard macro. The recording is started with cDstart-kbd-macrocA
    and ended with cDend-kbd-macrocA. The recording is then repeated whenever you
    execute the keyboard macro using lslmexecute-kbd-macro(2)le.

    Since it is key-strokes that are being saved, you can freely intermix
    commands and text to be inserted into the buffer.

    You can save a keyboard macro for later using the lslmname-kbd-macro(2)le
    command, which saves the keyboard macro as a named macro. Otherwise if you
    start another keyboard macro recording session, the previously defined
    macro is lost. So make sure that you are done with the current keyboard
    macro before defining another one. If you have a series of commands that
    you would like to cCrecordcA for later use, lslminsert-macro(2)le can be used to
    insert the macro into a text file and can be reloaded using the
    lslmexecute-file(2)le or lslmexecute-buffer(2)le commands.

    Recording commences with cDstart-kbd-macrocA (cGC-x (cA) and terminates when an
    cDend-kbd-macrocA (cGC-x )cA is encountered.


cEcENOTES cEcA


    Once cDstart-kbd-macrocA has been executed, the mouse is disabled until
    cDend-kbd-macrocA is executed. This is because the mouse events cannot be
    successfully recorded in macros. The main menu can still be used, but only
    via the keyboard bindings and hot-keys (note that the layout of the menu
    may change).


cEcESEE ALSO cEcA


    lslmexecute-kbd-macro(2)le, lslminsert-macro(2)le, lslmkbd-macro-query(2)le,
    lslmname-kbd-macro(2)le.
! 2 beginning-of-buffer
! 2 end-of-buffer
cEcENAME cEcA


|beginning-of-buffer
    beginning-of-buffer - Move to beginning of buffer/file
|end-of-buffer
    end-of-buffer - Move to beginning/end of buffer/file
$a


cEcESYNOPSIS cEcA


    cDbeginning-of-buffercA (cDesc <cA)
    cDend-of-buffercA (cDesc >cA)


cEcEDESCRIPTION cEcA


    cDbeginning-of-buffercA places the cursor at the beginning of the buffer/file.

    cDend-of-buffercA places the cursor at the end of the buffer/file.


cEcENOTES cEcA


    cDbeginning-of-buffercA is typically bound to cDhomecA.
    cDend-of-buffercA is typically bound to cDendcA.


cEcESEE ALSO cEcA


    lslmbeginning-of-line(2)le, lslmend-of-line(2)le.
! 2 global-bind-key
! 2 global-unbind-key
cEcENAME cEcA


|global-bind-key
    global-bind-key - Bind a key to a named command or macro
|global-unbind-key
    global-unbind-key - "Unbind a key from a named command or macro"
$a


cEcESYNOPSIS cEcA


    cCncA cDglobal-bind-keycA "cCcommandcA" "cCkeycA" (cDesc kcA)
    cCncA cDglobal-unbind-keycA "cCkeycA" (cDesc C-kcA)


cEcEDESCRIPTION cEcA


    cDglobal-bind-keycA takes one of the named commands and binds it to a key.
    Thereafter, whenever that key is struck, the bound command is executed. If
    an argument cCncA is given then the bound command is executed cCncA times when the
    key is struck. (i.e. the command is passed the numeric argument 'cCncA').

    cDglobal-unbind-keycA unbinds (detaches) a user entered cCkeycA sequence (i.e. cGC-x
    C-fcA) from any command to which it may be bound. This does not work with
    lsbuffer-bind-key(2)lmbufferle or lsml-bind-key(2)lmmessage linele key bindings, see lslmbuffer-unbind-key(2)le and
    lslmml-unbind-key(2)le. If an argument of 0 is given to cDglobal-unbind-keycA, only
    a single key is obtained for the user, if the character is currently bound
    to the lsprefix(2)lmprefixle command, the prefix binding and any sub-bindings are
    removed. cDglobal-bind-keycA calls cDglobal-unbind-keycA first if the key to be
    bound is already bound to something else.

    If a negative argument is given to cDglobal-unbind-keycA then all bindings are
    removed, cDcautioncA - removing all bindings interactively will render the
    current MicroEmacs session unusable. This can only be used within macro
    development where new bindings are created immediately afterwards.

    The cDglobal-bind-keycA command, currently bound to cGesc kcA, prompts the user
    for the named command and the key to which it is to be bound. This help
    file gives a complete list of all built in commands, and some useful
    macros, a complete list of all commands and macros can be obtained by
    using the command completion (type cGesc xcA cGtabcA cGtabcA, see lslmml-bind-key(2)le) or
    using the command lslmdescribe-bindings(2)le.

    The mouse buttons are considered to be cCkeyscA, there is a cCkeycA for each
    button press and release event, use lslmdescribe-key(2)le to get the binding key
    string.

    The non-ASCII standard keys such as the cursor keys have 'standard' key
    names to make cross platform binding support easy. Some systems such as
    cCtermcapcA do not have fixed key-bindings, for these key the users must use
    the command lslmtranslate-key(2)le to convert the system key binding to the
    standard key binding.

    Permanent changes are done indirectly through the cGme.emfcA file. This is a
    file that MicroEmacs 2009 reads and executes (see lslmexecute-file(2)le) during
    startup and hence results in the appearance of a permanent change in the
    key bindings. The syntax of commands in the cGme.emfcA file is described under
    the lsexecute-file(2)lmexecute-filele command. Of principal concern here are the two commands
    cDglobal-bind-keycA and cDglobal-unbind-keycA. The primary difference between the
    way parameters are passed to these commands in the cGme.emfcA file is that the
    keys are not typed in directly (as in the cCcontrol-IcA key when you want cGC-icA)
    but by symbolic names. Every key has a unique name which can be easily
    obtained with the current binding by using the command lslmdescribe-key(2)le.

    See help on lskeyNames(2)lmKey Namesle for a description of the symbolic naming system and
    a complete list of valid key names. Also see lsBindings(2)lmBindingsle for a complete list
    of default key bindings.


cEcEEXAMPLE cEcA


    cDAlt PcA
sB
        global-bind-key "func" "A-p"

sA
    cDControl F2cA
sB
        global-bind-key "func" "C-f3"

sA
    cDShift Alt Left CursorcA
sB
        global-bind-key "func" "A-S-left"

sA
    cDControl Alt DeletecA
sB
        global-bind-key "func" "C-A-delete"

sA
        Note that binding cDControl-Alt-DeletecA is not recommended for MS-DOS
        systems for obvious reasons.


cEcENOTES cEcA


    Some ASCII keys, such as cG<CR>cA (C-m), cG<tab>cA (C-i), cG<BACKSPACE>cA (C-h) have
    non-ASCII key bindings, namely "cDreturncA", "cDtabcA", "cDbackspacecA" etc. this is
    to allow separate key-bindings for the real "cDC-mcA" etc.

    Be very careful in binding and unbinding keys since you could get into
    some very peculiar situations such as being unable to abort out of a
    command (if you unbind CTRL-G or bind it to something else) or recover
    from the bad binding/unbinding if you unbind lslmexecute-named-command(2)le or
    the cDglobal-unbind-keycA command. As long as you leave yourself the
    opportunity to do both of the last two commands, you can recover from
    disastrous bindings/unbindings.


cEcESEE ALSO cEcA


    lslmbuffer-bind-key(2)le, lslmbuffer-unbind-key(2)le, lslmdescribe-bindings(2)le,
    lslmdescribe-key(2)le, lslmml-bind-key(2)le, lslmml-unbind-key(2)le, lslmtranslate-key(2)le.
! 2 buffer-info
cEcENAME cEcA


    buffer-info - Status information on current buffer position
$a


cEcESYNOPSIS cEcA


    cCncA cDbuffer-infocA (cDC-x =cA)


cEcEDESCRIPTION cEcA


    cDbuffer-infocA reports on the current and total lines and characters of the
    current buffer. It also gives the hexadecimal code of the character
    currently under the cursor.

    The output of the command is displayed on the message line e.g.

        Line 1845/3955 Col 0/0 Char 78267/167172 (46%) Win Line 99/48 ACol 0/0 char 10 (0x0a)


    lslm$result(5)le is set to the same output string unless a numeric value of zero
    is given to the command in which case the values are given in a ls&ldel(4)lmMicroEmacsln
    lnlistle format and not printed to the message line; this information can be
    useful in macros.


cEcESEE ALSO cEcA


    lslm$result(5)le, lslm$mode-line(5)le, lslmabout(2)le.
! 2 capitalize-word
! 2 lower-case-word
! 2 upper-case-word
! 2 lower-case-region
! 2 upper-case-region
cEcENAME cEcA


|capitalize-word
    capitalize-word - Capitalize word
|lower-case-word
    lower-case-word - Lowercase word (downcase)
|upper-case-word
    upper-case-word - Uppercase word (upcase)
|lower-case-region
    lower-case-region -  Lowercase a region (downcase)
|upper-case-region
    upper-case-region - Uppercase a region (upcase)
$a


cEcESYNOPSIS cEcA


    cCncA cDcapitalize-wordcA (cDesc ccA)
    cCncA cDlower-case-wordcA (cDesc lcA)
    cCncA cDupper-case-wordcA (cDesc ucA)

    cDlower-case-regioncA (cDC-x C-lcA)
    cDupper-case-regioncA (cDC-x C-ucA)


cEcEDESCRIPTION cEcA


    cDcapitalize-wordcA capitalizes the next cCncA words.

    cDlower-case-wordcA changes the next cCncA words to lower case.

    cDupper-case-wordcA changes the next cCncA words to upper case.

    cDlower-case-regioncA changes all alphabetic characters in the marked region
    to lower case (see lslmset-mark(2)le).

    cDupper-case-regioncA changes all alphabetic characters in the marked region
    to upper case


cEcESEE ALSO cEcA


    lslmset-mark(2)le.
! 2 change-file-name
cEcENAME cEcA


    change-file-name - Change the file name of the current buffer
$a


cEcESYNOPSIS cEcA


    cDchange-file-namecA "cCfile-namecA" (cDC-x ncA)


cEcEDESCRIPTION cEcA


    cDchange-file-namecA changes the file name of the current buffer to cCfile-namecA.
    A validity check is made on the given file name and if found to be invalid
    (e.g. its a directory) the name is rejected.


cEcESEE ALSO cEcA


    lslmchange-buffer-name(2)le, lslmwrite-buffer(2)le.
! 2 change-frame-depth
! 2 change-frame-width
! 2 change-screen-depth
! 2 change-screen-width
cEcENAME cEcA


|change-frame-depth
    change-frame-depth - Change the number of lines on the current frame
|change-frame-width
    change-frame-width - Change the number of columns on the current frame
$a


cEcESYNOPSIS cEcA


    cCncA cDchange-frame-depthcA [ "cCdepthcA" ]
    cCncA cDchange-frame-widthcA [ "cCwidthcA" ]


cEcEDESCRIPTION cEcA


    cDchange-frame-depthcA changes the depth of the current frame, if the numeric
    argument cCncA is given then the frame depth is changed by cCncA lines. If cCncA is
    not specified the user is prompted for the new cCdepthcA and the frame depth
    will be changed to this value. It is assumed that the screen can draw the
    requested cCncA lines and MicroEmacs draws the lines at the users peril.

    A change in depth causes all of the internal windows currently displayed
    in the frame to be re-sized, the vertical position of the windows are
    modified to match the new screen dimension, the horizontal position of the
    windows remains unaltered. If the window is down-sized and the currently
    displayed windows are not able to fit into the new screen space then all
    windows are deleted with the exception of the current window.

    cDchange-frame-widthcA changes the width of the current frame, if the numeric
    argument cCncA is given then the frame width is changed by cCncA characters. If cCncA
    is not specified the user is prompted for the new cCwidthcA and the frame
    width will be changed to this value. It is assumed that the screen can
    draw the requested cCncA columns and MicroEmacs draws them at the users peril.
    The windows are reorganized as cDchange-frame-depthcA working horizontally
    rather than vertically.


cEcENOTES cEcA


    Within windowing environments such as cDX-WindowscA and cDMicrosoft WindowscA
    these commands cause the canvas window to be re-sized to accommodate the
    change in screen size.

    In MS-DOS and UNIX Termcap environments the physical size of the screen is
    determined by the characteristics of the display adapter.
    cDchange-frame-depthcA may be used to correct anomalies (usually on portables)
    in the displayable screen area and the graphics mode. e.g. In DOS the
    graphics mode utilizes 50 lines, and only 47 lines are viewable. In this
    case change the screen depth to 47 and MicroEmacs will not utilize the
    remaining lines which are not viewable.


cEcESEE ALSO cEcA


    lslm$frame-depth(5)le, lslm$frame-width(5)le.
! 2 search-buffer
cEcENAME cEcA


    search-buffer - Search the current buffer for a string
$a


cEcESYNOPSIS cEcA


    cCncA cDsearch-buffercA "cCflagscA" "cCstringcA"


cEcEDESCRIPTION cEcA


    cDsearch-buffercA searches for a cCstringcA from the current cursor position, in a
    forwards or backwards direction, to the end or start of the buffer,
    respectively. The search direction and mode is specified by the by cCflagscA
    argument.

    The cDsearch-buffercA command is designed to be used from the macro language
    rather than the command line as the search may be defined independently of
    the buffer setting of lslmmagic(2m)le mode, which allows regular expression
    pattern matching, or lslmexact(2m)le mode, which makes the search case
    sensitive. The cCflagscA argument is used to explicitly set the lslmmagic(2m)le and
    lslmexact(2m)le search modes.

    The cCflagscA argument is defined as a character string which defines the
    search behavior:

    cGbcA - backward search
        Specifies the direction of the search as backwards, when omitted then
        a forward search is performed.

    cGecA - enable exact search
        A lslmexact(2m)le mode search is performed, the characters are matched case
        sensitively.

    cGEcA - disable exact search
        A lslmexact(2m)le mode search is not performed, the characters are matched
        case insensitively.

    cGmcA - enable magic
        A lslmmagic(2m)le mode search is performed, the search cCstringcA is interpreted
        as a regular expression.

    cGMcA - disable magic
        A lslmmagic(2m)le mode search is not performed, the search string is
        searched for literally.

    When the cCflagscA are not specified then the default behavior is to search in
    a forwards direction inheriting the lslmexact(2m)le and lslmmagic(2m)le modes of the
    buffer. Within macros it is suggested that the search modes are explicitly
    specified unless the buffer modes are to be inherited.

    The numeric argument cCncA is interpreted in the same way as a
    lslmsearch-forward(2)le command:-

    cDn > 0cA
        The cCncAth occurrence of the cCstringcA is located.

    cDn < 0cA
        The first occurrence of the cCstringcA is located in the next cCncA lines.


cEcEDIAGNOSTICS cEcA


    The command returns a status of cGFALSEcA if the cCstringcA could not be located
    (or cCncAth cCstringcA where cCncA occurrences are requested). If the cCstringcA is found
    within the given search criteria the return status is cGTRUEcA.


cEcEEXAMPLE cEcA


    The following examples show the use of the cDsearch-buffercA command. The
    cDsearch-buffercA is usually used with the lslm!force(4)le directive which traps any
    cGFALSEcA return status and may be subsequently tested using the lslm!if(4)le
    directive on the status lslm$status(5)le variable. If the cD!forcecA directive is
    omitted then the macro will abort with a failure status if the search
    fails (sometimes this behavior may be required).

    Case sensitive search forward for the word "cGfoocA", this is not a magic
    regular expression.
sB
        !force search-buffer "eM" "foo"
        !if $status
            ; found string
        !else
            ; not found
        !endif

sA
    Case sensitive search bacward for the word "cGfoocA", this is not a magic
    regular expression.
sB
        search-buffer "beM" "foo"

sA
    Regular expression search forward for `cG<cA' or `cG>cA'.
sB
        search-buffer "m" "[<>]"

sA
    Regular expression search catching the regular expression. A[a-z]*. The
    macro variable cD@s1cA returns the regular expression string that has been
    found.
sB
        !force search-buffer "em" "\\(A[a-z]*\\)"
        !if $status
            ; found string
            1000 ml-write &spr "Found string '%s'" @s1
        !else
            ; not found
        !endif

sA

cEcENOTES cEcA


    cDSearch-buffercA was added in November 2004 to simplify macro writing and to
    speed up macro execution. It replaces the macro commands cDregex-forward(3)cA
    and cDregex-backward(3)cA. The command simplifies macro development by
    allowing the lslmexact(2m)le and lslmmagic(2m)le modes to be specified on the command
    line, this ensures that the buffer mode does not need to be saved, set and
    then restored in order to modify the behaviour of a search operation.


cEcESEE ALSO cEcA


    lslmbuffer-mode(2)le, lslmexact(2m)le, lslmhunt-backward(2)le, lslmhunt-forward(2)le,
    lslmisearch-forward(2)le, lslmnarrow-search-forward(3)le, lslmmagic(2m)le,
    lslmreplace-string(2)le, lslmsearch-backward(2)le, lslmsearch-forward(2)le.
    lsRegularExpressions(2)lmRegular Expressionsle
! 2 compare-windows
! 3 compare-windows-exact
cEcENAME cEcA


|compare-windows
    compare-windows - Compare buffer windows, ignore whitespace.
|compare-windows-exact
    compare-windows-exact - Compare buffer windows, with whitespace.
$a


cEcESYNOPSIS cEcA


    cCncA cDcompare-windowscA
    cDcompare-windows-exactcA


cEcEDESCRIPTION cEcA


    cDcompare-windowscA compares the textural content of ALL the current windows
    from their current cursor position. These commands are generally used to
    locate the next difference in the windows displayed. Returns cGTRUEcA if the
    buffers of the windows do not differ from the current position to the end
    of the file (inclusive), else returns cGFALSEcA setting the cursor of each
    buffer to the first point of difference.

    The default mode of operation ignores white-space, a numeric argument cCncA of
    zero (0) then an exact white-space match is performed.

    cDcompare-windows-exactcA is a macro short cut for cC0 compare-windowscA, forcing
    a white space comparison.


cEcESEE ALSO cEcA


    lslmdiff(3)le, lslmdiff-changes(3)le, lslmgdiff(3)le.
! 2 set-scroll-with-mouse
cEcENAME cEcA


    set-scroll-with-mouse - Scroll the window with the mouse
$a


cEcESYNOPSIS cEcA


    cCncA cDset-scroll-with-mousecA


cEcEDESCRIPTION cEcA


    The cDset-scroll-with-mousecA command controls the scrolling of a window by
    the mouse. This is a two stage process, the first stage locks the cursor
    to the mouse, the second stage scrolls the screen.

    The first stage (locking) is performed when the mouse is located on the
    scroll-box (typically when the left button is depressed i.e.
    cDpick-mouse-1cA). cDset-scroll-with-mousecA is invoked with an argument cCncA, this
    causes the mouse position to be recorded ready for a scroll. Depending on
    the scroll method, the blank lines present at the end of the buffer are
    scrolled off the screen.

    Subsequent calls to the cDset-scroll-with-mousecA are made with no argument,
    the window is scrolled by the relative displacement of the mouse from it's
    locked position, motion is limited at the end of the scrolling region.
    Scrolling is proportional to the buffer length. The command is typically
    bound to cDmove-mouse-1cA which results in an update whenever the mouse is
    moved by the user.

    When the button is released cDdrop-mouse-1cA then the scrolling is stopped by
    unbinding cDmove-mouse-1cA, thereby breaking the binding between the mouse
    moving and the scroll command.

    The scrolling utilizes fractional mouse positional information (i.e. units
    smaller than a character cell), if available, resulting in a smoother
    scrolling motion.


cEcEEXAMPLE cEcA


    The following example shows how the command is used.
sB
        0 define-macro mouse-scroll-pick
            1 set-scroll-with-mouse         ; Lock mouse position to scroller
            global-bind-key set-scroll-with-mouse "mouse-move-1"
        !emacro

        0 define-macro mouse-scroll-drop
            global-unbind-key "mouse-move-1"
        !emacro

        global-bind-key mouse-scroll-pick "mouse-pick-1"
        global-bind-key mouse-scroll-drop "mouse-drop-1"

sA
    When the left button is 'picked', cDmouse-scroll-pickcA lock the cursor to the
    mouse and binds mouse movement to cDset-scroll-with-mousecA so that whenever
    the mouse is moved the cursor will be repositioned appropriately. When the
    button is 'dropped', the mouse movement is unbound so that the cursor will
    no longer be locked to the mouse.


cEcESEE ALSO cEcA


    lslm$mouse-pos(5)le, lslm$scroll-bar(5)le, lslmset-cursor-to-mouse(2)le.
! 2 copy-region
cEcENAME cEcA


    copy-region - Copy a region of the buffer
$a


cEcESYNOPSIS cEcA


    cCncA cDcopy-regioncA (cDesc wcA)


cEcEDESCRIPTION cEcA


    cDcopy-regioncA copies all the characters between the cursor and the mark set
    with the lslmset-mark(2)le command into the kill buffer (so they can later be
    lsyank(2)lmyankedle elsewhere).

    If the last command also entered text into the kill buffer (or the lslm@cl(4)le
    variable is set to one of these commands) the cDcopy-regioncA text is appended
    to the last kill.

    The numeric argument cCncA determines how the copy operates when a narrow
    region, defined by lslmnarrow-buffer(2)le, is encountered. The default
    operation, when the number argument is cG1cA, is to copy all of the text
    contained within the narrowed region. When the numeric argument is cG0cA then
    narrowed region is NOT copied and the text is copied as it appears in the
    buffer.


cEcEUSAGE cEcA


    To copy text from one place to another, using the cDcopy-regioncA command, the
    following operations are performed:

        * Move to the beginning of the text you want to copy.
        * Set the mark there with the lsset-mark(2)lmset-markle (cDesc-spacecA) command.
        * Move the point (cursor) to the end of the text.
        * Use cDcopy-regioncA to copy the region you just defined. The text will
          be saved in the kill buffer. (If you accidentally delete the text
          use lsyank(2)lmyankle (cDC-ycA) immediately or lsundo(2)lmundole (cDC-x ucA) to restore the text).
        * Move the point to the place you want the text to appear.
        * Use the lsyank(2)lmyankle (cDC-ycA) command to copy the text from the kill buffer to
          the current point.

    Repeat the last two steps to insert further copies of the same text.


cEcENOTES cEcA


    Windowing systems such as X-Windows and Microsoft Windows utilize a global
    windowing kill buffer allowing data to be moved between windowing
    applications (cCcut buffercA and cCclipboardcA, respectively). Within these
    environments MicroEmacs 2009 automatically interacts with the windowing
    systems kill buffer, the last MicroEmacs 2009 cDcopy-regioncA entry is
    immediately available for a paste operation into another windowing
    application.

    The numeric argument cCncA was introduced in the '04 release.


cEcESEE ALSO cEcA


    lslmexchange-point-and-mark(2)le, lslmkill-region(2)le, lslmnarrow-buffer(2)le, lslmset-mark(2)le,
    lslmyank(2)le.
! 2 count-words
cEcENAME cEcA


    count-words - Count the number of words in a region
$a


cEcESYNOPSIS cEcA


    cDcount-wordscA (cDesc C-ccA)


cEcEDESCRIPTION cEcA


    cDcount-wordscA Counts the number of words between the lslmset-mark(2)le position
    and the current cursor position. The command also gives statistics on the
    number of characters and the average characters per word. The output
    appears on the message line in a format such as:-

        cG54 Words, 345 Chars, 8 LinescA

    lslm$result(5)le is set to the same output string.


cEcESEE ALSO cEcA


    lslm$result(5)le, lslmbuffer-info(2)le, lslmset-mark(2)le.
! 2 create-callback
cEcENAME cEcA


    create-callback - Create a timer callback
$a


cEcESYNOPSIS cEcA


    cCncA cDcreate-callbackcA "cCcommandcA"


cEcEDESCRIPTION cEcA


    cDcreate-callbackcA creates a timer based callback command. The given cCcommandcA
    is called back in cCncA milliseconds time. This can be used by the user to
    monitor system events (such as incoming mail). The command is called only
    once, but if the command creates a callback of itself a loop is created.

    If a negative argument cCncA is given any pending callback for cCcommandcA is
    cancelled.


cEcEEXAMPLE cEcA


    The following example creates a callback that is invoked every 10 minutes.
sB
        define-macro Example-callback
            ml-write "It was 10 minutes since you last saw me!"
            600000 create-callback Example-callback
        !emacro
        Example-callback

sA

cEcENOTES cEcA


    A call-back cannot interrupt while MicroEmacs is active, instead the
    call-back is delayed until MicroEmacs becomes inactive. MicroEmacs is
    considered to be inactive when it is waiting for user input, this could be
    during the execution of another macro. If a command or macro requires no
    user input then once execution has started, it cannot be interrupted by a
    call-back macro.

    The resolution of the clock is platform dependent, some platforms limit
    the minimum timer period to 10 milliseconds.

    MicroEmacs does not guarantee to service the callbacks within any set time
    constraints, the resultant callback intervals may be of a slightly
    different duration than requested.

    When a callback macro is executed, the key given by lslm@cck(4)le is "cGcallbackcA.
    If the current buffer has a lslm$buffer-input(5)le command set, this command
    will be called instead of the callback command with cD@cccA and cD@cckcA set
    appropriately. It is the responsibility of the input macro to deal with
    the callback.


cEcESEE ALSO cEcA


    lslm$auto-time(5)le, lslmdefine-macro(2)le.
! 2 list-registry
cEcENAME cEcA


    list-registry - Display the registry in a buffer
$a


cEcESYNOPSIS cEcA


    cCncA cDlist-registrycA ["cCpathcA"] ["cCbuffercA"]


cEcEDESCRIPTION cEcA


    cDlist-registrycA lists the contents of the registry in the a buffer in a
    hierarchical format. The key name and any associated string is optionally
    shown as a hierarchical tree, the resultant information that is displayed
    is controlled by the numeric argument cCncA and mode of the registry node.

    The registry listing is generated in the buffer "cG*registry*cA" by default,
    the buffer may be modified with the cCbuffercA argument.

    The numerical argument cCncA is interpreted as a bit-mask as follows:-

    cC1cA
        If bit cG0x1cA is clear then the listing buffer is specified by the
        argument cCbuffercA. The default (when set) used buffer cG*registry*cA.

    cC2cA
        If bit cG0x2cA is set the path of the root of the registry is defined by
        argument cCpathcA. The default when clear is to list the whole registry.

    The visibility of the node is controlled by the attributes assigned by
    lslmmark-registry(2)le. The node value may be hidden (modes cG!cA, cGicA and cGhcA) and are
    not displayed in the resultant listing.


cEcEHISTORY cEcA


    The numeric argument to cDlist-registrycA with associated parameters and
    extended hidden modes were added in January 2005.


cEcESEE ALSO cEcA


    lslmcopy-registry(3)le, lslmdelete-registry(2)le, lslmmark-registry(2)le, lslmread-registry(2)le,
    lslmsave-session(3)le, lslmsave-registry(2)le, lslmset-registry(2)le, lslm&reg(4)le, lslmerf(8)le.
! 2 beginning-of-line
! 2 end-of-line
cEcENAME cEcA


|beginning-of-line
    beginning-of-line - Move to beginning of line
|end-of-line
    end-of-line - Move to end of line
$a


cEcESYNOPSIS cEcA


    cDbeginning-of-linecA (cDC-acA)
    cDend-of-linecA (cDC-ecA)


cEcEDESCRIPTION cEcA


    cDbeginning-of-linecA places the cursor at the beginning of the line.

    cDend-of-linecA places the cursor at the end of the line.


cEcESEE ALSO cEcA


    lslmbeginning-of-buffer(2)le, lslmend-of-buffer(2)le.
! 2 change-font
cEcENAME cEcA


    change-font - Change the screen font
$a


cEcESYNOPSIS cEcA


    cC[X-Windows]cA
    cDchange-fontcA "cCfontNamecA"

    cC[IBM-PC / MS-DOS]cA
    cDchange-fontcA "cCmode-nocA" "cCspeccA"

    cC[Microsoft Windows]cA
    cCncA cDchange-fontcA "cCnamecA" cCcharSetcA cCweightcA cCwidthcA cCheightcA


cEcEDESCRIPTION cEcA


    cDchange-fontcA is a platform specific command which allows the displayable
    font to be modified. The selection of font is determined by the monitor
    resolution and the capabilities of the graphics adapter.

    This command is available on all systems except termcap. While MS-DOS does
    not support the concept of different fonts, it does (or at least the
    graphics card does) support the concept of changing screen resolution,
    which has the effect of changing the font. Each platform takes different
    arguments and are considered independently, as follows:


cEX-Windows cA


    The X-Windows UNIX environments accept a single argument which is a fully
    qualified font name. Simply give the font X name and the font will change
    if it is available. The window size changes to attempt to retain the same
    number of rows and columns so ensure that when changing to a larger font
    then there is enough room (or a way) to resize a window which is larger
    than the actual screen.

    The X font string describes the attributes of the font in terms of it's
    size name etc. as follows:-

    -cCfoundrycA-cCfamilycA-cCweightcA-cCslantcA-cCwidthcA--cCpixelscA-cCpointcA-cChrescA-cCvrescA-cCspacecA-cCavcA-cCsetcA

    Where

    cCfoundrycA
        The type of foundry that digitized and supplied the font.

    cCfamilycA
        Font Family.

    cCweightcA
        Modifies the appearance of the font, the cCweightcA is usually cDmediumcA or
        cDboldcA.

    cCslantcA
        Determines the orientation of the font. cCslantcA is usually cDrcAoman
        (upright), cDicAtalic or cDocAblique.

    cCwidthcA
        Describes the proportionate width of the font. Typical widths include
        cDnormalcA, cDcondensedcA, cDnarrowcA, cDdoublecA.

    cCpixelscA
        Pixel size of the font

    cCpointcA
        The resolution of the font in tenths of a cDdpicA (i.e. dpi*10)

    cChrescA
        Horizontal resolution of the font in dpi.

    cCvrescA
        Vertical resolution of the font in dpi.

    cCspacecA
        The spacing of the font. Typical spacing values include cDmcAonospaced
        (i.e. fixed width), cDpcAroportional and cDccAharacter cell.

    cCavcA
        Mean width of all font characters, measured in tenths of a pixel.

    cCsetcA
        Character set - character set standards e.g. cDiso8859-1cA.

    The default font used by MicroEmacs 2009 is

        -*-fixed-medium-r-normal--15-*-*-*-c-90-iso8859-1


    A good font to try is:
sB
        change-font "-misc-fixed-medium-r-normal--13-*-*-*-c-80-iso8859-1"

sA
    The font may also be changed in your cD.XdefaultscA file by inserting the
    line:-

        MicroEmacs.font "-misc-fixed-medium-r-normal--13-*-*-*-c-80-iso8859-1"


cEIBM-PC / MS-DOS cA


    MS-DOS may only change the screen resolution, the standard screen
    resolution is either 80 columns by 25 rows or 80 by 50. A more advanced
    graphics card can typically support up to 132 by 60, MicroEmacs in theory
    has no limit but it has only been tested up to this size.

    The main problem with MS-DOS machines is that there is no standard and
    this is no exception. The graphics mode needed to get a 132 by 60 screen
    (if available) varies from one card to the next so MicroEmacs 2009 needs
    to know the graphic mode number your card uses to get your required screen
    resolution.

    MicroEmacs 2009 can also attempt a little bit of magic to double the
    number of rows on the screen for a given screen resolution. This is how 50
    lines are obtained from the standard 25 line mode 3. If the value of
    "cCspeccA" is non-zero then this is attempted, to the authors knowledge this
    will either work or not depending on the direction of the wind and no harm
    will befall the users equipment. However the author also quickly disclaims
    anything and everything, the user uses this at their own peril, like
    everything else.

    MicroEmacs 2009 attempts to determine the new screen width and depth
    itself, in case this fails the commands lslmchange-frame-width(2)le and
    lslmchange-frame-depth(2)le may be used to correct the problem.

    Following are the standard MS-DOS text modes:
sB
        change-font "2" "0"       ; Simple monochrome or EGA monitor, 80 by 25.
        change-font "3" "0"       ; Simple EGA/VGA monitor, again 80 by 25.
        change-font "3" "1"       ; Simple EGA/VGA monitor using spec, 80 by 50.

sA
    Most Trident cards support the following text mode:
sB
        change-font "86" "0"      ; Sweet 132 by 60

sA
    A Diamond Stealth supports the following mode:
sB
        change-font "85" "1"      ; Nice 132 by 50

sA
    Cirrus video cards (1MB) seem to support:
sB
        change-font "84" "1"      ; PT-526 (132x50)

sA
    Time to start digging out your graphics card manual!


cEMicrosoft Windows cA


    The Microsoft Windows environments utilize font files to drive the
    display. When cDchange-fontcA is invoked with no arguments, or a negative
    argument then a font dialog is presented to the user to allow the font to
    be selected. The current font is not changed if a negative argument is
    given, in both cases the variable lslm$result(5)le is set the the user selected
    font. The format of the returned string is "cGOWwwwwhhhhhFontNamecA", where:-

    cDOcA
        The type of character set (0 for OEM and 1 for ANSI).

    cDWcA
        The font weight (0 - 9).

    cDwwwwcA
        The font width.

    cDhhhhcA
        The font height.

    cDFontNamecA
        The font name.

    If a positive argument is specified with cDchange-fontcA then the arguments
    are explicitly entered, arguments are defined as follows:-

    cCfontcA
        The name of the font - maximum of 32 characters. Select Fixed mono
        fonts only. Proportional fonts may be specified but the cursor will
        not align with the characters on the screen.

        An empty name ("") may be specified resulting in the selection of the
        default system OEM font. No other arguments are required when
        specified.

        Note that cDCourier NewcA is not actually a fixed mono font as might be
        expected.

    cCcharSetcA
        The type of character set required, this is an integer value of:-

            cG  0cA - ANSI or Western (True Type etc)
            cG161cA - Greek
            cG162cA - Turkish
            cG204cA - Russian
            cG255cA - OEM (or bitmapped)

    cCweightcA
        The weight of the font. The values are defined as:-

            cG0cA - Don't care (Automatically selected).
            cG1cA - Thin
            cG2cA - Extra Light
            cG3cA - Light
            cG4cA - Normal
            cG5cA - Medium
            cG6cA - Semi-Bold
            cG7cA - Bold
            cG8cA - Extra-Bold
            cG9cA - Heavy

        Note that you may request a weight and it is not honored. Typically 4
        and 7 are honored by most font definitions. 4 is typically used.

    cCwidthcA
        The width of the font. Specifies the average width, in logical units,
        of characters in the requested font. If this value is zero, the font
        mapper chooses a "closest match" value. The "closest match" value is
        determined by comparing the absolute values of the difference between
        the current device's aspect ratio and the digitized aspect ratio of
        available fonts.

        Note that if the width is specified as zero then the height should be
        specified and the width will be automatically selected.

    cCheightcA
        The height of the font. Specifies the desired height, in logical
        units, of the requested font's character cell or character. (The
        character height value is the character cell height value minus the
        internal-leading value.) If this value is greater than zero, the font
        mapper matches it against available character cell height values; if
        this value is zero, the font mapper uses a default height value when
        it searches for a match; if this value is less than zero, the font
        mapper matches it against available character height values.

        Note: as with the weight the width and height may not be honored if
        the font cannot support the specified width/height in which case the
        closest matching height is automatically selected


cENotes on the Standard Windows Configuration cA


    For releases prior to '99, the cDTerminalcA font is the standard MS-DOS font
    used for the MS-DOS window. This is an OEM fixed width character set which
    contains all of the conventional symbols found in the DOS shell.

    Releases of MicroEmacs post '99 may utilise any of the windows fonts,
    typically cGCourier NewcA or cGLucida ConsolecA are used, these provide the best
    screen rendering of characters. cGLucida ConsolecA is slightly better with a
    smaller font size as this allows a 'cG1cA' (one) and 'cGlcA' (lower case L) to be
    distinguished.

    The cDTerminalcA fonts are the same as shown in the DOS window the last 2
    arguments are the width x height, the terminal equivalents (Bit Mapped)
    are commented here.

    cD7x12cA
        Regular weight seems to offer the best resolution for 14/15" monitors.

    cD6x8cA
        Regular weight is more suitable for 17-21" monitors which offer better
        resolutions.

    The best options for the fonts are defined as follows:-
sB
        ;Standard Terminal Fonts - standard weight
        ;change-font "Terminal" 0 4  4  6
        change-font "Terminal" 0 4  6  8
        ;change-font "Terminal" 0 4  8  8
        ;change-font "Terminal" 0 4  5 12
        ;change-font "Terminal" 0 4  7 12
        ;change-font "Terminal" 0 4  8 12
        ;change-font "Terminal" 0 4 12 16
        ;change-font "Terminal" 0 4 10 18

        ;Standard Terminal Fonts - heavy weight
        ;change-font "Terminal" 0 7  4  6
        ;change-font "Terminal" 0 7  6  8
        ;change-font "Terminal" 0 7  8  8
        ;change-font "Terminal" 0 7  5 12
        ;change-font "Terminal" 0 7  7 12
        ;change-font "Terminal" 0 7  8 12
        ;change-font "Terminal" 0 7 12 16
        ;change-font "Terminal" 0 7 10 18

sA
    The "cDCourier NewcA" font is not actually a fixed mono font as might be
    expected.


cEcESEE ALSO cEcA


    lslmchange-frame-width(2)le, lslmchange-frame-depth(2)le, lslm$result(5)le, lslmuser-setup(3)le.
! 2 prefix
cEcENAME cEcA


    prefix - Key prefix command
|prefix2
    prefix2 - Control(2) prefix
|prefix3
    prefix3 - Control(3) prefix
|prefix4
    prefix4 - Control(4) prefix
$a


cEcESYNOPSIS cEcA


    cCncA cDprefixcA

    Default prefix bindings:

    cDprefix 1cA (cDesccA)
    cDprefix 2cA (cDC-xcA)
    cDprefix 3cA (cDC-hcA)
    cDprefix 4cA (cDC-ccA)


cEcEDESCRIPTION cEcA


    cDprefixcA sets up to 8 prefix key sequences, allowing two stroke key
    bindings. The command does not do anything, it is used to create double
    barrel key bindings such as such as lslmgoto-line(2)le (cDesc gcA). This binding may
    be redefined, redefining ALL meta bindings. If the meta bindings are not
    required the command should first be unbound using the
    lslmglobal-unbind-key(2)le.

    The prefix key can only be defined using the lslmglobal-bind-key(2)le, passing
    the command the prefix number required, for example:
sB
        1 global-bind-key "prefix" "esc "
        2 global-bind-key "prefix" "C-x"

sA
    Binds the first prefix to the Escape key and the second prefix to
    Control-x.

    The first prefix key (cDprefix 1cA) differs from the other prefixes since it
    permits entry of the numeric argument at the message line, e.g. "cGesc 1 0
    C-fcA" will move forward 10 characters.


cEcENOTES cEcA


    Invocating this command via lslmexecute-named-command(2)le or by a macro has no
    effect. It can be bound to only one key sequence which must be a single
    key stroke such as cDC-x cAetc. Re-binding the command to another key will not
    only unbind the new key but also the current cDprefix ?cA key bindings.


cEcESEE ALSO cEcA


    lslmglobal-bind-key(2)le, lslmglobal-unbind-key(2)le.
! 2 define-macro
cEcENAME cEcA


    define-macro - Define a new macro
$a


cEcESYNOPSIS cEcA


    cCncA cDdefine-macrocA cCmacro-namecA
        cCMacro bodycA
    cD!emacrocA


cEcEDESCRIPTION cEcA


    cDdefine-macrocA starts the definition of an macro named cCmacro-namecA, only used
    within macro files or buffers. After the above header line, the body of
    the macro is added, one command or expression on a line. The macro
    definition is completed by the ls!emacro(4)lm!emacrole directive.

    The numeric argument cCncA, specified as zero, defines the macro as private
    such that it does not appear on a command completion list. A zero argument
    is generally used on helper macro's that form part of a larger macro. If
    the argument is omitted, or non-zero, then the macro appears in the
    command completion list.

    See lslmexecute-file(2)le for a complete definition and examples of the
    MicroEmacs 2009 macro language.

    Once the macro has been defined, it becomes indistinguishable from a
    standard MicroEmacs 2009 command, i.e. lslmexecute-named-command(2)le (cGesc xcA)
    can be used to execute the macro and lslmglobal-bind-key(2)le can be used to
    globally bind the command to a key combination.

    There are no restrictions on the number of macros that may be defined,
    provided that the name space is managed properly. Consideration must be
    given as to when any additional macros that are created are loaded into
    MicroEmacs 2009. We usually like start-up to be rapid and macros are
    loaded as and when requested by the user, or by the buffer hooks as new
    files are loaded (see lslmadd-file-hook(2)le and lslmdefine-macro-file(2)le).

    User defined macros may be documented with on-line help by including a
    lslmdefine-help(2)le construct within the macro file.


cEcEEXAMPLE cEcA


    The following are two standard macros provided with MicroEmacs 2009. The
    first is a macro called cDcleancA, this strips trailing white space from the
    ends of lines in a file and removes blank lines from the end of the file.
sB
        define-macro clean
            ;
            ; Prepare to clean up file.
            ; Remember line & magic mode
            set-variable #l0 $window-line
            set-variable #l1 &not &bmod magic
            !if #l1
                1 buffer-mode "magic"
            !endif
            ;
            ; Get rid of trailing white space on EOL
            beginning-of-buffer
            replace-string "[\t ]+$" "\\0"
            beginning-of-buffer
            replace-string "[ ]+\t" "\t"
            ;
            ; Strip trailing blank lines.
            end-of-buffer
            backward-line
            !while &and &gre $window-line 1 &sequal @wc "\n"
                kill-line
                backward-line
            !done
            ;
            ; Clean up - restore buffer modes etc.
            ; Move back to starting line & restore original magic mode
            !force goto-line #l0
            !if #l1
                -1 buffer-mode "magic"
            !endif
            screen-update
            ml-write "Cleaned up file."
        !emacro

sA
    The second example converts all of the cG<tab>cA characters in the file to
    their cG<SPACE>cA character equivalent.
sB
        ;
        ; tabs-to-spaces.
        ; Convert all of the tabs to spaces.
        define-macro tabs-to-spaces
            ; Remember line
            set-variable #l0 $window-line
            beginning-of-buffer
            !force search-forward "\t"
            !while $status
                set-variable #l1 $window-acol
                backward-delete-char
                &sub #l1 $window-acol insert-space
                !force search-forward "\t"
            !done
            goto-line #l0
            screen-update
            ml-write "[Converted tabs]"
        !emacro

sA
    Both of these commands are available from the command line, they are
    indistinguishable from the built in commands.

    Macros may also be nested, as shown in the next example, this macro
    contains a cDdefine-macrocA within itself, when executed the macro creates
    another macro dynamically - dynamic macros are generally given a prefix of
    cD%cA and are highlighted differently in lslmdescribe-bindings(2)le.

    The following example is taken from the lslmalarm(3)le macro, executing cDalarmcA
    the user is prompted for a message, and the time interval before the alarm
    expires in hours and minutes. It then creates a new macro with a callback
    so that the new macro will be called at the correct time.
sB
        !if &seq %alarm-numb "ERROR"
            set-variable %alarm-numb 0
            set-variable %osd-alarm &pinc %osd 1
        !endif

        define-macro alarm
            set-variable %alarm-numb &add %alarm-numb 1
            set-variable #l0 &cat "%alarm-" %alarm-numb
            !force set-variable #l2 @3
            !if &not $status
                set-variable &ind #l0 @ml "Message"
                set-variable #l1 @ml "Hours"
                set-variable #l2 @ml "Minutes"
            !else
                set-variable &ind #l0 @1
                set-variable #l1 @2
            !endif
            set-variable #l1 &mul 60000 &add &mul 60 #l1 #l2
            define-macro #l0
                !bell
                set-variable #l0 &add &len &ind @0 10
                osd %osd-alarm 0 "bat" 9 3
                osd %osd-alarm 1 ""
                osd %osd-alarm 2 "c" "ALARM"
                osd %osd-alarm 3 ""
                osd %osd-alarm 4 "" &ind @0
                osd %osd-alarm 5 ""
                osd %osd-alarm 6 "Bcf" " OK " f void
                %osd-alarm osd
            !emacro
            #l1 create-callback #l0
        !emacro

sA

cEcESEE ALSO cEcA


    Refer to lslm!return(4)le and lslm!abort(4)le for details macro termination.

    lslm!emacro(4)le, lslmadd-file-hook(2)le, lslmdefine-macro-file(2)le, lslmdefine-help(2)le,
    lslmdescribe-bindings(2)le, lslmexecute-file(2)le, lslmexecute-named-command(2)le,
    lslmglobal-bind-key(2)le, lslminsert-macro(2)le, lslmstart-kbd-macro(2)le.
! 2 delete-blank-lines
cEcENAME cEcA


    delete-blank-lines - Delete blank lines about cursor
$a


cEcESYNOPSIS cEcA


    cDdelete-blank-linescA (cDC-x C-ocA)


cEcEDESCRIPTION cEcA


    cDdelete-blank-linescA deletes all the blank lines before and after the
    current cursor position. Note that the deleted lines are not added to a
    kill buffer.


cEcESEE ALSO cEcA


    lslmdelete-indentation(3)le, lslmclean(3)le, lslmkill-line(2)le.
! 2 delete-buffer
cEcENAME cEcA


    delete-buffer - Delete a buffer
$a


cEcESYNOPSIS cEcA


    cCncA cDdelete-buffercA "cCbuffer-namecA" (cDC-x kcA)


cEcEDESCRIPTION cEcA


    cDdelete-buffercA disposes of buffer cCbuffer-namecA in the editor and reclaim the
    memory. This does not delete the file that the buffer was read from.

    If the buffer has been edited and its name does not start with a 'cD*cA' then
    the user is prompted as to whether the changes should be discarded. Also
    if the buffer has an active process running in it then confirmation is
    sort from the user before the process is killed.

    The argument cCncA can be used to change the default behavior of delete-buffer
    described above, cCncA is a bit based flag where:-

    cD0x01cA
        Enables loss of work checks (default). These include a check that the
        buffer has not been modified, if so the user is prompted. Also if a
        process is running then user must confirm that the process can be
        killed. If this flag is not supplied then the buffer is killed without
        any user prompts (useful in macros).


cEcESEE ALSO cEcA


    lslmnext-buffer(2)le.
! 2 directory-tree
cEcENAME cEcA


    directory-tree - Draw the file directory tree
$a


cEcESYNOPSIS cEcA


    cCncA cDdirectory-treecA ["cCdirectorycA"]


cEcEDESCRIPTION cEcA


    cDdirectory-treecA creates or manipulates a view of the file systems directory
    structure. The command is quite complex to use directly so is largely used
    but macros such as lslmfile-browser(3)le.

    The argument cCncA is a bit based flag which is used to control the command,
    where the bits have the following meaning:-

    cD0x01cA
        If set, the focal directory of the command is set by the given
        "cCdirectorycA" argument. Otherwise the argument is not required and the
        command must be executed within the "cC*directory*cA" buffer; the current
        line sets the focal directory.

    cD0x02cA
        Specifies that the current line in resultant "cC*directory*cA" window
        should be set to the focal directory. If this bit is not set then the
        current line will be the last selected directory, or if none have been
        selected, the first line in the buffer.

    cD0x04cA
        Specifies that any evaluations required during the commands operation
        should be performed. Without this flag an open operation on a
        directory which has not previously been evaluated will not be perform
        an evaluation and the results will likely be incomplete.

    cD0x08cA
        Specifies that the current focal directory should be opened. This
        means that sub-directories within the current focal directory will
        also be drawn in the directory tree.

    cD0x10cA
        Specifies that the current focal directory should be closed. This
        means that sub-directories within the current focal directory will not
        be drawn in the directory tree.

    cD0x20cA
        Specifies that the current focal directory's open state should be
        toggled. This means that if the sub-directories are currently hidden
        they will now be drawn and vice-versa.

    cD0x40cA
        When specified any directory opened will be re-evaluated, ensuring the
        accuracy of the information.

    cD0x80cA
        Enables a recursive behavior, for example if this flag was specified
        with the open then not only will the focal directory be opened, but
        all of it's children, and their children etc. Note that if the
        Evaluation flag is not specified then only the already evaluated
        directories can be opened.

    directory-tree creates a new buffer "cC*directory*cA" and draws the known
    directory tree. Every drawn directory is preceded by a character flag
    giving the user an indication of the directory state, where:

    cD?cA
        Directory has not been evaluated.

    cD-cA
        Directory has been evaluated and is visible.

    cD+cA
        Directory has been evaluated but is currently hidden.

    Directories which have been evaluated and found to have no children use
    the '-' lslm$box-chars(5)le instead of a '-' character.

    On UNIX platforms, if a directory is a symbolic link to another directory,
    the link name is given after the directory name.


cEcEEXAMPLE cEcA


    The best example of the use of directory-tree is lslmfile-browser(3)le which can
    be found in hkdirlst.emf.


cEcESEE ALSO cEcA


    lslmfile-browser(3)le, lslm$box-chars(5)le.
! 2 indent
cEcENAME cEcA


    indent - Manage the auto-indentation methods
$a


cEcESYNOPSIS cEcA


    cC0cA cDindentcA "cCind-nocA" "cCflagscA" [ "cClook-backcA" ] [ "cCindent-schemecA" ]

    cDindentcA "cCind-nocA" "cCtypecA" "cCtokencA" [ "cCclosecA" "cCignorecA" ] [ "cCindentcA" ]
    cDindentcA "cCind-nocA" "cDtcA" "cCtokencA" [ "cCtokencA" ] "cCindent-schemecA"
    cDindentcA "cCind-nocA" "cDxcA" | "cDwcA" "cCtokencA" "cCindentcA" "cCindent-schemecA"


cEcEDESCRIPTION cEcA


    The cDindentcA command creates and manages the auto-indenting methods, the
    process of creating a new indentation method is best described in lslanguageTemplates(2)lmFileln
    lnLanguage Templatesle. The command takes various forms as defined by the
    arguments. Each of the argument configurations is defined as follows:-


cEIndentation Method Creation cA


    cC0cA cDindentcA "cCind-nocA" "cCflagscA" "cClook-backcA" [ "cCindent-schemecA" ]

    With an argument of cG0cA, cDindentcA creates a new indentation method with the
    integer handle cCind-nocA. The indentation method is assigned to a buffer by
    setting lslm$buffer-indent(5)le to cCind-nocA. cCind-nocA cannot be 0 as setting
    cD$buffer-indentcA to zero disables indentation. If the indentation method
    with the same cCind-nocA already exists, then the existing method is deleted
    and a new method may be created.

    cCflagscA Sets the indent bit flags where:-

    cG0x01cA
        Indent method is case insensitive. Note that cDindentcA tokens must be
        specified in lower case.

    cG0x02cA
        Defines a cDfast look-backcA indentation scheme to be used in conjunction
        with the current indentation scheme. The fast look-back scheme is used
        to identify a change in the current buffer's indent scheme, for
        example the starting of embedded script in html. The cCindent-schemecA
        argument is required when this flag bit is set and identifies the
        handle of the fast look-back indentation scheme to be used.

        This feature is only used when indent is required to support multiple
        complex indentation schemes within a single file, for example
        indentation of scripts within html, asp or php pages etc. When defined
        the given cCindent-schemecA must also be defined using cDindentcA, the
        scheme's cClook-backcA argument is typically set to look back a long way
        to ensure correctness, i.e. 500 lines, but it should therefore contain
        few tokens to maintain performance.

    cG0x04cA
        Defines C mode of indentation. C styling is built into the editor and
        is enabled through the cDindentcA command. The C form is discussed in more
        detail in the next section.

    cG0x08cA
        Ring the bell if lslmgoto-matching-fence(2)le fails.

    cG0x10cA
        Comment continuation mode. This is only valid when C mode is defined
        and is defined further in the next section.

    cClook-backcA specifies the maximum number of lines, prior to the current
    line, considered when calculating the indentation of a line, i.e. if there
    are cClook-backcA number of lines between the line to be indented and the
    previous non-blank line then the current indentation is lost.

    If cClook-backcA is set to 0 then the indentation is effectively disabled as
    the current indentation can never be found. The maximum value has been
    increase as of January 2004 from 255 to an integer (large number), a value
    of 10 is typically sufficient for a normal indent scheme and 500 for a
    fast look-back scheme.


cEC Indentation cA


    cC0cA cDindentcA "cCind-nocA" "cCflagscA"
    cDindentcA "cCind-nocA" cGscA "cCstatementcA"
    cDindentcA "cCind-nocA" cGccA "cCcontinuecA"
    cDindentcA "cCind-nocA" cGxcA "cCmaxcA"
    cDindentcA "cCind-nocA" cGbcA "cCbracecA"
    cDindentcA "cCind-nocA" cGecA "cCbraceStatementcA"
    cDindentcA "cCind-nocA" cGwcA "cCswitchcA"
    cDindentcA "cCind-nocA" cGacA "cCcasecA"
    cDindentcA "cCind-nocA" cGmcA "cCmargincA"
    cDindentcA "cCind-nocA" cGucA "cCcomcontcA"

    C mode is built into the editor by default and is enabled by setting the
    indent intialization flag bit cG0x04cA. With this bit enabled then the
    indentation for 'C' mode is defined through the additional arguments.
    cCind-nocA and cCflagscA have the same meaning as defined in the previous section.
    C mode is typically initialized with the value 12. The remaining C
    arguments are defined as follows:

    cDindentcA "cCind-nocA" "cGscA" "cCstatementcA" (=t)
        The indent of the current line is derived from cCstatementcA value plus
        the indent of the last c token (cCifcA, cCelsecA, cCwhilecA etc.) or the last 'cG{cA'
        (which ever was found first). i.e. if the last 'cG{cA' was found at column
        16 then the current line will be indented to 20:-

                    {
                        xxxxxxxxxx
                        xxxxxxxxxx


        or

                    if(xxxxx)
                        xxxxxxxxxx


        C tokens are only used to indent the next line, whereas 'cG{cA' are used
        in indenting every line to it's partnering 'cG}cA'.

    cDindentcA "cCind-nocA" "cGccA" "cCcontinuecA" (=3/2t)
        cCcontinuecA sets the indent to be added to a split line, i.e. for an
        indent of 20, a continued statement would be indented to 30. A
        continued statement is a single c statement which is spread over 2 or
        more lines, the 2nd and any following lines would be indented to 30.
        For example

                    thisIsAVeryLongVariableWhichMeansAssignmentsAreSplit =
                              ThisIsTheFirstContinuedStatementLine +
                              ThisIsTheSecondContinuedStatementLine + etc ;


        The indent is changed if there is an open bracket, continued
        statements are indented to the depth of the open bracket plus one,
        e.g.

                    func(firstFuncArg,
                         secondFuncArg,
                         anotherBracketForFun(firstAnotherBracketForFunArg,
                                              secondAnotherBracketForFunArg),
                         thirdFuncArg) ;


    cDindentcA "cCind-nocA" "cGxcA" "cCmaxcA"
        cCmaxcA sets an upper limit of the indentation where an open bracket is
        encountered, in the case where the leading indent of the function name
        and open bracket exceeds cCmaxcA, then the continuation is reduced to the
        continuation indent.

        The effect of cCmaxcA is described as follows; if cCmaxcA is set to a large
        value then the default open brace offset appearence is:-

            longVariable = LongFunctionNameWhichMeans(isSoFar,
                                                      OverAndYouRunOutOfRoom) ;


        Setting cCmaxcA to 16 gives:

            longVariable = LongFunctionNameWhichMeans(isSoFar,
                            overAndYouRunOutOfRoom) ;


        Where by the second argument indent has been artificially reduced
        because of it's length.

    cDindentcA "cCind-nocA" "cGbcA" "cCbracecA" (=0)
        Sets the indent of a 'cG{cA' and a 'cG}cA' on a new line from the current
        statement indent. For example, a value of 0 results in the following

                            if(xxxxxx)
                            {
                                xxxxxxxxxx
                                xxxxxxxxxx
                            }


        With a setting of 2, this would become:-

                            if(xxxxxx)
                              {
                                xxxxxxxxxx
                                xxxxxxxxxx
                              }


        This works in conjunction with cCstatementcA and cCbraceStatementcA a change
        to cCstatementcA will change the position of 'cG{cA's. In summary:

            if (condition)      if (condition)     if (condition)
            {                       {                {
                statement;          statement;         statement;
            }                       }                }

            brace = 0             brace = 4         brace = 2


    cDindentcA "cCind-nocA" "cGecA" "cCbraceStatementcA" (t)
        The cCbraceStatementcA defines the indentation following a curly brace 'cG{cA'
        which follows a statement.

    cDindentcA "cCind-nocA" "cGwcA" "cCswitchcA" (=0)
        The additional indent to be applied after a cDswitchcA statement, the
        cCstatementcA indent is applied in addition to the cCswitchcA indent. See the
        cCcasecA argument.

    cDindentcA "cCind-nocA" "cGacA" "cCcasecA" (=-t)
        cCswitchcA value sets the offset of a "cGcasecA" entry statement from the
        opening brace left margin position. The default value is zero. e.g.

                            switch(xxxxxxxxx)
                            {
                            case 1:
                                xxxxxxxxxx
                                xxxxxxxxxx
                            case 2:
                                xxxxxxxxxx
                            }


        Setting the value to 4, increases the leading space on the "cGcasecA"
        statement, e.g.

                            switch(xxxxxxxxx)
                            {
                                case 1:
                                    xxxxxxxxxx
                                    xxxxxxxxxx
                                case 2:
                                    xxxxxxxxxx
                            }


        cCcasecA sets the offset of the lines following a "cGcasecA" statement, from
        the current indent. For example, using the default settings, if the
        current indent was 20 then a line starting with a "cGcasecA" would be
        indented to 16, i.e.

                                xxxxxxxxxx
                            case xxxxxxxxxx
                                xxxxxxxxxx


        This is used inside "cGswitchcA" statements, the default setting give the
        following lay-out:-

                            switch(xxxxxxxxxx)
                            {
                            case 1:
                                xxxxxxxxxx
                                xxxxxxxxxx
                            case 2:


        This works in conjunction with the cCstatementcA variable, a change to
        cCstatementcA will change the position of 'cG{cA's.

        In summary:

            switch (variable)   switch (variable)
            {                   {
            case 1:                 case 1:
                break;                  break;
            default:                default:
                break;                  break;
            }                    }

              switch = 0           switch = t
              case = -t            case = -t


    cDindentcA "cCind-nocA" "cGmcA" "cCmargincA" (=-1)
        If inserting a comment at the end of a C line, it is tedious typing cCxcA
        number of spaces to the comment column (by default tab does not insert
        a tab when lslmindent(2)le is enabled, it reformats the indentation of the
        line regardless of the cursor position). This variable sets the indent
        column of these comments. So with the default settings and the
        following line,

                    xxxxxx ;/


        when a '*' is entered the line becomes

                    xxxxxx ;                /*


        The indenting of the "cG/*cA" occurs only if there is text on the line
        before it, and none after it. If the current column is already past
        cCmargincA then it is indented to the next tab stop.

        A value of -1 disables this feature.

        In summary:

                statement;        /* Comment */      statement; /* Comment */

                margin = 40                          margin = -1


    cDindentcA "cCind-nocA" "cGucA" "cCcomcontcA" ("cG * cA")
        This argument is only specified if cCflagscA bit cG0x10cA is set. This defines
        the string which is inserted when a new line is started while in a
        comment. The string is only inserted if the cursor is at the end of
        the line when the lslmnewline(2)le command is given. For example, for the
        default settings, if a cDnewlinecA was entered at the end of the first
        line, the second line would initialize to:-

                            /* xxxxxxxxxx
                               @


        where 'cG@cA' is the current cursor position. With a setting of "cG * cA",
        then:-

                            /* xxxxxxxxxx
                             * @


        In summary:

            /*                  /*               /* Comment
             * Comment          ** Comment          Comment */
             * Comment          ** Comment
             */                 */
             comcont = " * "    comcont = "** "   comcont = "   "


    The standard indent rule for setting up C and Java is defined as:-
sB
            0 indent .hilight.c 12
            indent .hilight.c "s" t     ; Default may be omitted
            indent .hilight.c "e" t     ; Default may be omitted
            indent .hilight.c "c" 3/2t  ; Default may be omitted
            indent .hilight.c "x" 0     ; Default may be omitted
            indent .hilight.c "b" 0     ; Default may be omitted
            indent .hilight.c "w" 0     ; Default may be omitted
            indent .hilight.c "a" -t    ; Default may be omitted
            indent .hilight.c "m" -1    ; Default may be omitted
            indent .hilight.c "u" " * "

sA
    This is typically written with the defaults omitted.
sB
            0 indent .hilight.c 12
            indent .hilight.c "u" " * "

sA
    If GNU Emacs indentation is required then the following definition may be
    used:-
sB
            0 indent .hilight.c 12            ; if (a == b)
            indent .hilight.c "e" t           ;   {
            indent .hilight.c "b" t           ;     c = d;
            indent .hilight.c "s" t           ;   }
            indent .hilight.c "u" " * "

sA
    The default configuration scheme is defined as:-
sB
            0 indent .hilight.c 12            ; if (a == b)
            indent .hilight.c "e" t           ; {
            indent .hilight.c "b" 0           ;   c = d;
            indent .hilight.c "s" t           ; }
            indent .hilight.c "u" " * "

sA
    Where comments are to be aligned at the end of a statement then the margin
    parameter may be defined in cG<user>.emfcA.
sB
            indent .hilight.c "m" 40

sA

cEIndentation Rule Creation cA


    cDindentcA "cCind-nocA" "cCtypecA" "cCtokencA" [ "cCclosecA" [ "cCignorecA" ]] [ "cCindentcA" ] [
    "cCindent2cA" ] [ "cCindent-schemecA" ]

    With the default argument of cG1cA, cDindentcA creates a new rule for the
    indentation method cCind-nocA which must have previously been defined and
    initialized.

    The indentation of a line in a buffer, which is using an indentation
    method, is affected by the token types matched on the line (cCtypecA cGfcA, cGocA, cGscA)
    and the current indentation (if line is not of type cGfcA).

    The current indentation is determined by searching the previous lines
    (look-back) for the indentation of the last indented line. This may not
    simply be the indentation of the last non-blank line, the exact
    indentation is determined by searching for tokens in the line and
    assessing their effect on the indentation of the current line.

    The format of the regex valid in the "cCtokencA" and "cCclosecA" arguments are the
    same as at used by hilight token creation, see lslmhilight(2)le for more
    information.

    The cCindentcA argument specifies the indent to apply in characters. The
    indent may be specified as a literal integer value, a positive value
    increases the indent a negative value reduces the indent. The cCindentcA may
    be specified in terms of buffer specific generic value
    lslm$buffer-indent-width(5)le using the value cDtcA, indicating a tab width. The
    value of cDtcA may be prefixed with a signed integer or vulgar fraction which
    adjusts the size of the indentation width by the appropriate amount.
    Modifying the value of ls$indent-width(5)lm$buffer-indent-widthle modifies the indent width that
    is applied allowing the indentation method to be specified independently
    of the indentation width.

    The indent tokens may be assigned one of the following types, using the
    cCtypecA argument. If the type is specified in upper case then the token must
    be surrounded by non-alpha-numeric characters:

    cDFixedcA (cCtypecA = 'cGfcA' or 'cGFcA')
        A line containing a fixed indent token will be indented to the given
        cCindentcA column from the left-hand edge. cCindentcA is the only argument
        specified. e.g. MicroEmacs macro cG!gotocA labels:-
sB
            indent .hilight.emf f "*" 0

sA
        producing

                .....
            *label
                .....


        The fixed token must be the first non-white character on the line, the
        rest of the line is ignored. The indentation of the previous line has
        no effect.

    cDIndent-from-next-line-onwardcA (cCtypecA = 'cGncA' or 'cGNcA')
        The indentation changes by cCindentcA from the next line onwards from the
        current line. cCindentcA is the only argument specified. e.g. MicroEmacs
        macro cG!ifcA:-
sB
            indent .hilight.emf n "!if" t

sA
        Keeps the indentation of the cG!ifcA line the same as the previous
        indentation, change the indentation on the following lines by an extra
        ls$indent-width(5)lm$buffer-indent-widthle characters, to produce:

            ....
            !if
                ....


    cDIndent-from-current-line-onwardcA (cCtypecA = 'cGocA' or 'cGOcA')
        Increment the current and following lines indentation by cCindentcA.
        cCindentcA is the only argument specified. e.g. MicroEmacs macro cG!endifcA
sB
            indent .hilight.emf o "!endif" -t

sA
        decrement the indent of the cG!endifcA line and following lines by
        ls$indent-width(5)lm$buffer-indent-widthle spaces producing:

                ....
            !endif
            ....


    cDUniversal-indentcA (cCtypecA = 'cGucA' or 'cGUcA')
        Independent control of the current line and next line indent.
        Increment the current line indentation by cCindentcA and the following
        line indentation by cCindent2cA. Where cCindentcA represents indent with the cGocA
        option and cCindent2cA represents indent with the cGncA option. This command
        is useful where the indentation of both the current and next line need
        to be controlled independently given a single token.
sB
            indent .hilight.emf u "<cfelse" -t 3/2t

sA
        This has been used in the cCColdFusioncA indentation to control the
        cG<cfelse>cA condition which requires control of both the current line and
        next line with different values from the same token. Note that a
        cDIndent-singlecA could be implemented with this command using an argument
        of cG-t tcA.

    cDIndent-singlecA (cCtypecA = 'cGscA' or 'cGScA')
        Changes the indentation of the current line ONLY by cCindentcA. cCindentcA is
        the only argument specified. e.g. MicroEmacs macro cG!elifcA:-
sB
            indent .hilight.emf o "!elif" -t

sA
        decrements the indentation of the cG!elifcA line by ls$indent-width(5)lm$buffer-indent-widthle
        characters, but restores the previous indentation after the current
        line, producing:

                ....
            !elif
                ....


    cDBracketcA (cCtypecA = 'cGbcA' or 'cGBcA')
        A bracket should be used when a starting token pairs with a closing
        token which may span multiple lines. i.e. the opening and closing
        braces of a programming language. Note that the opening and closing
        tokens must be different otherwise they cannot be differentiated. A
        bracket has two main effects:

        When the previous line has an unmatched open bracket
            In this situation the current line is indented to the right of the
            mismatched bracket.

        When the previous line has an unmatched close bracket
            In this situation the matching open bracket is hunted for in
            previous lines until either the cClook-backcA limit (See cDIndentation
            Method CreationcA) is exhausted or the bracket is matched, in which
            case the indent of that line is used.

        For a bracket the only other argument given is the cCclosecA. e.g. tcl's
        'cG(cA' and 'cG)cA' brackets
sB
            indent .hilight.tcl b "(" ")"

sA
        Which produces:

            ....
            .... (....
                  ....
                  ....)
            ....


    cDContinuecA (cCtypecA = 'cGccA' or 'cGCcA')
        Indicates that when cCtokencA is found on the current line, the next line
        is a continuation of the current line. The indentation of the next
        line is the indentation of the first continuation line plus the given
        cCindentcA. cCindentcA is the only argument specified. e.g. tcl's '\'
sB
            indent .hilight.tcl c "\\" 3/2t

sA
        A simple example is

            ....
            12345678901234567890      \
                     ....
            ....


        When used in conjunction with brackets, the following effect is
        observed:

            ....
            12345678901234567890      \
                      ....(....       \
                           ....)      \
                      ....            \
                      ....
            ....


        This shows why the first continuation line (the cG123456...cA line) must
        be located and used as the base line from which the indentation is
        derived; again the cClook-backcA limits the search for this line.

    cDExclusioncA (cCtypecA = 'cGecA' or 'cGEcA')
        Used to exclude text between start cCtokencA and cCclosecA token from the
        indentation calculation, typically used for quotes. The cCignorecA
        argument is also specified (see lslmhilight(2)le cGtype 0x004cA type bracket)
        e.g. MicroEmacs macro quotes:-
sB
            indent .hilight.emf e "\"" "\"" "\\"

sA
        e.g. tcl's quotes
sB
            indent .hilight.tcl e "\"" "\"" "\\"

sA
        producing:-

            ....
            ".... ignore { ... \" ... ignore another { token ... "
            ....


    cDIgnorecA (cCtypecA = 'cGicA' or 'cGIcA')
        Text to the right of a line containing cCtokencA is to be ignored;
        typically used for comments. e.g. MicroEmacs macro 'cG;cA' comment:-
sB
            indent .hilight.emf i ";"

sA
        Or tcl's 'cG#cA' comment
sB
            indent .hilight.tcl i "#"

sA
        producing

            ....
            # ... ignore this { indent token
            ....


    cDTypecA (cCtypecA = 'cGtcA' or 'cGTcA')
        Used in a cDfast look-backcA indentation scheme (see bit cG0x02cA of cD0 indentcA
        above) to define the scheme change tokens. The fast look-back token
        typically shadows the cGxcA and cGwcA types and identifies the indentation
        scheme. The token itself does not change the indentation, it simply
        identifies the indentation scheme. The 'cGxcA' or 'cGwcA' types are used to
        perform the actual indentation of the line if required.

        If the cCindent-schemecA is defined as zero (cG0cA) then the indentation
        scheme is set to the same value as the lslm$buffer-indent(5)le variable.

        The following example is taken from the XML language definition . A
        fast-look back scheme is used (cGhilight.xmlTcA) to search for the
        alternative indentation schemes for cCjavascriptcA and cCvbscriptcA. The cGtcA
        indent type defines the start of script tokens and to switch the
        indentation to the new indent type.
sB
            ; Fast look-back indentation scheme
            0 indent .hilight.xmlT 1 500
            ; Indentation scheme
            0 indent .hilight.xml 3 20 .hilight.xmlT

            !if &exist .indent.javascript
                indent .hilight.xmlT t "<script ... javascript>"   .indent.javascript
                indent .hilight.xml  x "<script ... javascript>" 2 .indent.javascript
                indent .indent.javascript w "</script>" -2 0
            !endif
            !if &exist .indent.vbscript
                indent .hilight.xmlT t "<script ... vbscript>"   .indent.vbscript
                indent .hilight.xml  x "<script ... vbscript>" 2 .indent.vbscript
                indent .indent.vbscript w "</script>" -2 0
            !endif
            indent .hilight.xmlT t "</script>" 0
            indent .hilight.xml  o "</script>" -2
            ; Define the indentation tokens. XML is well defined so there are
            ; always opening and closing brackets.
            indent .hilight.xml e "\"" "\"" "\\"
            indent .hilight.xml b "<!--" "-->"
            indent .hilight.xml b "<\\?" "\\?>"
            indent .hilight.xml n "<[^/!]" 2
            indent .hilight.xml o "</"    -2
            indent .hilight.xml o "/>"    -2

sA
    cDChangecA (cCtypecA = [cGxcA|cGXcA|cGwcA|cGWcA|cGvcA|cGVcA])
        Change the indentation scheme from the current scheme to the new
        cCindent-schemecA. If the cCindent-schemecA is specified as zero (cG0cA) then the
        indentation scheme is set to the same handle value as the
        lslm$buffer-indent(5)le variable. cCindentcA specifies the indent value, when
        the cCtypecA is cGwcA then the current line onwards is indented (similar to
        cGocA), a cCtypecA of cGxcA indents the next line onwards (similar to cGncA), a cCtypecA
        of cGvcA indents both the current line and next time onwards (similar to
        cGucA).

        Refer the the cCtypecA=cGtcA for an example of indentation switching.


cEcEEXAMPLE cEcA


    Examples of indentation method creations can be found in macro files
    cGhkemf.emfcA, cGhktcl.emfcA and cGhkvrml.emfcA. The following example is taken from
    cGhkemf.emfcA:-
sB
        !if &not &exist .hilight.emf
            set-variable .hilight.emf &pinc .hilight.next 1
        !endif

        ...

        0 indent  .hilight.emf 0 10
        indent .hilight.emf N "define-macro" t
        indent .hilight.emf n "!if" t
        indent .hilight.emf s "!eli" -t
        indent .hilight.emf s "!els" -t
        indent .hilight.emf o "!end" -t
        indent .hilight.emf n "!whi" t
        indent .hilight.emf o "!don" -t
        indent .hilight.emf n "!rep" t
        indent .hilight.emf o "!until" -t
        indent .hilight.emf o "!ema" -t
        indent .hilight.emf e "\"" "\"" "\\"
        indent .hilight.emf i ";"
        indent .hilight.emf f "*" 0

sA
    Note that a cD.hilightcA command variable is typically used as a buffer with
    indentation rules will almost certainly have hilighting and the same
    variable is used to define the hilighting scheme.


cEcENOTES cEcA


    The variables lslm$indent-width(5)le, lslm$buffer-indent-width(5)le and the cDtcA indent
    notation were introduced in the November 2004 version of MicroEmacs.

    The electric C mode cDcmode(2m)cA was removed in December 2004, as were the
    variables cD$c-brace(5)cA, cD$c-case(5)cA, cD$c-contcomm(5)cA, cD$c-continue(5)cA,
    cD$c-margin(5)cA and cD$c-statement(5)cA. All replaced by the C Indent
    initialisation method.

    The Universal indent (cGucA) was introduced in the 2006 release.


cEcESEE ALSO cEcA


    lslanguageTemplates(2)lmFile Language Templatesle, lslm$buffer-indent(5)le, lslm$buffer-indent-width(5)le,
    lslm$indent-width(5)le, lslmadd-file-hook(2)le, lslmhilight(2)le.
! 2 forward-delete-char
! 2 backward-delete-char
cEcENAME cEcA


|forward-delete-char
    forward-delete-char - Delete next character at the cursor position
|backward-delete-char
    backward-delete-char - Delete previous character at the cursor position
$a


cEcESYNOPSIS cEcA


    cCncA cDforward-delete-charcA (cDC-dcA)
    cCncA cDbackward-delete-charcA (cDbackspacecA)


cEcEDESCRIPTION cEcA


    cDforward-delete-charcA deletes the next cCncA characters from the current cursor
    position. If the cursor is at the end of a line, the next line is joined
    onto the end of the current line. If a numeric argument is given the
    character(s) are added to the kill buffer, otherwise the kill buffer
    remains unaltered.

    cDbackward-delete-charcA deletes the next cCncA characters immediately to the left
    of the cursor (e.g. more conventionally backspace). If the cursor is at
    the beginning of a line, this joins the current line to the end of the
    previous line. If an argument is given then the character is added to the
    kill buffer, otherwise the kill buffer remains unaltered.

    Where the numeric argument is cG0cA the command has no effect. A negative
    argument changes the direction.


cEcENOTES cEcA


    cDforward-delete-charcA is also bound to cDdeletecA and cDS-deletecA.

    cDbackward-delete-charcA is also bound to cDS-backspacecA.


cEcEHISTORY cEcA


    As of December 2004 the mode cDletter(2m)cA which controlled whether the
    deleted character is added to the kill buffer was removed. Letter mode
    used to be disabled by default, the behavior of the old letter mode, when
    enabled, may be achieved through the key bindings:-
sB
        1 global-bind-key backward-delete-char "backspace"
        1 global-bind-key forward-delete-char "delete"

sA
    The use of the numeric argument of 1 in the global binding has the has the
    same effect as the existing cDletter(2m)cA mode (when enabled).


cEcESEE ALSO cEcA


    lslmbackward-char(2)le, lslmbackward-kill-word(2)le, lslmforward-char(2)le,
    lslmforward-kill-word(2)le, lslmkill-paragraph(2)le, lslmkill-region(2)le.
! 2 forward-kill-word
! 2 backward-kill-word
cEcENAME cEcA


|forward-kill-word
    forward-kill-word - Delete next word at the cursor position
|backward-kill-word
    backward-kill-word - Delete previous word at the cursor position
$a


cEcESYNOPSIS cEcA


    cCncA cDforward-kill-wordcA (cDesc dcA)
    cCncA cDbackward-kill-wordcA (cDesc backspacecA)


cEcEDESCRIPTION cEcA


    cDforward-kill-wordcA deletes the next cCncA words starting at the current cursor
    position, the deleted text is added to the kill buffer. See
    lslmforward-word(2)le for a description of word boundaries. If no argument cCncA is
    given and the current character is a non-word character then only the
    characters from the current position to the start of the next word are
    removed. If the argument cCncA is cG0cA the command has no effect. If a negative
    argument is specified, cCncA words are deleted backwards (i.e. this is the
    same as cD-n backward-kill-wordcA).

    cDbackward-kill-wordcA deletes the previous cCncA words before the cursor, the
    deleted text is added to the kill buffer. The numeric argument has the
    same effect as with cDforward-kill-wordcA.


cEcENOTES cEcA


    cDbackward-kill-wordcA is also bound to cDesc backspacecA.

    The negative argument is typically used by macro scripts where the kill
    buffer is more precisely controlled.


cEcEHISTORY cEcA


    The interpretation of the numeric argument was changed in the 2005 release
    to kill cCncA words in a forwards or backwards direction. In previous releases
    then the negative argument controlled the kill buffer behavior. If kill
    buffer control is required then lslmkill-region(2)le should be used instead.


cEcESEE ALSO cEcA


    lslmbackward-delete-char(2)le, lslmforward-delete-char(2)le, lslmforward-word(2)le,
    lslmkill-region(2)le, lslmyank(2)le.
! 2 delete-window
! 2 delete-other-windows
cEcENAME cEcA


|delete-window
    delete-window - Delete the current window
|delete-other-windows
    delete-other-windows - Delete other windows
$a


cEcESYNOPSIS cEcA


    cCncA cDdelete-windowcA (cDC-x 0cA)
    cCncA cDdelete-other-windowscA (cDC-x 1cA)


cEcEDESCRIPTION cEcA


    cDdelete-windowcA attempts to delete the current window (remove window from
    the screen), retrieving the lines for use in the window adjacent to it.
    The command fails if there is no other window or if the current window is
    protected from deletion (see lslm$window-flags(5)le). The deletion protection
    can be overridden by giving the command a numerical argument cCncA of 2.

    The window deletion policy is determined by the formation of the windows
    displayed on the screen. The bias is for the cCpreviouscA window (above) the
    current window to be merged when split vertically, and for the left window
    to be merged when split horizontally.

    cDdelete-other-windowscA deletes all of the other windows, the current window
    becomes the only window, using the entire available screen area. Windows
    can be protected from deletion by using the ls$window-flags(5)lm$window-flagsle variable, giving
    the command a numerical argument cCncA of 2 overrides this protection.


cEcESEE ALSO cEcA


    lslmset-position(2)le, lslmgrow-window-vertically(2)le, lslmresize-window-vertically(2)le,
    lslmsplit-window-horizontally(2)le, lslmsplit-window-vertically(2)le,
    lslm$window-flags(5)le.
! 2 backward-delete-tab
cEcENAME cEcA


    backward-delete-tab - Delete white space to previous tab-stop
$a


cEcESYNOPSIS cEcA


    cDbackward-delete-tabcA (cDS-tabcA)


cEcEDESCRIPTION cEcA


    cDbackward-delete-tabcA deletes all white characters left of the cursor back
    to the previous tab stop or non-white space, the deleted text is not added
    to the kill buffer.


cEcESEE ALSO cEcA


    lslmtab(2)le, lslm$tab-width(5)le, lslm$buffer-tab-width(5)le.
! 2 describe-bindings
cEcENAME cEcA


    describe-bindings - Show current command/key binding
$a


cEcESYNOPSIS cEcA


    cDdescribe-bindingscA (cDC-h bcA)


cEcEDESCRIPTION cEcA


    cDdescribe-bindingscA pops up a window with a list of all the named commands,
    and the keys currently bound to them. Each entry is formatted as:

        cDkeyCodecA cG...........cA cDcommandcA

    cDdescribe-bindingscA is buffer context sensitive and shows the bindings for
    the currently active buffer (i.e. the buffer that is active when the
    command is invoked). The resultant command list is divided into three
    sections as follows:

    cDBuffer BindingscA
        The bindings for the active buffer when cDdescribe-bindingscA was invoked.
        These are the buffer bindings set by lslmbuffer-bind-key(2)le.

    cDMl BindingscA
        The message line bindings as set by lslmml-bind-key(2)le.

    cDGlobal BindingscA
        Global binding of keys as set by lslmglobal-bind-key(2)le.


cEcEEXAMPLE cEcA


    The following is an example of the displayed output from
    cDdescribe-bindingscA. This was invoked while editing buffer cDm2fun038.2cA which
    is the cDNroffcA file for this manual page; the local bindings for the buffer
    are all Nroff related.

        Buffer [m2cmd038.2] bindings:

            "C-c C-s" ..................... nroff-size
            "C-c C-r" ..................... nroff-roman
            "C-c C-b" ..................... nroff-bold
            "C-c C-i" ..................... nroff-italic
            "C-c C-c" ..................... nroff-mono
            "C-c C-o" ..................... nroff-para
            "esc o" ....................... nroff-para
            "esc q" ....................... nroff-para
            "C-c b" ....................... nroff-bold-block
            "C-c i" ....................... nroff-italic-block
            "C-c C-h" ..................... nroff-swap-hilight
            "C-c &" ....................... nroff-add-padding
            "C-x &" ....................... nroff-remove-padding
            "C-c C-p" ..................... nroff-prev
            "C-mouse-drop-1" .............. nroff-tag

        Ml bindings:

            "esc esc" ..................... tab

        Global bindings:

            "C-a" ......................... beginning-of-line
            "C-b" ......................... backward-char
            "C-c" ......................... 4 prefix
            "C-d" ......................... forward-delete-char
            "C-e" ......................... end-of-line
            "C-f" ......................... forward-char
            "C-g" ......................... abort-command
            "C-h" ......................... 3 prefix
            "C-i" ......................... insert-tab
            "C-k" ......................... kill-line
            "C-l" ......................... recenter
            "C-m" ......................... newline
            "C-n" ......................... forward-line
            "C-o" ......................... insert-newline
            "C-p" ......................... backward-line
            "C-q" ......................... quote-char
            "C-r" ......................... isearch-backward
            "C-s" ......................... isearch-forward
            "C-t" ......................... transpose-chars
            "C-u" ......................... universal-argument
            "C-v" ......................... scroll-down
            "C-w" ......................... kill-region
            "C-x" ......................... 2 prefix
            "C-y" ......................... yank
            "C-z" ......................... scroll-up
            "C-_" ......................... undo
            "A-e" ......................... file-browser
            "A-r" ......................... replace-all-string
            "esc C-c" ..................... count-words
            "esc C-f" ..................... goto-matching-fence
            "esc C-g" ..................... abort-command
            "esc C-i" ..................... goto-matching-fence
            "esc C-k" ..................... global-unbind-key
            "esc C-n" ..................... change-buffer-name
            "esc C-r" ..................... query-replace-string
            "esc C-v" ..................... scroll-next-window-down
            "esc C-w" ..................... kill-paragraph
            "esc C-z" ..................... scroll-next-window-up
            "esc space" ................... set-mark
            "esc !" ....................... pipe-shell-command
            "esc $" ....................... spell-word
            "esc ." ....................... set-mark
            "esc /" ....................... execute-file
            "esc <" ....................... beginning-of-buffer
            "esc >" ....................... end-of-buffer
            "esc ?" ....................... help
            "esc @" ....................... pipe-shell-command
            "esc [" ....................... backward-paragraph
            "esc \\" ...................... ipipe-shell-command
            "esc ]" ....................... forward-paragraph
            "esc ^" ....................... delete-indentation
            "esc b" ....................... backward-word
            "esc c" ....................... compile
            "esc d" ....................... forward-kill-word
            "esc e" ....................... set-encryption-key
            "esc f" ....................... forward-word
            "esc g" ....................... goto-line
            "esc i" ....................... tab
            "esc k" ....................... global-bind-key
            "esc l" ....................... lower-case-word
            "esc m" ....................... global-mode
            "esc n" ....................... forward-paragraph
            "esc o" ....................... fill-paragraph
            "esc p" ....................... backward-paragraph
            "esc q" ....................... fill-paragraph
            "esc r" ....................... replace-string
            "esc t" ....................... find-tag
            "esc u" ....................... upper-case-word
            "esc v" ....................... scroll-up
            "esc w" ....................... copy-region
            "esc x" ....................... execute-named-command
            "esc y" ....................... reyank
            "esc z" ....................... quick-exit
            "esc ~" ....................... -30 buffer-mode
            "esc A-r" ..................... query-replace-all-string
            "C-x C-a" ..................... set-alpha-mark
            "C-x C-b" ..................... list-buffers
            "C-x C-c" ..................... save-buffers-exit-emacs
            "C-x C-e" ..................... execute-kbd-macro
            "C-x C-f" ..................... find-file
            "C-x C-g" ..................... abort-command
            "C-x C-h" ..................... hunt-backward
            "C-x C-i" ..................... insert-file
            "C-x C-l" ..................... lower-case-region
            "C-x C-o" ..................... delete-blank-lines
            "C-x C-q" ..................... rcs-file
            "C-x C-r" ..................... read-file
            "C-x C-s" ..................... save-buffer
            "C-x C-t" ..................... transpose-lines
            "C-x C-u" ..................... upper-case-region
            "C-x C-v" ..................... view-file
            "C-x C-w" ..................... write-buffer
            "C-x C-x" ..................... exchange-point-and-mark
            "C-x C-y" ..................... insert-file-name
            "C-x C-z" ..................... shrink-window-vertically
            "C-x #" ....................... filter-buffer
            "C-x (" ....................... start-kbd-macro
            "C-x )" ....................... end-kbd-macro
            "C-x /" ....................... isearch-forward
            "C-x 0" ....................... delete-window
            "C-x 1" ....................... delete-other-windows
            "C-x 2" ....................... split-window-vertically
            "C-x 3" ....................... next-window-find-buffer
            "C-x 4" ....................... next-window-find-file
            "C-x 5" ....................... split-window-horizontally
            "C-x 9" ....................... find-bfile
            "C-x <" ....................... scroll-left
            "C-x =" ....................... buffer-info
            "C-x >" ....................... scroll-right
            "C-x ?" ....................... describe-key
            "C-x @" ....................... pipe-shell-command
            "C-x [" ....................... scroll-up
            "C-x ]" ....................... scroll-down
            "C-x ^" ....................... grow-window-vertically
            "C-x `" ....................... get-next-line
            "C-x a" ....................... goto-alpha-mark
            "C-x b" ....................... find-buffer
            "C-x c" ....................... shell
            "C-x e" ....................... execute-kbd-macro
            "C-x h" ....................... hunt-forward
            "C-x k" ....................... delete-buffer
            "C-x m" ....................... buffer-mode
            "C-x n" ....................... change-file-name
            "C-x o" ....................... next-window
            "C-x p" ....................... previous-window
            "C-x q" ....................... kbd-macro-query
            "C-x r" ....................... search-backward
            "C-x s" ....................... search-forward
            "C-x u" ....................... undo
            "C-x v" ....................... set-variable
            "C-x w" ....................... resize-window-vertically
            "C-x x" ....................... next-buffer
            "C-x z" ....................... grow-window-vertically
            "C-x {" ....................... shrink-window-horizontally
            "C-x }" ....................... grow-window-horizontally
            "C-h C-c" ..................... help-command
            "C-h C-i" ..................... help-item
            "C-h C-v" ..................... help-variable
            "C-h a" ....................... command-apropos
            "C-h b" ....................... describe-bindings
            "C-h c" ....................... list-commands
            "C-h d" ....................... describe-variable
            "C-h k" ....................... describe-key
            "C-h v" ....................... list-variables
            "backspace" ................... backward-delete-char
            "delete" ...................... forward-delete-char
            "down" ........................ forward-line
            "end" ......................... end-of-buffer
            "esc" ......................... 1 prefix
            "f1" .......................... menu
            "home" ........................ beginning-of-buffer
            "insert" ...................... 141 buffer-mode
            "left" ........................ backward-char
            "mouse-drop-1" ................ mouse-drop-left
            "mouse-drop-2" ................ yank
            "mouse-drop-3" ................ menu
            "mouse-pick-1" ................ mouse-pick-left
            "mouse-pick-2" ................ void
            "mouse-pick-3" ................ void
            "page-down" ................... scroll-down
            "page-up" ..................... scroll-up
            "redraw" ...................... screen-update
            "return" ...................... newline
            "right" ....................... forward-char
            "tab" ......................... tab
            "up" .......................... backward-line
            "S-backspace" ................. backward-delete-char
            "S-delete" .................... forward-delete-char
            "S-tab" ....................... backward-delete-tab
            "C-down" ...................... 5 forward-line
            "C-left" ...................... backward-word
            "C-mouse-drop-1" .............. mouse-control-drop-left
            "C-mouse-pick-1" .............. set-cursor-to-mouse
            "C-page-down" ................. scroll-next-window-down
            "C-page-up" ................... scroll-next-window-up
            "C-right" ..................... forward-word
            "C-up" ........................ 5 backward-line
            "A-down" ...................... 1 scroll-down
            "A-left" ...................... 1 scroll-left
            "A-right" ..................... 1 scroll-right
            "A-up" ........................ 1 scroll-up
            "esc backspace" ............... backward-kill-word
            "esc esc" ..................... expand-abbrev
            "C-c g" ....................... grep


    Note that both internal commands and macro commands are shown in the list.


cEcESEE ALSO cEcA


    lslmbuffer-bind-key(2)le, lslmcommand-apropos(2)le, lslmdescribe-key(2)le,
    lslmdescribe-variable(2)le, lslmglobal-bind-key(2)le, lslmlist-commands(2)le,
    lslmml-bind-key(2)le.
! 2 describe-key
cEcENAME cEcA


    describe-key - Report keyboard key name and binding
$a


cEcESYNOPSIS cEcA


    cDdescribe-keycA (cDC-x ?cA)


cEcEDESCRIPTION cEcA


    cDdescribe-keycA allows a key to be typed and it will report the name of the
    command bound to that key (if any) and the internal key-code. This command
    is useful when trying to locate the identity of keyboard keys for binding.


cEcENOTES cEcA


    cDdescribe-keycA is also bound to cDC-h kcA.


cEcESEE ALSO cEcA


    lslmcommand-apropos(2)le, lslmglobal-bind-key(2)le, lslmdescribe-bindings(2)le,
    lslmdescribe-variable(2)le.
! 2 describe-variable
cEcENAME cEcA


    describe-variable - Describe current setting of a variable
$a


cEcESYNOPSIS cEcA


    cDdescribe-variablecA (cDC-h vcA)


cEcEDESCRIPTION cEcA


    cDdescribe-variablecA describes the current setting of the given variable (cD%cA,
    cD:cA and cD$cA variables), returning cGERRORcA if the variable is undefined. If a cG$cA
    variable is not found then it is tested for an environment variable, i.e.
sB
        describe-variable $PATH

sA
    returns your environment cG$PATHcA setting. This is the easiest and best way
    of determining the current platform from within a Macro file.

    The returned value of any undefined variable is the string cGERRORcA.


cEcENOTES cEcA


    Completion is enabled on the command line for variable names.


cEcESEE ALSO cEcA


    lslmdescribe-key(2)le, lslmhelp-variable(2)le, lslmset-variable(2)le.
! 2 delete-dictionary
cEcENAME cEcA


    delete-dictionary - Remove a spelling dictionary from memory
$a


cEcESYNOPSIS cEcA


    cCncA cDdelete-dictionarycA ["cCdictionarycA"]


cEcEDESCRIPTION cEcA


    cDdelete-dictionarycA removes the given cCdictionarycA from memory, where cCncA is a
    bitwise flag determining the removal mode, defined as follows:-

    cD0x01cA
        Prompt the user before loosing any changes (except to the ignore
        dictionary).

    cD0x02cA
        Delete all the dictionaries other than the ignore dictionary.

    cD0x04cA
        Delete the ignore dictionary.

    If the argument does not have bit 0x02 or 0x04 set, which specify the
    dictionaries to be deleted, the user is prompted for the "cCdictionarycA". The
    default argument is 1.


cEcENOTES cEcA


    The ignore dictionary is a temporary dictionary that exists in memory for
    duration of the MicroEmacs session; the dictionary holds words that have
    been ignored during any previous spell checks (see lslmspell(2)le). All of the
    words that have been ignored may be discarded with:-
sB
        4 delete-dictionary

sA
    i.e. cDesc 4 esc x delete-dictionarycA.


cEcESEE ALSO cEcA


    lslmspell-buffer(3)le, lslmadd-dictionary(2)le, lslmsave-dictionary(2)le, lslmspell(2)le.
! 2 set-registry
cEcENAME cEcA


    set-registry - Modify a node value in the registry.
$a


cEcESYNOPSIS cEcA


    cDset-registrycA "cCrootcA" cC"valuecA"
    cC2cA cDset-registrycA "cCrootcA" cC"new-namecA"


cEcEINTRODUCTION cEcA


    The cCregistrycA is a hierarchical tree of node names optionally with
    associated node values that is used for storing and retrieving values. The
    registry mechanism is used for saving and retrieving persistent user
    information between sessions.


cEcEDESCRIPTION cEcA


    cDset-registrycA adds a new value or modifies an existing value in the
    registry. cCrootcA is an absolute path node name to the new entry. The first
    path component MUST exist or the call fails, subsequent path components (a
    `cG/cA' separated path) are created if they do not already exist. cCvaluecA is the
    value to assign to the node.

    If a numeric argument of 2 is specified the cCrootcA is renamed to cCnew-namecA,
    the cCrootcA must exist or the call fails. If the cCnew-namecA contains a path
    (i.e. "cGnew/path/namecA") the registry node is moved to the new path which
    must be an existing absolute path, i.e. not relative to its current
    location.

    The value assigned to a node with cDset-registrycA may be retrieved using
    lslm&reg(4)le.


cEcEEXAMPLE cEcA


    The following call (where the registry node cG/historycA already exists):
sB
        set-registry "/history/foo/win32/printer" "foo-bar"

sA
    constructs a registry hierarchy of the form:-

        "history" {
          "foo" {
            "win32" {
              "printer"="foo-bar";
            }
          }
        }


    The value of the registry node may be retrieved using:-
sB
        &reg "/history/foo/win32/printer"

sA
    which would return the value "cGfoo-barcA".


cEcEHISTORY cEcA


    The cDget-registry(2)cA command was removed in January 2005 in preference to
    the lslm&reg(4)le function, the existing get command was never used.


cEcESEE ALSO cEcA


    lslmcopy-registry(3)le, lslmdelete-registry(2)le, lslmfind-registry(2)le, lslmlist-registry(2)le,
    lslmmark-registry(2)le, lslmread-registry(2)le, lslm&reg(4)le, lslmerf(8)le.
! 2 exchange-point-and-mark
cEcENAME cEcA


    exchange-point-and-mark - Exchange the cursor and marked position
$a


cEcESYNOPSIS cEcA


    cDexchange-point-and-markcA (cDC-x C-xcA)


cEcEDESCRIPTION cEcA


    cDexchange-point-and-markcA moves the cursor to the current marked position
    (see lslmset-mark(2)le) in the current window and moves the mark to where the
    cursor was. This is very useful in finding where a mark was, or in
    returning to a position previously marked.

    The current buffer mark line and column position may be obtained from
    within a macro using the variables lslm$window-mark-line(5)le and
    lslm$window-mark-col(5)le.


cEcESEE ALSO cEcA


    lslmset-mark(2)le, lslmcopy-region(2)le, lslm$window-mark-col(5)le, lslm$window-mark-line(5)le.
! 2 execute-buffer
! 2 execute-line
cEcENAME cEcA


|execute-buffer
    execute-buffer - Execute script lines from a buffer
|execute-line
    execute-line - Execute a script line from the command line
$a


cEcESYNOPSIS cEcA


    cDexecute-buffercA "cCbuffer-namecA"
    cDexecute-linecA ["cCcommand-linecA"]


cEcEDESCRIPTION cEcA


    cDexecute-buffercA executes script lines in the named buffer cCbuffer-namecA. If
    the buffer is off screen and an error occurs during execution, the cursor
    is left on the line causing the error.

    cDexecute-linecA executes a in script line entered from the command line.
    Typically this is used in macros.


cEcESEE ALSO cEcA


    lslmexecute-file(2)le, lslmexecute-string(2)le, lslmexecute-named-command(2)le.
! 2 execute-file
cEcENAME cEcA


    execute-file - Execute script lines from a file
$a


cEcESYNOPSIS cEcA


    cCncA cDexecute-filecA "cCfilecA" (cDesc /cA)


cEcEDESCRIPTION cEcA


    cDexecute-filecA executes script lines from the given cCfilecA cCncA times in
    succession, this is the normal way to execute a MicroEmacs 2009 script.
    The command prompts for a file name, and will then search for <cCfilecA>[.emf]
    in the search path. If the file is found then the file is loaded and the
    buffer is executed cCncA times.


cEcESEE ALSO cEcA


    lslmexecute-buffer(2)le, lslmexecute-line(2)le, lslmexecute-named-command(2)le,
    lslmexecute-string(2)le.
! 2 execute-kbd-macro
cEcENAME cEcA


    execute-kbd-macro - Execute a keyboard macro
$a


cEcESYNOPSIS cEcA


    cCncA cDexecute-kbd-macrocA (cDC-x ecA)


cEcEDESCRIPTION cEcA


    cDexecute-kbd-macrocA executes a keyboard macro. The entire sequence of
    recorded key-strokes is repeated starting at the current point. The result
    is exactly as if you were retyping the sequence all over again. A numeric
    argument cCncA prefixing the cDexecute-kbd-macrocA command repeats the stored
    key-strokes cCncA times.

    Keyboard macros are recored with lslmstart-kbd-macro(2)le; recording is
    terminated with lslmend-kbd-macro(2)le.


cEcESEE ALSO cEcA


    lslmend-kbd-macro(2)le, lslmkbd-macro-query(2)le, lslmname-kbd-macro(2)le,
    lslmstart-kbd-macro(2)le.
! 2 execute-named-command
cEcENAME cEcA


    execute-named-command - Execute a named command
$a


cEcESYNOPSIS cEcA


    cCncA cDexecute-named-commandcA "cCcommand-stringcA" esc x


cEcEDESCRIPTION cEcA


    cDexecute-named-commandcA command prompts the user for the name of a command
    to execute and then executes the command cCncA times. MicroEmacs 2009 offers
    command completion and history facilities, see lslmml-bind-key(2)le.


cEcESEE ALSO cEcA


    lslmexecute-buffer(2)le, lslmdescribe-bindings(2)le, lslmml-bind-key(2)le.
! 2 execute-string
cEcENAME cEcA


    execute-string - Execute a string as a command
$a


cEcESYNOPSIS cEcA


    cCncA cDexecute-stringcA "cCstringcA"


cEcEDESCRIPTION cEcA


    cDexecute-stringcA executes the given cCstringcA cCncA times as if it is being typed.
    This is the writable format of a keyboard macro, it can be placed in any
    cDemfcA file. Any characters may form the cCstringcA (unprintables as cG\xXXcA) and
    key-strokes that are bound to a command will execute that command. This
    command is used by macros to store user defined keyboard macros.


cEcEEXAMPLE cEcA


    The following example uses keyboard strokes with cDexecute-stringcA in a macro
    to format cDnroff(1)cA text located between cG.cA commands:
sB
        define-macro nroff-para
            beginning-of-line
            !if &not &sequal @wc "."
                1 buffer-mode "magic"
                execute-string "\CXS^\\.\CM\CB\CM\CX\CH\CN\CM"
                -1 fill-paragraph
                execute-string "\CD\CX\CH\CN\CD\CXH\CB"
            !endif
            forward-line
        !emacro

sA
    cDexecute-stringcA has the advantage that execution is very fast as the amount
    of parsing and decoding to be performed is limited. The disadvantage is
    that you cannot quickly discern which operations are being performed !!


cEcENOTES cEcA


    Try to avoid using named key, such as "cGupcA" and "cGreturncA", as the keyboard
    macro equivalent is not readable and is likely to change in future
    releases.

    For this reason the following special abbreviations may be used

    cD\EcA
        The "cDescapecA" key.

    cD\NcA
        The "cDreturncA" key.

    cD\TcA
        The "cDtabcA" key.

    cD\bcA
        The backspace character (0x08).

    cD\dcA
        The delete character (0x7f).

    cD\ecA
        The escape character (0x1b).

    cD\fcA
        The form-feed character (0x0c).

    cD\ncA
        The carriage-return character (0x0a).

    cD\rcA
        The line-feed character (0x0d).


cEcESEE ALSO cEcA


    lslmbuffer-abbrev-file(2)le, lslmglobal-abbrev-file(2)le, lslminsert-macro(2)le,
    lslmname-kbd-macro(2)le, lslmstart-kbd-macro(2)le.
! 2 exit-emacs
cEcENAME cEcA


    exit-emacs - Exit MicroEmacs
$a


cEcESYNOPSIS cEcA


    cCncA cDexit-emacscA [cCexitCodecA]


cEcEDESCRIPTION cEcA


    Exit MicroEmacs back to the operating system. If no argument cCncA is given
    and there are any unwritten, changed buffers, the editor prompts the user
    to discard changes. If an argument is specified then MicroEmacs exits
    immediately.

    The numeric argument is defined as a bit-mask as follows:

    cG0x01cA
        Prompting the user before saving any files, writes out all changed
        buffers to the files they were read from. Saves all changed
        dictionaries, killing any running commands and exits the editor.

    cG0x02cA
        Writes out all changed buffers to the files they were read from, saves
        all changed dictionaries, killing any running commands and exits the
        editor. The behavior is modified by flags cG8cA and cG16cA.

    cG0x04cA
        Define the exit code cCexitCodecA from MicroEmacs, the default when
        omitted is 0.

    cG0x08cA
        Discard changed buffers (except the history and registry) and delete
        any backup files associated with the edited buffer(s). This mode does
        not operate when bit cG1cA is set.

    cG0x10cA
        Discard changed buffers (except the history and registry) and create a
        auto save file(s) with the changes from unsaved buffers. This mode
        does not operate when bit cG1cA is set.

    cG0x20cA
        Forces the program exit status to be 1 (non-zero), which is
        interpreted by any parent task as an error status.

    cDexit-emacscA may be used to reproduce the behavior of
    lslmsave-buffers-exit-emacs(2)le and lslmquick-exit(2)le as follows:

        3 exit-emacs == save-buffers-exit-emacs
        2 exit-emacs == quick-exit


cEcEMACRO INTERACTION cEcA


    If the macro lslmshut-down(3)le is defined then it is invoked by the editor when
    it is closed. A user defined shutdown action may be associated with the
    close operation. It is the callers responsibility that the macro
    terminates correctly otherwise the editor will hang.


cEcENOTES cEcA


    All buffers with a name starting with a 'cG*cA' are assumed to be system
    buffers (i.e. cD*scratch*cA) and are not saved.

    Modes cG8cA and cG16cA may be used where the user wishes to discard edited buffers
    on exiting and does not want to confirm the exit. Dictionaries should be
    configured to auto-save in lslmuser-setup(3)le.

    An emergency exit command which forces the editor to quit may be
    implemented as cG0x28 exit-emacscA i.e. Force quit and exit with failed
    status. Internally this is what MicroEmacs uses to perform an emergency
    quit operation caused by signal fault etc.


cEcESEE ALSO cEcA


    lslmquick-exit(2)le, lslmsave-buffers-exit-emacs(2)le, lslmshut-down(3)le.
! 2 insert-file-name
cEcENAME cEcA


    insert-file-name - Insert filename into current buffer
$a


cEcESYNOPSIS cEcA


    cCncA cDinsert-file-namecA (cDC-x C-ycA)


cEcEDESCRIPTION cEcA


    cDinsert-file-namecA inserts the current buffer's file name into the current
    buffer or, if entering text on the message line then enters the file name
    into the message line buffer.

    If the numeric argument cCncA is cG-1cA then the buffer name is inserted into the
    buffer.


cEcESEE ALSO cEcA


    lslminsert-file(2)le, lslmyank(2)le.
! 2 expand-abbrev
cEcENAME cEcA


    expand-abbrev - Expand an abbreviation
$a


cEcESYNOPSIS cEcA


    cDexpand-abbrevcA


cEcEDESCRIPTION cEcA


    cDexpand-abbrevcA expands an abbreviation to an alternate form. The
    abbreviation must be an alpha-numeric string and the cursor must be one
    position to the right of the abbreviation (which must not be
    alpha-numeric) when this command is called. If the abbreviation is found,
    it is deleted and the alternate form is inserted leaving the cursor at the
    end of the insertion unless cG\pcA is used. If not found, a space is inserted.


cEcESEE ALSO cEcA


    lslmbuffer-abbrev-file(2)le, lslmglobal-abbrev-file(2)le, lslmexpand-abbrev-handle(3)le,
    lslmeaf(8)le.
! 2 fill-paragraph
cEcENAME cEcA


    fill-paragraph - Format a paragraph
$a


cEcESYNOPSIS cEcA


    cCncA cDfill-paragraphcA (cDesc ocA)


cEcEDESCRIPTION cEcA


    cDfill-paragraphcA this takes all the text in the current paragraph (as
    defined by surrounding blank lines, or a leading indent) and attempts to
    fill it from the left margin to the current fill column as defined by
    lslm$buffer-fill-col(5)le. When an argument cCncA is supplied cCncA paragraphs are
    filled. If cCncA is positive then MicroEmacs 2009 performs indented filling
    (i.e. indentation for a bullet mark etc). If cCncA is negative then indented
    filling is disabled. If no argument cCncA is supplied then the paragraph is
    filled and the cCpointcA and cCmarkcA positions are retained. This allows
    paragraphs to be filled, whilst in the middle of the paragraph and the
    word position is maintained.

    If cDjustify modecA is enabled the variable lslm$buffer-fill-mode(5)le determines
    how the paragraph is filled (i.e. cCleftcA, cCrightcA, cCbothcA or cCcentercA). The
    variable lslm$fill-eos-len(5)le determines the trailing space used after a
    period (cG.cA) character (the trailing characters are specified by
    lslm$fill-eos(5)le), typically defined as 2.

    A set of characters defined by lslm$fill-bullet(5)le enable bullet markers to be
    placed in the text at the beginning of the paragraph causing the left
    margin to be moved to the right of the bullet. The search depth for fill
    to locate a bullet character is defined by lslm$fill-bullet-len(5)le. When the
    paragraph is formatted and one of the bullet characters is encountered
    then the user is prompted as to whether the paragraph should be indented
    following the marker or not. The point of indentation is shown with a cG<<<<cA
    marker.

    Filling is automatically disabled on paragraphs which start with
    characters in the lslm$fill-ignore(5)le set.

    The simple text formatting is generally used for mail messages, ASCII text
    README files etc.


cEcEEXAMPLE cEcA


    The following examples show how the text is formatted with indented
    filling enabled and both justification enabled:-

        This  is  regular  text  that  is on the
        margin

            This is a regular  paragraph that is
            offset  from  the  margin.  Note how
            MicroEmacs 2009 retains the indent.

            * With  the  introduction  of one of
              the  special  characters,  in this
              case a  bullet,  a  format  of the
              paragraph  offsets  the text  from
              the bullet.

            1) Numbered  lists   are  the  same.
               Note that the  paragraphs are all
               separated with a blank line.

            1. Numbered  lists  ending  with   a
               period.

            label - Or labeled lists, separated
                    with a dash.

            >  '>' might be an ignore
            >  character so it skips the paragraph
            >
            >          it is up to the user to
            >   format these.


cEcESEE ALSO cEcA


    lslm$buffer-fill-col(5)le, lslm$buffer-fill-mode(5)le, lslm$fill-bullet(5)le,
    lslm$fill-bullet-len(5)le, lslm$fill-col(5)le, lslm$fill-eos(5)le, lslm$fill-eos-len(5)le,
    lslm$fill-ignore(5)le, lslm$fill-mode(5)le, lslmifill-paragraph(3)le, lslmparagraph-to-line(3)le.
! 2 filter-buffer
cEcENAME cEcA


    filter-buffer - Filter the current buffer through an O/S command
$a


cEcESYNOPSIS cEcA


    cDfilter-buffercA (cDC-x #cA)


cEcEDESCRIPTION cEcA


    cDfilter-buffercA executes one operating system command, using the contents of
    the current buffer as input, sending the results back to the same buffer,
    replacing the original text.

    This would typically be used in conjunction with cDsort(1)cA, cDawk(1)cA or cDsed(1)cA
    to translate the contents of the buffer.


cEcESEE ALSO cEcA


    lslmpipe-shell-command(2)le.
! 2 find-file
cEcENAME cEcA


    find-file - Load a file
$a


cEcESYNOPSIS cEcA


    cCncA cDfind-filecA "cCfile-namecA" (cDC-x C-fcA)


cEcEDESCRIPTION cEcA


    cDfind-filecA finds the named file cCfile-namecA. If it is already in a buffer,
    make that buffer active in the current window, otherwise attempt to create
    a new buffer and read the file into it.

    The numeric argument cCncA is used to modify the default behavior of the
    command, where the bits are defined as follows:

    cD0x01cA
        If the file does not exist and this bit is not set the command fails
        at this point. If the file does not exist and this bit is set (or no
        argument is specified as the default argument is cG1cA) then a new empty
        buffer is created with the given file name, saving the buffer
        subsequently creates a new file.

    cD0x02cA
        If this bit is set the file will be loaded with lslmbinary(2m)le mode
        enabled. See help on cDbinarycA mode for more information on editing
        binary data files.

    cD0x04cA
        If this bit is set the file will be loaded with lslmcrypt(2m)le mode
        enabled. See help on cDcryptcA mode for more information on editing
        encrypted files.

    cD0x08cA
        If this bit is set the file will be loaded with lslmrbin(2m)le mode enabled.
        See help on cDrbincA mode for more information on efficient editing of
        binary data files.

    cD0x10cA
        If this bit is set then the file hook evaluation is not performed when
        the file is loaded (i.e. the lsfileHooks(2)lmbuffer's file hookle is not executed).

    Text files are usually thought of as named collections of text residing on
    disk (or some other storage medium). In MicroEmacs 2009 the disk based
    versions of files come into play only when reading into or writing out
    buffers. The link between the physical file and the buffer is through the
    associated file name.

    MicroEmacs 2009 permits full file names, i.e. you can specify:

        disk:\directories\filename.extension


    or (UNIX)

        /directories/filename.extension


    If the disk and directories are not specified, the current buffers disk/
    directory is used. Several points should be noted in respect to the
    methods that MicroEmacs utilizes in the handling of files:-

        * Without explicitly saving the buffer(s) to file, all edits would be
          lost upon leaving MicroEmacs - you are asked to confirm whenever you
          are about to lose edits.

        * MicroEmacs has a mechanism for "protecting" your disk-based files
          from overwriting when it saves files. When instructed to save a
          file, it proceeds to dump the file to disk, making a backup of the
          existing file when lslmbackup(2m)le mode is enabled.

        * Auto-saving files can be performed on edited buffers by setting the
          lslm$auto-time(5)le variable. The file is saved in the same place with a
          'cG#cA' appended to the file name. This can be used directly by the user
          or in the unlikely event of MicroEmacs crashing (or system crash),
          the files are automatically recovered next time it is edited.

    If you do not wish to perform any edits but merely browse the file(s), add
    the lslmview(2m)le mode to the buffer or ask for the file to be read in for
    lsview-file(2)lmviewingle only.


cERCS Support cA


    If the file does not exist and the variable lslm$rcs-file(5)le is set then the
    existence of the RCS file is tested. If the rcs file exists then it will
    be checked out using a command-line created from the variable
    lslm$rcs-co-com(5)le. If the check-out is successful then this file is loaded.

    This raw interface for supporting file revision control systems has been
    adapted to support SCCS and Visual Source Safe see help on variable
    cD$rcs-filecA for more information and examples.


cEHTTP Support cA


    MicroEmacs supports http file loading, this is available by default on
    UNIX systems but must be compiled in on win32 platforms (socket libraries
    not available on all win95 machines so cannot be compiled in by default).
    When available a http file can be loaded by simply executing cDfind-filecA and
    giving the http file name, i.e. "cGhttp://user:password@address:port/filecA".
    Only thecG http://cA, cGaddresscA and cG/filecA components are mandatory, the rest can
    usually be omitted. e.g.:

        find-file "http://www.jasspa.com/index.html"


    See help page on lslm%http-proxy-addr(5)le for information on HTTP proxy server
    support.


cEFTP support cA


    MicroEmacs supports ftp file loading, this is identical to http except the
    prefix cGftp://cA is used as opposed tocG http://cA. The user name and password
    defaults to cCguestcA in the absence of both these fields. If the user name is
    supplied but not the password the password will be prompted for; this can
    be useful as the password will not be stored or written to the history
    file. Connection is by default on port 21.

        find-file "ftp://<me>:<password>@members.xoom.com/jasspa/index.html"


    See also lslmftp(3)le.

    The progress of the FTP transfer, and the FTP commands issued, may be
    viewed in the cG*ftp-console*cA buffer. This is popped up depending on the
    setting of the lslm%ftp-flags(5)le variable.


cEcENOTES cEcA


    The base name part (i.e. not the path) of cGfile-namecA can contain wild-card
    characters compatible with most file systems, namely:-

    cD?cA
        Match any character.

    cD[abc]cA
        Match character only if it is cCacA, cCbcA or cCccA.

    cD[a-d]cA
        Match character only if it is cCacA, cCbcA, cCccA or cCdcA.

    cD[^abc]cA
        Match character only if it is not cCacA, cCbcA or cCccA.

    cD*cA
        Match any number of characters.

    If the name matches more than one file, a buffer will be created for each
    matching file. Note that these are not the same wild-card characters used
    by lsRegularExpressions(2)lmregexle.

    For cCftpcA and cChttpcA then a ftp console window is opened up to show the
    progress of the transfer (when configured), this is described in lslmftp(3)le.


cEcESEE ALSO cEcA


    lslmauto(2m)le, lslmbinary(2m)le, lslmcrypt(2m)le, lslmrbin(2m)le, lslmtime(2m)le, lslmview(2m)le,
    lslmbuffer-mode(2)le, lslmfile-attrib(3)le, lslmfile-op(2)le, lslmfind-bfile(3)le, lslmftp(3)le,
    lslmnext-window-find-file(2)le, lslmpage-bfile(3)le, lslmpage-file(3)le, lslmread-file(2)le,
    lslmsave-buffer(2)le, lslmview-file(2)le, lslmwrite-buffer(2)le, lslm$rcs-file(5)le,
    lslm%ftp-flags(5)le, lslm%http-flags(5)le, lslm%http-proxy-addr(5)le.
! 2 find-tag
cEcENAME cEcA


    find-tag - Find tag, auto-load file and move to tag position
$a


cEcESYNOPSIS cEcA


    cCncA cDfind-tagcA "cCstringcA" (cDesc tcA)


cEcEDESCRIPTION cEcA


    cDfind-tagcA finds the current or given tag (cCstringcA) in a cDtagscA file and goes
    to the given point, loading the file if necessary. The tag is either the
    current word under the cursor or a user supplied word if the cursor is not
    in a word. The buffer containing the tag is popped up in another window
    and the cursor moved to the tag in the new window.

    A cDtagscA file is usually created by an external program (e.g. cDctags(1)cA)
    which stores word references (or tags) and the name of the file containing
    the tag, with a search string to go to its local. It is an indexing system
    which is often used in programming.

    The argument cCncA can be used to change the default behavior of find-tag
    described above, cCncA is a bit based flag where:-

    cD0x01cA
        Use popup-window to display the tag in a different window (default)
        when this flag is not given the current window is used to display the
        tag.

    cD0x02cA
        Disable the use of the current cursor position to determine the tag.
        Instead the tag must always be supplied through "cCstringcA".

    cD0x04cA
        Find the next definition of the last tag (multiple tag support). This
        feature can only be used if multiple tag support is enabled (see flag
        'cDmcA' of variable lslm%tag-option(5)le) and cDfind-tagcA has already been
        successfully executed. In this situation the last invocation of
        find-tag defines the current tag and executing again with an argument
        of cG4cA will jump to the next definition of the current tag or return the
        message "cG[No more "<current>" tags]cA".

        The next tag is typically bound to cGM-C-tcA.

    The cDtagscA file is, by default, assumed to reside in the current directory
    of the currently viewed file. The user variable lslm%tag-option(5)le may be
    specified with a value of 'cGrcA' (recursive) and 'cGccA' (continue) flags, which
    ascends the directory tree from the current directory and attempts to
    locate a cCrecursivelycA generated tags file at a higher directory level.
    Recursive tag files are generally easier to maintain where project source
    files are located in a number of project sub-directories, and enable the
    whole of the project tree to be taggable.

    Two user variables must be defined before cDfind-tagcA will execute, if either
    lslm%tag-file(5)le or lslm%tag-template(5)le are not defined the error message "cD[tags
    not setup]cA" is signaled.


cEcENOTES cEcA


    A cDtagscA file may be generated by MicroEmacs 2009 from the menu (cCTools->XX
    Tools->Create Tags FilecA). Alternatively a cDtagscA file may be generated by
    the cDctags(1)cA utility. This is typically standard on UNIX platforms. For
    Windows and DOS platforms then the cDExuberant CtagscA is recommended, this is
    available from:-

       cG http://darren.hiebert.comcA

    A MicroEmacs 2009 compatible tags file may be generated using the command
    line "cGctags -N --format=1 ."cA cataloging the current directory. To generate
    cDtagscA for a directory tree then use "cGctags -NR -format=1 .cA". Refer to the
    cDExuberant CtagscA documentation for a more detailed description of the
    utility.


cEcESEE ALSO cEcA


    lslm%tag-file(5)le, lslm%tag-option(5)le, lslm%tag-template(5)le, lslmgenerate-tags-file(3)le,
    cDctags(1)cA.
! 2 get-next-line
cEcENAME cEcA


    get-next-line - Find the next command line
$a


cEcESYNOPSIS cEcA


    cDget-next-linecA (cDC-x `cA)


cEcEDESCRIPTION cEcA


    cDget-next-linecA is typically used in conjunction with the lslmcompile(3)le and
    lslmgrep(3)le commands to enable the user to step through errors/locations one
    by one. The command looks for lines in the form defined by
    lslmadd-next-line(2)le in the order of definition. If a match is found the
    command attempts to find the next error or warning found from the current
    location (See lslmcompile(3)le). If the buffer was not found then the next
    buffer set is searched for, and if found then the next expression from the
    cursor is automatically located. The command fails if none of the buffers
    exist, or the end of the buffer is reached.


cEcESEE ALSO cEcA


    lslm$file-template(5)le, lslm$line-template(5)le. lslmadd-next-line(2)le, lslmcompile(3)le,
    lslmgrep(3)le.
! 2 goto-alpha-mark
cEcENAME cEcA


    goto-alpha-mark - Move the cursor to a alpha marked location
$a


cEcESYNOPSIS cEcA


    cDgoto-alpha-markcA "cC?cA" (cDC-x acA)
    cC0cA cDgoto-alpha-markcA


cEcEDESCRIPTION cEcA


    cDgoto-alpha-markcA prompts user for an alpha character and sets the cursor
    position to the preset location. Alpha marks are specified on a per buffer
    basis, thus the current buffer is not changed, merely the current location
    in the buffer. The alpha mark must already be defined using
    lslmset-alpha-mark(2)le. This functionality is useful for rapidly returning back
    to locations in large files.

    cDgoto-alpha-markcA with a numeric argument of zero (0) returns a string
    containing all of the alpha marks that exist in the current buffer. The
    alpha mark string is returned in lslm$result(5)le, this is an empty string if
    there are no alpha marks in the buffer.


cEcESEE ALSO cEcA


    lslmset-alpha-mark(2)le.
! 2 goto-line
cEcENAME cEcA


    goto-line - Move the cursor to specified line
$a


cEcESYNOPSIS cEcA


    cCncA cDgoto-linecA (cDesc gcA)
    cDgoto-linecA "cCnumcA"


cEcEDESCRIPTION cEcA


    cDgoto-linecA moves the cursor to the specified line in the buffer. The user
    is prompted for the new line number on the command line, which may be
    entered as a relative displacement ([cG+cA|cG-cA]cCnumbercA) from the current
    position, or as an absolute line number (cCnumbercA). If the number is
    preceded by cG+cA or cG-cA then this is treated as a relative displacement from
    the current line, otherwise it is an absolute line number.

    If a positive argument cCncA is supplied, cDgoto-linecA moves to this line, e.g.
    to move the cursor to line 240:
sB
        240 goto-line

sA
    A special case of cDgoto-linecA is operative if an argument of cG0cA is supplied,
    argument "cCnumcA" must also be given as above except cDgoto-linecA treats the
    line number or displacement as an absolute move, i.e. includes cCnarrowed
    outcA sections when calculating the new position. If the new line lies
    within a narrowed out section (i.e. a section that has been hidden and is
    not visible on the screen) the narrow is automatically expanded. See
    lslmnarrow-buffer(2)le for more information on narrowing.

    Supplying a negative argument to goto-line results in an error.


cEcENOTES cEcA


    After successfully calling goto-line, variable lslm$window-line(5)le is set to
    the required line number.


cEcESEE ALSO cEcA


    lslmgoto-alpha-mark(2)le, lslmgoto-matching-fence(2)le, lslmnarrow-buffer(2)le,
    lslm$window-line(5)le.
! 2 goto-matching-fence
cEcENAME cEcA


    goto-matching-fence - Move the cursor to specified line
$a


cEcESYNOPSIS cEcA


    cCncA cDgoto-matching-fencecA (cDesc C-fcA)


cEcEDESCRIPTION cEcA


    cDgoto-matching-fencecA moves the cursor to the opposing fence character of
    the character currently under the cursor. The set of fence characters
    include cG[ ... ]cA, cG{ ... }cA, cG( ... )cA and cG< ... >cA. i.e. if the character under
    the cursor is `cG{cA' then cDgoto-matching-fencecA moves the cursor to the
    matching closing `cG}cA' fence, and visa versa.

    cDgoto-matching-fencecA can also be used to move to a matching cG' ... 'cA and cG"
    ... "cA fence, but, as the start and end fence is the same, bit cG0x04cA must be
    used to indicate whether the current fence is the open or close fence, see
    below.

    cDgoto-matching-fencecA can also be used to move the cursor between the start
    and end of a C/C++ cG/* ... */cA style comment. It can also be used to move to
    matching C/C++ cG#ifcA, cG#elifcA, cG#elsecA and cG#endifcA constructs, cycling through
    them in the given order.

    The numeric argument cCncA is used to modify the default behavior of the
    command, where the bits are defined as follows:

    cD0x01cA
        When this bit is set (the default) the terminal bell is rung if the
        matching fence cannot be found.

    cD0x02cA
        When this bit is set the command moves the cursor to the matching
        fence, updates the screen and pauses for lslm$pause-time(5)le before moving
        hte cursor back again. When omitted the cursor is simply moved to the
        matching fence.

    cD0x04cA
        When this bit is set the fence the cursor is current at is treated as
        the close fence so cDgoto-matching-fencecA moves backwards through the
        file looking for the matching open fence. When this bit is omitted the
        fence is assumed to be the open fence, this bit is only used for cG'cA and
        cG"cA type fences.

    When the lslmfence(2m)le buffer mode is enabled the matching open fence is
    automatically displayed when the closing fence is typed. The length of
    time the matching fence is displayed for can be controlled by the
    lslm$pause-time(5)le variable.


cEcESEE ALSO cEcA


    lslmfence(2m)le, lslm$pause-time(5)le, lslmgoto-line(2)le.
! 2 list-commands
cEcENAME cEcA


    list-commands - List available commands
$a


cEcESYNOPSIS cEcA


    cCncA cDlist-commandscA (cDC-h ccA)


cEcEDESCRIPTION cEcA


    cDlist-commandscA constructs a list of all known built in commands and macros
    that are currently defined by MicroEmacs 2009 and presents a list of those
    commands in the buffer "cD*commands*cA". Each entry is formatted as:-

        cDcommand ......................... keyCodecA

    Where multiple keys are bound to the same command, then each of the
    cCkeyCodecA's is shown.

    cDlist-commandscA only displays visible commands, if a numeric argument cCncA of 0
    is given then all commands are displayed, irrespective of their hidden
    status.

    cDlist-commandscA is similar to lslmdescribe-bindings(2)le except that the commands
    are presented in alphabetical order (as opposed to key binding order).


cEcEEXAMPLE cEcA


    The following is an example of the output of cDlist-commandscA:-

        backward-char ................. "C-b"
                                        "left"
        backward-delete-char .......... "backspace"
                                        "S-backspace"
        backward-delete-tab ........... "S-tab"
        backward-kill-word ............ "esc backspace"
        backward-line ................. "C-p"
                                        "up"
                                        "C-up"
        backward-paragraph ............ "esc ["
                                        "esc p"
        backward-word ................. "esc b"
                                        "C-left"
        beginning-of-buffer ........... "esc <"
                                        "home"
        beginning-of-line ............. "C-a"
        buffer-bind-key
        buffer-info ................... "C-x ="
        buffer-mode ................... "esc ~"
                                        "C-x m"
                                        "insert"
        buffer-unbind-key
        :
        :


cEcESEE ALSO cEcA


    lslmcommand-apropos(2)le, lslmdescribe-bindings(2)le, lslmlist-variables(2)le.
! 2 change-window-depth
! 2 grow-window-vertically
! 2 shrink-window-vertically
! 2 resize-window-vertically
cEcENAME cEcA


|change-window-depth
    change-window-depth - Change the depth of the current window
|grow-window-vertically
    grow-window-vertically - Enlarge the current window (relative change)
|shrink-window-vertically
    shrink-window-vertically - Shrink the current window (relative change)
|resize-window-vertically
    resize-window-vertically - Resize the current window (absolute change)
$a


cEcESYNOPSIS cEcA


    cCncA cDchange-window-depthcA [ "cCdepthcA" ]

    cCncA cDgrow-window-verticallycA
    cCncA cDshrink-window-verticallycA
    cCncA cDresize-window-verticallycA


cEcEDESCRIPTION cEcA


    cDchange-window-depthcA changes the depth of the current window, if the
    numeric argument cCncA is given then the window depth is changed by cCncA lines.
    If cCncA is not specified the user is prompted for the new cCdepthcA and the
    window depth will be changed to this value. The command aborts if the
    requested size cannot be achieved (the window becomes too small or a
    neighbouring one does).


cEcENOTES cEcA


    Commands cDgrow-window-verticallycA, cDshrink-window-verticallycA and
    cDresize-window-verticallycA were replaced by the new cDchange-window-depthcA
    command in April 2002. Following are macro implementations of the old
    commands:
sB
        define-macro grow-window-vertically
            @# change-window-depth
        !emacro

        define-macro shrink-window-vertically
            &neg @# change-window-depth
        !emacro

        define-macro resize-window-vertically
            !if &not @?
                !abort
            !endif
            change-window-depth @#
        !emacro

sA

cEcESEE ALSO cEcA


    lslmchange-window-width(2)le, lslmresize-all-windows(2)le, lslmsplit-window-vertically(2)le.
! 2 tab
cEcENAME cEcA


    tab - Handle the tab key
$a


cEcESYNOPSIS cEcA


    cCncA cDtabcA (cDtabcA)


cEcEDESCRIPTION cEcA


    cDtabcA manages the cGtabcA key, typically inserts cCncA tabs. The effect of the
    command is determined by:

    cD$buffer-indentcA
        If lslm$buffer-indent(5)le, is non-zero then the effect of tab is defined by
        the setting of bit cG0x1000cA of variable lslm$system(5)le, typically it resets
        the current line indentation or inserts a tab.

    cDtabcA
        If a tab is to be inserted and this mode is enabled then multiple
        spaces are used instead of tab characters, see lslmtab(2m)le mode.


cEcESEE ALSO cEcA


    lslm$buffer-indent(5)le, lslm$buffer-tab-width(5)le, lslm$tab-width(5)le,
    lslmbackward-delete-tab(2)le, lslmindent(2)le, lslminsert-tab(2)le, lslmnormal-tab(3)le, lslmtab(2m)le.
! 2 help
! 2 help-command
! 2 help-variable
! 2 help-item
cEcENAME cEcA


|help
    help - Help; high level introduction to help
|help-command
    help-command - Help; command information
|help-variable
    help-variable - Help; variable information
|help-item
    help-item - Help; item information
$a


cEcESYNOPSIS cEcA


    cCncA cDhelpcA (cDesc ?cA)
    cDhelp-commandcA "cCcommandcA" (cDC-h C-ccA)
    cDhelp-variablecA "cCvariablecA" (cDC-h C-vcA)
    cDhelp-itemcA "cCitemcA" (cDC-h C-icA)


cEcEDESCRIPTION cEcA


    The help commands provide a quick on-line help facility within MicroEmacs
    2009 without invoking a third party documentation system (e.g. a browser
    such as cDNetscape(1)cA or cDwinhelp(1)cA).

    The on-line help is assisted by a set of macros which enable key words
    within the help buffers to be located by either tagging (cGesc tcA) or by
    selection with the left mouse button. The tag mechanism supports command
    completion.

    cDhelpcA provides general help on the philosophy and functionality of
    MicroEmacs 2009, if an argument cCncA of 0 is given to the command it changes
    the current buffer to the internal help buffer, typically named "cG*on-line
    help*cA". This is a lshide(2m)lmhiddenle system buffer used to store all the on-line help
    and can be used for a variety of things. Note that access to this buffer
    must be via the cDhelpcA command, not cDfind-buffercA and the help command will
    also ensure the system help file is loaded first.

    cDhelp-commandcA describes the purpose of the given cCcommandcA.

    cDhelp-variablecA Describes the purpose of the given cCvariablecA, similar to
    cDhelp-commandcA, only for variables.

    cDhelp-itemcA Describes the purpose of any given item, where item could be a
    command, variable or any aspect of MicroEmacs 2009.


cEcEFILES cEcA


    The help files are ASCII text files located in the MicroEmacs 2009 home
    directory. The files are defined as follows:-

    cGme.ehfcA - Help text file.
    cGhkehf.emfcA - Help macros.


cEcESEE ALSO cEcA


    lslmosd-help(3)le, lslmcommand-apropos(2)le, lslmdescribe-bindings(2)le, lslmdescribe-key(2)le,
    lslmlist-commands(2)le, lslmlist-variables(2)le.
! 2 osd
cEcENAME cEcA


    osd - Manage the On-Screen Display
$a


cEcESYNOPSIS cEcA


    cC-4cA cDosdcA
    cC-3cA cDosdcA
    cC-2cA cDosdcA
    cC-1cA cDosdcA cCncA
    cDosdcA cD-1cA cCflagcA
    cDosdcA cCncA cD0cA cCflagscA ["cCschemecA"] ["cCx-poscA" "cCy-poscA"] ["cCmin-widthcA" "cCmin-depthcA"
    "cCmax-widcA" "cCmax-depcA"] ["cCdefault-buttoncA"] ["cCinitial-itemcA"]
    [["cCtitle-bar-schemecA"] ["cCTextcA"]] ["cCresize-commandcA"] ["cCcontrol-commandcA"]
    ["cCinit-commandcA"]
    cDosdcA cCncA cCicA cCflagscA ["cCitem-schemecA"] ["cCwidthcA" "cCdepthcA"] ["cCtextcA"] ["cCargumentcA"
    "cCcommandcA"]
    cCncA cDosdcA


cEcEDESCRIPTION cEcA


    The cDosdcA command manages the On-Screen Display, menu and dialogs. The
    command takes various forms as defined by the arguments. Each of the
    argument configurations is defined as follows:-


cEMain Menu-Bar Status cA


    cDosdcA cD-1cA cCflagcA

    This invocation determines the state of the top main menu bar. The state
    is set by the argument cCflagcA defined as:-

            cG 1cA - enable.
            cG 0cA - disable.
            cG-1cA - disable and destroy.


cEDialog Creation and Redefinition cA


    cDosdcA cCncA cD0cA cCflagscA ["cCschemecA"] ["cCx-poscA" "cCy-poscA"] ["cCmin-widthcA" "cCmin-depthcA"
    "cCmax-widcA" "cCmax-depcA"] ["cCdefault-buttoncA"] ["cCinitial-itemcA"]
    [["cCtitle-bar-schemecA"] ["cCTextcA"]] ["cCresize-commandcA"] ["cCcontrol-commandcA"]
    ["cCinit-commandcA"]

    This invocation creates or resets the base properties of dialog cCncA. The
    cCflagscA argument determines the arguments and are defined as follows:

        cDAcA
            Defines dialog as an alpha type dialog, items are added according
            to their string text value. Alpha dialogs may not have separator
            or child items.

        cDicA
            Used with the cDAcA flag, sets the alpha ordering to be case
            insensitive.

        cDGcA
            Create a Grid dialog. Every item in the dialog is given a single
            character boarder around it. If one of the dialogs items is also
            given a 'cDGcA' flag, the boarder is drawn as a box around it,
            otherwise spaces are used.

        cDNcA
            Create a Note-Book (or tabs) dialog. The dialog can only contain
            one dialog inclusion item ('cDIcA') and Note-Book pages ('cDPcA'). Pages
            added before the Inclusion item (page item number is lass than the
            inclusion page item number) will be drawn at the top of the
            note-book, those added after will be drawn at the bottom.

        cDbcA
            Draw boarder, draws a boarder around the outside of the dialog.
            See also cCflagcA cDtcA (title) as flag effects the boarder.

        cDacA
            Defines the absolute start-up position of the dialog in the
            arguments cCx-poscA and cCy-poscA, which are the column and row positions
            respectively of the dialog from the top left-hand corner of the
            display. The arguments must be specified. e.g. the main menu is
            defined with an absolute position of (0,0). If the dialog can not
            be fully drawn on the screen at the given position it will be
            moved to a position which shows the most.

        cDocA
            Specifies an offset to the dialog position calculated by
            MicroEmacs in the arguments cCx-poscA and cCy-poscA, which are the column
            and row offsets. This flag is ignored when flag cDacA is also
            specified. If the dialog can not be fully drawn on the screen at
            the new position it will be moved to a position which shows the
            most.

        cDscA
            Sets the size of the dialog. cDosdcA automatically resizes a dialog to
            fit the contents, this flag should be considered as a size hint
            for cDosdcA, and is not guaranteed to be honored. If the dialog has a
            boarder (flag cDbcA) the size given should include the boarder size.

            The arguments, cCmin-widthcA, cCmin-depthcA, cCmax-widthcA and cCmax-depthcA must
            be specified, as

            cD+vecA
                The actual size of the dialog, minimum and maximum sizes.

            cD0cA
                cCmincA value should be specified as desired window size, cCmaxcA may
                be 0 which specifies the screen size.

            cD-vecA
                cCmincA defines the maximum size. cCmaxcA is unlimited.

            The following table shows possible combination of the sing
            parameters and their effect:-

            cCmincA=0, cCmaxcA=0
                Default setting, makes dialog as small as possible, with a
                maximum size of the screen.

            cCmincA=0, cCmaxcA=50
                Make dialog as small as possible with a max of 50 characters.

            cCmincA=50, cCmaxcA=0
                Make dialog as small as possible, but make it at least 50
                characters big and no larger than the screen.

            cCmincA=30, cCmaxcA=-1
                Make dialog at least 30 characters big with no upper limit,
                very useful for dialogs being used as scrolled children.

            cCmincA=-1, cCmaxcA=50
                Make dialog 50 characters big.

            cCmincA=-1, cCmaxcA=0
                Make dialog the same size as the screen.

            cCmincA=-1, cCmaxcA=-1
                Make dialog as big as possible (do not do this unless you have
                a large amount of memory to throw away).

        cDScA
            Sets the main dialog scheme, The default scheme when not specified
            is lslm$osd-scheme(5)le See macro file cGfileopen.emfcA for an example.

        cDDcA
            Sets "cCdefault-buttoncA" to be the button executed when the cGreturncA
            key is pressed and no other button has the focus. The current
            default button is typically denoted by "cG> Button <cA", other buttons
            are denoted by "cG[ Button ]cA" or have no denoting characters, this
            is configured via the lslm$window-chars(5)le variable.

        cDIcA
            Set "cCinitial-itemcA" to be selected when the dialog first opens, if
            this item is an automatically opened sub-menu then the child menu
            will also be opened.

        cDtcA
            Title bar is present - draws the title bar. The cCtextcA argument is
            optional Also see flags cDHcA, cDccA and cDrcA.

        cDHcA
            Defines the title bar color scheme if flag cDtcA is specified. If cCtcA is
            absent the option is ignored.

        cDccA
            Centers the title bar text if specified. Option cDtcA must be
            specified, otherwise the option is ignored.

        cDrcA
            Right justifies the title bar text if specified. Option cDtcA must be
            specified, otherwise the option is ignored.

        cDRcA
            Defines the dialog as re-sizable. The cCresize-commandcA argument must
            be specified and the command should resize the dialog to the sizes
            given in lslm$result(5)le in the format "cGwwwwddddcA", where cGwcA is width and
            cGdcA the depth. If the cCresize-commandcA is aborted then that resize
            operation is abandoned.

        cDMcA
            Identifies the dialog as the main menu dialog.

        cDCcA
            Binds a command to the dialog, which is automatically executed
            when the dialog is opened. When the dialog with a cDCcA attribute is
            opened, it is rendered on the screen and then a command, defined
            by cCcontrol-commandcA is invoked, when the command completes the
            dialog is closed.

            The command dialog is typically used to create status messages.
            e.g. a "cGBusy - Please WaitcA" dialog box, such a dialog may be
            implemented when saving the current buffer then create the simple
            dialog and sent the cCcontrol-commandcA to lslmsave-buffer(2)le. The dialog
            would be defined as:-
sB
                osd 200 0 "btcHC" %osd-title-scheme "Saving Buffer" save-buffer
                osd 200 1 ""
                osd 200 2 "" "Busy - Please Wait"
                osd 200 3 ""
                200 osd

sA
            If the dialog has buttons which need to become active then control
            can be returned to cDosdcA by calling cDosdcA with no arguments, e.g. in
            the above example the dialog can be made to stay on the screen
            until the user selects cGokaycA by:
sB
                define-macro test-osd
                    save-buffer
                    osd 200 2 "" "Save Complete"
                    osd 200 4 "BcfH" %osd-ebtt-scheme "  \HOkay  " f void
                    -4 osd
                !emacro

                osd 200 0 "btcHC" %osd-title-scheme "Saving Buffer" test-osd
                osd 200 1 ""
                osd 200 2 "" "Busy - Please Wait"
                osd 200 3 ""
                osd 200 4 "BcfHS" %osd-dbtt-scheme "  Okay  "

                200 osd

sA
            The above mechanism is how lslmspell-buffer(3)le operates.

        cDBcA
            Makes the mouse right Button have the same behaviour as the left,
            by default the right mouse button simply closes the dialog. This
            is useful for some dialogs which are opened using the right mouse
            button.

        cDfcA
            Automatically uses the first letter of an item's test as the hot
            key. Unlike the normal hot keys, the letter is not hi-lighted and
            when typed by the user the item is only selected, not executed.
            This flag also disables the normal hot-keys for the dialog, so all
            text strings are copied literally.

        cDncA
            Disables '\n' characters in text fields leading to multi lines. By
            default a text item of "Hello\nWorld" will create an item 5 by 2
            characters big.

        If "cCinit-commandcA" is given then this function is always called just
        prior to the dialog being displayed so it can be used to configure the
        dialog.


cEDialog Destruction cA


    cD-1cA cDosdcA cCncA

    This invocation destructs a dialog cCncA. The dialog is only destroyed if it
    is not currently being displayed.


cEDialog Item Creation and Redefinition cA


    cDosdcA cCncA cCicA cCflagscA ["cCitem-schemecA"] ["cCwidthcA" "cCdepthcA"] ["cCtextcA"] ["cCargumentcA"
    "cCcommandcA"]

    This invocation type adds a new item cCicA to a dialog cCncA, the operation of the
    invocation is controlled by the cCflagscA as follows:-

        cDDcA
            Disable item cCicA, the item is ignored and is not rendered in the
            dialog.

        cDIcA
            Include dialog "cCargumentcA" into this dialog. If "cCcommandcA" is
            specified then it is called prior to the child being constructed
            and can be used to define the child. This is similar to the cDMcAs
            command. See also flag cDbcA.

        cDPcA
            Item is a Note-Book page, the item must have text and have an
            argument which is the osd dialog to be show when the page is
            activated.

        cDMcA
            Item is a sub-menu, The argument "cCargumentcA" specifies the
            sub-menus osd dialog number. A "cCcommandcA" may also be specified
            which is executed first, this can actually re-define the item and
            set the dialog number, e.g.
sB
                ; To start with the dialog number is unknown
                osd 1 1 "M" f submenu-setup

                define-macro submenu-setup
                    osd 200 0 ....
                    ....
                    ; Now the sub-menu number is known redefine parent item,
                    ; note the setup  command  is not given as we have now set
                    ; it up!
                    osd 1 1 "M" 200
                !emacro

sA
            See also options cDmcA, cDscA and cDdcA.

        cDmcA
            Sub-menu must be manually opened, using hot-key, the return key or
            the left mouse button.

        cDscA
            Specifies the sub-menu is to be placed to the south (under) the
            parent item, The default when omitted is to the right of the
            parent.

        cDdcA
            Display sub-menu type, i.e. "cG..cA" for auto opening and "cG >cA" for a
            manual opening sub-menu.

        cD-cA
            Fill a non-defined chars with 'cG-cA's instead of 'cG cA's, used to draw
            the lines across menus, typically with no text given, e.g.
sB
                osd 200 5 "-"

sA
            But could also be specified as:
sB
                osd 200 5 "-c" "Lined"

sA
        cDCcA
            Item is a check-box. The setting of the check-box is evaluated
            when the dialog is first drawn, re-draw and whenever any item is
            executed. A "cCcommandcA" must be specified which must both return the
            current setting when the given argument (of 1) is given (!abort if
            false, !return if true) and change the value if the argument value
            is negated. The text string must also be specified, the first 6
            characters are used in the drawing of the check box. The format
            can be shown as follows:-

                String\State       Off         On
                "123456"            "12356"     "12456"
                " (-+)^"            " (-)"      " (+)"
                "^[ *] "            "[ ] "      "[*] "
                "^^NY^^"            "N"         "Y"
                "^^^^^^"            ""          ""


            Note that no character is rendered when a 'cG^cA' character is used.
            See also cDpcA for prepending the check-box.

        cDpcA
            Prepend the check-box box. By default a check box is drawn as:

                "Check box12?56"


            This option changes it to:

                "12?56Check box"


        cDxcA
            When the item is executed do not exit the dialog. Often used with
            Check-boxes.

        cDicA
            The command given is a command line string which is executed in a
            similar fashion to lslmexecute-line(2)le. Note that if an argument is
            required it is usually specified in the string, i.e.
sB
                osd "i" "text" 5 "1000 ml-write @#"

sA
            writes the argument (i.e. 5) for 1 second.
sB
                osd "i" "text" 5 "my-command"

sA
            in this case cCmy-commandcA will not be given an argument,
sB
                osd "i" "text" 5 "10 my-command"

sA
            in this case cCmy-commandcA will be given an argument of 10,
sB
                osd "i" "text" 5 "@# my-command"

sA
            in this case cCmy-commandcA will be given an argument of 5.

        cDhcA
            Horizontally add the next item, e.g.
sB
                osd "h" "1st on line "
                osd ""  "2nd on line"

sA
            Will produce "cG1st on line 2nd on linecA". If there is not enough
            room on a single dialog line to display all the horizontally added
            items then the line is split and as many lines as needed are used.

        cDccA
            Center the text for the item in the middle of the dialog.

        cDrcA
            Right hand justify the text for the item.

        cDtcA
            Set the item to be in the tab order of the dialog. The order of
            tab items in the dialog is auto-generated, based on item cCicA
            numbers.

        cDbcA
            Child inclusion is a scroll box type. By default a child inclusion
            simply draws the whole child dialog at the position. If this flag
            is specified then arguments "cCwidthcA" and "cCdepthcA" must also be
            supplied and a window displaying "cCwidthcA" by "cCdepthcA" of the child
            is created. The size of this item will be "cCwidthcA"+1+cCsscA by
            "cCdepthcA"+1+cCsscA where cCsscA is the scroll bar size which is 1 or 2
            depending on the setting of lslm$scroll-bar(5)le. It is up to the user
            to ensure that the child dialog being displayed is at least
            "cCwidthcA" by "cCdepthcA" characters in size, if this is not true then
            the effect is undefined, (a crash dump is not out of the
            question).

        cDfcA
            Fix the item size to the given "cCsizecA", by default an item is
            expanded to the width of the dialog.

        cDEcA
            Item is an entry box type. Use the 'cDzcA' flog or set the text to a
            string of cG#cA's to set the size of the entry text box. Similar to
            Check-boxes, the command given must both return and set the value
            depending on value of the argument given. The value must be
            returned in lslm$result(5)le if the given argument (or 1 for 'cGfcA') is
            given, and the value must be set (usually using lslm@ml(4)le or lslm@mc(4)le)
            if the argument is negated. The absolute value of the argument is
            maintained.
sB
                set-variable %entry-value "Hello world"

                define-macro my-entry-set
                    !if &equ @# -1
                        set-variable %entry-value @ml "" %entry-value
                    !else
                        set-variable $result %entry-value
                    !endif
                !emacro

                osd 200 1  "S" " \HEnter text" 2
                osd 200 2  "ExHf" %osd-entry-scheme "########" 1 my-entry-set

sA
        cDOcA
            Item is a read-only Combo-box type of entry. As with entry items
            (type cDEcA) the command given must return the current value to be
            displayed in the entry box when it is called with a non-negated
            argument. However, when the entry box is selected the item behaves
            like a sub-menu (type cGMcA), the command is called (with a negated
            argument) which can be used to create the sub-menu. The type of
            item is often used with a button item (type cDBcA) to the right of it
            which also opens the sub-menu by executing this item.

        cDBcA
            Item is a Button type. Add the last 2 characters of
            lslm$window-chars(5)le to the text string given, one on each side, i.e.
            if the last two chars are "[]" then:
sB
                osd "B" " Okay "

sA
            will be drawn as "cG[ Okay ]cA". See also flag cDTcA.

        cDTcA
            Item is a repeat type, this is typically used with buttons,
            altering their execution behavior. By default an item is only
            executed when the left mouse button is released while over the
            item. However when this flag is specified the item is executed as
            soon as the left mouse button is pressed and is repeatedly
            executed until the button is release or the mouse moves off the
            item. The delay between repeated executions is determined by the
            variables lslm$delay-time(5)le and lslm$repeat-time(5)le.

        cDScA
            Item is a separator type. This is not often required as any item
            without anything to execute is automatically set to be a
            separator. Occasionally a mouse-insensitive item which can be
            executed is required, typically a text string with a hot key, e.g.
sB
                osd 200 1  "S" " \HEnter text" 2
                osd 200 2  "ExHf" %osd-entry-scheme "########" 1 my-entry-set

sA
            will be drawn as "cG[ Okay ]cA". The hot-key is denoted by \H so for
            osd item 1 then this is the cDEcA of cCEntercA.

            Item 1 will have a hot-key which executes item 2 (as no command is
            given), but it will not hi-light if the mouse is placed over it.

        cDRcA
            Redraw dialog. Forces a redraw of the dialog when the item is
            executed. This is not usually required as cDosdcA generally works out
            for itself whether a redraw is needed, however, sometimes it does
            not, most notably when the item sets a variable that is displayed
            by another item as an entry, e.g.
sB
                set-variable %entry-value "Hello world"

                define-macro my-entry-set
                    !if &equ @# -1
                        set-variable %entry-value @ml "" %entry-value
                    !else
                        set-variable $result %entry-value
                    !endif
                !emacro

                osd 200 1  "S" " \HEnter text" 2
                osd 200 2  "ExHf" %osd-entry-scheme "########" 1 my-entry-set
                osd 200 3  "BxHcfiR" %osd-ebtt-scheme  " \HReset " f "set-variable %entry-value\"\""

sA
            If item 3 did not have flag cDRcA set when executed, cDosdcA would not
            realize that the change to value cG%entry-valuecA affects the display
            and the button would not appear to operate.

        cDHcA
            Sets the item color scheme. Note that for scrolled child items
            this only sets the scroll-box color scheme, the dialog scheme is
            used for the rest of the boarder.

        cDucA
            Disables the high-lighting of the item when the mouse is over it.

        cDGcA
            This flag is only applicable in grid dialogs (see flag cDGcA in dialog
            creation). The current item will be drawn with a box around it
            using lslm$box-chars(5)le.

        cDzcA
            Sets the item size, arguments "cCwidthcA" and "cCdepthcA" must be given.

        cDNcA
            This flag only has an effect on entry item types, it selects
            'New-line' style text entry which allows the user to enter
            multiple line of text using the return key and to end the input
            using the tab key.

        Note that for a non-sub-menu item type, if an argument is given with
        no command then it is assumed that the number given is the item number
        to be executed, see flag cDScA for an example.


cEDialog Execution cA


    cCncA cDosdcA

    This invocation with a single positive numeric argument executes the cCncAth
    dialog.


cEReturning Command Control cA


    cC-4cA cDosdcA

    An invocation of cDosdcA with an argument of -4 returns control back to the
    cDosdcA from a cCcontrol-commandcA. Refer to the cDCcA flag in the create/reset dialog
    property for information and an example.


cECurrent Dialog Redraw cA


    cC-2cA cDosdcA

    Calling osd with an argument of -2 forces the complete redrawing of
    current dialog and any sub-dialogs. This is very useful when the execution
    of one item may effect the appearance of another.


cERedraw All Active Dialogs cA


    cC-3cA cDosdcA

    Calling osd with an argument of -3 forces the complete redrawing of all
    currently active osd dialogs. This is better than calling lslmscreen-update(2)le
    when only the osd dialogs need updating as it suffers less from
    flickering.


cEcEEXAMPLE cEcA


    Refer to cGosd.emfcA, cGuserstp.emfcA, cGsearch.emfcA, cGspell.emfcA and cGorganize.emfcA for
    examples of the OSD.


cEcENOTES cEcA


    In December 2004 the cDdcA default item flag in dialog creation was replaced
    with two new flags, cDDcA and cDIcA. At the same time the dialog tab order was
    changed to an automated calculation so a tab index value is no longer
    required with the item tab cDtcA flag.


cEcESEE ALSO cEcA


    lslm$osd-scheme(5)le, lslm$result(5)le, lslm$scroll-bar(5)le. lslm$window-chars(5)le.
! 2 show-cursor
cEcENAME cEcA


    show-cursor - Change the visibility of the cursor
$a


cEcESYNOPSIS cEcA


    cCncA cDshow-cursorcA


cEcEDESCRIPTION cEcA


    cDshow-cursorcA hides the cursor if a negative argument is given and restores
    it if a positive or no argument is given. Note that this is not supported
    on all platforms.

    cDshow-cursorcA internally performs a counting operation, if the cursor is
    hidden cCmcA times then it must also be shown cCmcA times before the cursor
    becomes visible again, giving no argument will restore the count ensuring
    it is visible.
! 2 narrow-buffer
cEcENAME cEcA


    narrow-buffer - Hide buffer lines
$a


cEcESYNOPSIS cEcA


    cCncA cDnarrow-buffercA
    n cDnarrow-buffercA [cCline-schemecA] ["cCout-markup-linecA" |
         "cCto-top-markup-linecA" "cCto-bottom-markup-linecA"] ["cCmarkup-commandcA"]


cEcEDESCRIPTION cEcA


    The cDnarrow-buffercA command allows lines in a buffer to be hidden
    (effectively folded up) the scope of the narrow is defined by a region. A
    region is the text located between the cDpointcA (the current cursor position)
    and the cDmarkcA defined by lsset-mark(2)lmset-markle.

    cDnarrow-buffercA supports two types of information hiding. A simple cCNarrowcA or
    cCNarrowcA cCOutcA hides lines of the region from display and optionally inserts a
    new line, called a mark-up line. The mark-up line allows the narrow
    position to be annotated with a line scheme color and annotation text
    providing a visual representation of the narrow i.e.

        Before Narrow Out           After Narrow Out
        ________________________________________________________________

        ... buffer text ...        ... buffer text ..
        <region start>              <Optional Narrow Out line mark-up>
        .... region text ...       ... more buffer text ...
        <region end>
        ... more buffer text ...


    The second narrow form is a cCNarrow TocA hides text around the region leaving
    the region displayed only. A cCNarrow OutcA will optionally show a mark-up
    line at both the top and bottom of the region. The mark-up line allows the
    cCNarrowcA cCTocA position to be annotated in the buffer with a line scheme color
    and annotation text providing a visual representation of the narrow i.e.

        Before Narrow To            After Narrow To
        ________________________________________________________________

        ... buffer text ...        <Optional Narrow Out top mark-up>
        <region start>              <region start>
        .... region text ...       .... region text ...
        <region end>                <region end>
        ... more buffer text ...   <Optional Narrow Out bottom mark-up>


    Once a narrow has been created and information has been hidden
    cDnarrow-buffercA may be used to subsequently reveal the hidden text on a line
    or complete buffer basis.

    Narrowed regions do not delete the text contained within the buffer the
    information is simply hidden. Saving the buffer using lslmsave-buffer(2)le, by
    default, writes both the displayed and hidden information the command may
    be optionally invoked to save only the visible representation.

    While information is hidden in a narrow lslmcopy-region(2)le and lslmkill-region(2)le
    operate as expected. If a narrow is copied then all of the information
    that is contained within the narrow is also copied to the new location.
    Similarly killing or deleting a narrow removes all of the information that
    is contained within the narrow.

    cDnarrow-regioncA performs the low-level information hiding and is used from
    the macro command language, the command is not generally invoked directly
    by the user. Within the macro environment the location of narrows in any
    buffer may be determined using the line variable lslm$line-flags(5)le. This
    variable allows the narrow state of the current line in a buffer to be
    determined. The narrow state of a buffer may be determined with
    lslmnarrow(2m)le. When a narrow is created the buffer mode lslmnarrow(2m)le is
    automatically set, when the last narrow is removed the mode is deleted.

    The effect of cDnarrow-buffercA depends on the given argument and is defined
    as follows:-

    cG1cA
        Removes all narrows in the current buffer (the default), it aborts if
        there are no narrows in the buffer.

    cG2cA
        Removes the current line's narrow, it aborts if there is no narrow at
        the current line.

    cG3cA
        Narrow to region hides all but the lines of text in the current buffer
        from the lsset-mark(2)lmmarkle position to the current cursor position, effectively
        'narrowing' the buffer to the remaining text.

    cG4cA
        Narrow out region hides the lines of text in the current buffer from
        the lsset-mark(2)lmmarkle position to the current cursor position. This is the inverse
        effect of argument cD3cA.

    The second form of the command takes a variable number of arguments which
    are determined by the value of cCncA when bits in the range cG0x0ff0cA are
    defined. These bits are interpreted as a bit-mask and determine how the
    narrow is to be visually displayed to the user. When these bits are set
    then a mark-up line is created.

    cG0x0010cA - cCline-schemecA
        Bit cG0x0010cA specifies the line lslmhilight(2)le color scheme to be used on
        the narrow line when it is an open or closed narrow. The scheme colors
        used are defined by the scheme variables cGscheme.fold-opencA and
        cGscheme.fold-closedcA.

    cG0x0020cA - "cCout-markup-linecA" | "cCto-top-markup-linecA" "cCto-bottom-markup-linecA"
        Bit cG0x0020cA specifies that mark-up text is used, the text mark up is
        passed into the call. The number of arguments is determined by the
        type of markup operation (cCtocA/cCoutcA). The arguments are placed on the
        mark-up lines.

    cG0x0040cA - "cCmarkup-commandcA"
        Bit cG0x0040cA specifies that a mark-up line is used to represent the
        narrow region. When the narrow region is created then the
        cCmarkup-commandcA macro is executed to annotate the narrowed region. The
        macro is invoked when the narrow is created and is passed a numeric
        argument cCncA which identifies the operation of the narrow. The numeric
        argument to the mark-up macro is defined below, generally a positive
        argument means that a narrow is being added and negative means that
        the narrow is being removed.

        cG1cA - This is a cCNarrow OutcA line.
        cG2cA - This is the top of a cCNarrow TocA.
        cG3cA - This is the bottom of a cCNarrow TocA.

        When the macro is executed then the current line is the start of the
        narrow region, the text of the line is available to the macro via
        lslm@wl(4)le. The cCmarkup-commandcA aborts, using lslm!abort(4)le if the mark-up line
        is to be removed, otherwise returns a mark-up line in the variable
        lslm$result(5)le.


cEcEEXAMPLE cEcA


    For example, if the buffer contains the following text:

        1 Richmond
        2 Lafayette
        3 Bloomington
        4 Indianapolis
        5 Gary
        6


    If the mark is on line 2 and the current point is on line 4, executing:-
sB
        4 narrow-buffer

sA
    Creates one narrow, narrowing out lines 2 and 3, line 4 becomes the narrow
    anchor line. When the narrow is removed lines 2 and 3 will be inserted
    before line 4. The buffer will become:-

        1 Richmond
        4 Indianapolis
        5 Gary


    If instead the following command was executed:-
sB
        3 narrow-buffer

sA
    Two narrows are created, the first narrowing out lines 4 and 5 (line 6,
    the last line, being the anchor line) the second narrowing out line 1
    (line 2 being the anchor line). The buffer will become:-

        2 Lafayette
        3 Bloomington
        6


    Executing cDnarrow-buffercA with an argument of cD2cA will only work on the anchor
    lines, namely 4 in the first example and 2 and 6 in the second.


cEMarking Up cA


    A pseudo line may be created by cDnarrow-buffercA which is hilighted and
    annotated to show that a narrow exists. This markup is used in the
    language templates in the collapse operations (cGcollapse.emfcA) to show that
    a narrow exists. The narrow region is applied using the cDnarrow-buffercA
    command as follows:-
sB
        0x34 narrow-buffer .scheme.fold-close collapse-markup

sA
    This defines a narrow region with a color scheme mark-up. The mark-up line
    is annotated by the macro cGcollapse-markupcA once the narrow is created. The
    macro is defined as follows:-
sB
        0 define-macro collapse-markup
            !if &les @# 0
                ; no markup line modificaton
                !abort
            !endif
            set-variable $result &cat &trr &lef @wl 40 " ..."
        !emacro

sA
    The cGcollapse-markupcA macro process the numeric argument lsMacroArguments(4)lm@#(4)le to determine
    the mark-up type to be applied to the buffer. When the numeric argument is
    negative then lslm!abort(4)le is called to remove the mark-up. When the numeric
    argument is positive then a mark-up line annotation is created by taking
    the first 40 characters of the line and appending "cG...cA" to indicate that
    this is a narrow. The original cDnarrow-buffercA call included a lslmhilight(2)le
    line scheme so the resultant mark-up line will be hilighted and show the
    first 40 characters of the defined followed by an ellipsis.


cEcENOTES cEcA


    Alpha mark set by lslmset-alpha-mark(2)le in text which is subsequently narrowed
    out will automatically remove the narrow if the user returns to the mark
    using lslmgoto-alpha-mark(2)le.

    lslmget-next-line(2)le operates on the unnarrowed buffer and will remove any
    narrows hiding the 'next' line.

    When copying a region containing a narrowed region(s) with lslmcopy-region(2)le
    then the content of the narrowed region(s) is also copied. A numeric
    argument to lslmcopy-region(2)le may be used to change the behavior to copy the
    visual representation only.


cEcEFURTHER EXAMPLES cEcA


    lslmc-hash-eval(3)le macro defined in cCcmacros.emfcA uses cDnarrow-buffercA to hide
    regions of source code which have been cG#definedcA out, improving
    readability.

    lslmvm(3)le defined in cCvm.emfcA uses cDnarrow-buffercA with appropriate arguments to
    lslmappend-buffer(2)le and lslmwrite-buffer(2)le to write out only parts of the
    current buffer.


cEcESEE ALSO cEcA


    lslm!abort(4)le, lslm$line-flags(5)le, lslm$result(5)le, lsMacroArguments(4)lm@#(4)le, lslm@wl(4)le, lslmappend-buffer(2)le,
    lslmc-hash-eval(3)le, lslmcollapse-all(3)le, lslmcollapse-current(3)le, lslmcopy-region(2)le,
    lslmfold-close(3)le, lslmfold-open(3)le, lslmget-next-line(2)le, lslmgoto-alpha-mark(2)le,
    lslmhilight(2)le, lslmkill-region(2)le, lslmnarrow(2m)le, lslmnarrow-search-backward(3)le,
    lslmnarrow-search-forward(3)le, lslmsave-buffer(2)le, lslmset-alpha-mark(2)le, lslmset-mark(2)le,
    lslmvm(3)le, lslmwrite-buffer(2)le.
! 2 hilight
cEcENAME cEcA


    hilight - Manage the buffer hilighting schemes
$a


cEcESYNOPSIS cEcA


    cC0cA cDhilightcA "cChil-nocA" "cCflagscA" [ "cCnolcA" ] [ "cCbuffer-schemecA" [ "cCtrunc-schemecA" ]
    ]

    cDhilightcA "cChil-nocA" "cCtypecA" "cCtokencA" [ ["cCrtokencA"]
        [ ( [ "cCclosecA" ["cCrclosecA"] "cCignorecA" ] ) |
            ( ["cCcontinuecA"] ) |
            ( ["cCb-hil-nocA"] ) ]
        "cCschemeNumcA"
    cDhilightcA "cChil-nocA" "cC0x200cA" "cCtokencA"
    cDhilightcA "cChil-nocA" "cC0x400cA" "cCfrom-colcA" "cCto-colcA" "cCschemeNumcA"

    cC-1cA cDhilightcA "cChil-nocA" "cCtypecA" "cCtokencA"


cEcEDESCRIPTION cEcA


    The cDhilightcA command creates and manages the buffer hilighting, the process
    of creating a new hilighting scheme is best described in lslanguageTemplates(2)lmFile Languageln
    lnTemplatesle. The command takes various forms as defined by the arguments.
    Each of the argument configurations is defined as follows:-


cEHilight Scheme Creation cA


    cC0cA cDhilightcA "cChil-nocA" "cCflagscA" [ "cCnolcA" ] [ "cCbuffer-schemecA" [ "cCtrunc-schemecA" ]
    ]

    With an argument of cG0cA, cDhilightcA initializes or re-initializes the hilight
    scheme cChil-nocA (1-255). Every buffer has a hilight scheme, the default is 0
    which means no hi-lighting and only the lslm$global-scheme(5)le etc. are used.
    The hilighting scheme must be defined before use and is used to specify
    how the buffer is to be hilighted. MicroEmacs 2009 supports the following
    hilighting concepts:-

        * cDhilight stringcA, a user specified string is hilighted in any color
          scheme.
        * cDTokenscA, same as a hilight string except that the string must be
          enclosed in non alpha-numeric characters.
        * cDStart-of-line hilightscA, the start of the hilight must be the first
          non-white character of the line.
        * cDEnd-of-Line hilightscA, the hilight starts from the current position
          and continues until the end of the line. Optionally, the hilight may
          continue onto the next line if the current line ends in a given
          string. A bracket may also be searched for within the line.
        * cDBracket hilightcA, hi-lights from the current position until the
          closing bracket token is found.
        * cDReplace string cA, allows the hilight string to be replaced with a
          different user specified string. (i.e. the displayed representation
          is different from the buffer contents)

    Terminals that cannot display color directly may still be able to take
    advantage of the hi-lighting. A terminal that has fonts (i.e. cCTermcapcA) can
    use them in the same way using the lslmadd-color-scheme(2)le command. The
    hi-light scheme is also used in printing (see lslmprint-buffer(2)le). If your
    terminal cannot display color in any way, it is recommended that
    hi-lighting is disabled (except when printing) as it does take CPU time.

    The "cChil-nocA" argument specifies which hi-lighting scheme is being
    initialized. Once a hilighting scheme has been initialized, hi-light
    tokens can be added to it and it can be used by setting the current
    buffer's lslm$buffer-hilight(5)le variable to "cChil-nocA". The "cCflagscA" argument is
    a bit based flag setting global hi-light characteristics, where:-

    cD0x01cA
        The hi-light scheme is case insensitive, i.e. the following tokens
        become equivalent:-

            cGhousecA == cGHOUSEcA == cGhOuSecA

        When the hilight scheme is attributed as case insensitive then the
        tokens must cDallcA be specified in cDlowercA case.

    cD0x02cA
        Set a hi-light look-back. During the process of determining the window
        hilighting then the hilight process has to determine whether the top
        of the window starts in a hi-light bracket or not. The look-back
        command tries looking "cCnolcA" lines backwards for an open bracket. If an
        open bracket is found then the top of the window is assumed to start
        with that bracket, else it is assumed that the top of the window is
        not in a bracket. For example, in `C', a comment starts with "cG/*cA" and
        ends with "cG*/cA" so if the hilight was initialized with
sB
            0 hilight 1 2 10 $global-scheme

sA
        of the following, only the first would begin hi-lighted which is
        correct (assuming the "cG/*cA" is 10 or less lines away).

             /* ........         /*.........           .........
                ........           .........*/         .........
            ----------------    ---------------     --------------- top of
                ........*/         .........           .........    window


    The optional argument "cCbuffer-schemecA" specifies the default scheme to use
    if there is no specific hi-light, when omitted the value of
    lslm$global-scheme(5)le is used. The cCbuffer-schemecA is a reference to a set of
    foreground and background color pairs previously defined with
    lslmadd-color-scheme(2)le. The last argument "cCtrunc-schemecA" is also optional and
    specifies the line truncation scheme, when omitted the value of
    lslm$trunc-scheme(5)le is used.

    The hi-lighting scheme required is based on the type of file being edited
    and so is usually directly related to the file extension, thus it can be
    automatically set using file hooks (see lslmadd-file-hook(2)le).


cEHilight Scheme Token Creation cA


    cDhilightcA "cChil-nocA" "cCtypecA" "cCtokencA" [ ["cCrtokencA"]
        [ ( [ "cCclosecA" ["cCrclosecA"] "cCignorecA" ] ) |
            ( ["cCcontinuecA" ["cCrcontinuecA"] ] ) |
            ( ["cCb-hil-nocA"] ) ]
        "cCschemeNumcA"
    cDhilightcA "cChil-nocA" "cC0x200cA" "cCtokencA"
    cDhilightcA "cChil-nocA" "cC0x400cA" "cCfrom-colcA" "cCto-colcA" "cCschemeNumcA"

    With the default argument of cG1cA, cDhilightcA creates a hilight token to be used
    in hilight color scheme identified by "cChil-nocA" (1-255) (see the section on
    cDHilight Scheme CreationcA for a overview of hi-lighting). The second
    argument "cCtypecA" specifies the token type and must always be specified, it
    determines which other arguments required.

    Typically the last argument, cCschemeNumcA, is also required. This identifies
    the color scheme to use when hilighting the token, defining the
    foreground, background and selection color schemes. This is an index
    generated from lslmadd-color-scheme(2)le. If the cCschemeNumcA argument is omitted
    the default hilght color scheme is used.

    The token "cDtypecA" is a bit based flag of which 0, 1 or more of the bits may
    be set, the effect of the bits are defined as follows:

    cD0x001cA
        The "cCtokencA" must be surrounded by non-word characters (word characters
        are typically the alpha-numeric characters), e.g. the following
        defines "cGifcA" as a token:
sB
            hilight 1 1 "if" .scheme.keyword

sA
        this hilights the 'if' in "cG if cA" but not in "cGaifacA".

    cD0x002cA
        Color this to the end of the line, often used for comments etc. For
        example in MicroEmacs macro language a 'cG;cA' character signifies the
        rest of the line as a comment, hilighting is defined as follows:
sB
            ; this is a comment line
            hilight 1 2 ";" .scheme.comment

sA
    cD0x004cA
        This is a bracket token, the closing bracket string "cCclosecA" and an
        ignore character "cCignorecA" must also be supplied. The ignore character
        indicates that when found it should ignore the next character; this
        prevents an early end on bracket miss-match. For example, in C a 'cG"cA'
        character can be inserted into a string by 'protecting' it with a 'cG\cA'
        character, such as "cCthis is a string with a \" in itcA". In this example
        the ignore character should be 'cC\cA' so the mid string 'cG"cA' is correctly
        ignored, as follows:
sB
            hilight 1 4 "\"" "\"" "\\" .scheme.string

sA
        An empty value, "", effectively disables the ignore feature. If
        replacing bit cG0x040cA is set the replacement close bracket "cCrclosecA" must
        be supplied.

    cD0x008cA
        The token has a continuation string, usually used with 0x02 but cannot
        be used with token types cG0x004cA and cG0x080cA. The argument "cCcontinuecA" must
        be supplied and if the replacing bit cG0x040cA is set the replacement
        continue string "cCrcontinuecA" must also be supplied. The best example of
        its use can again be found in C; macros defined using the cG#definecA
        pre-processor construct may be constructed on single or multiple
        lines. The macro continues onto another line if the current line ends
        with a backslash 'cG\cA' character, e.g.:

            #define a_single_line_macro() printf("hello world\n")

            #define a_four_lined_macro()          \
            do {                                  \
                printf("hello world\n") ;         \
            } while(0)


        This can be correctly hilighted with the pre-processor scheme using:
sB
            ; use to-end-of-line (2) and continuation (8), i.e. 2+8=10
            hilight 1 10 "#" "\\" .scheme.prepro

sA
    cD0x010cA

        If this is an end of line token (cG0x002cA) then
            The rest of the line is checked for any valid brackets.

        Else if this is a bracket token (cG0x004cA) then
            This is still searched for after an end of line token is found.

        Else
            Ignored

        This feature enables the searching and hilighting of specific brackets
        contained within a to-end-of-line scheme. For example, consider the
        following C code:

            #define My_Token 0x01  /* This is a multi-lined comment
                                    * describing My_Token */


        With the 'cG#cA' pre-processor hilight (see bit 0x08 above) the #define
        line would all be hilighted with the pre-process scheme, the comment
        would be missed causing incorrect hilighting of the next line. Instead
        this feature may be used by both the pre-processor and comment hilight
        tokens to correctly hilight the above example:
sB
            hilight 1 26 "#" "\\" .scheme.prepro
            hilight 1 20 "/\\*" "*/" "" .scheme.comment

sA
    cD0x020cA
        This token must be the first non-white character of the line.

    cD0x040cA
        The token (and closing bracket tokens) are to be replaced by the given
        replacement strings. This is often utilized when displaying formated
        text such as MicroEmacs on-line help lslmehf(8)le pages, the output from
        UNIX cDman(1)cA etc. In MicroEmacs help pages, the start of bold text is
        delimited with the character sequence "cG\C[cDcA" and ends with the
        character sequence "cG\C[cAcA", e.g.

            "the word \C[cDbold\C[cA is in \C[cDbold\C[cA"


        Obviously the hilight delimiters should not appear so the character
        sequence may be correctly drawn using a bracket token, starting with
        "cG\C[cDcA" and ending with "cG\C[cAcA", replacing both with an empty string:
sB
            hilight 1 0x44 "\C[cD" "" "\C[cA" "" "" .scheme.bold

sA
    cD0x080cA
        This is a branch token. When this token is found, the token (or the
        replace string) is colored using the given color cCschemeNumcA and then
        the current hilighting scheme is changed to "cCb-hil-nocA" (which MUST be
        defined by the time it is first used). The "cCb-hil-nocA" hi-light scheme
        should also contain a branch token which branches back to "cChil-nocA" or
        "cG0cA" (which branches to lslm$buffer-hilight(5)le). A branch does not have to
        branch back to "cChil-nocA", it may branch to any other hi-light scheme.
        The branches are not stacked and there is no limit on the nesting.

    cD0x100cA
        The token must be at the start of the line.

    cD0x200cA
        This is an invalid token in its own right, which is used for
        optimizing a hi-lighting scheme.

        This has the second highest precedence (see cD0x400cA) and all other bits
        are ignored. Only the first 3 arguments are required. For example, if
        there are 11 tokens starting with "cGdelete-cA" as with the hi-lighting of
        this buffer, then adding the token "cGdelete-cA", while invalid in its own
        right, means that "cGdelete-cA" is only checked for once. This also
        reduces the size of the internal hilighting tables so if the message
        "cDTable fullcA" appears, the hilighting scheme should be reduced by
        removal of the common components.

    cD0x400cA
        This is a column hilighting token, which allows absolute columns
        within a window to be hilighted (irrespective of the contents). This
        bit takes precedence over all other bits and all other bits are
        ignored. Column highlighting is a different concept to token in that
        it requires a "cCfrom-colcA" and a "cCto-colcA" column positions and a line
        will be hilighted in the given scheme between these two columns.

    cD0x800cA
        The flag is used with bracket tokens (cG0x04cA) and indicates that the
        bracket is typically contained on a single line. This information is
        used by MicroEmacs in trying to avoid hilighting anomalies caused when
        the start and end tokens of the bracket are the same (e.g. a string's
        start and end token is 'cG"cA'). Problems arise when the bracket starts on
        one line and closes on a later line, even with a large look-back,
        eventually the start bracket will become too far back and only the end
        bracket is found. But as this is the same as the open token it is
        mistaken for an open bracket and the strings become out of synch. This
        test can reset this if further down the file an open and close bracket
        is found on the same line. For this to have any effect, the hilighting
        scheme must use look-back (flag cG0x02cA of cDHilight CreationcA).

    cD0x1000cA
        Flag is typically used with a branch token (cG0x04cA) and indicates that
        the hilight exists to the end of the line or is terminated by the new
        line (i.e. encountering the end of line will removes the branch
        hilight).

    Note that cG0x004cA, cG0x008cA and cG0x080cA are mutually exclusive and more than 1
    should not be set in any one hilight token, if 2 or more are set the
    effect is undefined. Other than this there is no restrictions placed on
    the types of token used, although strange combinations like cG0x006cA may lead
    to unexpected results -- hopefully not a core dump, but not guaranteed !

    The token and close token of brackets may contain a limited subset of
    regular expression tokens as follows:-

    cD^cA
        When specified as the first character of the token, the token must be
        at the start of the line.

    cD$cA
        The token must be at the end of the line, must be the last character.

    cD\{cA
        Indicates the start of the hilighted part of the token, only one may
        be used per token. This token use is different from regex. The cD\{cA
        hilight start marker must be at a fixed point from the start of the
        token, that is a wild card sequence may NOT proceed the "cG\{cA" token,
        i.e. "cGA\{ *BcA" is correct, "cGA *\{BcA" is incorrect as it is proceeded by
        a wild card character.

    cD\}cA
        Indicates the end of the hilighted part of the token, only one may be
        used per token. The rest of the token must be matched for it to be
        used but is not considered part of the token, i.e. hilighting
        continues on the character immediately after the "cC\}cA", not at the end
        of the token. Similar to the cD\<cA token, the length of the rest of the
        token must be fixed. This token use is different from regex.

    cD\(.\)cA
        Groups are supported in hilighting, but they must only enclose a
        single character, closures ('*', '?' and '+') must come after the
        closure, i.e. use "\(.\)*", not "\(.*\)". Alternatives ("cG\|cA") are not
        supported.

        Groups are used to capture a single, this single character may be
        tested again within the string using the syntax cG\1cA..cG\9cA as with regular
        expressions. Where the inverse character is required then the syntax
        cG\!1cA..cG\!9cA may be used. This NOT syntax is special to highlighting and
        is not present in the regular expression general syntax.

    cD.cA
        Matches any character.

    cD[...]cA
        Matches a single buffer character to a range of characters, for
        example to hilight MicroEmacs register variables (i.e. cG#g0cA-cG#g9cA,
        cG#p0cA-cG#p9cA, cG#l0cA-cG#l9cA) the following regex string may be used:
sB
            hilight 1 1 "#[gpl][0-9]"

sA
        This matches a token which starts with a 'cG#cA', followed by a 'cGgcA', 'cGpcA'
        or 'cGlcA' character and ends with a numerical digit. If the user required
        the replacement (bit 0x40) of the "cG#cA" to "#register" to aid
        readability, the replacement string some now needs to know whether the
        second character was a 'cGgcA', 'cGpcA' or 'cGlcA' and which digit. Up to 9 groups
        ("cG\(.\)cA") can be use to store a store a single search character, which
        can be used later in the search string and in the replacement string
        by using the form "\cG#cA", where cG#cA is the range test number counting from
        the left, e.g. for the given example use:
sB
            hilight 1 65 "#\\([gpl]\\)\\([0-9]\\)" "#register\\1\\2"

sA
        The content of the brackets (cD[cA...cD]cA) include a set of special short
        cuts and regular expression syntax definitions as follows:-

        cG[abc]cA
            A list of characters.

        cG[a-z]cA
            A range of characters.

        cG[-.0-9]cA
            A combination of character lists and ranges.

        cG[[:space:]]cA
            A white space character. See lslmset-char-mask(2)le for a full
            description on MicroEmacs character range support.

        cG[[:digit:]]cA
            A digit, 0-9.

        cG[[:xdigit:]]cA
            A hexadecimal digit, 0-9, a-f, A-F.

        cG[[:lower:]]cA
            A lower case letter, by default a-z.

        cG[[:upper:]]cA
            An upper case letter, by default A-Z.

        cG[[:alpha:]]cA
            A lower or upper case letter.

        cG[[:alnum:]]cA
            A lower or upper case letter or a digit.

        cG[[:sword:]]cA
            A spell word character.

        cD[^...]cA
            Matches all characters except the given range of characters, e.g.
            "cG[^[:space:]]cA".

    cG\#cA
        The same character which matched the #th group token. This
        functionality is best explained using UNIX cDman(1)cA output as an
        example, to create a bold character 'cDXcA' it produces "cGX\CHXcA" where cG\CHcA
        is a backspace character thereby overstriking the first 'cGXcA' with
        another creating a bold character. This can be checked for and
        simulated in MicroEmacs using the following:
sB
            hilight 1 64 "\\(.\\)\CH\\1" "\\1" .scheme.bold

sA
        The use of "cG\1cA" in the search string ensures that the second character
        is the same as the first. This is replace by a single character drawn
        in the bold scheme.

    cG\!#cA
        The inverse character that matched the #th group token, i.e. NOT cG\1cA.

    cD?cA cD+cA cD*cA
        Matches 0 or 1, 1 or more and 0 or more of the previous character or
        character range respectively.

    cG\a \A \w \W \l \L \m \u \U \d \D \h \H \x \s \S \e \g \n \rcA
        Marches (cGacA)lphabetic lower, the special word characters (cGwcA)ord,
        (cGlcA)ower, (cGmcA)alhpanumeric, (cGucA)pper, (cGdcA)igit, (cGhcA)exdigit (cGxcAxx) literal
        hexdecimal digit, white(cGscA)pace, (cGecAescape, (cGncA)ewline, (cGgcA}bell,
        (cGrcA)formfeed. The uppercase letters are the inverse. (see lsRegularExpressions(2)lmRegularln
        lnExpressionsle).

    Following is a list of hilighting regular expression restrictions:

        The number of characters to the left of a cD\{cA and to the right of a cD\}cA
        token must be fixed, i.e. the 'cD?cA', 'cD+cA' and 'cD*cA' tokens cannot be used
        before this token. Consider the hilighting of a C function name
        defined to be a token at the start of a line followed by 0 or more
        spaces followed by a '('. The following hilight token looks valid but
        the variable space match is incorrect as it is to the right of the cD\}cA:
sB
            hilight 1 0 "^\\w+\\}\\s*(" .scheme.function

sA
        Instead either the space match must be include in the function token
        hilighting (which may cause problems, particularly if printing with
        underlining) or by fixing the number of spaces as follows:
sB
            ; include the spaces in the function hilighting
            hilight 1 0 "^\\w+\\s*\\}(" .scheme.function
            ; or fix the number of spaces to 0, 1 ...
            hilight .hilight.c    0 "^\\w+\\}(" .scheme.function
            hilight .hilight.c    0 "^\\w+\}\\s(" .scheme.function

sA
        The cD+cA and cD*cA tokens match the longest string and do not narrow, e.g.
        consider the hilighting of a C goto label which takes the form of an
        alpha-numerical name at the start of a line followed by a ':'
        character. The token "cG^.*:cA" cannot be used as cG.cA will also match and
        move past the ending ':', ending only at the end of the line. As no
        narrowing is performed the final 'cG:cA' in the token will not match and
        the label will not be hilighted. Instead a character range which
        excludes a ':' character must be used, e.g. "cD^[^:]*:cA".

        A group should not be followed by a cD?cA or cD*cA closure, it should either
        be a fixed single character or followed by a cD+cA closure (in which case
        the last matching character is stored).

    Following is a list of hilight type bit / token regex equivalents:

    cD0x01cA
        "cG[^word]\{????\}[^word]cA"

    cD0x02cA
        "cG????.*cA"

    cD0x20cA
        "cG^\s*\{????cA" - (note that this is strictly incorrect as the cG\s*cA is to
        the left of the cG\{cA, it is correctly handled for the ease of use).

    cD0x100cA
        "cG^????cA"


cEHilight Scheme Token Deletion cA


    cC-1cA cDhilightcA "cChil-nocA" "cCtypecA" "cCtokencA" With a negative argument cDhilightcA
    deletes the given "cCtokencA" from a hi-light color scheme identified by
    "cChil-nocA". The token "cCtypecA" must also be specified to distinguish between
    normal and column token types.


cEcEEXAMPLE cEcA


cEExample 1 cA


    Hilighting a MicroEmacs character given in hex form, checking its validity
    (i.e. "cG\x??cA" where cG?cA is a hex digit):
sB
        hilight 1 0 "\\x[[:xdigit:]][[:xdigit:]]" .hilight.variable

sA
    Hilighting a C style variable length hex number (i.e. "cG0x???cA"):
sB
        hilight 1 1 "0[xX][[:xdigit:]]+" .hilight.variable

sA

cEExample 2 cA


    Replacing a quoted character with just the character (i.e. cG'x'cA -> cGxcA)
sB
        hilight 1 64 "'\\(.\\)'" "\\1" %magenta

sA

cEExample 3 cA


    The following example uses the branch hilighting feature to hilight each
    window line a different color to its neighbors by cycle through 3
    different color schemes:
sB
        0 hilight .hilight.line1 0                        $global-scheme
          hilight .hilight.line1 0x80 "\\n" .hilight.line2 .scheme.no1
        0 hilight .hilight.line2 0                        .scheme.no1
          hilight .hilight.line2 0x80 "\\n" .hilight.line3 .scheme.no2
        0 hilight .hilight.line3 0                        .scheme.no2
          hilight .hilight.line3 0x80 "\\n" .hilight.line1 $global-scheme

sA

cEExample 4 cA


    Simulate the hilighting from the output of a UNIX man page (taken from
    hkman.emf):
sB
        0 hilight  .hilight.man 0                                $global-scheme
        ; ignore
        hilight .hilight.man 64 ".\CH" ""                        $global-scheme
        ; normal underline/italic
        hilight .hilight.man 64 "_\CH\\(.\\)\\}[^\CH]" "\\1"     .scheme.italic
        hilight .hilight.man 64 "\\(.\\)\CH_\\}[^\CH]" "\\1"     .scheme.italic
        ; bold - first is for nroff -man
        hilight .hilight.man 64 "\\(.\\)\CH\\1\\}[^\CH]" "\\1"   .scheme.bold
        hilight .hilight.man 64 "_\CH_\CH_\CH_\\}[^\CH]" "_"     .scheme.header
        hilight .hilight.man 64 "\\(.\\)\CH\\1\CH\\1\CH\\1\\}[^\CH]" "\\1" .scheme.header
        ; bold underline
        hilight .hilight.man 64 "_\CH_\CH_\CH_\CH_\\}[^\CH]" "_" .scheme.italic
        hilight .hilight.man 64 "_\CH\\(.\\)\CH\\1\CH\\1\CH\\1\\}[^\CH]" "\\1" .scheme.italic

sA
    This replaces the complex nroff character string with a single hi-lighted
    character (if you do not believe me then try it!).


cEcENOTES cEcA


    MicroEmacs hilight was written with speed and flexibility in mind, as a
    result the user is assumed to know what they are doing, if not the effects
    can sometimes be fatal.

    Within MicroEmacs macro language then a single backslash "cG\cA" is the escape
    character of the macro pre-processor. When writing a regular expression
    search string in the macro language then search string backslashes should
    be escaped. Hence a regular expression defined as "cG\x41\\x41cA" searches for
    the character 'cGAcA' ('cGAcA' is hexadecimal 0x41 i.e. "cG\x41cA") followed by a
    single hexadecimal character ("cG\\xcA) followed by the literal string "cG41cA".


cEcEHISTORY cEcA


    The March 2005 release modified the NOT replacement pattern with "cG\s!DcA"
    where cGDcA is the numeric group identifier cG1..9cA.

    The token cG0x1000cA was undocumented before March 2005 and is now a fully
    supported hilight mode.


cEcESEE ALSO cEcA


    lsRegularExpressions(2)lmRegular Expressionsle, lslanguageTemplates(2)lmFile Language Templatesle, lslm$buffer-hilight(5)le,
    lslmadd-file-hook(2)le, lslmadd-color-scheme(2)le, lslmprint-scheme(2)le, lslmindent(2)le,
    lslm$system(5)le, lslmprint-buffer(2)le.
! 2 hunt-forward
! 2 hunt-backward
cEcENAME cEcA


|hunt-forward
    hunt-forward - Resume previous search in forward direction
|hunt-backward
    hunt-backward - Resume previous search in backward direction
$a


cEcESYNOPSIS cEcA


    cCncA cDhunt-forwardcA (cDC-x hcA)
    cCncA cDhunt-backwardcA (cDC-x C-hcA)


cEcEDESCRIPTION cEcA


    cDhunt-forwardcA repeats the last search with the last search string in a
    forwards direction, from the current cursor position. lslmmagic(2m)le and
    lslmexact(2m)le modes are operational.

    cDhunt-backwardcA repeats the last search with the last search string in a
    backwards direction, as per cDhunt-forwardcA.

    The numeric argument cCncA is interpreted as follows:-

    cDn > 0cA
        The cCncAth occurrence of the pattern is located.

    cDn < 0cA
        The first occurrence of the pattern is located in the next cCncA lines.


cEcEDIAGNOSTICS cEcA


    The command returns a status of cGFALSEcA if no previous search string has
    been established, or if the pattern could not be located (or cCncAth pattern
    where cCncA occurrences are requested). If the pattern is found within the
    given search criteria the return status is cGTRUEcA.


cEcESEE ALSO cEcA


    lslmexact(2m)le, lslmisearch-forward(2)le, lslmmagic(2m)le, lslmnarrow-search-backward(3)le,
    lslmnarrow-search-forward(3)le, lslmsearch-backward(2)le, lslmsearch-forward(2)le,
    lsRegularExpressions(2)lmRegular Expressionsle
! 2 shell
cEcENAME cEcA


    shell - Create a new command processor or shell
$a


cEcESYNOPSIS cEcA


    cDshellcA (cDC-x ccA)


cEcEDESCRIPTION cEcA


    cDshellcA creates a new command processor or shell. Upon exiting the shell,
    MicroEmacs 2009 redraws its screen and continues editing. The exceptions
    to this are as follows:

    cDX-WindowscA
        A new cDxtermcA is spawned off and editing control is returned to
        MicroEmacs 2009 once the cDxtermcA has initialized.

    cDMicrosoft WindowscA
        A new MS-DOS shell is created and control is returned to MicroEmacs
        2009 once the DOS console window has initialized. The shell created is
        determined by the MS-DOS environment variable cGCOMSPECcA, this may be a
        replacement shell e.g. cG4DOScA.


cEcESEE ALSO cEcA


    lslmipipe-shell-command(2)le, lslmpipe-shell-command(2)le, lslmshell-command(2)le,
    lslmsuspend-emacs(2)le.
! 2 find-registry
cEcENAME cEcA


    find-registry - Index search of a registry sub-tree.


cEcESYNOPSIS cEcA


    cDfind-registrycA "cCrootcA" cCindexcA


cEcEDESCRIPTION cEcA


    cDfind-registrycA performs an indexed search of a registry sub-tree allowing
    the caller to determine the names of the children that exist as sub-nodes
    of the specified node. cCrootcA defines position in the hierarchy whose
    children are to be determined. cCindexcA is a value from cG0..ncA and identifies
    the index number of the child node. The name of the child node is returned
    in lslm$result(5)le if one exists, otherwise an error status is returned.


cEcEEXAMPLE cEcA


    The following example comes from cGaddrbook.emfcA and shows how cDfind-registrycA
    is used to iterate through entries in the address book. Note that
    cDfind-registrycA is used with lslm!force(4)le and the lslm$status(5)le of the call is
    tested to determine if the invocation succeeded.
sB
        !force find-registry "/AddressBook/Names" #l0
        !if $status
            set-variable #l1 $result
            76 insert-string "_"
            2 newline
            insert-string &spr "Section: %s" #l1
            newline
            ; Iterate through all of the entries.
            set-variable #l2 0

            !repeat
                !force #l2 ab-buffer
                !if $status
                    set-variable #l2 &add #l2 1
                !endif
            !until &not $status
            set-variable #l0 &add #l0 1
            !goto next
        !endif

sA

cEcESEE ALSO cEcA


    lslmcopy-registry(3)le, lslmdelete-registry(2)le, lslmlist-registry(2)le, lslmmark-registry(2)le,
    lslmread-registry(2)le, lslmset-registry(2)le, lslm&reg(4)le, lslmerf(8)le.
! 2 insert-file
cEcENAME cEcA


    insert-file - Insert file into current buffer
$a


cEcESYNOPSIS cEcA


    cCncA cDinsert-filecA "cCfile-namecA" [ cCbyte-offsetcA cCbyte-lengthcA ] (cDC-x C-icA)


cEcEDESCRIPTION cEcA


    cDinsert-filecA inserts the named file cCfile-namecA cCncA times into the current
    buffer at the beginning of the current line. The buffer mark is set to the
    start of the insertion and the cursor is moved to the end. If the
    cCfile-namecA is a directory then a directory listing is inserted into the
    buffer.

    If the numeric argument cCncA is negative then cDinsert-filecA reads and inserts
    cCbyte-lengthcA bytes from the byte file offset cCbyte-offsetcA.


cEcESEE ALSO cEcA


    lslmfind-bfile(3)le, lslmfind-file(2)le, lslminsert-file-name(2)le, lslmpage-bfile(3)le,
    lslmpage-file(3)le, lslmset-mark(2)le, lslmview-file(2)le.
! 2 insert-macro
cEcENAME cEcA


    insert-macro - Insert keyboard macro into buffer
$a


cEcESYNOPSIS cEcA


    cDinsert-macrocA "cCcommandcA"


cEcEDESCRIPTION cEcA


    cDinsert-macrocA inserts the named cCcommandcA into the current buffer in the
    MicroEmacs 2009 macro language, thus enables it to be saved, re-load and
    therefore re-used at a later date. This is often used in conjunction with
    lslmstart-kbd-macro(2)le, lslmend-kbd-macro(2)le and lslmname-kbd-macro(2)le. The given
    cCcommandcA must have been defined either by a keyboard macro or in MicroEmacs
    2009 macro code.


cEcENOTES cEcA


    The cDinsert-macrocA provides a good method of identifying unknown low level
    key codes. Simply record the unknown key as a macro and insert the macro
    into the scratch buffer. The low level key code appears within the string.


cEcESEE ALSO cEcA


    lslmstart-kbd-macro(2)le, lslmname-kbd-macro(2)le, lslmdefine-macro(2)le, lslmexecute-file(2)le.
! 2 insert-space
cEcENAME cEcA


    insert-space - Insert space(s) into current buffer
$a


cEcESYNOPSIS cEcA


    cCncA cDinsert-spacecA


cEcEDESCRIPTION cEcA


    cDinsert-spacecA inserts cCncA spaces at the current cursor position, moving the
    cursor position.


cEcESEE ALSO cEcA


    lslminsert-string(2)le, lslminsert-tab(2)le, lslminsert-newline(2)le, lslmspace-rectangle(3)le.
! 2 insert-string
cEcENAME cEcA


    insert-string - Insert character string into current buffer
$a


cEcESYNOPSIS cEcA


    cCncA cDinsert-stringcA "cCstringcA"


cEcEDESCRIPTION cEcA


    cDinsert-stringcA inserts a string cCncA times into the current buffer, moving the
    cursor position.

    cDinsert-stringcA allows text to be built in a buffer without reading it from
    a file. Some special escape characters are interpreted in the cCstringcA, as
    follows:

        cG\ncA - Enters a new line
        cG\tcA - A tab character
        cG\bcA - Backspace
        cG\fcA - Form-feed
        cG\\cA - Literal backslash character 'cG\cA'
        cG\xXXcA - Hexadecimal value of character ASCII value


cEcENOTES cEcA


    If a negative argument cCncA is given to cDinsert-stringcA the given string is
    inserted 0-cCncA times into the buffer. The behavior is the same as if a
    positive argument is given except that if the string contains a new-line
    character (ascii char 0x0a), rather than splitting the string over
    multiple lines the character is inserted into a single line of the buffer.

    This is highly irregular and can break MicroEmacs (for example lslmundo(2)le
    will fail and could lead to a crash); the feature has been added to
    support bit cG0x100cA of the lslmshell-command(2)le process spawning group of
    commands. It's use outside of this context is to be avoided.


cEcESEE ALSO cEcA


    lslminsert-file(2)le, lslminsert-newline(2)le, lslminsert-space(2)le, lslminsert-tab(2)le,
    lslmnewline(2)le.
! 2 ipipe-shell-command
! 2 ipipe-kill
! 2 ipipe-write
cEcENAME cEcA


|ipipe-shell-command
    ipipe-shell-command - Incremental pipe (non-suspending system call)
|ipipe-kill
    ipipe-kill - Kill a incremental pipe
|ipipe-write
    ipipe-write - Write a string to an incremental pipe
$a


cEcESYNOPSIS cEcA


    cCncA cDipipe-shell-commandcA "cCcommandcA" ["cCbuffer-namecA"] ["cCbuffer-ipipe-commandcA"]
    (cDesc \cA)
    cCncA cDipipe-writecA "cCstringcA"
    cCncA cDipipe-killcA


cEcEPLATFORM cEcA


    UNIX - cCirixcA, cChpuxcA, cCsunoscA, cCfreebsdcA, cClinuxcA.

    Windows NT - cCwin32cA.


cEcEDESCRIPTION cEcA


    cDipipe-shell-commandcA executes the given system command cCcommandcA, opening up
    a cD*icommand*cA buffer into which the results of the command execution are
    displayed. Unlike the lslmpipe-shell-command(2)le, the user may continue editing
    during command execution. The command may be terminated by deleting the
    buffer or issuing a cDipipe-killcA command.

    The argument cCncA can be used to change the default behavior of
    pipe-shell-command described above, cCncA is a bit based flag where:-

    cD0x01cA
        Enables the use of the default buffer name cD*icommand*cA (default). If
        this bit is clear the user must supply a buffer name cCbuffer-namecA. The
        buffer naming allows another command to be started without effecting
        any other existing command buffer.

    cD0x02cA
        Hides the output buffer, the default action pops up a window and
        displays the output buffer in a new window.

    cD0x04cA
        Disable the use of the command-line processor to launch the program
        (MS Win32 versions only). By default the "cCcommandcA" is launched by
        executing the command:

            %COMSPEC% /c command


        Where cG%COMSPEC%cA is typically cGcommand.comcA. If this bit is set "cCcommandcA"
        is launched directly.

    cD0x08cA
        Detach the launched process from MicroEmacs (MS Win32 versions only).
        By default the command is launched as a child process of MicroEmacs
        with a new console. With this bit set the process is completely
        detached from MicroEmacs instead.

    cD0x10cA
        Disable the command name mangling (MS Win32 versions only). By default
        any 'cG/cA' characters found in the command name (the first argument only)
        are converted to 'cG\cA' characters to make it Windows compliant.

    cD0x20cA
        Displays the new process window (win32 versions only), by default the
        window is hidden.

    cD0x40cA
        Raw ipipe, disable text annotation at the start and end of the pipe
        output and force lslmwrap(2m)le mode off.

    cD0x80cA
        Supply a function cCbuffer-ipipe-commandcA to be invoked when the pipe
        receives data and terminates. This is equivalent to setting the buffer
        variable lslm$buffer-ipipe(5)le but allows the pipe to be set when the ipipe
        is created. Setting the cC$buffer-ipipecA on invocation allows the pipe
        exit status to be trapped properly.

    cD0x100cA
        When set the command-line to be run is the first line of buffer
        cCstringcA, this feature can be used to overcome the default 1024
        character command-line limit. When a multiple-line command-line is
        required, a negative argument can be given to lslminsert-string(2)le.

    cD0x200cA
        When set prevents the lines from wrapping.

    Many other macro commands (see lslmcompile(3)le, lslmgrep(3)le, etc.) use this
    command.

    cDipipe-writecA writes a string cCstringcA to an open ipipe, cCncA times.

    cDipipe-killcA terminates an open ipipe and is automatically invoked when the
    ipipe buffer is deleted using lslmdelete-buffer(2)le or when MicroEmacs is
    exited. The numeric argument cCncA may be used to change the signal generated,
    where cCncA takes the following values:

    cD1cA
        Sends a Terminate process signal, literally a cGSIGKILLcA signal on UNIX
        or a cGWM_CLOSEcA on Windows. This is the default signal and is typically
        bound to cGC-c C-kcA.

    cD2cA
        Sends an interrupt signal, writes a cCCtrl-CcA to the cC<stdin>cA pipe on UNIX
        or sends cCCtrl-CcA key events on Windows. This is typically bound to cGC-c
        C-ccA.


cEcENOTES cEcA


    On UNIX platforms the TERM environment variable of the new process may be
    set by setting the user variable cD%ipipe-termcA to the required value, e.g.:

            set-variable %ipipe-term "TERM=vt100-nam"


    Ipipe shells support a large sub-set of vt100 terminal commands, notable
    exceptions are color, font support and auto-margins. Using the terminal
    type "cGvt100-namcA" disables the use of auto-margins, thereby providing
    better support.

    On platforms which do not support cDipipe-shell-commandcA, such as MS-DOS,
    executing cDipipe-shell-commandcA automatically invokes lspipe-shell-command(2)lmpipe-shell-commandle.
    Therefore macros may safely use ipipes without explicitly checking the
    platform type. cDipipe-shell-commandcA does not run reliably on cDWindowscA cD3.11cA
    and cDWindowscA cD95cA; cDWindowscA cDNTcA does support ipipes.

    While the pipe command is running, mode lslmpipe(2m)le is enabled. Modes
    lslmlock(2m)le and lslmwrap(2m)le effect the output behavior of an
    cDipipe-shell-commandcA.


cEcEEXAMPLE cEcA


    The following example is the lslmxgrep(3)le command macro which utilizes the
    cDipipe-shell-commandcA, diverting the output to a buffer called cD*grep*cA.
sB
        define-macro xgrep
            !force set-variable #l0 @1
            !if &not $status
                set-variable #l0 @ml00 %xgrep-com
            !endif
            !if @?
                1 pipe-shell-command &cat %xgrep-com #l0 "*grep*" @mna
            !else
                1 ipipe-shell-command &cat %xgrep-com #l0 "*grep*" @mna
            !endif
        !emacro

sA
    Note that if an argument is passed to cDgrepcA then it uses pipe-shell-command
    instead. This is useful if another command is using cDgrepcA which must finish
    before the calling command can continue, see lslmreplace-all-string(3)le for an
    example.


cEcEBUGS cEcA


    On MicroSoft Windows platforms, cDipipe-shell-commandcA spawns the shell (e.g.
    cGcommand.comcA) with the appropriate command line to make it execute the
    given command. If the command to be run detaches from the shell and
    creates its own window, for example cGme.execA, cDipipe-killcA will only kill the
    shell, it will not kill the actual process, i.e. the cGme.execA.

    On MicroSoft Windows platforms cDipipe-shell-commandcA does not work on
    Novell's Intranet Client v2.2 networked drives, version 2.5 does appear to
    work.


cEcESEE ALSO cEcA


    lslm$buffer-ipipe(5)le, lslm$buffer-input(5)le, lslmcompile(3)le, lslmgrep(3)le,
    lslmpipe-shell-command(2)le, lslmreplace-all-string(3)le, lslmshell-command(2)le, lslmpipe(2m)le,
    lslmlock(2m)le, lslmwrap(2m)le.
! 2 isearch-forward
! 2 isearch-backward
cEcENAME cEcA


|isearch-forward
    isearch-forward - Search forward incrementally (interactive)
|isearch-backward
    isearch-backward - Search backwards incrementally (interactive)
$a


cEcESYNOPSIS cEcA


    cCncA cDisearch-forwardcA [ "cCargcA" ] (cDC-scA)
    cCncA cDisearch-backwardcA [ "cCargcA" ] (cDC-rcA)


cEcEDESCRIPTION cEcA


    cDisearch-forwardcA provides an interactive search in the forward direction.
    This command is similar to lslmsearch-forward(2)le, but it processes the search
    as each character of the input string is typed in. This allows the user to
    only use as many key-strokes as are needed to uniquely specify the string
    being searched. The string argument cCargcA is not supplied when invoked
    interactively.

    The follow keys can be used at the start of an incremental search only:

        cGC-scA - Search for last string.
        cGC-mcA - Perform a search-forward instead.
        cGesc pcA,
        cGesc ncA - Scroll through history list etc (See lslmml-bind-key(2)le).

    Several control characters are active while isearching:

    cDC-scA or cDC-x cA
        Skip to the next occurrence of the current string

    cDC-rcA
        Skip to the last occurrence of the current string

    cDC-hcA
        Back up to the last match (possibly deleting the last character on the
        search string)

    cDC-wcA
        Insert the next word into the search string.

    cDC-gcA
        Abort the search, return to start.

    cDesc cAor cDC-mcA
        End the search, stay here

    cDisearch-backwardcA is the same as cDisearch-forwardcA, but it searches in the
    reverse direction.

    For both commands when the end of the buffer is reached, an alarm is
    raised (bell etc.) a further search request (cGC-scA) causes the search to
    commence from the start of the buffer.

    The numeric argument cCncA controls the behavior of cDisearch-*cA at the end of
    the buffer. When specified as cG0cA then the search exits when the start/end
    of the buffer is reached and the search is exhausted. When omitted (or
    specified as cG1cA) then the search recommences again at the start/end of the
    buffer, this is the default behavior.

    When cDisearch-*cA is invoked from a macro then the string argument cCargcA
    specifies the search string. cDisearchcA is primarily designed for for
    interactive use and is not typically used from within a macro. When
    embedded in a macro then it is typically invoked with the cG0cA argument so
    that the calling macro may handle the start/end of buffer condition. The
    macro lslmpage-file(3)le uses cDisearch-*cA and performs exactly this operation, for
    a comprehensive example refer to macro file cGpagefile.emfcA.


cEcENOTES cEcA


    The lslmml-bind-key(2)le bindings are used.

    The incremental search supports buffer modes lslmexact(2m)le and lslmmagic(2m)le.


cEcEHISTORY cEcA


    The numeric argument to cDisearch-*cA was first introduced into MicroEmacs
    '04.


cEcEBUGS cEcA


    Due to the dynamic nature of active lslmipipe-shell-command(2)le buffers the
    search history cannot be stored in the same way (list of fixed locations).
    As a result the search history is stored as a list of searches which are
    not guaranteed to be consistent.


cEcESEE ALSO cEcA


    lslmexact(2m)le, lslmhunt-forward(2)le, lslmmagic(2m)le, lslmml-bind-key(2)le,
    lslmnarrow-search-forward(3)le, lslmpage-file(3)le, lslmsearch-forward(2)le.
    lsRegularExpressions(2)lmRegular Expressionsle
! 2 kbd-macro-query
cEcENAME cEcA


    kbd-macro-query - Query termination of keyboard macro
$a


cEcESYNOPSIS cEcA


    cC[Definition]cA
    cDkbd-macro-querycA (cDC-x qcA)

    cC[Execution]cA
    cDkbd-macro-querycA "cDycA"|"cDncA"|"cDC-gcA"


cEcEDESCRIPTION cEcA


    cDkbd-macro-querycA queries the termination state of keyboard macro recording.
    If the command is executed during a keyboard macro definition, at that
    point during its execution the user is prompted as to whether to continue
    the macro execution. A reply of "cDycA" continues the execution as normal, "cDncA"
    stops execution at that point once, if executing the macro cCncA times the
    macro will still executed a further cCn-1cA times. If the "cGC-gcA" abort command
    is entered then all keyboard macro execution is aborted, regardless of the
    number of repetitions.


cEcESEE ALSO cEcA


    lslmstart-kbd-macro(2)le, lslmexecute-kbd-macro(2)le.
! 2 kill-paragraph
cEcENAME cEcA


    kill-paragraph - Delete a paragraph
$a


cEcESYNOPSIS cEcA


    cCncA cDkill-paragraphcA


cEcEDESCRIPTION cEcA


    cDkill-paragraphcA deletes the next cCncA paragraphs from the current cursor
    position, the paragraphs that are killed are added to the kill buffer. If
    the cursor is in the middle of a paragraph then the text from the current
    cursor position to the end (or start, depending on direction) of the
    paragraph is deleted.

    If cCncA is positive then the kill direction is forwards, if cCncA is negative
    then the kill direction is backwards. If cCncA is cG0cA (zero) the command simply
    returns. The default value for cCncA is cG+1cA.


cEcEDIAGNOSTICS cEcA


    The following errors can be generated, in each case the command returns a
    FALSE status:

    cD[end of buffer]cA
        The positive argument cCncA is greater than the number of remaining
        paragraphs, all of the remaining paragraphs to the end of the buffer
        are still removed.

    cD[top of buffer]cA
        The negative argument cCncA is greater than the number of previous
        paragraphs, all of the previous paragraphs to the top of the buffer
        are still removed.


cEcENOTES cEcA


    A paragraph is terminated by a blank line. All text residing between two
    blank lines is considered to be a paragraph - regardless of the text
    layout.


cEcEHISTORY cEcA


    The behavior of cDkill-paragraphcA was modified in November 2004 after which
    the numeric argument cCncA was interpreted to control the number and direction
    of paragraphs to delete. Previous releases interpreted a negative value as
    a control to disable the deleted text from entering the kill buffer. If
    the existing behavior is required then lslmkill-region(2)le with a negative
    argument should be used to delete a region of marked text,
    lslmforward-paragraph(2)le and lslmbackward-paragraph(2)le may be used to move to the
    appropriate kill position.


cEcESEE ALSO cEcA


    lslmbackward-paragraph(2)le, lslmforward-paragraph(2)le, lslmkill-region(2)le, lslmundo(2)le,
    lslmyank(2)le.
! 2 kill-region
cEcENAME cEcA


    kill-region - Delete all characters in the marked region
$a


cEcESYNOPSIS cEcA


    cCncA cDkill-regioncA (cDC-wcA)


cEcEDESCRIPTION cEcA


    cDkill-regioncA deletes all characters from the cursor to the mark set with
    the lslmset-mark(2)le command. The characters removed are copied into the kill
    buffer and may be extracted using lslmyank(2)le. If a numeric argument of cG0cA is
    given the command has no effect. If a negative argument is given the
    characters are not placed in the kill buffer, therefore the text is
    effectively lost (this does not effect the lslmundo(2)le operation).

    The mark position may be ahead or behind the current cursor position.

    Where the region contains a narrowed region, defined by lslmnarrow-buffer(2)le,
    then cDkill-regioncA deletes all text contained within the narrow, this text
    is added to the kill buffer.


cEcEUSAGE cEcA


    To move text from one place to another:

        * Move to the beginning of the text you want to move.
        * Set the mark there with the lsset-mark(2)lmset-markle (cDesc spacecA) command.
        * Move the point (cursor) to the end of the text.
        * Use the cDkill-regioncA command to delete the region you just defined.
          The text will be saved in the kill buffer.
        * Move the point to the place you want the text to appear.
        * Use the lsyank(2)lmyankle (cDC-ycA) command to copy the text from the kill buffer to
          the current point.

    Repeat the last two steps to insert further copies of the same text.


cEcENOTES cEcA


    If a region is accidentally removed then lsyank(2)lmyankle the text back immediately or
    use lslmundo(2)le.

    Windowing systems such as X-Windows and Microsoft Windows utilize a global
    windowing kill buffer allowing data to be moved between windowing
    applications (cCcut buffercA and cCclipboardcA, respectively). Within these
    environments MicroEmacs 2009 automatically interacts with the windowing
    systems kill buffer, the last MicroEmacs 2009 cDkill-regioncA entry is
    immediately available for a paste operation into another windowing
    application.


cEcESEE ALSO cEcA


    lslmbackward-kill-word(2)le, lslmcopy-region(2)le, lslmforward-kill-word(2)le, lslmkill-line(2)le,
    lslmkill-paragraph(2)le, lslmkill-rectangle(2)le, lslmnarrow-buffer(2)le, lslmreyank(2)le,
    lslmset-mark(2)le, lslmundo(2)le, lslmyank(2)le.
! 2 kill-line
cEcENAME cEcA


    kill-line - Delete all characters to the end of the line
$a


cEcESYNOPSIS cEcA


    cCncA cDkill-linecA (cDC-kcA)


cEcEDESCRIPTION cEcA


    cDkill-linecA, when used with no argument cCncA, deletes all text from the cursor
    to the end of a line, the end of line character is NOT deleted. The
    deleted text is placed in the kill buffer, see lslmyank(2)le for more
    information on the kill buffer. If the line is blank then the whole line
    is deleted, including the end of line character.

    If a positive argument cCncA is supplied the specified number of lines are
    deleted. If a negative argument is specified the previous -cCncA lines are
    deleted. If cCncA is cG0cA the command has no effect.


cEcENOTES cEcA


    If a line is accidentally removed then use lsyank(2)lmyankle to restore the text or use
    lslmundo(2)le.

    The Emacs Key binding for kill line ((cDC-kcA) ) may be re-bound to affect the
    behavior of the command.
sB
        ; MicroEmacs binding. Bind to kill the end of line character
        1 global-bind-key kill-line "C-k"

        ; GNU Emacs binding. Bind to leave the end of line character
          global-bind-key kill-line "C-k"

sA

cEcEHISTORY cEcA


    The behavior of cDkill-linecA was modified in November 2004. cDkill-linecA now
    interprets the numeric argument cCncA in both a positive and negative
    direction. The existing implementation did not operated in a negative
    direction, the negative argument controlled the kill buffer behavior of
    the line. The kill behavior is no longer an option to cDkill-linecA and the
    line(s) are always added to the kill buffer, control of the kill buffer is
    required then deletion should be performed with lslmkill-region(2)le.

    The behavior of the end of line kill used to be controlled by a cDline(2m)cA
    mode, this behavior may be replicated by modification of the binding as
    described in the previous section.


cEcESEE ALSO cEcA


    lslmforward-kill-word(2)le, lslmglobal-bind-key(2)le, lslmkill-paragraph(2)le,
    lslmkill-region(2)le, lslmundo(2)le, lslmyank(2)le.
! 2 list-buffers
cEcENAME cEcA


    list-buffers - List all buffers and show their status
$a


cEcESYNOPSIS cEcA


    cCncA cDlist-bufferscA (cDC-x C-bcA)


cEcEDESCRIPTION cEcA


    cDlist-bufferscA splits the current window and in one half brings up a list of
    all the buffers currently existing in the editor. The active modes, change
    flag, and active flag for each buffer is displayed. (The change flag is a
    cD*cA character if the buffer has been changed and not written out. The active
    flag is not an cD@cA if the file had been specified on the command line, but
    has not been read in yet since nothing has switched to that buffer.)

    The numerical argument cCncA is a bitwise flag which determines the
    information that is displayed by the command, it is interpreted follows:-

    cG  1cA - The default, when the bit is set displays visible buffers only. When
    clear displays both visible and lshide(2m)lmhiddenle buffers.
    cG  2cA - When set shows buffer size information, including file size, memory
    size and undo size in bytes.

    The buffer list has some special command keys associated with it which
    allow the state of the buffers to be edited from the buffer list, the
    editing allows buffers to be killed and saved to disk. The key codes are
    defined as follows:-

    cD1cA - Switch to buffer
        Switch to that buffer and make it the only buffer.

    cD2cA - Move to buffer
        Switch the buffer list window to that buffer.

    cDDcA - delete buffer
        Flag buffer for deletion. A buffer scheduled for deletion is marked
        with a 'cDDcA' in first column. The delete status is enacted by the 'cDXcA'
        command, or may be removed with the 'cDUcA' command.

    cDScA - save buffer
        Flag buffer for saving. A buffer scheduled from saving is marked with
        a 'cDScA' in the second column. Note that a buffer may be marked for
        saving and deletion, the save operation is performed before the
        delete.

    cDUcA - unmark buffer
        Unmark the 'cDDcA' and 'cDScA' flags on current line.

    cDXcA - execute
        Execute all the 'cDDcA' and 'cDScA' flags currently set. The cDScAave is enacted
        first.

    For all but 'cDXcA', the buffer selected is the buffer noted on the current
    cursor line. These keys are not remappable.


cEcESEE ALSO cEcA


    lslmlist-variables(2)le, lslmlist-commands(2)le, lslmsplit-window-horizontally(2)le.
! 2 buffer-bind-key
! 2 buffer-unbind-key
cEcENAME cEcA


|buffer-bind-key
    buffer-bind-key - Create local key binding for current buffer
|buffer-unbind-key
    buffer-unbind-key - Remove local key binding for current buffer
$a


cEcESYNOPSIS cEcA


    cCncA cDbuffer-bind-keycA "cCcommandcA" "cCkeycA"
    cCncA cDbuffer-unbind-keycA "cCkeycA"


cEcEDESCRIPTION cEcA


    cDbuffer-bind-keycA creates a key binding local to the current buffer, binding
    the command cCcommandcA to the keyboard input cCkeycA. This command is
    particularly useful in conjunction with file loading hooks (see
    lslmadd-file-hook(2)le) allowing local key bindings dependent upon the context
    of the buffer.

    The message line input is not effected by the current buffers local
    bindings.

    cDbuffer-unbind-keycA unbinds a user created local key binding, this command
    effects only the current buffer. If a negative argument is given to
    cDbuffer-unbind-keycA then all the current buffer's bindings are removed.


cEcENOTES cEcA


    The prefix commands cannot be rebound with this command.

    Key response time linearly increases with each local binding added.


cEcESEE ALSO cEcA


    lslmglobal-bind-key(2)le, lslmml-bind-key(2)le, lslmosd-bind-key(2)le, lslmglobal-unbind-key(2)le.
! 2 ml-bind-key
! 2 ml-unbind-key
cEcENAME cEcA


|ml-bind-key
    ml-bind-key - Create key binding for message line
|ml-unbind-key
    ml-unbind-key - Remove key binding from message line
$a


cEcESYNOPSIS cEcA


    cCncA cDml-bind-keycA "cCcommandcA" "cCkeycA"
    cCncA cDml-unbind-keycA "cCkeycA"


cEcEDESCRIPTION cEcA


    cDml-bind-keycA creates a key binding local to the message line input buffer.
    There are several commands that can be used in message line input, each
    command is associated with a main buffer editing command and inherits all
    that commands global bindings, i.e. moving forward 1 character is
    associated with the command lslmforward-char(2)le and thus inherits the binding
    cGC-fcA (as well as any other like the right cursor key). The following is a
    list of available commands, what they do and their associated commands


cECursor Movement cA


        * move backwards 1 character, command: lsforward-char(2)lmbackward-charle (cDC-bcA, cDleftcA)
        * move forwards 1 character, command: lsforward-char(2)lmforward-charle (cDC-fcA, cDrightcA)
        * move backwards 1 word, command: lsforward-word(2)lmbackward-wordle (cDesc bcA)
        * move forwards 1 word, command: lsforward-word(2)lmforward-wordle (cDesc fcA)
        * move to beginning of buffer, command: lsbeginning-of-line(2)lmbeginning-of-linele (cDC-acA, cDhomecA)
        * move to the end of buffer, command: lsbeginning-of-line(2)lmend-of-linele (cDC-ecA, cDendcA)
        * move to beginning of buffer, command: lsbeginning-of-buffer(2)lmbeginning-of-bufferle (cDesc <cA)
        * move to the end of buffer, command: lsbeginning-of-buffer(2)lmend-of-bufferle (cDesc >cA)


cEInput cA


        * Quote a character, command: lsquote-char(2)lmquote-charle (cDC-qcA)
        * Yank kill buffer into message line, command: lsyank(2)lmyankle (cDC-ycA)
        * insert current buffers current line into the buffer, command:
          lsinsert-newline(2)lminsert-newlinele (cDC-ocA)
        * insert current buffers file name into the buffer, command:
          lsinsert-file-name(2)lminsert-file-namele (cDC-x C-ycA)
        * insert current buffer name into the buffer, command: lsinsert-file-name(2)lm-1ln
          lninsert-file-namele (cDC-x ycA)
        * get the previous item in the yank buffer, command: lsreyank(2)lmreyankle (cDesc ycA)


cEDeletion cA


        * copy marked region, command: lscopy-region(2)lmcopy-regionle (cDesc wcA)
        * delete marked region, command: lskill-region(2)lmkill-regionle (cDcwcA)
        * delete backward 1 character, command: lsforward-delete-char(2)lmbackward-delete-charle (cDC-hcA,
          cDbackspacecA)
        * delete forward 1 character, command: lsforward-delete-char(2)lmforward-delete-charle (cDC-dcA,
          cDdeletecA)
        * delete forward word, command: lsforward-kill-word(2)lmforward-kill-wordle (cDesc dcA)
        * delete backward word, command: lsforward-kill-word(2)lmbackward-kill-wordle (cDesc backspacecA)
        * kill text from current position to end of line, the text is placed
          in the kill buffer. Command: lskill-line(2)lmkill-linele (cDC-kcA).
        * erase whole line, the text is placed in the kill buffer, command
          lskill-region(2)lmkill-regionle (cDC-wcA). Note that in incremental searches this is used to
          add the current word to the search string.


cEHistory cA


    MicroEmacs 2009 stores the last 20 entries of each kind (command, buffer,
    file, search and general which is also saved in the history file so the
    state of the history is retained when next loaded. The following commands
    can be used to manipulate the history.

        * next history list entry (loop through history), command:
          lsforward-paragraph(2)lmforward-paragraphle (cDesc ncA, cDC-ncA, cDdowncA)
        * previous history list entry, command: lsforward-paragraph(2)lmbackward-paragraphle (cDesc pcA,
          cDC-pcA, cDupcA)


cECompletion cA


    When entering a command, file, buffer or a mode name MicroEmacs 2009
    creates a list of possible completions the following operations can be
    performed on this list.

        * expand. This completes the given input until the first ambiguous
          character, command: a space (' ') or lstab(2)lmtable (cDC-icA).
        * expand to the previous completion (loops through the completion
          list), command: lsscroll-next-window-down(2)lmscroll-next-window-uple (cDesc C-zcA)
        * expand to the next completion (loops through the completion list),
          command: lsscroll-next-window-down(2)lmscroll-next-window-downle (cDesc C-vcA)
        * create a listing of all completions, command: a double expansion,
          i.e. 2 spaces or lstab(2)lmtabsle. The first expands and the second creates the
          list.
        * page up the completion list buffer, lsscroll-down(2)lmscroll-uple (cDC-zcA, cDpage-upcA)
        * page down the completion list buffer, lsscroll-down(2)lmscroll-downle (cDC-vcA, cDpage-downcA)


cEMiscellaneous cA


        * abort input, returning failure to the input, lsabort-command(2)lmabort-commandle (cDC-gcA)
        * re-fresh the message line, command: lsrecenter(2)lmrecenterle (cDC-lcA)
        * finish input, command lsnewline(2)lmnewlinele (cDC-mcA, cDreturncA)
        * set mark, command: lsset-mark(2)lmset-markle (cDC-spacecA)
        * exchange point and mark, command: lsexchange-point-and-mark(2)lmexchange-point-and-markle
        * transpose previous character with current character, command:
          lstranspose-chars(2)lmtranspose-charsle (cDC-tcA)
        * capitalize the next word, command: lscapitalize-word(2)lmcapitalize-wordle (cDesc ccA)
        * Turn the whole of the next word to lower case letters, command:
          lscapitalize-word(2)lmupper-case-wordle (cDesc ucA)
        * Turn the whole of the next word to upper case letters, command:
          lscapitalize-word(2)lmlower-case-wordle (cDesc lcA)
        * Cursor to mouse position, command: lsset-cursor-to-mouse(2)lmset-cursor-to-mousele (mouse select
          in window)
        * Empty function, command: lsvoid(2)lmvoidle

    cDml-unbind-keycA unbinds a user created message line key binding, this
    command effects only the message line key bindings. If a negative argument
    is given to cDml-unbind-keycA then all message line bindings are removed.


cEcEEXAMPLE cEcA


    If expansion was required on the cDesc esccA key binding then use the
    following:-
sB
        ml-bind-key tab "esc esc"

sA

cEcENOTES cEcA


    The prefix commands cannot be rebound with this command.

    Command key response time will linearly increase with each local binding.


cEcESEE ALSO cEcA


    lslmglobal-bind-key(2)le, lslmbuffer-bind-key(2)le, lslmdescribe-bindings(2)le,
    lslmosd-bind-key(2)le, lslmglobal-unbind-key(2)le.
! 2 list-variables
cEcENAME cEcA


    list-variables - List defined variables
$a


cEcESYNOPSIS cEcA


    cDlist-variablescA (cDC-h vcA)


cEcEDESCRIPTION cEcA


    cDlist-variablescA pops up a window with a list of all register, buffer, user
    and global variables with their current setting. The variables are shown
    for the current buffer from which the command was invoked

    cDlist-variablescA provides a good alternative to lslmdescribe-variable(2)le where
    the value of multiple variables is to be interrogated.

    The output is displayed in four sections:-

    cDRegister variablescA
        The current settings of the global register variables ('cD#cA' prefix).

    cDBuffer VariablescA
        The current setting of the buffer variables ('cD:cA' prefix). This
        variables relate to the current buffer from which the command was
        invoked.

    cDSystem VariablescA
        The current settings of the system variables ('cD$cA' prefix).

    cDGlobal VariablescA
        The current setting of the global variables ('cD%cA' prefix).


cEcEEXAMPLE cEcA


    An example output from cDlist-variablescA is shown below:-

        Register variables:

            #g0 ........................... "29"
            #g1 ........................... ""
            #g2 ........................... "ERROR"
            :
            :
            #g8 ........................... "ERROR"
            #g9 ........................... "ERROR"

        Buffer [m2cmd086.2] variables:


        System variables:

            $auto-time .................... "300"
            $buffer-bhook ................. "bhook-nroff"
            $buffer-bname ................. "m2cmd086.2"
            $buffer-ehook ................. "ehook-nroff"
            $buffer-fhook ................. "fhook-nroff"
            $buffer-fmod .................. "040"
            $buffer-fname ................. "d:/emacs/doc/m2cmd086.2"
            $buffer-hilight ............... "3"
            :
            :
            $window-width ................. "80"
            $window-x-scroll .............. "0"
            $window-xcl-scroll ............ "0"
            $window-y-scroll .............. "52"

        Global variables:

            %company-name ................. "JASSPA"
            %compile-com .................. "build "
            %diff-com ..................... "diff -c -w"
            :
            :
            %tag-file ..................... "tags"
            %tag-option ................... "rcemsv"
            %xgrep-com .................... "grep -n "


cEcESEE ALSO cEcA


    lslmdescribe-variable(2)le, lslmlist-commands(2)le.
! 2 scroll-down
! 2 scroll-up
cEcENAME cEcA


|scroll-down
    scroll-down - Move the window down (scrolling)
|scroll-up
    scroll-up - Move the window up (scrolling)
$a


cEcESYNOPSIS cEcA


    cCncA cDscroll-downcA (cDC-ncA)
    cCncA cDscroll-upcA (cDC-pcA)


cEcEDESCRIPTION cEcA


    cDscroll-downcA moves the window in the current buffer down by cCncA lines, the
    default when cCncA is omitted is 1 windows worth of lines i.e. a next page
    operation. A negative value of cCncA causes the window to move up.

    cDscroll-upcA moves the window in the current buffer up by cCncA lines, default
    when cCncA is omitted is 1 windows worth of lines, i.e. a previous page
    operation. A negative value of cCncA causes the window to move down.


cEcESEE ALSO cEcA


    lslmscroll-left(2)le, lslmscroll-right(2)le, lslm$window-y-scroll(5)le.
! 2 change-buffer-name
cEcENAME cEcA


    change-buffer-name - Change name of current buffer
$a


cEcESYNOPSIS cEcA


    cCncA cDchange-buffer-namecA "cCbuffer-namecA" (cDesc C-ncA)


cEcEDESCRIPTION cEcA


    cDchange-buffer-namecA changes the name of the current buffer to cCbuffer-namecA.
    Buffer names must be unique as they act as the identity handle. By default
    the buffer name is derived from the buffer's file name excluding the path.
    This can lead to conflicts, when editing files with the same name and
    different paths, in which case a counter is appended to the end of the
    buffer name to make the name unique. For example:

        File Name               Buffer Name

        /etc/file.c             file.c
        /tmp/file.c             file.c<1>


    The numeric argument cCncA is a bit-mask and is interpreted as follows:

    cG0x01cA
        By default, or an argument is specified with bit 1 set,
        cDchange-buffer-namecA fails if a buffer with the given name already
        exists. This behavior can be changed by specifying an argument with
        the first bit cleared, e.g. 0, in which case if a buffer with that
        name already exists then a counter as appended.

    cG0x02cA
        Forces the buffer to adopt the given name cCbuffer-namecA, changing the
        name of any existing buffer if required.


cEcESEE ALSO cEcA


    lslm$buffer-fname(5)le, lslmchange-file-name(2)le, lslmdelete-buffer(2)le.
! 2 name-kbd-macro
cEcENAME cEcA


    name-kbd-macro - Assign a name to the last keyboard macro
$a


cEcESYNOPSIS cEcA


    cDname-kbd-macrocA "cCcommandcA"


cEcEDESCRIPTION cEcA


    cDname-kbd-macrocA labels the last defined keyboard macro with the given
    cCcommandcA name. The command name must be either unique or the name of an
    existing macro. A keyboard macro is deleted when another keyboard macro is
    defined, but when named, it is preserved. A named keyboard macro can also
    be bound to its own command key sequence, and may be inserted into a
    buffer enabling it to be saved and thus re-loaded and re-used at a later
    date.


cEcESEE ALSO cEcA


    lslmexecute-file(2)le, lslmexecute-kbd-macro(2)le, lslmglobal-bind-key(2)le,
    lslminsert-macro(2)le, lslmstart-kbd-macro(2)le.
! 2 newline
cEcENAME cEcA


    newline - Insert a new line
$a


cEcESYNOPSIS cEcA


    cCncA cDnewlinecA (cDreturncA)


cEcEDESCRIPTION cEcA


    cDnewlinecA inserts cCncA new lines into the text, move the cursor down to the
    beginning of the next physical line, carrying any text that was after it
    with it. The next line may automatically be indented depending on the
    current buffer mode, see lslmindent(2m)le, and lslmwrap(2m)le.


cEcESEE ALSO cEcA


    lslmindent(2m)le, lslmwrap(2m)le, lslmbuffer-mode(2)le.
! 2 next-buffer
! 2 find-buffer
cEcENAME cEcA


|next-buffer
    next-buffer - Switch to the next buffer
|find-buffer
    find-buffer - Switch to the next buffer
$a


cEcESYNOPSIS cEcA


    cCncA cDnext-buffercA (cDC-x xcA)
    cCncA cDfind-buffercA "cCbuffer-namecA" (cDC-x bcA)


cEcEDESCRIPTION cEcA


    cDnext-buffercA switches to the cCncAth next buffer in the buffer list in the
    current window, the default cCncA is cG1cA, if cCncA is negative then the cG0-cAcCncAth
    previous buffer is selected. If cG0cA or a number greater than the number of
    buffers is specified then the command fails.

    cDfind-buffercA switches to buffer "cCbuffer-namecA" in the current window. If the
    buffer does not exist and a zero argument cCncA is supplied then the command
    fails. If the buffer does not exist but no argument or a positive argument
    cCncA is specified then a new buffer is created, at which point the file-hook
    is evaluated.

    If a negative argument cCncA is given to cDfind-buffercA then the buffer will be
    hidden. Any window displaying "cCbuffer-namecA" will find another buffer to
    display. This functionality is often used with the lslmhide(2m)le buffer mode.
    If a value of -1 is given then the buffer will not be hidden in a window
    whose lslm$window-flags(5)le are set to lock the buffer to the window. If a
    value of less than -1 is given then the buffer is hidden from all windows.

    The numeric argument of cDfind-buffercA is treated as a bit mask as follows:

    cG0x01cA
        Bit set then the buffer is created if it does not exist. Bit clear
        then the command fails if the buffer does not exist.

    cG0x02cA
        Locate the buffer whose buffer file name matches the argument
        cCbuffer-namecA.

    cG0x04cA
        Bit set then an inactive buffer (i.e. a buffer whose contents have not
        been loaded) shall remain inactive and the buffer contents shall not
        be restored from file. This bit setting is used to allow the buffer
        variables to be interrogated without causing the file to load. Setting
        of this bit must be used with care.

    cG0x08cA
        Bit set causes the buffer to be hidden.

    cG0x10cA
        Forces the buffer to be hidden from all windows.

    cG0x20cA
        Stop the history of the outgoing buffer from being incremented.

    If the current buffer has an cC$buffer-ehookcA command set then this command
    is executed before the new buffer is switched in. If the new buffer has a
    $cCbuffer-bhookcA command set then this command is automatically executed
    after the new buffer is switched in but before control returns to the
    user.


cEcESEE ALSO cEcA


    lslmnext-window-find-buffer(2)le, lslmhide(2m)le.
! 2 forward-line
! 2 backward-line
cEcENAME cEcA


|forward-line
    forward-line - Move the cursor to the next line
|backward-line
    backward-line - Move the cursor to the previous line
$a


cEcESYNOPSIS cEcA


    cCncA cDforward-linecA (cDC-ncA)
    cCncA cDbackward-linecA (cDC-pcA)


cEcEDESCRIPTION cEcA


    cDforward-linecA moves the cursor down cCncA lines, default 1. If the line is not
    on the current screen then display the next page and move to the line.

    cDbackward-linecA moves the cursor up cCncA lines, if the line is not on the
    current screen then display the previous page and move to the line.

    For both invocations a negative value reverses the sense of movement as
    expected.


cEcESEE ALSO cEcA


    lslmbackward-word(2)le, lslmforward-word(2)le, lslmscroll-down(2)le, lslmscroll-up(2)le.
! 2 define-help
cEcENAME cEcA


    define-help - Define help information
$a


cEcESYNOPSIS cEcA


    cDdefine-helpcA "cCstringcA" ["cCsectioncA"]

        cCFree form textcA

    cD!ehelpcA


cEcEDESCRIPTION cEcA


    cDdefine-helpcA provides a mechanism to define help information for commands
    and variables within macro files. The command allows user defined macros
    to be documented with help information that is accessible from the command
    line via the normal help commands such as lslmhelp-item(2)le.

    The help information is typically embedded in the macro file with the
    macro command that it is documenting. When the macro file is loaded then
    the help information is loaded and integrated into the existing help
    database.

    cCstringcA is the name of the item that is being defined, cCsectioncA defines what
    section the item belongs to. Following is a table of standard MicroEmacs
    2009 sections:

        cG1 cAMicroEmacs command line arguments.
        cG2 cABuilt-in commands.
        cG2mcA MicroEmacs buffer modes.
        cG3 cAMacro commands.
        cG4 cAMacro language commands.
        cG5 cAMicroEmacs variables.
        cG8 cAMicroEmacs file formats.

    When cCsectioncA is omitted is defaults to the general section which is
    usually used for the higher level help pages.

    Text following the cDdefine-helpcA line contains the help information, this is
    a free form text area that is reproduced when the help information is
    requested. The end of the text area is delimited by a cD!ehelpcA construct.
    The help text is usually displayed using a special lshilight(2)lmhilighting schemele to
    control the colors and hyper-text links to other help pages. As a result
    the text may contain escape ('cG^[cA') key sequences, see lslmehf(8)le for more
    information on the format.


cEcEEXAMPLE cEcA


    The following example is a define-help representation for the
    lslmparagraph-to-line(3)le macro.
sB
        define-help "paragraph-to-line" "3"

        ^[cENAME^[cA

             paragraph-to-line - Convert a paragraph to a single line
        $a


        ^[cESYNOPSIS^[cA

             n paragraph-to-line


        ^[cEDESCRIPTION^[cA

             paragraph-to-line  reduces  each of the  next n  paragraphs  of text to a
             single  line.  This  is  used to  prepare  a  document  to go into a word
             processor environment where end of line marks represent paragraph marks.


        ^[cENOTES^[cA

             This command is a macro defined in format.emf.


        ^[cESEE ALSO^[cA

             ^[ls^[lm^[cGfill-paragraph(2)^[cA^[le.

        !ehelp

sA

cEcESEE ALSO cEcA


    lslmehf(8)le, lslmhelp-item(2)le, lslmdefine-macro(2)le, lslmhelp-command(2)le, lslmhelp-variable(2)le.
! 2 forward-paragraph
! 2 backward-paragraph
cEcENAME cEcA


|forward-paragraph
    forward-paragraph - Move the cursor to the next paragraph
|backward-paragraph
    backward-paragraph - Move the cursor to the previous paragraph
$a


cEcESYNOPSIS cEcA


    cCncA cDforward-paragraphcA (cDesc ncA)
    cCncA cDbackward-paragraphcA (cDesc pcA)


cEcEDESCRIPTION cEcA


    cDforward-paragraphcA moves forwards cCncA paragraphs. The cursor is placed at the
    end of the cCncAth paragraph at the start of the blank paragraph separation
    line. The default value of cCncA is 1, if cCncA is negative then the direction is
    backwards.

    cDbackward-paragraphcA similarly moves backwards cCncA paragraphs. The cursor is
    placed at the start of the blank paragraph separation line. The default
    value of cCncA is 1, if cCncA is negative then the direction is forwards.


cEcEDIAGNOSTICS cEcA


    The following errors can be generated, in each case the command returns a
    FALSE status:

    cD[end of buffer]cA
        When moving forwards, the given argument cCncA was greater that the number
        of remaining paragraphs, the cursor is left at the end of the buffer.

    cD[top of buffer]cA
        When moving backwards, the given argument cCncA was greater than the
        number of paragraphs before the cursor, the cursor is left at the
        beginning of the buffer.


cEcENOTES cEcA


        * For both invocations a negative value reverses the sense of movement
          as expected.
        * A paragraph break is defined as a blank line.


cEcESEE ALSO cEcA


    lslmbackward-line(2)le, lslmforward-line(2)le, lslmkill-paragraph(2)le, lslmscroll-down(2)le,
    lslmscroll-up(2)le.
! 2 next-window
! 2 previous-window
cEcENAME cEcA


|next-window
    next-window - Move the cursor to the next window
|previous-window
    previous-window - Move the cursor to the previous window
$a


cEcESYNOPSIS cEcA


    cCncA cDnext-windowcA (cDC-x ocA)
    cCncA cDprevious-windowcA (cDC-x pcA)


cEcEDESCRIPTION cEcA


    cDnext-windowcA makes the next window down the current window, if the current
    window is the last one in the frame the first one is selected. The numeric
    argument cCncA can be used to modify this default behaviour, it is a bitwise
    flag where the bits are defined as follows:

    cD0x01cA
        If there is no 'next' window because this is the last then if this bit
        is set the search for the next window is allow to continue with the
        first window of the frame. As the default argument cCncA is cG1cA this is the
        default behaviour.

    cD0x02cA
        When this bit is set windows whose lslm$window-flags(5)le are set to be
        ignored by this command are not skipped. The setting of bit cG0x010cA of a
        windows cD$window-flagscA will make the default action of this command
        skip it which means the the command may not simply select the next
        window but the next window without this flag set. Setting this bit of
        the numeric argument will force the command to always select the next
        window.

    cD0x04cA
        When set the search for the next window starts at the first window
        instead of the current window, this can be used to find the first
        window in the current frame.

    cDprevious-windowcA makes the next window up the current window. The numeric
    argument cCncA has the same effect on this command as for cDnext-windowcA except
    bit cD0x04cA starts the search at the last window of the frame.


cEcEEXAMPLE cEcA


    The following example visits every window in the current frame printing
    the buffer it displays with a second pause between each one:
sB
        ; go to the first window
        !force 6 next-window
        !while $status
            1000 ml-write $buffer-bname
            ; go to the next window - fail if this is the last
            !force 2 next-window
        !done

sA

cEcENOTES cEcA


    Both commands fail if a suitable window cannot be for, see the example on
    how this can be used.


cEcESEE ALSO cEcA


    lslmnext-window-find-buffer(2)le, lslmnext-window-find-file(2)le, lslmset-position(2)le,
    lslmgoto-position(2)le, lslm$window-flags(5)le.
! 2 forward-word
! 2 backward-word
cEcENAME cEcA


|forward-word
    forward-word - Move the cursor to the next word
|backward-word
    backward-word - Move the cursor to the previous word
$a


cEcESYNOPSIS cEcA


    cCncA cDforward-wordcA (cDesc fcA)
    cCncA cDbackward-wordcA (cDesc bcA)


cEcEDESCRIPTION cEcA


    cDforward-wordcA places the cursor at the end of the cCncAth word from the current
    position; the default is 1.

    cDbackward-wordcA places the cursor at the beginning of the cCncAth previous word,
    default 1.


cEcENOTES cEcA


    Words are distinguished by non-alphanumeric characters and need not be
    white space such as spaces and tabs.

    A character is considered to be part of a word if it is in the
    lslm$buffer-mask(5)le character set. The default setting for cD$buffer-maskcA is
    "cGluhcA" which gives a word character set of the alphanumeric characters,
    i.e. cG0cA-cG9cA, cGAcA-cGZcA, cGacA-cGzcA, this may be changed by setting the cD$buffer-maskcA
    variable. The character sets (including 4 user character sets cG1cA-cG4cA) may be
    altered by using the command lslmset-char-mask(2)le.


cEcESEE ALSO cEcA


    lslmbackward-line(2)le, lslmbackward-paragraph(2)le, lslmforward-line(2)le,
    lslmforward-paragraph(2)le, lslocaleSupport(2)lmLocale Supportle, lslm$buffer-mask(5)le, lslmset-char-mask(2)le.
! 2 insert-newline
cEcENAME cEcA


    insert-newline - Insert new line at cursor position
$a


cEcESYNOPSIS cEcA


    cCncA cDinsert-newlinecA (cDC-ocA)


cEcEDESCRIPTION cEcA


    cDinsert-newlinecA inserts cCncA new lines at the current cursor position, but
    does not move the cursor. Any text following the cursor is moved to the
    newly created line.

    cDinsert-newlinecA is the built in key binding for (cDC-ocA) the key binding is
    typically replaced with lslmopen-line(3)le which behaves correctly by
    maintaining the cursor position.


cEcESEE ALSO cEcA


    lslmnewline(2)le, lslmopen-line(3)le.
! 2 pipe-shell-command
! 5 $ME_PIPE_STDERR
cEcENAME cEcA


    pipe-shell-command - Execute a single operating system command
    $ME_PIPE_STDERR - Command line diversion to stderr symbol
$a


cEcESYNOPSIS cEcA


|pipe-shell-command
    cCncA cDpipe-shell-commandcA "cCcommandcA" ["cCbuffer-namecA"] (cDesc @cA)
|$ME_PIPE_STDERR
    cC[MS-DOS and Win32s Only]cA
|$ME_PIPE_STDERR
    cD$ME_PIPE_STDERRcA "cCstringcA"; Default is undefined.


cEcEDESCRIPTION cEcA


    cDpipe-shell-commandcA executes one operating system command cCcommandcA and pipes
    the resulting output into a buffer with the name of cD*command*cA.

    The argument cCncA can be used to change the default behavior of
    pipe-shell-command described above, cCncA is a bit based flag where:-

    cD0x01cA
        Enables the use of the default buffer name cD*command*cA (default). If
        this bit is clear the user must supply a buffer name. This enables
        another command to be started without effecting any other command
        buffer.

    cD0x02cA
        Hides the output buffer, default action pops up a window and displays
        the output buffer in the new window.

    cD0x04cA
        Disable the use of the command-line processor to launch the program
        (win32 versions only). By default the "cDcommandcA" is launched by
        executing the command:

            %COMSPEC% /c command


        Where cG%COMSPEC%cA is typically command.com. If this bit is set, the
        "cDcommandcA" is launched directly.

    cD0x08cA
        Detach the launched process from MicroEmacs (win32 versions only). By
        default the command is launched as a child process of MicroEmacs with
        a new console. With this bit set the process is completely detached
        from MicroEmacs instead.

    cD0x10cA
        Disable the command name mangling (win32 versions only). By default
        any 'cG/cA' characters found in the command name (the first argument only)
        are converted to 'cG\cA' characters to make it Windows compliant.

    cD0x20cA
        Displays the new process window (win32 versions only), by default the
        window is hidden.

    cD0x40cA
        Raw mode, disable text annotation at the start of the pipe output.

    cD0x100cA
        When set the command-line to be run is the first line of buffer
        cCstringcA, this feature can be used to overcome the default 1024
        character command-line limit. When a multiple-line command-line is
        required, a negative argument can be given to lslminsert-string(2)le.


cEcENOTES cEcA


    On MS-DOS and cCWin32scA the standard shell cDcommand.com(1)cA does not support
    the piping of cCstderrcA to a file. Other shells, such as cD4Dos.com(1)cA, do,
    using the command-line argument "cG>&cA". If the environment variable
    "cGME_PIPE_STDERRcA" is defined (the value is not used) then MicroEmacs
    assumes that the current shell supports piping of stderr.


cEcESEE ALSO cEcA


    lslmipipe-shell-command(2)le, lslmshell-command(2)le.
! 2 screen-poke
cEcENAME cEcA


    screen-poke - Immediate write string to the screen
$a


cEcESYNOPSIS cEcA


    cCncA cDscreen-pokecA cCrowcA cCcolumncA cCcolorSchemecA "cCstringcA"


cEcEDESCRIPTION cEcA


    cDscreen-pokecA writes a cCstringcA to the screen at position (cCrowcA, cCcolumncA) using
    the given color scheme. The screen coordinates are defined with (0,0) at
    the top left of the screen.

    cDscreen-pokecA by-passes the conventional buffer update and writes directly
    to the screen buffer. The command has no effect on buffers already showing
    on the screen and is erased on the next screen update. The cCstringcA is
    clipped to the screen area hence the caller need not continually check on
    the size of the client area.

    The numeric argument cCncA is a bitwise flag which has the following meaning
    cG0x01cA Don't mark the poke area for update.
    cG0x02cA Don't flush poke to screen.
    cG0x04cA colorScheme is an array of values, one for each letter.
    cG0xf0cA colorScheme pair offset to use.

    If the cD0x01cA flag is absent then the parts of the screen over written by
    cDscreen-pokecA are marked and refreshed on the next cDscreen-updatecA operation,
    thereby erasing the poked information. If the flag is present the poked
    information remains on the screen until a forced refresh is performed
    (i.e. cD1 screen-updatecA) or the window information under the poked screen
    data is modified.

    In macros using many consecutive screen-pokes (e.g. lslmPatience(3)le to display
    a pack of cards) most pokes use the 'No flush' flag to improve performance
    and look on some platforms.

    The use of cDscreen-pokecA has largely been reduced to games such as lslmMetris(3)le
    since the introduction of lslmosd(2)le to create dialogs.


cEcENOTES cEcA


    Some platforms do not allow all character values to be poked, illegal
    characters are replaced with a 'cG.cA'.


cEcESEE ALSO cEcA


    lslmosd(2)le, lslmscreen-update(2)le, lslmMahjongg(3)le, lslmMetris(3)le.
! 2 popup-window
cEcENAME cEcA


    popup-window - Pop-up a window on the screen
$a


cEcESYNOPSIS cEcA


    cCncA cDpopup-windowcA "cCnamecA"


cEcEDESCRIPTION cEcA


    cDpopup-windowcA manages the display of a new window on the screen. If only
    one window exists then it will be split else the current window will
    changed to one of the other existing visible windows. If the given buffer
    name "cCnamecA" is not null ("") then the buffer is created, if it does not
    exist, and swapped in.

    The numeric argument cCncA alters the behavior of the command as follows:

    cG0cA
        When cCncA is zero is given then the command only succeeds if the given
        buffer is already being displayed in an existing window, this window
        is made current.

    cG1cA
        When cCncA is 1 and the given buffer is not visible then a window
        displaying a system buffer is chosen in preference. A system buffer is
        one who's name starts with a 'cG*cA' character, e.g. "cG*help*cA". window used
        to display

    cG2cA
        When cCncA is 2 the frame containing the buffer is made current, this will
        interact with the window manager and bring MicroEmacs to the top of
        the window stack and bring it into focus. The cCnamecA argument is not
        required.

    cG3cA
        When cCncA is 3 then the frame position on the Desktop Window is allowed
        to be re-positioned, this is typically called after a font change or
        screen re-size operation and ensures that the MicroEmacs window is
        positioned on the screen. The cCnamecA argument is not required.

    cG4cA
        When cCncA is 4 then both the frame position and frame size on the Desktop
        Window is adjusted, this is the same as cG3cA except the frame size may
        also be adjusted to fit on the desktop. The cCnamecA argument is not
        required.


cEcESEE ALSO cEcA


    lslmfind-buffer(2)le.
! 2 print-buffer
! 2 print-region
cEcENAME cEcA


|print-buffer
    print-buffer - Print buffer, with formatting
|print-region
    print-region - Print region, with formatting
$a


cEcESYNOPSIS cEcA


    cCncA cDprint-buffercA
    cCncA cDprint-regioncA


cEcEDESCRIPTION cEcA


    cDprint-buffercA and cDprint-regioncA print the current buffer or region,
    respectively, using high-lighting where appropriate. The hilighting
    assigned to a buffer is defined by the variable lslm$buffer-hilight(5)le the
    print scheme is defined with lslmprint-scheme(2)le, the lslmscheme-editor(3)le should
    be used to create printer schemes.

    The printing is typically configured using lslmprint-setup(3)le, which can be
    found in the main menu under cDFile->Printer SetupcA.

    The numerical argument cCncA is generally used for macro development, it
    changes the default behaviour of these commands as follows:

    cD-2cA
        Configures the printer and, on win32 platforms, opens a Windows
        printing dialog box enabling the user to configure the printer, font
        and page layout. The configuration is stored in the "cG/printcA" registry.

    cD-1cA
        Configures the printer, the configuration is stored in the "cG/printcA"
        registry.

    cD0cA
        Configures the printer and, on win32 platforms, using the Windows
        printer, opens a Windows printing dialog box enabling the user to
        configure the printer, font and page layout. The required printing is
        then performed.

    cD1cA
        Configures the printer and performs the required printing.


cEPrinting Process cA


    When either of these commands are executed the macro file cGprint.emfcA is
    executed to configure the printer (in a same vain as cGme.emfcA is executed to
    configure MicroEmacs for general usage). After the macro file has been
    executed the "cG/printcA" registry must contain the information required for
    printing. Following is a list of registry entries and their use:

    cDflagscA (cCintegercA)
        The setup flags, defined as a bit mask as follows:-

        cG0x0fcA - Destination of the printer output.
            cG0x00cA - Buffer only.
            cG0x01cA - Internal queue.
            cG0x02cA - To file only.
            cG0x03cA - To file and command line.
        cG0x10cA - Bit set, header enabled.
        cG0x20cA - Bit set, footer
        cG0x40cA - Bit set, enable line numbers.
        cG0x80cA - Bit set, Enable truncated line character (typically \).

    cDpaper-xcA (cCintegercA)
        Paper page width in character cells.

    cDpaper-ycA (cCintegercA)
        Paper page depth in character cells.

    cDpage-xcA (cCintegercA)
        The logical page width in character cells.

    cDpage-ycA (cCintegercA)
        The logical paper depth in character cells.

    cDspecifier-xcA (cCintegercA)
        Windows only.

    cDspecifier-ycA (cCintegercA)
        Windows only.

    cDfont-facecA (cCstringcA)
        The name of the font face (Windows only).

    cDrowscA (cCintegercA)
        Number rows per output page.

    cDcolscA (cCintegercA)
        Number of columns per output page.

    cDmtopcA (cCintegercA)
        The size of the top margin in character cells (i.e. where printing may
        commence).

    cDmbottomcA (cCintegercA)
        The size of the bottom margin in character cells (i.e. where printing
        stops).

    cDmleftcA (cCintegercA)
        The number of characters of space forming the left magin of the
        physical page.

    cDmrightcA (cCintegercA)
        The number of characters of space forming the right magin of the
        physical page.

    cDheadercA (cCstringcA)
        The ASCII text string for the header line.

    cDfootercA (cCstringcA)
        The ASCII text string for the footer line.

    cDportcA (cCstringcA)
        Printer port identity.

    cDbuffercA (cCstringcA)
        The name of the destination buffer.

    cDfilecA (cCstringcA)
        The name of the destination file.

    cDstripcA (cCintegercA)
        If cCintegercA value strip spaces from eol.

    cDdevicecA (cCstringcA)
        The ASCII name of the device (i.e. cG/dev/lpcA).

    cDeofcA (cCstringcA)
        The printer codes for the end of the file, may be the empty string if
        not reqired.

    cDeolcA (cCstringcA)
        The printer codes for the end of line character.

    cDeopcA (cCstringcA)
        The printer codes for the end of a page.

    cDsofcA (cCstringcA)
        The printer codes for the start of a file, may be the empty string if
        not required.

    cDsolcA (cCstringcA)
        The printer codes for the start of a line.

    cDsopcA (cCstringcA)
        The printer codes for the start of a page.

    cDscontcA (cCstringcA)
        The printer codes for a start of row continuation.

    cDecontcA (cCstringcA)
        The printer codes for the end of row continuation.

    cDhsepcA (cCstringcA)
        The horizonal logical page separator character.

    cDvsepcA (cCstringcA)
        The vertical logical page separator character.

    cDwsepcA (cCstringcA)
        The depth in character cells of the vertical logical page separator.

    cDxsepcA (cCstringcA)
        The width in character cells of the logical horizontal separator.

    cDbg-colorcA (cCintegercA)
        The background colour number.

    cDcommand-linecA (cCstringcA)
        The command line to perform a print operation.


cEPrinting Under Microsoft Windows Environments cA


    Printing under Microsoft Windows Environments automatically invokes a
    dialog box to assign and configure the printer page characteristics. The
    dialog box allows the printer to be selected, enables line numbering,
    headers and footers.

    The dialog allows the user to select the font size, by defining the number
    of characters that appear on a logical page, and the number of logical
    pages that appear on a physical page. Selecting the logical and physical
    page characteristics determine the size of the font. For dense pages with
    a small typeface then a point size of 6 is appropriate. For clarity, a
    larger typeface of 10 or 12 points is advised.


cEcENOTES cEcA


    The last printer configuration selected by the user is held in the
    registry file "cGprint.erfcA" which is loaded into the cC/print-historycA registry
    section. This feature is implemented in the macro file cGprint.emfcA.


cEcEBUGS cEcA


    Landscape printing under Microsoft Windows environments is temperamental.

    Font selection under Microsoft Windows environments does not always
    determine the most appropriate font size.

    The printer interface does not support native postscript generation. (In
    progress).


cEcESEE ALSO cEcA


    lslmprint-setup(3)le, lslmscheme-editor(3)le, lslmprint-scheme(2)le, lslmhilight(2)le,
    lslmprintall(3f)le, lslm$buffer-hilight(5)le.
! 2 query-replace-string
cEcENAME cEcA


    query-replace-string - Search and replace a string - with query
$a


cEcESYNOPSIS cEcA


    cDquery-replace-stringcA (cDesc C-rcA)


cEcEDESCRIPTION cEcA


    cDquery-replace-stringcA operates like the lslmreplace-string(2)le command.
    replacing one string with another. However, it allows you to step through
    each string and ask you if you wish to make the replacement. The user is
    prompted for a replacement response as follows:-

    cD?cA
        Help - get a list of options.

    cDycA or cDspacecA
        Make the replacement and continue on to the next string.

    cDncA
        Do not make the replacement, and continue.

    cDacA or cD!cA
        Replace the rest of the strings without asking.

    cDecA
        Edit the replacement string.

    cDlcA
        Last replacement, do next and stop.

    cDucA
        Undo last replacement.

    cD^GcA
        Stop the command.

    lslm$result(5)le is set to a list giving the number of substitutions, the final
    replace mode ('a' for all, 'l' for last or 'q' for query) and the replace
    with string.


cEcESEE ALSO cEcA


    Refer to lslmsearch-forward(2)le for a description of the magic mode search
    characters.

    lslmreplace-string(2)le, lslm$result(5)le.
    lsRegularExpressions(2)lmRegular Expressionsle
! 2 quick-exit
! 2 save-buffers-exit-emacs
cEcENAME cEcA


|quick-exit
    quick-exit - Exit the editor writing changes
|save-buffers-exit-emacs
    save-buffers-exit-emacs - Exit the editor prompt user to write changes
$a


cEcESYNOPSIS cEcA


    cCncA cDquick-exitcA (cDesc zcA) [cCexitCodecA]
    cDsave-buffers-exit-emacscA (cDC-x C-ccA) [cCexitCodecA]


cEcEDESCRIPTION cEcA


    cDquick-exitcA writes out all changed buffers to the files they were read
    from, saves all changed dictionaries, killing any running commands and
    exits the editor.

    The numeric argument is defined as follows:

    cG0cA
        A zero numeric argument then the editor is closed down and any unsaved
        buffers are lost.

    cG1cA
        Prompting the user before saving any files, writes out all changed
        buffers to the files they were read from. Saves all changed
        dictionaries, killing any running commands and exits the editor.

    cG2cA
        Discard changed buffers (except the history and registry) and delete
        any backup files associated with the edited buffer(s). Only valid with
        cDquick-exitcA.

    cDsave-buffers-exit-emacscA prompts the user before saving any files, writes
    out all changed buffers to the files they were read from. Saves all
    changed dictionaries, killing any running commands and exits the editor.


cEcEMACRO INTERACTION cEcA


    If the macro lslmshut-down(3)le is defined then it is invoked by the editor when
    it is closed. A user defined shutdown action may be associated with the
    close operation. It is the callers responsibility that the macro
    terminates correctly otherwise the editor will hang.

    For macros development then the lslmexit-emacs(2)le command provides better
    control of the exit process than cDquick-exitcA and cDsave-buffers-exit-emacscA
    and should be used instead. cDsave-buffers-exit-emacscA is actually
    implemented as cD3 exit-emacscA.


cEcENOTES cEcA


    All buffers with a name starting with a 'cD*cA' are assumed to be system
    buffer (i.e. cD*scratch*cA) and are not saved.


cEcESEE ALSO cEcA


    lslmexit-emacs(2)le, lslmsave-buffer(2)le, lslmshut-down(3)le.
! 2 quote-char
cEcENAME cEcA


    quote-char - Insert literal character
$a


cEcESYNOPSIS cEcA


    cCncA cDquote-charcA "cCkeycA" (cDC-qcA)


cEcEDESCRIPTION cEcA


    cDquote-charcA inserts the next typed character cCncA times, default is 1,
    ignoring the fact that it may be a command character. cDquote-charcA obeys the
    current buffer setting of lslmover(2m)le mode.


cEcESEE ALSO cEcA


    lslminsert-string(2)le, lslminsert-symbol(3)le.
! 2 rcs-file
cEcENAME cEcA


    rcs-file - Handle Revision Control System (RCS) files
$a


cEcESYNOPSIS cEcA


    cCncA cDrcs-filecA (cDC-x C-qcA)


cEcEDESCRIPTION cEcA


    MicroEmacs 2009 RCS support command. The action of this command depends on
    the current buffer lslmview(2m)le mode state, the argument cCncA, and the existence
    of an RCS file.

    cDview-mode ON; RCS file does not existcA
        Removes buffer view mode to enable the user to edit the file.

    cDview-mode ON; RCS file existscA
        MicroEmacs attempts to check out the file using the command line given
        by the variable lslm$rcs-cou-com(5)le (co unlock). The file is then reloaded
        and the view mode status re-evaluated.

    cDview-mode OFF; RCS file does not existcA
        MicroEmacs attempts to check-in the file into RCS for the first time
        using the command-line given by the variable lslm$rcs-cif-com(5)le (ci
        first). The file is then reload.

    cDview-mode OFF; RCS file existscA
        MicroEmacs attempts to check-in the file into RCS using the
        command-line given by the variable lslm$rcs-ci-com(5)le. The file is then
        reload.

    cDnegative argument givencA
        MicroEmacs attempts to unedit any changes made to the file using the
        command-line given by the variable lslm$rcs-ue-com(5)le. The file is then
        reload.


cEcESEE ALSO cEcA


    cDrcs(1)cA. lslm$rcs-file(5)le, lslmbuffer-mode(2)le, lslmfind-file(2)le, lslmview(2m)le.
! 2 read-file
cEcENAME cEcA


    read-file - Find and load file replacing current buffer
$a


cEcESYNOPSIS cEcA


    cCncA cDread-filecA "cCfile-namecA" (cDC-x C-rcA)


cEcEDESCRIPTION cEcA


    cDread-filecA operates like lslmfind-file(2)le, this command either finds the file
    in a buffer, or creates a new buffer and reads the file in. The command
    destroys the current buffer before the new buffer is created making this
    command ideal to use when the wrong file was entered on a lslmfind-file(2)le.
    This command is also useful for re-loading files that have changed on
    disk.

    The numeric argument cCncA can be used to modify the default behaviour of the
    command, where the bits are defined as follows:

    cD0x01cA
        If the file does not exist and this bit is not set the command fails
        at this point. If the file does not exist and this bit is set (or no
        argument is specified as the default argument is cG1cA) then a new empty
        buffer is created with the given file name, saving the buffer
        subsequently creates a new file.

    cD0x02cA
        If this bit is set the file will be loaded with lslmbinary(2m)le mode
        enabled. See help on cDbinarycA mode for more information on editing
        binary data files.

    cD0x04cA
        If this bit is set the file will be loaded with lslmcrypt(2m)le mode
        enabled. See help on cDcryptcA mode for more information on editing
        encrypted files.

    cD0x08cA
        If this bit is set the file will be loaded with lslmrbin(2m)le mode enabled.
        See help on cDrbincA mode for more information on efficient editing of
        binary data files.

    cD0x10cA
        If this bit is set then the file hook evaluation is not performed when
        the file is loaded (i.e. the lsfileHooks(2)lmbuffer's file hookle is not executed).

    cD0x20cA
        Disables loss of work checks, if this bit is set then the contents of
        the buffer is destroyed without any user prompts (useful in macros).


cEcESEE ALSO cEcA


    lslmreread-file(3)le, lslmfind-file(2)le, lslmview-file(2)le, lslmbinary(2m)le, lslmcrypt(2m)le,
    lslmrbin(2m)le.
! 2 recenter
cEcENAME cEcA


    recenter - Recenter the window (refresh the screen)
$a


cEcESYNOPSIS cEcA


    cCncA cDrecentercA (cDC-lcA)


cEcEDESCRIPTION cEcA


    cDrecentercA scrolls the current window so that the cursor position is at the
    center of the window and redraws the whole screen. If cCncA is given then
    scrolls the window so that the cursor is cCncA lines from the top if cCncA is
    positive or from the bottom if negative.

    cDrecentercA is typically used to refresh the screen if it is out of date
    (i.e. needs to be redrawn).


cEcESEE ALSO cEcA


    lslmscreen-update(2)le.
! 2 replace-string
cEcENAME cEcA


    replace-string - Replace string with new string
$a


cEcESYNOPSIS cEcA


    cCncA cDreplace-stringcA (cDesc rcA)


cEcEDESCRIPTION cEcA


    cDreplace-stringcA replaces all occurrences of one string with another string.
    The replacement starts at the current location of the cursor and goes to
    the end of the current buffer.

    A numeric argument positive cCncA limits the number of strings replaced to cCncA.
    A negative argument cCncA limits the number of lines in which the replacement
    may take place, e.g. a value of -15 restricts the replacement of the
    string to the next 15 lines from the current cursor position.

    lslm$result(5)le is set to a list giving the number of substitutions, a replace
    mode of 'a' for all and the replace with string.


cEcESEE ALSO cEcA


    See lslmOperating Modesle for a description of the lslmmagic(2m)le and lslmexact(2m)le modes
    which change the search space.

    lslmbuffer-mode(2)le, lslmquery-replace-string(2)le, lslmsearch-forward(2)le, lslm$result(5)le.
    lsRegularExpressions(2)lmRegular Expressionsle
! 2 set-position
! 2 goto-position
! 2 set-window
! 2 goto-window
cEcENAME cEcA


|set-position
    set-position - Store the current position
|goto-position
    goto-position - Restore a stored position
$a


cEcESYNOPSIS cEcA


    cCncA cDset-positioncA "cClabelcA"
    cCncA cDgoto-positioncA "cClabelcA"


cEcEDESCRIPTION cEcA


    cDset-positioncA stores current window, buffer, cursor and mark position
    information against the given 'cGlabelcA' (a single alpha-numeric character).
    cDgoto-positioncA takes the positional information stored against the given
    'cGlabelcA' and restores the window, buffer and cursor positions from those
    previously cDsetcA.

    A call to cDset-positioncA with the same label over-writes the previous stored
    information, a call to cDgoto-positioncA does not alter the information and
    may be restored multiple times.

    The numerical argument to cDset-positioncA is used to define the information
    that is stored in the position item. The argument is intrepreted as a
    bitmask, flagging what information is to be stored. The bit mask is
    defined as follows:

    cG0x001cA
        Store the current window.

    cG0x002cA
        Store the current window's horizonal scroll (value of
        lslm$window-x-scroll(5)le).

    cG0x004cA
        Store the current window's current line horizonal scroll (value of
        lslm$window-xcl-scroll(5)le).

    cG0x008cA
        Store the current window's vertical scroll (value of
        lslm$window-y-scroll(5)le).

    cG0x010cA
        Store the current buffer.

    cG0x020cA
        Store the current window's current line using an lsset-alpha-mark(2)lmalpha markle.

    cG0x040cA
        Store the current window's current line number (value of
        lslm$window-line(5)le).

    cG0x080cA
        Store the current window's current column offset (value of
        lslm$window-col(5)le).

    cG0x100cA
        Store the current window's mark line using an lsset-alpha-mark(2)lmalpha markle.

    cG0x200cA
        Store the current window's mark line number (value of lslm$window-line(5)le
        when mark was set).

    cG0x400cA
        Store the current window's mark column offset (value of lslm$window-col(5)le
        when mark was set).

    When cCncA is not specified, the default value is cG0x0bfcA, i.e. store all
    information required to return to the window, buffer and cursor position.

    The argument supplied to cDgoto-positioncA similarly interpreted as a bitmask,
    restoring the positional information. When the numerical argument cCncA is
    omitted the same default is used when omitted on the store. On restoring a
    position, information stored during the call to cDset-positioncA which is not
    requested in corresponding cDgotocA is ignored, similarly information
    requested in a cDgotocA which was not stored in the cDsetcA is also ignored.


cEcEEXAMPLE cEcA


    The following example shows the typical use of these commands:
sB
        set-position "a"
            .
            .
        goto-position "a"

sA
    The following example stores the current position at the start of a macro
    sequence, if cGmy-commandcA is not successful (cD$statuscA equals 0) the original
    position is restored:
sB
        set-position "\x80"
        !force my-command
        !if &equ $status 0
            ; command failed, return to the original position
            goto-position "\x80"
        !endif

sA
    Note 'cG\x80cA' is interpreted as the character with the ASCII value of 0x80
    which is a non-alphanumeric character, this is permitted in macros to
    avoid using alphanumerics.

    The following example shows how the current position can be restored after
    re-reading a file:
sB
        0xce set-position
        read-file $buffer-fname @mna
        ; a numeric argument of 0xce is not
        ; required as this is the default
        goto-position

sA

cEcENOTES cEcA


    The position item may store and restore the current line by using an alpha
    mark or the line number. The restrore strategy will determine what is
    required, as follows:-

    The main benefit from using an alpha mark is that the position is
    maintained even when the buffer is edited, for example if the position is
    stored at line 10 and a line is subsequently inserted at the top of the
    buffer, if the line number was used then it would return back to the 10th
    line which is the old 9th line whereas if an alpha mark were used it would
    correctly return to the 11th line, as expected.

    The disadvantage of using an alpha mark is that it is only associated with
    that buffer. In some cases a position may need to be restored in another
    buffer (e.g. when re-reading a buffer the original buffer may be deleted
    first), in this situation the buffer line number must be used.

    Commands cDset-windowcA and cDgoto-windowcA, which simple stored and returned to
    the current window, were replaced by set-position and goto-position in
    August 2000. The following macro implementations can be used as a
    replacement:
sB
        define-macro set-window
            1 set-position "\x80"
        !emacro

        define-macro goto-window
            goto-position "\x80"
        !emacro

sA

cEcESEE ALSO cEcA


    lslmset-alpha-mark(2)le, lslmfind-buffer(2)le, lslm$window-x-scroll(5)le,
    lslm$window-xcl-scroll(5)le, lslm$window-y-scroll(5)le, lslm$window-line(5)le,
    lslm$window-col(5)le.
! 2 reyank
cEcENAME cEcA


    reyank - Restore next yank buffer
$a


cEcESYNOPSIS cEcA


    cCncA cDreyankcA (cDesc ycA)


cEcEDESCRIPTION cEcA


    Every region killed goes onto a stack, with the most recent at the top.
    Immediately after yanking text out into the current buffer using lslmyank(2)le,
    the user may cDreyankcA which deletes the region just yanked and replaces it
    with cCncA insertions of the next region on the kill stack. Another call to
    reyank deletes that region and replaces it with the next in the stack etc.

    The default behavior of cDreyankcA is to wrap around the kill chain in a loop
    (i.e. returns to the start of the list when the end of the kill chain is
    reached). If a negative argument cCncA is specified then cDreyankcA fails when the
    end of the kill chain is reached rather than looping back to the start of
    the list.

    The last 15 kills are stored.


cEcESEE ALSO cEcA


    lslmcopy-region(2)le, lslmkill-region(2)le, lslmset-mark(2)le, lslmyank(2)le.
! 2 save-dictionary
cEcENAME cEcA


    save-dictionary - Save changed spelling dictionaries
$a


cEcESYNOPSIS cEcA


    cCncA cDsave-dictionarycA ["cCdictionarycA"]


cEcEDESCRIPTION cEcA


    cDsave-dictionarycA may be used to save one, or all changed, dictionaries back
    to disk. By default cDsave-dictionarycA prompts for a single dictionary, which
    is then saved. If the dictionary to be saved has been created within the
    session (rather than read from disk) the user is always prompted to save
    and enter a full dictionary file name (pathname) to save to. If the
    dictionary was not created then the user is only prompted to save if,

        * a non-zero argument is supplied
        * and the users history registry node "cC/history/spell/autosavecA" does
          not exist or its value is zero.

    Otherwise the dictionary is automatically saved.

    The argument cCncA may be used to control the effect of the command, cCncA is a
    bit based flag defined as follows:-

    cD0x01cA
        Enables prompting before saving, only used when saving all
        dictionaries.

    cD0x02cA
        Save all changed dictionaries.


cEcENOTES cEcA


    This command is called to save all dictionary changes whenever MicroEmacs
    is exited.

    The dictionary auto-save registry value can be changed via the
    lslmuser-setup(3)le dialog.


cEcESEE ALSO cEcA


    lslmadd-dictionary(2)le, lslmdelete-dictionary(2)le, lslmspell(2)le.
! 2 save-buffer
cEcENAME cEcA


    save-buffer - Save contents of changed buffer to file
$a


cEcESYNOPSIS cEcA


    cCncA cDsave-buffercA (cDC-x C-scA)


cEcEDESCRIPTION cEcA


    cDsave-buffercA saves the contents of the current buffer if the contents have
    been changed, writing the buffer back to the file it was read from.

    On saving the file, if lslmtime(2m)le mode is enabled then the ls$timestamp(5)lmtime stamp stringle
    is searched for in the file and modified if located, to reflect the
    modification date and time.

    If lslmbackup(2m)le mode is enabled then a backup copy of the file existing is
    created and the contents of the buffer are written to the file. Any
    ls$auto-time(5)lmautomatic savele copies of the file are deleted.

    If the buffer contains a lslmnarrow(2m)le it will automatically be removed
    before saving so that the whole buffer is saved and restored when saving
    is complete

    If lslmauto(2m)le mode is enabled the the file is written out in the style
    indicated by modes lslmcr(2m)le, lslmlf(2m)le and lslmctrlz(2m)le. Otherwise the file is
    written out in the style on the current platform.

    The argument cCncA can be used to change the default behavior of save-buffer
    described above, cCncA is a bit based flag where:-

    cD0x01cA
        Enables validity checks (default). These include check that the buffer
        has been modified, if not an error occurs. Also the time stamp of the
        file to be written is checked, if the file systems file exists and is
        newer the confirmation of writing is requested from the user. If this
        flag is not supplied then the buffer is written whenever possible and
        without any prompts to the user.

    cD0x02cA
        Disables the expansion of any narrows (see lslmnarrow-buffer(2)le) before
        saving the buffer. That is, the buffer is saved as it appears on the
        screen and the content of any narrow regions is discarded.


cEcENOTES cEcA


        * lslmundo(2)le information is discarded when the file is saved.
        * Refer to lslm$auto-time(5)le for a description of the file extensions used
          by MicroEmacs 2009 for backup and temporary files.
        * Buffers may also be saved via the lslmlist-buffers(2)le command.


cEcESEE ALSO cEcA


    lslm$auto-time(5)le, lslm$timestamp(5)le, lslmbuffer-mode(2)le, lslmfind-file(2)le,
    lslmnarrow-buffer(2)le, lslmsave-some-buffers(2)le, lslmundo(2)le, lslmbackup(2m)le, lslmtime(2m)le,
    lslmundo(2m)le, lslmnarrow(2m)le, lslmauto(2m)le, lslmcr(2m)le, lslmctrlz(2m)le, lslmlf(2m)le,
    lslmwrite-buffer(2)le, lslmappend-buffer(2)le.
! 2 delete-registry
cEcENAME cEcA


    delete-registry - Delete a registry tree


cEcESYNOPSIS cEcA


    cDdelete-registrycA "cCrootcA"


cEcEDESCRIPTION cEcA


    cDdelete-registrycA deletes a registry node cCrootcA from the registry, any
    children belonging to the node are also deleted.


cEcEDIAGNOSTICS cEcA


    cDdelete-registrycA fails if cCrootcA does not exist.


cEcESEE ALSO cEcA


    lslmcopy-registry(3)le, lslmdelete-registry(2)le, lslmfind-registry(2)le, lslmlist-registry(2)le,
    lslmmark-registry(2)le, lslmread-registry(2)le, lslmset-registry(2)le, lslm&reg(4)le, lslmerf(8)le.
! 2 scroll-next-window-down
! 2 scroll-next-window-up
cEcENAME cEcA


|scroll-next-window-down
    scroll-next-window-down - Scroll next window down
|scroll-next-window-up
    scroll-next-window-up - Scroll next window up
$a


cEcESYNOPSIS cEcA


    cCncA cDscroll-next-window-downcA (cDesc C-vcA)
    cCncA cDscroll-next-window-upcA (cDesc C-zcA)


cEcEDESCRIPTION cEcA


    cDscroll-next-window-downcA scrolls the next window down cCncA lines, if cCncA is
    omitted then the next window is scrolled by cCwindowcA number of lines (i.e.
    next screen page).

    cDscroll-next-window-upcA scrolls the next window up cCncA lines, as
    cDscroll-next-window-downcA.

    These commands are useful in macros to control other windows.


cEcESEE ALSO cEcA


    lslmscroll-up(2)le, lslmscroll-down(2)le.
! 2 search-forward
! 2 search-backward
cEcENAME cEcA


|search-forward
    search-forward - Search for a string in the forward direction
|search-backward
    search-backward - Search for a string in the backward direction
$a


cEcESYNOPSIS cEcA


    cCncA cDsearch-forwardcA "cCstringcA" (cDC-x scA)
    cCncA cDsearch-backwardcA "cCstringcA" (cDC-x rcA)


cEcEDESCRIPTION cEcA


    cDsearch-forwardcA searches for a string from the current cursor position to
    the end of the file. The string is typed on the bottom line of the screen,
    and terminated with the cG<ESC>cA key. Special characters can be typed in by
    preceding them with a cG^QcA. A single cG^QcA indicates a null string. On
    successive searches, hitting cG<ESC>cA alone causes the last search string to
    be reused.

    Searching is affected by lslmmagic(2m)le mode, which allows regular expression
    pattern matching, and lslmexact(2m)le mode which makes the search case
    sensitive.

    The numeric argument cCncA is interpreted as follows:-

    cDn > 0cA
        The cCncAth occurrence of the cCstringcA is located.

    cDn < 0cA
        The first occurrence of the cCstringcA is located in the next cCncA lines.

    cDsearch-forwardcA does not search through text that is hidden with
    lslmnarrow-buffer(2)le. Where a search through hidden regions is required then
    lslmnarrow-search-forward(3)le should be used instead.

    cDsearch-backwardcA searches backwards in the file. In all other ways it is
    like cDsearch-forwardcA.


cEcEDIAGNOSTICS cEcA


    The command returns a status of cGFALSEcA if the cCstringcA could not be located
    (or cCncAth cCstringcA where cCncA occurrences are requested). If the cCstringcA is found
    within the given search criteria the return status is cGTRUEcA.


cEcESEE ALSO cEcA


    lslmbuffer-mode(2)le, lslmexact(2m)le, lslmhunt-backward(2)le, lslmhunt-forward(2)le,
    lslmisearch-forward(2)le, lslmnarrow-search-forward(3)le, lslmmagic(2m)le,
    lslmreplace-string(2)le, lslmsearch-buffer(2)le.
    lsRegularExpressions(2)lmRegular Expressionsle
! 2 global-abbrev-file
! 2 buffer-abbrev-file
cEcENAME cEcA


    global-abbrev-file, buffer-abbrev-file - Set abbreviation file(s).
$a


cEcESYNOPSIS cEcA


|global-abbrev-file
    cCncA cDglobal-abbrev-filecA "cCabbrev-filecA"
|buffer-abbrev-file
    cCncA cDbuffer-abbrev-filecA "cCabbrev-filecA"


cEcEDESCRIPTION cEcA


    The abbreviation files allow the user to define a set of short-cut
    expansion text, whereby a short sequence of chararacters are associated
    with a longer text segment. When the short sequence is entered, the user
    may elect to maually expand the sequnce with the associated replacement
    text. Provision for cursor positioning may be made in the replacement
    text.

    cDbuffer-abbrev-filecA sets the current buffer's abbreviation file (limit of
    one abbreviation file per buffer). cDbuffer-abbrev-filecA does the minimal
    amount of work to increase speed at load-up. The first use of
    lslmexpand-abbrev(2)le attempts to load the abbreviation file at which point
    errors may be reported.

    An argument cCncA of zero, forces the buffer abbreviation file to be uncached,
    such that the next abbreviation that is expanded forces a re-load of the
    abbreviation file. This is typically only used when an abbreviation file
    is being constructed and tested.

    cDglobal-abbrev-filecA assigns a global set of abbreviations accross ALL
    buffers, such that the abbreviation is available regardless of the current
    buffer type. The global abbreviation file has a lower presidence than the
    cDbuffer-abbrev-filecA, hence the currently assigned cDbuffer-abbrev-filecA is
    searched before the cDglobal-abbrev-filecA.

    Similarly for cDglobal-abbrev-filecA, an argument of zero forces the global
    abbreviation file to be uncached and re-loaded on the next use.

    An abbreviation is a string which is expanded to an alternate form, e.g.

        cDe.g.cA -> cDfor examplecA
    or
        cDPIcA -> cD3.1415926536cA
    etc.

    An abbreviation file is an ordinary text file with a strict format, it is
    loaded only once at the first call to lslmexpand-abbrev(2)le, from then on it
    reminds buffered. An abbreviation file has an abbreviation per line, they
    cannot use multiple lines. This is not a draw back as the expansion string
    is executed using lslmexecute-string(2)le so any MicroEmacs 2009 command may
    also be called.

    For example the following expansion string inserts the string "cG!continuecA"
    and a newline:-

        "cG!abort\rcA"

    Note that 'cG\rcA' is used instead of 'cG\ncA' as cDC-mcA is bound to lslmnewline(2)le and
    not cDC-jcA. The expansion string can also make use of a few useful
    abbreviations:-

        cD\pcA
            Mark the current position (expanded to "cGC-x C-a PcA")

        cD\PcA
            Move cursor to the marked position (expanded to "cGC-x a PcA")

    See help on lslmexecute-string(2)le for more useful abbreviations.


cEcEEXAMPLE cEcA


    The abbreviation must be on the left hand side followed by at least 1
    space, the expansion string must then be on the same line in quotes. So
    for the given examples, the abbreviation file would be:

        |
        |e.g. "for example"
        |PI   "3.1415926536"
        |


    The following abbreviation could be used for a C cCif-elsecA statement.

        |
        |if "if(\p)\r{\r\r}\relse\r{\r\r}\r\P"
        |


    This is particularly useful for email address, e.g.

        |
        |JA "\"JASSPA\" <support@jasspa.com>"
        |


    The following example is MicroEmacs 2009 C-Mode abbreviation file for
    constructing C files. Remember cD\pcA is where the cursor is positioned
    following the expansion.

        #i "#include <\p>\r\P"
        #d "#define "
        if "if(\p)\r{\r\r}\r\P"
        ef "else if(\p)\r{\r\r}\r\P"
        el "else\r{\r\p\r}\r\P"
        wh "while(\p)\r{\r\r}\r\P"
        sw "switch(\p)\r{\rcase :\rdefault:\r}\r\P"


cEcENOTES cEcA


    Abbreviation files are given the extension cD.eafcA in the MicroEmacs 2009
    home directory.

    One of the easiest ways to create more complex abbreviations is to record
    a keyboard macro, name it and then insert the resultant macro. See notes
    on commands lslmstart-kbd-macro(2)le, lslmname-kbd-macro(2)le and lslminsert-macro(2)le.

    Try to avoid using named key, such as "cGupcA" and "cGreturncA", as the keyboard
    macro equivalent is not readable and is likely to change in future
    releases.


cEcEFILES cEcA


    cDc.eafcA - C-Mode abbreviation file. cDemf.eafcA - Macro code abbreviation file.


cEcESEE ALSO cEcA


    lslmexecute-string(2)le, lslmexpand-abbrev(2)le, lslminsert-macro(2)le, lslmiso-accents-mode(3)le,
    lslmname-kbd-macro(2)le, lslmstart-kbd-macro(2)le, lslmeaf(8)le.
! 2 set-alpha-mark
cEcENAME cEcA


    set-alpha-mark - Place an alphabetic marker in the buffer
$a


cEcESYNOPSIS cEcA


    cDset-alpha-markcA "cC?cA" (cDC-x C-acA)


cEcEDESCRIPTION cEcA


    cDset-alpha-markcA places an alpha mark at the current location in the buffer
    which can be returned to from anywhere in the buffer using the command
    lslmgoto-alpha-mark(2)le. The user is prompted for a mark name which can be any
    alphabetic character. the mark is destroyed if the line is deleted.


cEcESEE ALSO cEcA


    lslmgoto-alpha-mark(2)le.
! 2 set-cursor-to-mouse
cEcENAME cEcA


    set-cursor-to-mouse - Move the cursor to the current mouse position
$a


cEcESYNOPSIS cEcA


    cCncA cDset-cursor-to-mousecA


cEcEDESCRIPTION cEcA


    cDset-cursor-to-mousecA sets the current window and cursor position to the
    location of the mouse on it's last event (button press or release). This
    command may change the current window. If the line on which the mouse was
    located was the message line then the no action is taken, if the line was
    a window mode line the that window is made the current window but the
    cursor location within the window remains the same. This is usually used
    in user defined macros that control the functionality of the mouse.

    Invocation of this command sets the variable lslm$mouse-pos(5)le which
    determines where the mouse is within the window. Interrogation of the
    variable following the command may be used to determine if the mouse is
    located on one of the more specialized window or screen regions.

    An argument cCncA determines if the command is permitted to change windows and
    cursor position, where the bits are defined as follows:

    cD0x01cA
        Permit changing of the current window, if not permitted and the mouse
        is not in the current window cDset-cursor-to-mousecA returns an error
        condition in lslm$mouse-pos(5)le.

    cD0x02cA
        Permit changing of the cursor position.

    The default argument when omitted is cC3cA, allowing the changing of both.

    When writing macros to cut and paste using the mouse, care should be taken
    to ensure that the window at the button release is the same is at the
    button press. If this is not undertaken, undesired effects could result.
    The use of lslmset-position(2)le and lslmgoto-position(2)le are most usefully used
    with this command to restore existing window context.


cEcESEE ALSO cEcA


    lslm$mouse-pos(5)le, lslm$mouse-x(5)le, lslm$mouse-y(5)le, lslm$window-mode-line(5)le,
    lslm$window-scroll-bar(5)le, lslmset-scroll-with-mouse(2)le, lslmset-position(2)le,
    lslmgoto-position(2)le.
! 2 set-encryption-key
cEcENAME cEcA


    set-encryption-key - Define the encryption key
$a


cEcESYNOPSIS cEcA


    cDset-encryption-keycA (cDesc ecA)


cEcEDESCRIPTION cEcA


    cDset-encryption-keycA sets the encryption key for files loaded or saved with
    lslmcrypt(2m)le mode enabled. This must be performed for each file, key is not
    entered into the history. The key can be set for each file on the command
    line using the cD-kcA flag. When saving a buffer in encryption mode the key
    will be prompted for if not already set.


cEcESEE ALSO cEcA


    lslmbuffer-mode(2)le, lslmcrypt(2m)le, lslmfind-file(2)le, lslmfind-cfile(3)le.
! 2 set-mark
cEcENAME cEcA


    set-mark - Set starting point of region
$a


cEcESYNOPSIS cEcA


    cDset-markcA (cDesc spacecA)


cEcEDESCRIPTION cEcA


    cDset-markcA is used to delimit the beginning of a marked region. Many
    commands are effective for a region of text. A region is defined as the
    text between the mark and the current cursor position. To delete a section
    of text, for example, one moves the cursor to the beginning of the text to
    be deleted, issues the cDset-markcA command by typing cDesc spacecA, moves the
    cursor to the end of the text to be deleted, and then deletes it by using
    the lslmkill-region(2)le (cDC-wcA) command. Only one mark can be set in one window
    or one buffer at a time, and MicroEmacs 2009 will try to remember a mark
    set in an off screen buffer when it is called back on screen.

    A region is a block of text to be acted upon by some MicroEmacs commands.
    It is demarcated by the cDPOINTcA on one end and the cDMARKcA at the other. The
    point is the primary location identifier where most of the action takes
    place and is always between two characters. The point is indicated by the
    cursor position in that it is just left of the cursor. The point is also
    significant in that it defines one end of the region. The mark, on the
    other hand, is invisible, and is used to demarcate the other end of the
    region and is set through cDset-markcA.

    The current buffer mark line and column position may be obtained from
    within a macro using the variables lslm$window-mark-line(5)le and
    lslm$window-mark-col(5)le.


cEcESEE ALSO cEcA


    lslmcopy-region(2)le, lslmexchange-point-and-mark(2)le, lslmkill-region(2)le. lslmreyank(2)le,
    lslmyank(2)le, lslm$window-mark-col(5)le, lslm$window-mark-line(5)le.
! 2 set-variable
! 2 unset-variable
cEcENAME cEcA


|set-variable
    set-variable - Assign a new value to a variable
|unset-variable
    unset-variable - Delete a variable
$a


cEcESYNOPSIS cEcA


    cDset-variablecA "cCvariablecA" "cCvaluecA" (cDC-x vcA)
    cDunset-variablecA "cCvariablecA"


cEcEDESCRIPTION cEcA


    cDset-variablecA sets the given register (cD#cA name), system (cD$cA name), global (cD%cA
    name), buffer (cD:cA name) or command (cD.cA name) variable to the given value,
    erasing its current value. The returned value of an undefined variable is
    the string "cGERRORcA", this maybe used to determine whether a variable has
    been set.

    cDunset-variablecA unsets the given variable so that it no longer exists. The
    variable must be a global (cD%cA), buffer (cD:cA) or command (cD.cA) variable, system
    (cD$cA) variables cannot be unset.

    The cCvaluecA may be quoted or unquoted, if there are any white space
    characters, or characters open to other interpretation (e.g. cD@wccA) in cCvaluecA
    then quotes should be used.

    cCvaluecA may contain control characters which are delimited by a back slash
    (cD\cA) which include:-

        cG\ncA newline
        cG\tcA tab
        cG\\cA backslash

    Confusion sometimes arises in macros with the back slash, as the back
    slashes are dereferenced when set. Commands such as lslmreplace-string(2)le
    where the command itself utilizes back slashes. In this case the number of
    back slashes should be doubled as the variable contents under go two
    stages of dereferencing.


cEcESEE ALSO cEcA


    lslmdescribe-variable(2)le, lslmlist-variables(2)le, lslm&set(4)le.

    lsVariables(4)lmVariablesle
    lslmIntroduction to Variable Functionsle
    lsVariables(4)lmRegister Variablesle
! 2 append-buffer
cEcENAME cEcA


    append-buffer - Write contents of buffer to end of named file
$a


cEcESYNOPSIS cEcA


    cCncA cDappend-buffercA "cCfile-namecA"


cEcEDESCRIPTION cEcA


    cDappend-buffercA is used to write the contents of the current buffer into an
    EXISTING file. Use lslmsave-buffer(2)le if the buffer is to over-write the
    existing file already associated with the buffer. Use lslmwrite-buffer(2)le if
    the buffer is to be written out to a new file, or to replace an existing
    file.

    cDappend-buffercA writes the contents of the current buffer to the named file
    cCfile-namecA. But unlike lslmwrite-buffer(2)le the action of the write does not
    change the attributes associated with the file (if it exists), it also
    does not effect the stats of the current buffer.

    On writing the file, append-buffer ignores the lslmtime(2m)le and lslmbackup(2m)le
    mode settings. The current buffer will not be time stamped and a backup
    will not be created for "cCfile-namecA". If the buffer contains a lslmnarrow(2m)le
    it will automatically be removed before saving so that the whole buffer is
    saved and restored when saving is complete

    The argument cCncA is a bit based flag, where:-

    cD0x01cA
        Enables validity checks (default). These include a check that the
        given file already exist, if not confirmation of writing is requested
        from the user. Without this flag the command will always succeed
        wherever possible. If "cCfile-namecA" does not exist the buffer is written
        out in a similar fashion to using the command lslmwrite-buffer(2)le.

    cD0x02cA
        Disables the expansion of any narrows (see lslmnarrow-buffer(2)le) before
        appending the buffer.

    cD0x04cA
        Truncate the existing file before writing out the contents of the
        buffer. This means that the file will consist solely of the contents
        of the buffer, but it will still have the file attributes of the
        original file.

    If cCncA is not specified then the default argument of 1 is used.


cEcEEXAMPLE cEcA


    The following example appends the current buffer onto the end of a file,
    creating the file if it does not exists
sB
        append-buffer "things_to_do.txt"

sA
    The following example truncates the users email file while maintaining the
    file attributes. This is taken from lslmvm(3)le where it is used to remove the
    current mail from the system mail box.

        find-buffer "*vm-empty-buffer"
        -1 buffer-mode "ctrlz"
        5 append-buffer %vm-mail-src
        delete-buffer $buffer-bname


    Note that the macro ensures that lslmctrlz(2m)le mode is removed. If it was
    enabled then the file written would not be empty.


cEcESEE ALSO cEcA


    lslmwrite-buffer(2)le, lslmsave-buffer(2)le.
! 2 sort-lines
cEcENAME cEcA


    sort-lines - Alphabetically sort lines
$a


cEcESYNOPSIS cEcA


    cCncA cDsort-linescA


cEcEDESCRIPTION cEcA


    cDsort-linescA alphabetically sorts lines of text in the current buffer from
    the lsset-mark(2)lmmarkle position to the current cursor position. If the buffer mode
    lslmexact(2m)le is enabled then the sort is case sensitive, otherwise the sort
    is case insensitive. By default the text is compared from left to right
    from column 0 (the left hand edge), if a positive argument cCncA is given then
    the text is compared left to right from the cCncAth column, any lines shorter
    than cCncA characters are moved to the top and sorted from column 0.

    If a negative argument cCncA is given then the text is sorted in reverse
    order. The comparison starts at column cG-1-ncA, i.e. an argument of -1 sorts
    in reverse order from column 0.


cEcEEXAMPLE cEcA


    The following table gives the results of cDsort-linescA for different exact
    modes and values of cCncA.

        ___________________________________________________________

                 Original        Sorted Lines
        ___________________________________________________________

          exact     -      n      n      y      y      n      n
            n       -      -      1      -      1      -1     -2
        ___________________________________________________________

                    B      a2     B      Aa     B      CA     Aa
                    CA     Aa     c      B      c      c      CA
                    b1     B      b1     CA     b1     b1     a2
                    Aa     b1     a2     a2     a2     B      b1
                    c      c      CA     b1     CA     Aa     c
                    a2     CA     Aa     c      Aa     a2     B
        ___________________________________________________________


cEcENOTES cEcA


    Typically MicroEmacs is executed with lslmexact(2m)le mode enabled, the macro
    command cDsort-lines-ignore-casecA provides a command to sort lines case
    insensitively while cDexactcA mode is enabled. The macro is defined as
    follows:-
sB
        define-macro sort-lines-ignore-case
            set-variable #l0 &bmod exact
            -1 buffer-mode "exact"
            !if @?
                @# sort-lines
            !else
                sort-lines
            !endif
            &cond #l0 1 -1 buffer-mode "exact"
        !emacro

sA
    lslmsort-lines-ignore-case(3)le is a macro defined in format.emf.


cEcESEE ALSO cEcA


    lslmbuffer-mode(2)le, lslmexact(2m)le, lslmsort-lines-ignore-case(3)le, lslmtranspose-lines(2)le,
    lslmuniq(3)le.
! 2 spell
cEcENAME cEcA


    spell - Spell checker service provider
$a


cEcESYNOPSIS cEcA


    cCncA cDspellcA ["cCwordcA"] ["cCrulescA"] ["cCcorrectioncA"] ["cCrulecA"]


cEcEDESCRIPTION cEcA


    cDspellcA is a low level command which provides spell checking capabilities
    for MicroEmacs 2009, it is not designed to be used directly. The action of
    cDspellcA depends on the argument given, which is a bitwise flag defined as
    follows:-

    cD0x001cA
        If set then gets the input word from the user, i.e. "cCwordcA" must be
        supplied. Otherwise the word input is taken from the current buffer.

    cD0x002cA
        If set then keeps getting words from the current buffer until either
        the end of the buffer is reached or an error is found. If the end of
        the buffer is reached then the command succeeds setting lslm$result(5)le to
        the value "cCFcA". This bit is ignored if bit 0x001 is set. cDspellcA sets the
        current show-region to enclose the problematical word and the command
        lslmshow-region(2)le can be used to move around the word.

    cD0x004cA
        Adds the given word to a dictionary determined by the state of bit
        0x008. If the word is flagged as erroneous (see bit 0x010) then a
        "cCcorrectioncA" word must be supplied, otherwise a list of "cCrulescA" which
        can be applied to the word must be given, this list can be empty. Note
        that if the word is not flagged as erroneous and it already exists in
        the dictionary, the word is not removed, instead a combined rule list
        is created.

    cD0x008cA
        When set flags that word additions (bit 0x004) and deletions (bit
        0x200) should be made to the ignore dictionary. Otherwise word
        additions are made the last added dictionary and deletions are made to
        all main dictionaries.

    cD0x010cA
        When set flags that the given word is erroneous, used solely by word
        additions to create auto-corrections.

    cD0x020cA
        Returns a 'cC|cA' separated guess list for the given word in cD$resultcA.

    cD0x040cA
        If bit cD0x100cA is also set a complete list of valid words derivable from
        the given word are inserted into the current buffer. Otherwise spell
        returns lslm$result(5)le set to the derivative word created when the given
        "cCrulecA" is applied to "cCwordcA". The rule applied is the first found of
        the given rule letter with a matching base ending (see
        lslmadd-spell-rule(2)le). The word need not exist as not tests for the
        legality of the resultant word is used, for example in American,
        executing

        65 spell "spelling" "V"


        returns "cGspellingivecA" in cD$resultcA. Returns the empty string if no rule
        could be applied.

    cD0x080cA
        Used with bit 0x002 to enable double word checking.

    cD0x100cA
        Return information in cD$resultcA about the given word, or the word which
        is used to derive the given word. The information consists of the
        spell status, the word as stored in the dictionary, and either the
        list of valid rules, or the correction word. See also bit cD0x040cA.

    cD0x200cA
        Delete the given word from a dictionary determined by bit 0x008

    If none of the main functions are used (bits 0x004, 0x020, 0x040 & 0x200)
    then the status flag is returned in the first column of cD$resultcA. These are
    defined as follows:-

    cDAcA
        Auto-replace. The word was found and flagged as erroneous. The
        correction word is given in cD$resultcA, either next to the flag, or if
        bit 0x100 is set then after the 'cC>cA' character.

    cDDcA
        Double word. Indicates that the first problem found is a double
        occurrence of the same word one after the other.

    cDEcA
        Erroneous. The word was not found, so is Erroneous

    cDNcA
        Not a word. The current word found contains no alphabetic characters
        so is not deemed to be a word, e.g. 3.141593.

    cDOcA
        Okay. The word was found and is not an erroneous word.


cEcESEE ALSO cEcA


    lslmadd-dictionary(2)le, lslmadd-spell-rule(2)le, lslmdelete-dictionary(2)le,
    lslmsave-dictionary(2)le, lslmshow-region(2)le, lslmspell-buffer(3)le, lslmspell-word(3)le, lslocaleSupport(2)lmLocaleln
    lnSupportle.
! 2 next-window-find-buffer
cEcENAME cEcA


    next-window-find-buffer - Split the current window and show new buffer
$a


cEcESYNOPSIS cEcA


    cDnext-window-find-buffercA "cCbuffercA" (cDC-x 3cA)


cEcEDESCRIPTION cEcA


    cDnext-window-find-buffercA splits the current window into two near equal
    windows, and swaps the current windows buffer to the given cCbuffercA. It is
    effectively a lslmsplit-window-vertically(2)le command followed by a
    lslmfind-buffer(2)le. When there is insufficient space in the current window to
    perform the split, then the current window is replaced. The requested
    cCbuffercA is always displayed, if the buffer does not already exist it is
    created.


cEcESEE ALSO cEcA


    lslmfind-buffer(2)le, lslmsplit-window-vertically(2)le, lslmnext-window-find-file(2)le.
! 2 next-window-find-file
cEcENAME cEcA


    next-window-find-file - Split the current window and find file
$a


cEcESYNOPSIS cEcA


    cDnext-window-find-filecA "cCfilecA" (cDC-x 4cA)


cEcEDESCRIPTION cEcA


    cDnext-window-find-filecA splits the current window into two near equal
    windows, and loads the given cCfilecA into the current window. It is
    effectively a lslmsplit-window-vertically(2)le command followed by a
    lslmfind-file(2)le.

    When there is insufficient space in the current window to perform the
    split, then the current window is replaced. The requested cCfilecA is always
    displayed, if the file does not already exist it is effectively created
    within MicroEmacs (although it will not exist on the disk until a save
    operation is performed).

    The numeric argument cCncA can be used to modify the default behaviour of the
    command, where the bits are defined as follows:

    cD0x01cA
        If the file does not exist and this bit is not set the command fails
        at this point. If the file does not exist and this bit is set (or no
        argument is specified as the default argument is cG1cA) then a new empty
        buffer is created with the given file name, saving the buffer
        subsequently creates a new file.

    cD0x02cA
        If this bit is set the file will be loaded with lslmbinary(2m)le mode
        enabled. See help on cDbinarycA mode for more information on editing
        binary data files.

    cD0x04cA
        If this bit is set the file will be loaded with lslmcrypt(2m)le mode
        enabled. See help on cDcryptcA mode for more information on editing
        encrypted files.

    cD0x08cA
        If this bit is set the file will be loaded with lslmrbin(2m)le mode enabled.
        See help on cDrbincA mode for more information on efficient editing of
        binary data files.


cEcESEE ALSO cEcA


    lslmfind-file(2)le, lslmnext-window-find-buffer(2)le, lslmsplit-window-vertically(2)le,
    lslmbinary(2m)le, lslmcrypt(2m)le, lslmrbin(2m)le.
! 2 split-window-vertically
cEcENAME cEcA


    split-window-vertically - Split the current window into two
$a


cEcESYNOPSIS cEcA


    cCncA cDsplit-window-verticallycA (cDC-x 2cA)


cEcEDESCRIPTION cEcA


    cDsplit-window-verticallycA splits the current window vertically into two near
    equal windows, each displaying the buffer displayed by the original
    window. A numeric argument cCncA of 1 forces the upper window to be the new
    current window (default), and an argument of 2 forces the lower window to
    be the new current window.


cEcESEE ALSO cEcA


    lslmgrow-window-vertically(2)le, lslmnext-window-find-buffer(2)le,
    lslmnext-window-find-file(2)le, lslmresize-window-vertically(2)le,
    lslmsplit-window-horizontally(2)le.
! 2 print-color
! 2 print-scheme
cEcENAME cEcA


|print-color
    print-color - Create a new printer color
|print-scheme
    print-scheme - Create a new printer color and font scheme
$a


cEcESYNOPSIS cEcA


    cCncA cDprint-colorcA "cCcol-nocA" "cCredcA" "cCgreencA" "cCbluecA"
    cCncA cDprint-schemecA "cCschemeNumcA" "cCforecA" "cCbackcA" "cCfont-maskcA"


cEcEDESCRIPTION cEcA


    cDprint-colorcA and cDprint-schemecA are similar to lslmadd-color(2)le and
    lslmadd-color-scheme(2)le except they configure MicroEmacs's printer scheme.

    cDprint-colorcA creates a new printer color and inserts it into the printer
    color table, where cCredcA, cCgreencA and cCbluecA are the color components and cCcol-nocA
    is the printer color index. The printer color table contains 256 entries
    indexed by cCcol-nocA in the range 0-255. cDprint-colorcA may also be used to
    modify an existing cCcol-nocA index by re-assignment, the existing color
    definition is over-written with the new color definition.

    An argument cCncA of 0 to cDprint-colorcA resets the printer color table, removing
    all currently defined colors.

    cDprint-schemecA creates a new printer scheme. A printer scheme maps the
    lslmhilight(2)le buffer's text into a print scheme. For example key words could
    be printed in cCboldcA or in cCbluecA etc. cDprint-schemecA arguments comprise an
    identifying index number "cCschemeNumcA", two color values, "cCforecA" and "cCbackcA"
    (defined by cDprint-colorcA) and a font setting "cCfont-maskcA". The cCfont-maskcA is
    a bit mask where each bit is defined as follows:

        cG0x01cA Enable bold font.
        cG0x02cA Enable italic font.
        cG0x04cA Enable light font.
        cG0x08cA Enable reverse font.
        cG0x10cA Enable underlining.

    An argument cCncA of 0 to cDprint-schemecA resets the printer scheme table,
    removing all currently defined printer schemes.


cEcENOTES cEcA


    Printer schemes may be created and altered using the lslmscheme-editor(3)le
    dialog, the created printer scheme may then be used directly in the
    lslmprint-setup(3)le dialog. Therefore direct use of these commands is largely
    redundant.


cEcESEE ALSO cEcA


    lslmscheme-editor(3)le, lslmprint-setup(3)le, lslmprint-buffer(2)le, lslmhilight(2)le,
    lslm$buffer-hilight(5)le.
! 2 suspend-emacs
cEcENAME cEcA


    suspend-emacs - Suspend editor and place in background
$a


cEcESYNOPSIS cEcA


    cCncA cDsuspend-emacscA


cEcEPLATFORM cEcA


    Supported on UNIX platforms - cCirixcA, cChpuxcA, cCsunoscA, cCfreebsdcA or cClinuxcA.


cEcEDESCRIPTION cEcA


    cDsuspend-emacscA suspends the editing processor and puts it into the
    background. The "cCfgcA" command restarts MicroEmacs. The prompt to suspend is
    disabled if a cG0cA numeric argument cCncA is given to the command.


cEcESEE ALSO cEcA


    lslmshell(2)le.
! 2 shell-command
cEcENAME cEcA


    shell-command - Perform an operating system command
$a


cEcESYNOPSIS cEcA


    cCncA cDshell-commandcA "cCstringcA"


cEcEDESCRIPTION cEcA


    cDshell-commandcA performs an operating system call with the given cCstringcA as
    its argument. The command only fails if the shell-command call returns -1.
    The lslm$result(5)le variable is set the return value and can be used to test
    the result.

    The argument cCncA can be used to change the default behavior of the
    shell-command, cCncA is a bit based flag where:-

    cD0x01cA
        When set shell-command waits for the command to complete, this is the
        default behavior. When not set the command is launched and forgotten
        about, the value returned in lslm$result(5)le will not reflect the exit code
        of the executed process itself.

    cD0x04cA
        Disable the use of the command-line processor to launch the program
        (win32 versions only). By default the "cDcommandcA" is launched by
        executing the command:

            %COMSPEC% /c command


        Where cG%COMSPEC%cA is typically command.com. If this bit is set, the
        "cDcommandcA" is launched directly.

    cD0x08cA
        Detach the launched process from MicroEmacs (win32 versions only). By
        default the command is launched as a child process of MicroEmacs with
        a new console. With this bit set the process is completely detached
        from MicroEmacs instead.

    cD0x10cA
        Disable the command name mangling (win32 versions only). By default
        any 'cG/cA' characters found in the command name (the first argument only)
        are converted to 'cG\cA' characters to make it Windows compliant.

    cD0x20cA
        Displays the new process window (win32 versions only), by default the
        window is hidden.

    cD0x100cA
        When set the command-line to be run is the first line of buffer
        cCstringcA, this feature can be used to overcome the default 1024
        character command-line limit. When a multiple-line command-line is
        required, a negative argument can be given to lslminsert-string(2)le.

    cD0x200cA
        No wait option, when set the the command is run without waiting for
        any completion status. This allows processes to be run and then
        forgotten about e.g. a Word processor, Adobe Acrobat reader etc.


cEcESEE ALSO cEcA


    lslm$result(5)le, lslmipipe-shell-command(2)le, lslmpipe-shell-command(2)le, lslmshell(2)le,
    lslmsuspend-emacs(2)le.
! 2 show-region
cEcENAME cEcA


    show-region - Show the current copy region
$a


cEcESYNOPSIS cEcA


    cCncA cDshow-regioncA


cEcEDESCRIPTION cEcA


    cDshow-regioncA manipulates the currently defined region, it can be used to
    inquire the state of the current region, if any. It can also be used to
    define a region, enable and disable the region hilighting, as well as move
    the cursor to the start or end of the region.

    Region hilighting occurs between the cCmarkcA (see lslmset-mark(2)le) and cCpointcA
    (current cursor) positions within the current buffer. A region is defined
    when text is copied to the kill buffer, by using any of the kill commands
    such as lslmkill-region(2)le, or lslmcopy-region(2)le. However, the kill region is
    only visible after a lslmcopy-region(2)le or a lslmyank(2)le operation. A hilight
    region is also created on a successful search using commands like
    lslmsearch-forward(2)le, the region encloses the search matching string.
    lsspell(2)lmSpell(2)le also creates a hilight region around the current spell word. The
    user can also define their own region using the numeric argument to
    cDshow-regioncA.

    The argument cCncA supplied to the command indicates the require functionality
    and can take the following values:-

        cG-3cA - Set the start position of the region.
        cG-2cA - Move the cursor the  Mark position.
        cG-1cA - Disable the hilighting of the current region.
        cG 0cA - Return the current status of the region in
        lslm$result(5)le.
        cG 1cA - Enable the hilighting of the current region.
        cG 2cA - Move the cursor the  Dot position.
        cG 3cA - Set the end position of the region.
        cG 4cA - Reactivate the current region.

    Where an argument of 0 is used to return the current state the value of
    $result is a bit based flag where:-

    cD0x01cA
        Indicates a region is currently active (visible).

    cD0x02cA
        Indicates a region has been fixed (may not visible).

    cD0x04cA
        Indicates the region is in the current buffer.

    cD0x08cA
        Indicates the cursor is in the current region.

    The color of the selection hilight is defined by lslmadd-color-scheme(2)le and
    is determined by lslm$buffer-scheme(5)le, lslm$global-scheme(5)le or
    lslm$buffer-hilight(5)le.


cEcEDIAGNOSTICS cEcA


    The following errors can be generated, in each case the command returns a
    FALSE status:

    cD[No current region]cA
        There is no current defined region on which to operate.

    cD[Current region not in this buffer]cA
        An argument of 2 or -2 was used and the defined region isn't in the
        current window so the cursor can not be moved to it.


cEcENOTES cEcA


    If no argument is given to the command it hilights the current region,
    similar to an argument of 1. But the properties of the hilight, namely how
    long it will be hilighted for, are inherited from the setting of
    lslm$show-region(5)le, whereas if an argument of 1 is passed in then the
    hilighting is set to be kept until the region becomes invalid (i.e. as if
    lslm$show-region(5)le is set to 3).


cEcESEE ALSO cEcA


    lslm$show-region(5)le, lslm$buffer-hilight(5)le, lslm$buffer-scheme(5)le, lslm$global-scheme(5)le,
    lslmadd-color-scheme(2)le, lslmcopy-region(2)le, lslmyank(2)le, lslmsearch-forward(2)le, lslmspell(2)le,
    lslmset-mark(2)le.
! 2 translate-key
cEcENAME cEcA


    translate-key - Translate key
$a


cEcESYNOPSIS cEcA


    cCncA cDtranslate-keycA [ "cCfromcA" ["cCtocA"] ]


cEcEDESCRIPTION cEcA


    cDtranslate-keycA may be used to convert any given input key sequence to
    another single key. cDtranslate-keycA operates at a very low level, before
    MicroEmacs attempts to evaluate keyboard bindings, so it may be used to
    solve a variety of keyboard problems such as special language characters
    and UNIX termcap key sequence bindings (see below).

    If a positive numeric argument cCncA is given it is used to set the time in
    milliseconds MicroEmacs waits for another key to be pressed before
    continuing, the default time use when no argument is supplied is 250ms.

    If a numeric argument cCncA of -1 is specified then the "cCtocA" argument is not
    required and the "cCfromcA" character sequence is removed from the translate
    key table.

    If a numeric argument cCncA of 0 is specified then no arguments are required;
    the current translation table is dumped to buffer "cC*tcap-keys*cA". Following
    is a sample output:-

            "C-h" ......................... "backspace"
            "C-[" ......................... "esc"
            "C-[ [ 1 ~" ................... "delete"
            "C-[ [ 1 1 ~" ................. "f1"
            "C-[ [ 1 2 ~" ................. "f2"
            "C-[ [ 1 3 ~" ................. "f3"
            "C-[ [ 1 4 ~" ................. "f4"
            "C-[ [ B" ..................... "down"
            "C-[ [ 4 ~" ................... "end"
            "C-[ [ 2 ~" ................... "insert"
            "C-[ [ 3 ~" ................... "home"
            "C-[ [ D" ..................... "left"
            "C-[ [ 6 ~" ................... "page-down"
            "C-[ [ 5 ~" ................... "page-up"
            "C-[ [ C" ..................... "right"
            "C-[ [ A" ..................... "up"
            "C-[ [ V" ..................... "page-up"
            "C-[ [ U" ..................... "page-down"
            "C-m" ......................... "return"
            "C-i" ......................... "tab"
            "\x7F" ........................ "backspace"


cEFOREIGN KEYBOARDS cA


    Foreign keyboards (non-US/UK) use a variety of key sequences, not
    recognized by MicroEmacs, to expand the keyboard character range to cope
    with accented characters. For example, on a German keyboard 'cGAltGr-mcA'
    (recognized as 'cGA-C-mcA') is used to insert a Greek mu (or micro sign). On a
    Belgian keyboard 'cGAltGr-9cA' inserts a '{' character.

    Many foreign keyboards are already directly supported by MicroEmacs and
    the keyboard specifics of a country have been understood and resolved. In
    these cases the cDKeyboardcA configuration in lslmuser-setup(3)le may be used for
    the country location.

    If MicroEmacs does not support your keyboard, cDtranslate-keycA may be used to
    fix any key input problems. For the aforementioned examples the following
    cDtranslate-keycA commands would be required:
sB
        ; translate AltGr-m to a Greek mu (char 0xb5)
        translate-key "A-C-m" "\xB5"
        ; translate AltGr-9 to a '{'
        translate-key "A-C-9" "{"

sA
    The problem is complicated further on Microsoft Window's platforms by the
    simultaneous generation of 2 keys for some Alt-Gr key combinations (this
    is a side effect of endeavoring to capture all key combinations in this
    environment). For the Belgian keyboard example, on Win32 platforms an
    'cGAltGr-9cA' generates an 'cGA-C-9cA' key first followed immediately by an
    'cGA-C-{cA'. As both keys are generated in quick succession this is unexpected
    and confusing.

    When the key is first pressed on a poorly configured system the error
    "cC[Key not bound "A-C-{"]cA" is given even when using the command
    lslmdescribe-key(2)le as the key described will be 'cGA-C-9cA' and then the 'cGA-C-{cA'
    key is generated and interpreted creating the error message.

    The variable lslm$recent-keys(5)le can be used to diagnose this problem and to
    obtain the 2 keys generated; alternatively use the macro below:
sB
        define-macro report-2-keys
            ml-write "Press key 1"
            set-variable #l0 @cgk
            ml-write "Press key 2"
            set-variable #l1 @cgk
            ml-write &spr "[The following keys where pressed: \"%s\" \"%s\"]" #l0 #l1
        !emacro

sA
    When executed the user is prompted for the first key; press the required
    key sequence (in this case 'cGAltGr-9cA'), if you are not prompted for the
    second key and the result is immediately returned then the key you pressed
    has generated 2 keys, both of which will be given in the print out, i.e.:

        "[The following keys where pressed: "A-C-9" "A-C-{"]"


    The translate-key required to fix this type of problem would be:
sB
        translate-key "A-C-9 A-C-{" "{"

sA
    If your keyboard is not directly supported by MicroEmacs, please submit
    the keyboard name and platform with a working translate-key configuration
    to lsMicroEmacs - Contact InformationlmJASSPAle as a cDBUGcA.


cEUNIX TERMCAP cA


    cDtranslate-keycA may also be used to interpret non-standard key sequences for
    UNIX termcap platforms to standard MicroEmacs keys. Non-standard keys,
    such as the cursor keys, have system dependent key sequences. The output
    from these keys usually take the form:

        cG^[[XcA or cG^[[DXcA or cG^[[DDXcA or cG^[[DDDcA

    where cD^[cA is the escape key (27), cDDcA is a digit and cDXcA is any character.
    These keys may be bound to the standard keys, for example the typical
    output of the cursor keys may be translated as follows:-

        cG^[[AcA = cDupcA, cG^[[BcA = cDdowncA, cG^[[CcA = cDrightcA and cG^[[DcA = cDleftcA

    The "cCfromcA" string is specified as this key sequence and the "cCtocA" string is
    simply the key it is to be bound to, see lslmglobal-bind-key(2)le for a guide to
    the string format. For the above example the following set of translations
    are required:-
sB
        translate-key "esc [ A" "up"
        translate-key "esc [ B" "down"
        translate-key "esc [ C" "right"
        translate-key "esc [ D" "left"

sA
    Note that MicroEmacs interprets cG\ecA as an escape key. More obscure keys
    tend to be very platform specific, following are some examples:
sB
        translate-key "esc [ 2 ~" "insert"
        translate-key "esc [ 5 ~" "page-up"
        translate-key "esc [ 5 ^" "C-page-up"

sA

cEcEEXAMPLE cEcA


    Using the positive numeric argument it is possible to reduce the delay and
    there by increase usability is some features. For instance, in the Mouse
    configuration of cDuser-setupcA there is an option to 'Simulate 3 Buttons'
    which translates a rapid left and right button press into a middle button
    press. This is implemented using cDtranslate-keycA as follows:
sB
        10 translate-key "mouse-pick-1 mouse-pick-3" "mouse-pick-2"
        10 translate-key "mouse-pick-3 mouse-pick-1" "mouse-pick-2"
        10 translate-key "mouse-drop-1 mouse-drop-3" "mouse-drop-2"
        10 translate-key "mouse-drop-3 mouse-drop-1" "mouse-drop-2"

sA
    When a cGmouse-pick-1cA key is generated MicroEmacs must wait to see if a
    cGmouse-pick-3cA key is next and therefore translate both to a single
    cGmouse-pick-2cA key. This wait time is usually a quarter of a second but this
    makes the left button unusable for dragging regions etc as the delay is
    too long. By giving a argument of 10ms the delay is long enough for a
    simultaneous left and right button press but short enough for the left
    button to still be usable on its own.

    The positive numeric argument can be very useful for delaying MicroEmacs
    as well, for example, the character string "cG'ecA" can be converted to
    e-accute using lslmexpand-iso-accents(3)le. This could be performed
    automatically using translate-key as follows:
sB
        1000 translate-key "' e" "\xE9"

sA
    The larger 1 second delay give the user enough time to type the 'cGecA' after
    the 'cG'cA' character.


cEKnown Translations cA


    The following are a set of known translations courtesy of cD-ThcA.
sB
        ; fix Backspace using Putty
        -1 translate-key "C-h"   ; remove translation to "backspace"
        translate-key "\x7F"  "backspace"  ; Backspace key

        ; fix del, home keys termcap/Putty/Solaris ME20040403
        translate-key "C-[ [ 3 ~" "delete"  ; ^[[3~ ('cat' output)
        translate-key "C-[ [ 1 ~" "home"  ; ^[[1~

        ; add support for termcap/Putty/Solaris
        translate-key "C-[ O A" "C-up" ; ctrl up ^[OA
        translate-key "C-[ O B" "C-down" ; ctrl down ^[OB
        translate-key "C-[ O D" "C-left" ; ctrl left ^[OD
        translate-key "C-[ O C" "C-right" ; ctrl right ^[OC

        ;-----
        ; SuSE xterm console mode ('me -n')
        ; 12-Jan-06 SuSE10/kde/gnome
        ;-----
        translate-key "C-[ [ 1 ; 5 A" "C-up"
        translate-key "C-[ [ 1 ; 5 B" "C-down"
        translate-key "C-[ [ 1 ; 5 C" "C-right"
        translate-key "C-[ [ 1 ; 5 D" "C-left"

        translate-key "C-[ [ 1 ; 2 A" "S-up"
        translate-key "C-[ [ 1 ; 2 B" "S-down"
        translate-key "C-[ [ 1 ; 2 C" "S-right"
        translate-key "C-[ [ 1 ; 2 D" "S-left"

        translate-key "C-[ [ H" "home"
        translate-key "C-[ [ F" "end"
        translate-key "C-[ [ 1 ; 5 H" "c-home"
        translate-key "C-[ [ 1 ; 5 F" "c-end"

        translate-key "C-[ [ 5 ; 5 ~" "C-page-up"
        translate-key "C-[ [ 6 ; 5 ~" "C-page-down"
        translate-key "C-[ [ 2 9 ~" "menu" ; context menu key

sA

cEcENOTES cEcA


    The concept of standardized key-bindings is very important for cross
    platform use and maintenance.

    Refer to lslmglobal-bind-key(2)le for a list of standard bindings.

    One of the easiest ways of obtaining a key sequence is to run cDsh(1)cA which
    does not attempt to interpret these keys so when a key is pressed
    (followed by cG<RETURN>cA) the following type of error message is usually
    generated:-

        sh: ^[[2~:  not found.


    where cG^[[2~cA is the required key sequence. Another method of obtaining
    these key sequences is to start MicroEmacs 2009, use lslmstart-kbd-macro(2)le to
    start a macro definition, press the required keys and then use
    lslmend-kbd-macro(2)le followed by lslmname-kbd-macro(2)le and lslminsert-macro(2)le to
    display the keys pressed.

    The key sequences generated for these keys are dependent on the machine
    displaying MicroEmacs 2009 as opposed to the machine running it. Often
    they are the same machine, but when they are not there is no easy method
    of determining the displaying machine and therefore correctly configuring
    MicroEmacs 2009.

    A better way of obtaining this cross platform consistency is to create an
    XTerm app-defaults setup file with the correct VT100 key translations,
    e.g. the setup file could contain the following

        *vt100.translations: #override \
         Shift<Key>Tab:  string("\033[Z") \n\
         <Key>BackSpace:  string("\177") \n\
         <Key>Delete:  string("\033[1~") \n\
         <Key>Insert:  string("\033[2~") \n\
         <Key>Home:  string("\033[3~") \n\
         <Key>End:  string("\033[4~") \n\
         <Key>Prior:  string("\033[5~") \n\
         <Key>Next:  string("\033[6~") \n\
         Ctrl<Key>Up:  string("\033Oa") \n\
         Ctrl<Key>Down:  string("\033Ob") \n\
         Ctrl<Key>Right:  string("\033Oc") \n\
         Ctrl<Key>Left:  string("\033Od") \n\
         Shift<Key>Up:  string("\033[a") \n\
         Shift<Key>Down:  string("\033[b") \n\
         Shift<Key>Right: string("\033[c") \n\
         Shift<Key>Left:  string("\033[d") \n


    By using the environment variable cCXUSERFILESEARCHPATHcA to ensure that this
    configuration file is found instead of the system one (found in
    cG/usr/lib/X11/app-defaultscA), the key sequences will then be the same across
    all platforms. See manual page on cDxterm(1)cA for more information.


cEcESEE ALSO cEcA


    lslmexpand-iso-accents(3)le, lslmuser-setup(3)le, lslmdescribe-key(2)le, lslmglobal-bind-key(2)le,
    lslmstart-kbd-macro(2)le, cDxterm(1)cA, cDsh(1)cA.
! 2 set-char-mask
cEcENAME cEcA


    set-char-mask - Set character word mask
$a


cEcESYNOPSIS cEcA


    cCncA cDset-char-maskcA "cCflagscA" ["cCvaluecA"]


cEcEDESCRIPTION cEcA


    cDset-char-maskcA returns or modifies the setting of MicroEmacs internal
    character tables. The argument cCncA defines the action to be taken, as
    follows:-

    cD-1cA
        Removes characters from the given set.

    cD0cA
        Returns characters in the given set in lslm$result(5)le.

    cD1cA
        Adds characters to the given set.

    The first argument "cCflagscA" determines the required character set as
    follows:-

    cDdcA
        Is Displayable. Characters in this set can be directly displayed to
        the screen (as a single character) when occurring in a buffer. When a
        character not in this set is to be displayed it is performed using
        more than one character. Characters in the range 1-31 are displayed as
        "cG^?cA" where cG?cA is the ASCII character plus 64, (e.g. 0x01 -> 65, i.e.
        "cG^AcA") otherwise the character is displayed in the form "cG\xhhcA" where cGhhcA
        is the hex form of the ASCII value. One notable exception is the tab
        character (0x09), by default this character is not displayable,
        instead it is displayed as a sequence of one or more spaces up to the
        next tab stop.

    cDpcA
        Is Pokable. Similar to cDdcA, characters in this set can be poked to the
        screen when using lslmscreen-poke(2)le. When found in a binary file the
        character is displayed in the right hand column. Unlike cDdcA, any
        character outside this set will be displayed as a single period 'cG.cA',
        indicating that it cannot be displayed.

    cDPcA
        Is Printable. Similar to cDdcA, characters in this set may be printed as a
        single character when using lslmprint-buffer(2)le or lslmprint-region(2)le. Any
        character not in this set is printed in a similar fashion to cDdcA.

    cDMcA
        Character font Map. Internally MicroEmacs uses ISO-8859-1 (Latin 1) to
        configure alphabetic classes and the spell-checker, however the system
        font being used by the native platform may not be the same, for
        example a small 'e' acute is character 0xe9 in ISO-8859-1 but
        character 0x82 in Windows OEM fonts. To change the characteristics of
        the 'e' acute character (such as making it an alphabetic character),
        the ISO-8859-1 character should always be used, but a correct mapping
        of ISO-8859-1 to the display font (such as Windows OEM) must also be
        supplied.

        Unlike other sets, this set cannot be incrementally altered, any calls
        to alter this set leads to the resetting of all the character tables
        so the character mapping must be performed first and in a single call.
        No other set may be altered in the same call. When setting, the
        "cCvaluecA" must supply pairs of characters, an ISO-8859-1 character
        followed by its system font equivalent.

    cDLcA
        ISO-8859-1 (Latin 1) character map list. This set cannot be altered
        using this flag, character mappings must be set up using flag cDMcA. The
        order of the characters in the returned cD$resultcA string is the same as
        the order for flag cDUcA.

    cDUcA
        User font character map list. This set cannot be altered using this
        flag, character mappings must be set up using flag cDMcA. The order of the
        characters in cD$resultcA when returned is the same as the order for flag
        cDLcA.

    cDacA
        Is Alphabetic letter. Characters in this set are alphabetical
        characters, used by many MicroEmacs commands such as lslmforward-word(2)le.
        When setting, the "cCvaluecA" must specify pairs of ISO-8859-1 (Latin 1)
        characters, an Upper-case character followed by its lower-case
        equivalent. This enables commands such as lslmlower-case-word(2)le to
        operate correctly regardless of the font and language being used. Some
        fonts may not have all the characters available for rendering, for
        instance PC Code page 437 does not have an upper-case 'e' grave. In
        this case an ordinary 'E' should be used as a sensible replacement,
        i.e. "E`e" (where `e is an 'e' grave). However, this will lead to all
        upper-case 'E's to map to a lower-case 'e' grave in a case changing
        operation, this may be corrected by adding a further mapping of 'E' to
        'e' to over-ride the 'e' grave mapping, i.e. "E`eEe". This technique
        does fail when changing the case more than once, when all lower case
        'e' graves will be lost.

        Note that the returned character list will pair all lower-case
        characters with their upper-case equivalent letters first.

    cDlcA
        Is Lower case letter. This set cannot be altered using this flag,
        alterations to the alphabetic set must be performed using flag cDacA.
        Characters in this set are all the lower-case letters, typically the
        characters 'cGacA' to 'cGzcA'. The order may not be the same as returned by
        flag cDucA.

    cDucA
        Is Upper case letter. This set cannot be altered using this flag,
        alterations to the alphabetic set must be performed using flag cDacA.
        Characters in this set are all the upper-case letters, typically the
        characters 'cGAcA' to 'cGZcA'. The order may not be the same as returned by

    cDhcA
        Is Hex-decimal Digit. The set is rarely used as it is invariably the
        digits 'cG0cA' to 'cG9cA' and the letters 'cGacA' to 'cGfcA' in upper and lower case.
        It is often used in the setting of lslm$buffer-mask(5)le.

    cDAcA
        Is Alpha-numeric. This set cannot be altered using this flag,
        alterations to the alphabetic set must be performed using flag cDacA.
        Characters in this set are either alphabetic characters or the digits
        0-9.

    cDscA
        Is Spell extended word character. The characters in this set are
        recognized by the spell checker as characters which may be considered
        part of a word, for example the period 'cG.cA's in e.g. or the hyphen 'cG-cA'
        in hyphenated-words. Typically this set contains the characters 'cG'cA',
        'cG-cA' and 'cG.cA'.

    cD1cA, cD2cA, cD3cA & cD4cA
        Is in Word. These user definable sets are used to add characters to a
        buffer's word character set, affecting the operation of commands like
        lslmforward-word(2)le. Many different file types operate better with a
        different word character set, e.g. it is preferable to include the 'cG_cA'
        character when editing C files. See variable lslm$buffer-mask(5)le.

    cDkcA
        Keyboard character map. This flag is used to configure a mapping from
        a foreign non-latin keyboard (such as Russian) to Latin characters,
        setting the mapping correctly can greatly improve usability in
        MicroEmacs as changing keyboards is required less frequently. The
        mapping is used by character input routines which first check the main
        key typed (e.g. the Cyrillic character) and if not bound or invalid
        MicroEmacs uses this keyboard mapping to translate the character into
        a Latin character. This allows the user to execute binding such as
        "cGC-x kcA" or responding to "cG[y/n]cA" prompts without having to change
        keyboards.

        As with flag cDMcA, this cannot be incrementally altered, any call to set
        this mapping first resets the mapping table so the mapping must be
        performed in a single call. No other set may be altered in the same
        call. When setting, the "cCvaluecA" must supply pairs of characters, the
        ISO-8859 non-latin character followed by its latin character mapping.

    Unless stated otherwise, multiple flags may be specified at the same time
    returning a combined character set or setting multiple properties for the
    given "cCvaluecA" characters.


cEcEEXAMPLE cEcA


    For many UNIX XTerm fonts the best characters to use for lslm$box-chars(5)le
    (used in drawing lslmosd(2)le dialogs) lie in the range 0x0B to 0x19. For
    example the vertical bar is 'cG\x19cA', the top left hand corner is 'cG\x0DcA'
    etc. These characters are by default set to be not displayable or pokable
    which renders them useless. They can be made displayable and pokable as
    follows:-
sB
        set-char-mask "dp" "\x19\x0D\x0C\x0E\x0B\x18\x15\x0F\x16\x17\x12"

sA
    MicroEmacs variables have either 'cG$cA', 'cG#cA', 'cG%cA', 'cG:cA' or a 'cG.cA' character
    prepended to their name, they may also contain a 'cG-cA' character in the body
    of their name. It is preferable for these characters to be part of the
    variable 'word' so commands like lslmforward-kill-word(2)le can work correctly.
    This may be achieved by adding these characters to user set cD2cA and setting
    the cDbuffer-maskcA variable to include set cD2cA, as follows:
sB
        set-char-mask "2" "$#%:.-"

        define-macro fhook-emf
            set-variable $buffer-mask "luh2"
            .
            .
        !emacro

sA
    For the examples below only the following subset of characters will be
    used:-

        Character               ISO-8859-1    Windows OEM    PC Page 437

        Capital A (A)           A             A              A
        Capital A grave (`A)    \xC0          \xB7           No equivalent
        Capital A acute ('A)    \xC1          \x90           No equivalent
        Small a (a)             a             a              a
        Small A grave (`a)      \xE0          \x85           \x85
        Small A acute ('a)      \xE1          \xA0           \xA0


    As the spell checker only operates in ISO-8859-1 (Latin 1), the character
    font mapping (flag cDMcA) must be correctly setup for spell checking to
    operate correctly. For ISO-8859-1 (ISO) this is an empty string as the
    default mapping is correct, but for both Windows OEM (OEM) and PC Code
    Page 437 (PC-437) the mappings should be set as follows:-
sB
        ; OEM font mapping setup
        set-char-mask "M" "\xC0\xB7\xC1\x90\xE0\x85\xE1\xA0"
        ; PC-437 font mapping setup
        set-char-mask "M" "\xC0A\xC1AAA\xE0\x85\xE1\xA0"

sA
    As all the characters in ISO have equivalents in OEM, the mapping for OEM
    is a simple ISO to OEM character list. However the missing capital cDAcA's in
    PC-437 cause problems, for the command lslmcharset-iso-to-user(3)le it is
    preferable for a mapping of cD`AcA to be given, otherwise the document being
    converted may remain unreadable. Therefore a mapping of cD`AcA to cDAcA is given
    to alleviate this problem, similarly cD'AcA is also mapped to cDAcA.

    This leads to a similar problem with the conversion of PC-437 back to ISO
    (the operation of command lslmcharset-user-to-iso(3)le). If only the mapping of
    "cG\xC0A\xC1AcA" was given, the last mapping (cD'AcA to cDAcA) would also be the back
    conversion for cDAcA, i.e. ALL cDAcA's would be converted back to cD'AcA's. To solve
    this problem, a further seemingly pointless mapping of cDAcA to cDAcA is given to
    correct the back conversion.

    For languages which use these characters, the alphabetic character set
    must be extended to include these characters for letter based commands
    like lslmforward-word(2)le and lslmupper-case-word(2)le to operate correctly. The
    addition of extra letters must achieve two goals, firstly to define
    whether a character is a letter, enabling commands like cDforward-wordcA to
    work correctly. The second is to provide an upper case to lower case
    character mapping, enabling commands like cDupper-case-wordcA to work
    correctly. This is achieved with a single call to cDset-char-maskcA using the
    cDacA flag as follows:-
sB
        set-char-mask "a" "\xC0\xE0\xC1\xE1"

sA
    Note that this flag always expects a ISO-8859-1 character, this allows the
    same map character list to be used regardless of the font set being used,
    i.e. the above line can be used for ISO, OEM and PC-437 fonts. But it does
    mean that the ISO to user font character mapping (flag cDMcA) must already
    have been performed.

    Similar problems are encountered with the cDMcA flag with font PC-437. This
    problem is not immediately obvious because the mapping is given in ISO,
    but when this is converted to PC-437, the mapping string becomes
    "cGA\x85A\xA0cA". As can be seen, cDAcA is mapped last to cD'acA so an upper to lower
    character operation will convert a cDAcA to cD'acA. A similar solution is used, a
    further mapping of cDAcA to cDacA is given to correct the default case mapping for
    both cDAcA and cDacA, i.e. the following line should always be used instead:-
sB
        set-char-mask "a" "\xC0\xE0\xC1\xE1Aa"

sA

cEcESEE ALSO cEcA


    lslmforward-word(2)le, lslm$buffer-mask(5)le, lslmscreen-poke(2)le, lslmspell(2)le,
    lslm$buffer-tab-width(5)le.
! 2 transpose-chars
! 2 transpose-lines
cEcENAME cEcA


|transpose-chars
    transpose-chars - Exchange (swap) adjacent characters
|transpose-lines
    transpose-lines - Exchange (swap) adjacent lines
$a


cEcESYNOPSIS cEcA


    cDtranspose-charscA (cDC-tcA)
    cCncA cDtranspose-linescA (cDC-x C-tcA)


cEcEDESCRIPTION cEcA


    cDtranspose-charscA exchanges (swaps) the current character under the cursor
    with the previous character. cDtranspose-characterscA does not operate in
    column 0 (since there is no previous character). If the cursor is at the
    end of a line when the command is initiated then the cursor is moved to
    the previous character and the operation performed from the new position.

    cDtranspose-linescA swaps the next line for the current line and moves to the
    next line, effectively retaining the same text position. Repeating this cCncA
    times moves the current line cCncA lines down.


cEcEEXAMPLE cEcA


    cDtranspose-charactercA performs the following operations (cursor at cD^cA):-

        abcde  => acbde         [Middle of line]
          ^         ^

        abcde  => abced         [End of line]
             ^         ^


cEcESEE ALSO cEcA


    lslmsort-lines(2)le.
! 2 undo
cEcENAME cEcA


    undo - Undo the last edit
$a


cEcESYNOPSIS cEcA


    cCncA cDundocA (cDC-x ucA)


cEcEDESCRIPTION cEcA


    cDundocA removes the last cCncA edits made to the current buffer. The lslmundo(2m)le
    buffer mode must be enabled for this command to operate.

    The undo information is retained up until the next save operation, at
    which point the undo information is discarded. When editing large files
    with gross changes then it is advisable to either disable undo mode, or
    save frequently to flush the undo buffer, thereby keeping MicroEmacs 2009
    memory requirements reasonable (most UNIX users have restrictions on the
    amount of memory that may be consumed by a single process. Windows is
    restricted by the amount of virtual memory (or swap space)).


cEcESEE ALSO cEcA


    lslmbuffer-mode(2)le, lslmsave-buffer(2)le, lslmundo(2m)le.
! 2 universal-argument
cEcENAME cEcA


    universal-argument - Set the command argument count
$a


cEcESYNOPSIS cEcA


    cDuniversal-argumentcA (cDC-ucA)


cEcEDESCRIPTION cEcA


    cDuniversal-argumentcA sets the argument number passed to a command to 4^cCncA (4
    to the power of cCncA) where cCncA is the number of calls to cDuniversal-argumentcA,
    e.g. the key sequence "cGC-uC-ncA" moves down 4 lines, "cGC-uC-uC-uC-ncA" moves
    down 4*4*4 = 64 lines.

    After invoking the cDuniversal-commandcA a 'cC-cA' character can be pressed to
    negate the argument value, and an alternative numeric argument can be
    entered using the 'cC0cA' to 'cC9cA' keys.

    Invoking this command via lslmexecute-named-command(2)le or by a macro has no
    effect. The command should be treated as a command key prefix (like
    lslmprefix(2)le) in that it may be bound to only one key sequence which must be
    a single key stroke. Re-binding this command to another key unbinds the
    new key and also the current cDuniversal-argumentcA key.

    The cDprefix 1cA key (by default bound to cGesccA) may also be used to enter a
    numeric argument at the message line, e.g. "cGesc 1 0 C-fcA" will move forward
    10 characters.


cEcESEE ALSO cEcA


    lslmprefix(2)le.
! 2 add-spell-rule
cEcENAME cEcA


    add-spell-rule - Add a new spelling rule to the dictionary
$a


cEcESYNOPSIS cEcA


    cCncA cDadd-spell-rulecA [ "cCrule-lettercA" "cCbase-endingcA" "cCremovecA" "cCderive-endingcA" ]


cEcEDESCRIPTION cEcA


    cDadd-spell-rulecA adds a new spelling rule to the speller. The rules
    effectively define the prefix and suffix character replacements of words,
    which is given an alphabetical identifier used within the speller , in
    conjunction with the language dictionary. The letter conventions are
    defined by the cDFree Software FoundationcA GNU cDispell(1)cA package.

    cDadd-spell-rulecA is used in the MicroEmacs 2009 dictionary initialization
    files called cC<language>cAr.emf, e.g. cGamericar.erfcA, cGbritishr.erfcA supplied in
    the MicroEmacs macros directory.

    The command takes a single numeric argument cCncA to control the addition of a
    rule to the speller, as follows:-

    cG0cA cDadd-spell-rulecA
        Removes all existing rules and re-initializes. This is, by convention,
        explicitly called before instantiating a new set of rules.

    cG-1cA cDadd-spell-rulecA "cCrule-lettercA" "cCbase-endingcA" "" "cCderiv-endingcA"

    cG-2cA cDadd-spell-rulecA "cCrule-lettercA" "cCbase-endingcA" "" "cCderiv-endingcA"
        Adds a prefix rule, an argument of -1 indicates that this prefix rule
        cannot be used with a suffix rule. An argument of -2 indicates it can
        be matched with any suffix rule which can be used with a prefix rule
        (e.g. argument of 2).

        "cCrule-lettercA" is any character in the range cGAcA-cGzcA except 'cG_cA', all rules
        of the given letter must be a prefix rule of the same type (i.e. same
        argument). The start of a base word must match the given "cCbase-endingcA"
        regular expression string for the rule to be applied, the "cCremovecA"
        string must be empty for a prefix and the "cCderiv-endingcA" is the prefix
        string. Example, for the American language;-

        cG-2 add-spell-rule "I" "" "" "in"cA ; As in disposed > indisposed

        A prefix rule of type 'cGIcA' can be applied to any base word which has
        rule 'cGIcA' enabled, and it prefixes "cGincA" to the word.

    cG1cA cDadd-spell-rulecA "cCrule-lettercA" "cCbase-endingcA" "cCremovecA" "cCderiv-endingcA"

    cG2cA cDadd-spell-rulecA "cCrule-lettercA" "cCbase-endingcA" "cCremovecA" "cCderiv-endingcA"
        Add suffix rules. An argument of 1 indicates that this prefix rule
        cannot be used with a prefix rule. An argument of 2 indicates it can
        be matched with any prefix rule which can be used with a suffix rule
        (i.e. argument of -2).

        "cCrule-lettercA" is any character in the range cGAcA-cGzcA, all rules of the
        given letter must be a suffix rule of the same type (i.e. same
        argument). The end of a base word must match the given "cCbase-endingcA"
        regular expression string for the rule to be applied, the "cCremovecA"
        string must be a fixed string and the "cCderiv-endingcA" must also be a
        fixed string which is appended to the base-word after "cCremovecA" has
        been removed. Example, for the American language;-
sB
            2 add-spell-rule "N" "e" "e" "ion"     ; As in create > creation
            2 add-spell-rule "N" "y" "y" "ication" ; As in multiply > multiplication
            2 add-spell-rule "N" "[^ey]" "" "en"   ; As in fall > fallen

sA
        A suffix rule of type 'cGNcA' can be applied to any base word which has
        rule 'cGNcA' enabled, and it can be used with prefixes, e.g. with rule;-
sB
            -2 add-spell-rule "A" "" "" "re"       ; As in enter > reenter

sA
        to derive "cCrecreationcA" from "cCcreatecA". A rule which cannot be used with
        prefixes, i.e.:
sB
            1 add-spell-rule "V" "e" "e" "ive"     ; As in create > creative
            1 add-spell-rule "V" "[^e]" "" "ive"   ; As in prevent > preventive

sA
        While some prefix words are legal, such as "cCrecreativecA" but some are
        not, such as "cCcollectcA" where "cCrecollectcA" is correct, so is
        "cCcollectivecA" but "cCrecollectivecA" is not.


cESPECIAL RULES cA


    Following are special forms of add-spell-rule used for tuning the spell
    support, note that an argument can not be given:-

    cDadd-spell-rulecA "cC-cA" "<cCycA|cCncA>"

        Enables and disables the acceptance of hyphens joining correct words.
        By default the phrase "cGout-of-datecA" would be accepted in American even
        though the phrase does not exist in the American dictionary. This is
        because the three words making up the phrase are correct and by
        default hyphens joining words are allowed. Some Latin language such as
        Spanish do not use this concept so this feature can be disable.

    cDadd-spell-rulecA "cC#cA" "cCscorecA"

        Sets the maximum allowed error score when creating a spelling guess
        list. When comparing a dictionary word with the user supplied word,
        cDspellcA checks for differences, each difference or error is scored in
        the range of 20 to 27 points, once the maximum allowed score has been
        exceeded the word is ignored. The default guess error score is 60,
        allowing for 2 errors.

    cDadd-spell-rulecA "cC*cA" "cCregexcA"

        Adds a correct word in the form of a lsRegularExpressions(2)lmregexle if a word being spell
        checked is completely matched by the cDregexcA the word is deemed to be
        correct. For example, the following rule can be used to make the
        spell-checker allow all hex numbers:
sB
        add-spell-rule "*" "0[xX][[:xdigit:]]+"

sA
    This will completely match the words "cG0x0cA", "cG0xffcA" etc but not "cG0x00zcA" as
    the whole word is not matched, only the first 4 letters.


cEcENOTES cEcA


    The format of the dictionary is a list of base words with each word having
    a list of rules which can be applied to that word. Therefore the list of
    words and the rules used for them are linked e.g.

        aback
        abaft
        abandon/DGRS
        abandonment/S
        abase/DGRS
        abasement/S
        abash/DGS
        abashed/U
        abate/DGRS


    where the "cG/...cA" is the valid list of rules for that word.

    The '_' character is used to separate different rule lists for a single
    word.

    The format of the dictionary word list and the rule list is compatible
    with cDispell(1)cA.


cEcESEE ALSO cEcA


    lslmadd-dictionary(2)le, lslmspell(2)le lslmspell-buffer(3)le, lslmspell-word(3)le, cDispell(1)cA.
! 2 screen-update
cEcENAME cEcA


    screen-update - Force screen update
$a


cEcESYNOPSIS cEcA


    cCncA cDscreen-updatecA (cDredrawcA)


cEcEDESCRIPTION cEcA


    cDscreen-updatecA updates the current screen, usually used in macros. The
    argument cCncA can be used to change the behaviour of this command as follows:

    cCnegative ncA
        Disables the next -cCncA screen updates, i.e. if cCncA is cG-1cA then the next
        time the screen needs to be redrawn nothing will happen.

    cG0cA
        Resets the screen update disable count to zero, useful to remember
        when the the disable feature has been used incorrectly.

    cG1cA
        Full screen update (default), the screen is completely cleared and
        redrawn (as if garbled).

    cG2cA
        Partial screen update, only the parts of the screen which require
        updating are redrawn.

    cG3cA
        No screen redraw, only window variables are up-dated. This feature is
        provided for macros which manipulate the screen view and need to know
        where the cursor is in the window without redrawing the screen (which
        may cause unwanted flickering). Note that as the screen is not redrawn
        not all variables may have the correct value, for example the frame
        store variable lslm@fs(4)le could be out of date.


cEcEEXAMPLES cEcA


    The following macro demonstrates the problems encountered when trying to
    use screen variables in macros after the current position has changed. The
    first value printed is the starting cursor Y position and the next value
    should be one less than the first value due to the call to
    lslmbackward-line(2)le. But it is the same as the first because the screen (and
    its variables) have not been updated. The subsequent call to screen-update
    ensures that the third value is the correct one although by giving it an
    argument of 3 the screen is not visibly updated thus avoiding any annoying
    screen flicker:
sB
        define-macro test-screen-update
            set-variable #l0 $cursor-y
            backward-line
            set-variable #l1 $cursor-y
            3 screen-update
            set-variable #l2 $cursor-y
            forward-line
            ml-write &spr "%d %d %d" #l0 #l1 #l2
        !emacro

sA

cEcENOTES cEcA


    Every time the screen requires updating, MicroEmacs executes the cCredrawcA
    key, it is similar in mechanism to the user pressing cCC-lcA to refresh the
    screen. The user can therefore re-bind the cCredrawcA key to another command
    or macro, thereby allowing the user complete control of what is displayed.
    For example if cCredrawcA was bound to lslmvoid(2)le the screen would not be
    up-dated (cDNotecA: this is difficult to get out of and may require MicroEmacs
    to be killed).

    This feature is often exploited by macros which take control of the input
    and output, such macros include lslmgdiff(3)le, lslmMetris(3)le, and lslmMahjongg(3)le.


cEcESEE ALSO cEcA


    lslmrecenter(2)le, lslmscreen-poke(2)le.
! 2 view-file
cEcENAME cEcA


    view-file - Load a file read only
$a


cEcESYNOPSIS cEcA


    cCncA cDview-filecA "cCfile-namecA" (cDC-x C-vcA)


cEcEDESCRIPTION cEcA


    cDview-filecA is like lslmfind-file(2)le, and either finds the file in a buffer, or
    creates a new buffer and reads the file in. A new file is left in lslmview(2m)le
    mode if the file was found (i.e. cannot be edited).

    The numeric argument cCncA can be used to modify the default behaviour of the
    command, where the bits are defined as follows:

    cD0x01cA
        If the file does not exist and this bit is not set the command fails
        at this point. If the file does not exist and this bit is set (or no
        argument is specified as the default argument is cG1cA) then a new empty
        buffer is created with the given file name, saving the buffer
        subsequently creates a new file.

    cD0x02cA
        If this bit is set the file will be loaded with lslmbinary(2m)le mode
        enabled. See help on cDbinarycA mode for more information on editing
        binary data files.

    cD0x04cA
        If this bit is set the file will be loaded with lslmcrypt(2m)le mode
        enabled. See help on cDcryptcA mode for more information on editing
        encrypted files.

    cD0x08cA
        If this bit is set the file will be loaded with lslmrbin(2m)le mode enabled.
        See help on cDrbincA mode for more information on efficient editing of
        binary data files.

    cD0x10cA
        If this bit is set then the file hook evaluation is not performed when
        the file is loaded (i.e. the lsfileHooks(2)lmbuffer's file hookle is not executed).


cEcESEE ALSO cEcA


    lslmbuffer-mode(2)le, lslmfind-file(2)le, lslmread-file(2)le, lslmview(2m)le, lslmbinary(2m)le,
    lslmcrypt(2m)le, lslmrbin(2m)le, lslmbrowse(3)le.
! 2 void
cEcENAME cEcA


    void - Null command
$a


cEcESYNOPSIS cEcA


    cCncA cDvoidcA


cEcEDESCRIPTION cEcA


    cDvoidcA does nothing except return cGFALSEcA if the given argument cCncA is zero,
    cGTRUEcA otherwise. Used to bind any frequently miss hit keys to something
    harmless.


cEcESEE ALSO cEcA


    lslmglobal-bind-key(2)le.
! 2 wrap-word
cEcENAME cEcA


    wrap-word - Wrap word onto next line
$a


cEcESYNOPSIS cEcA


    cDwrap-wordcA


cEcEDESCRIPTION cEcA


    cDwrap-wordcA wraps the current word onto the next line, justifying the
    current line if the lslmjustify(2m)le mode is enabled. The justification method
    is defined by lslm$fill-mode(5)le.


cEcESEE ALSO cEcA


    lslmbuffer-mode(2)le, lslmfill-paragraph(2)le, lslm$fill-mode(5)le, lslmjustify(2m)le.
! 2 write-buffer
cEcENAME cEcA


    write-buffer - Write contents of buffer to named (new) file
$a


cEcESYNOPSIS cEcA


    cCncA cDwrite-buffercA "cCfile-namecA" (cDC-x C-wcA)


cEcEDESCRIPTION cEcA


    cDwrite-buffercA is used to write the contents of the buffer to a NEW file,
    use lslmsave-buffer(2)le if the buffer is to be written to the existing file
    already associated with the buffer.

    cDwrite-buffercA writes the contents of the current buffer to the named file
    cCfile-namecA. The action of the write also changes the file name associated
    with the current buffer to the new file name.

    Unlike lslmappend-buffer(2)le, cDwrite-buffercA always replaces an existing file and
    the new file inherits the buffers file characteristics instead of the old
    file's.

    On writing the file, if lslmtime(2m)le mode is enabled then the ls$timestamp(5)lmtime stampln
    lnstringle is searched for in the file and modified if located, to reflect the
    modification date and time.

    If the buffer contains a lslmnarrow(2m)le it will automatically be removed
    before saving so that the whole buffer is saved and restored when saving
    is complete

    If lslmbackup(2m)le mode is enabled and the buffer is associated with a
    different file (compared with cCfile-namecA) then any ls$auto-time(5)lmautomatic savele copies of
    the file associated with the cCbuffercA are deleted.

    The argument cCncA may be used to change the default behavior of write-buffer
    described above, cCncA is a bit based flag where:-

    cD0x01cA
        Enables validity checks (default). These include a check that the
        proposed file does not already exist, if so confirmation of writing is
        requested from the user. Also MicroEmacs 2009 checks all other current
        buffers for one with the proposed file name, if found, again
        confirmation is requested. Without this flag the command will always
        succeed wherever possible.

    cD0x02cA
        Disables the expansion of any narrows (see lslmnarrow-buffer(2)le) before
        saving the buffer.


cEcENOTES cEcA


    lslmundo(2)le information may be discarded when the file is written.


cEcESEE ALSO cEcA


    lslm$auto-time(5)le, lslmappend-buffer(2)le, lslmbackup(2m)le, lslmbuffer-mode(2)le,
    lslmchange-file-name(2)le, lslmfile-attrib(3)le, lslmsave-buffer(2)le, lslmtime(2m)le,
    lslmwrite-region(3)le.
! 2 ml-write
cEcENAME cEcA


    ml-write - Write message on message line
$a


cEcESYNOPSIS cEcA


    cC0cA cDml-writecA
    cCncA cDml-writecA "cCmessagecA"


cEcEDESCRIPTION cEcA


    cDml-writecA writes the argument "cCmessagecA" to the message line. If a positive
    numeric argument cCncA is specified then the message is displayed with a cCncA
    milliseconds uninterruptible delay allowing the user time to see the
    message.

    The arguments to cDml-writecA are defined as follows:-

    cCNo argumentcA
        The default form, writes a cCmessagecA to the command line with no delay.

    cC+vecA
        Displays the cCmessagecA on the message line and waits cCncA milliseconds
        before proceeding with the next command.

    cG0cA
        the cCmessagecA argument is not required and the command clears the
        message line. This may be used to clear any previous message from the
        last command(s) in a script and is equivalent to the old MicroEmacs
        command cDml-clearcA.

    cG-1cA
        Writes the cCmessagecA to cCstandard outcA. A carriage return (cG'\n'cA) is
        automatically added to the end of the cCmessagecA to create a line on the
        given stream.

    cG-2cA
        Writes the cCmessagecA to cCstandard errorcA, the behaviour is the same as
        standard output (cG-1cA option)


cEcENOTES cEcA


    If the argument value is not cG-1cA or cG-2cA calls to cDml-writecA are ignored in
    standard MicroEmacs piped mode (command-line option cD-pcA). They are printed
    to cCstandard errorcA when debug piped mode is used (command-line option cD-PcA,
    see lslmme(1)le), making the debugging and maintenance of macro based piped
    processing easier.

    In previous releases the command cDml-clearcA was used to clear the message
    line, this command was replaced by cG0 ml-writecA in December 2004.


cEcEEXAMPLE cEcA


    The following call displays a message on the message-line with a 2 second
    pause:
sB
        2000 ml-write "Hello World!"

sA
    The following lslmstart-up(3)le macro may be used to add a header and footer
    line to a file piped to cCstandard incA, writing the output to cCstandard outcA.
sB
        define-macro start-up
            find-buffer "*stdin*"
            ml-write &spr "DEBUG: Read %d lines from stdin" $window-eline
            ml-write &spr "DEBUG: About to write header"
            -1 ml-write "<<<HEADER>>>"
            ml-write &spr "DEBUG: About to write body"
            0 save-buffer
            ml-write &spr "DEBUG: About to write footer"
            -1 ml-write "<<<FOOTER>>>"
            -2 ml-write &spr "%d lines written to stdout" &add $window-eline 2
            quick-exit
        !emacro

sA
    To run this example save this macro in a new macro file (such as
    cGmlwrite_test.emfcA) and in a shell run:

        cat input_file | me -n -p @mlwrite_test - > output_file


    Note the cGDEBUGcA lines will be printed if cD-PcA option is used. Also see
    example given for lslmcommand-wait(2)le.


cEcESEE ALSO cEcA


    lslmcommand-wait(2)le, lslmcreate-callback(2)le, lslmme(1)le.
! 2 yank
cEcENAME cEcA


    yank - Paste (copy) kill buffer contents into buffer
$a


cEcESYNOPSIS cEcA


    cCncA cDyankcA (cDC-ycA)


cEcEDESCRIPTION cEcA


    When a non negative argument is supplied to cDyankcA, the command copies the
    contents of the kill buffer cCncA times into the current buffer at the current
    cursor position. This does not clear the kill buffer, and therefore may be
    used to make multiple copies of a section of text. On windowing systems
    which support clip-boards, such as windows and X-terms, MicroEmacs will
    also cut to and paste from the global clip-board.

    If cCyankcA is IMMEDIATELY followed by a lslmreyank(2)le then the cCyankedcA text is
    replaced by text of the next entry in the kill ring. (another cDreyankcA
    replaces the text with the previous reyank text and so on).

    If an negative argument is given, cDyankcA removes the last 0-cCncA items from the
    kill ring.

    Text is inserted into the kill buffer by one of the following commands:-

        lslmbackward-kill-word(2)le, lslmcopy-region(2)le, lslmforward-kill-word(2)le,
        lslmkill-line(2)le, lslmkill-paragraph(2)le, lslmkill-region(2)le,
        lslmforward-delete-char(2)le, lslmbackward-delete-char(2)le.

    All the above commands (except cDcopy-regioncA) cut text out of the buffer,
    the last two character delete commands require the presence of a numeric
    argument to add the deleted text to the kill buffer. If any of these
    commands are executed immediately after any other (including itself) or
    the lslm@cl(4)le variable is set to one of these command, the new kill text is
    appended to the last kill buffer text.


cEcENOTES cEcA


    Windowing systems such as X-Windows and Microsoft Windows utilize a global
    windowing kill buffer allowing data to be moved between windowing
    applications (cCcut buffercA and cCclipboardcA, respectively). Within these
    environments MicroEmacs 2009 automatically interacts with the windowing
    systems kill buffer, the last MicroEmacs 2009 kill buffer entry is
    immediately available for a cCpastecA operation into another application
    (regardless of how it was inserted into the kill buffer). Conversely, data
    placed in the windowing kill buffer is available to MicroEmacs 2009, via
    cDyankcA, until a new item has been inserted into the kill buffer (the data
    may still be available via lslmreyank(2)le).


cEcEEXAMPLE cEcA


    The following example is a basic macro code implementation of the
    lslmtranspose-lines(2)le command,
sB
        beginning-of-line
        kill-line
        forward-line
        yank
        -1 yank
        backward-line

sA
    Note that similar to cDtranspose-linescA it does not leave the moved line in
    the kill buffer, effectively tidying up after itself.


cEcESEE ALSO cEcA


    lslmbackward-delete-char(2)le, lslmbackward-kill-word(2)le, lslmcopy-region(2)le,
    lslmforward-delete-char(2)le, lslmforward-kill-word(2)le, lslmkill-line(2)le,
    lslmkill-paragraph(2)le, lslmkill-region(2)le, lslmreyank(2)le, lslmyank-rectangle(2)le, lslm@y(4)le,
    lslm@cc(4)le.
! 2 define-macro-file
cEcENAME cEcA


    define-macro-file - Define macro file location
$a


cEcESYNOPSIS cEcA


    cDdefine-macro-filecA "cCfile-namecA" ["cCmacro-namecA" "cCmacro2-namecA" ...]


cEcEDESCRIPTION cEcA


    Macros are loaded as late as possible using an on-demand mechanism, this
    speeds up the load time of MicroEmacs 2009, it also keeps the startup file
    clean since macros are not defined within the start-up file. Only when the
    user first executes a macro defined via cDdefine-macro-filecA is the file
    loaded, the macro becomes defined and is executed. Subsequent calls to the
    macro will not reload the file as the macro will now be fully defined.

    cDdefine-macro-filecA binds macros (cCmacro-namecA ...) to a file name
    (cCfile-namecA). This operation informs MicroEmacs 2009 which file should be
    loaded when cCmacro-namecA is first executed. The cCmacro-namecA arguments may be
    omitted if the file contains only one exported macro which has the same
    name as cCfile-namecA.

    Alternatively the macro file may contain many macros all of which can be
    defined by a single call to cDdefine-macro-filecA, listing all macros on the
    same line after the cCfile-namecA. If a cCmacro-namecA is given then the default
    macro cCfile-namecA is not created, if a macro of that name does exist it must
    be added to the cCmacro-namecA list.


cEcEEXAMPLE cEcA


    The following definitions are found in the cGme.emfcA start-up file:-
sB
        0 define-macro-file utils ascii-time
        define-macro-file format clean sort-lines-ignore-case tabs-to-spaces ...
        define-macro-file cvs cvs cvs-state cvs-update cvs-commit cvs-log ...
        define-macro-file abbrev expand-abbrev-handle expand-iso-accents ...
        define-macro-file misc symbol check-line-length alarm time
        define-macro-file search replace-all-string query-replace-all-string
        define-macro-file tools compile grep rgrep which diff diff-changes
        define-macro-file hkdirlst file-browser file-browser-close
        define-macro-file comment comment-line uncomment-line comment-to-end-of-line
        define-macro-file spell spell-word spell-buffer spell-edit-word find-word
        define-macro-file games Metris Patience Triangle Mahjongg Match-It
        define-macro-file fattrib file-attrib
        define-macro-file osd osd-main
        define-macro-file gdiff
        define-macro-file calc
        define-macro-file draw

sA
    Hilighting a number of entries as examples; macro file cDcalccA is defined
    with no macro definition, the macro is assumed to be cDcalccA. The file
    cDtools.emfcA contains multiple macros cDcompilecA, cDgrepcA, cDdiffcA and cDdiff-changescA;
    all can be defined by a single cDdefine-macro-filecA entry.


cEcENOTES cEcA


        * Macro files are searched for in the current directory and along the
          lslm$search-path(5)le.
        * The macro file is not loaded unless a binding has been defined using
          cDdefine-macro-filecA.
        * Any other macros that exist in the cCfile-namecA macro file become
          defined when the entry point macro is loaded and are available for
          use. This is potentially useful as a single cCentrycA macro may be
          defined using cDdefine-macro-filecA, when invoked other helper macros
          become available.


cEcESEE ALSO cEcA


    lslmadd-file-hook(2)le, lslmdefine-macro(2)le, lslm$search-path(5)le, lslmstart-up(3)le.
! 2 about
cEcENAME cEcA


    about - Information About MicroEmacs 2009
$a


cEcESYNOPSIS cEcA


    cDaboutcA


cEcEDESCRIPTION cEcA


    cDaboutcA displays information about the current MicroEmacs 2009 editing
    session and includes the following information:-

        * Version number and date (YYYY/MM/DD) information for MicroEmacs
          2009.
        * Global status information including the number of active buffers and
          global mode status information.
        * Current buffer status information; buffer modes and buffer size
          information.


cEcEEXAMPLE cEcA


    The following is an example output from cDaboutcA.

        MicroEmacs 09 - Date 2009/09/09 - sunos

        Global Status:
          # buffers : 15
          Modes on  : autosv backup cr magic tab undo
          Modes off : binary crypt ctrlz edit exact fence hide indent justify lf lock
                      nact narrow over pipe rbin time view wrap

        Current Buffer Status:
          Buffer    : *grep*
          File name : /home/jon/merep/me/src/
          Lines     : Total    100, Current     26
          Characters: Total   7255, Current   1996
          Modes on  : autosv backup cr edit magic tab undo
          Modes off : binary crypt ctrlz exact fence hide indent justify lf lock nact
                      narrow over pipe rbin time view wrap

        Copyright (C) 1988-2009 JASSPA (www.jasspa.com)


cEcESEE ALSO cEcA


    lslmdescribe-bindings(2)le, lslmlist-buffers(2)le.
! 2 scroll-left
! 2 scroll-right
cEcENAME cEcA


|scroll-left
    scroll-left - Move the window left (scrolling)
|scroll-right
    scroll-right - Move the window right (scrolling)
$a


cEcESYNOPSIS cEcA


    cCncA cDscroll-leftcA (cDC-x <cA)
    cCncA cDscroll-rightcA (cDC-x >cA)


cEcEDESCRIPTION cEcA


    cDscroll-leftcA moves the window in current buffer left by 1 screen width. If
    an argument cCncA is supplied then the resolution of movement is specified in
    characters relative to the current displacement. Moving the window in the
    current buffer left by cCncA characters (that is if the current left-hand
    margin of the screen is column 0, the left hand margin becomes column cCncA).

    cDscroll-rightcA moves the window in current buffer right by 1 screen width.
    If an argument cCncA is supplied then the resolution of movement is specified
    in characters relative to the current displacement.

    The ends of the lines of a scrolled screen are delimited with a dollar (cD$cA)
    character indicating that the text continues. When no scroll is in effect
    the left hand margin of the screen does not show the cD$cA symbol. i.e. The
    line cGThis text is scrolled on this linecA with a current scroll offset of 2
    in a 22 column window would appear as follows:

                 22
        |<------------------->|

        |$s text is scrolled $|


    The amount of scroll (cCncA) is effectively unlimited, it is possible to
    scroll all of the text in a buffer out of the window, when only cD$cA's appear
    in the left margin, in the last highlighting color of the line (blank
    lines always remain blank and are not delimited with a cD$cA). Text on the
    current line is handled according to the value of lslm$scroll(5)le as follows:

    cD$scroll 0cA
        The current line ONLY is scrolled (about the current scroll position)
        to enable the current buffers cursor position to be viewed. To enable
        the user to determine where the current line is in relation to the
        scrolled lines then the first character of the current line is
        interpreted as follows:-

        cDAll of user text appearscA

            |$f line of te$|
            |At start of l$|
            |$f line of te$|


            Surrounding lines commence with "$" indicates at the start of the
            line.

        cD$ in column 0cA

            |$f line of te$|
            |$f line of te$|
            |$f line of te$|


            Text column is the same as the surrounding text i.e. the line and
            window scroll are the same.

        cD> Left of scroll positioncA

            |$f line of te$|
            |>f line of te$|
            |$f line of te$|


            The current line is to the left of the scrolled position.
            lsforward-char(2)lmforward-charle (i.e. interpret as cG-->cA indicating the direction of
            travel) moves the cursor, and therefore the line, towards the
            natural scroll position (cD$cA in column).

        cD< Right of scroll positioncA

            |$f line of te$|
            |<f line of te$|
            |$f line of te$|


            The current line is to the right of the scrolled position.
            lsforward-char(2)lmbackward-charle (i.e. interpret as cG<--cA indicating the direction of
            travel) moves the cursor, and therefore the line, towards the
            natural scroll position (cD$cA in column).

    cD$scroll 1cA
        The position of the cursor on the line determines the scrolled
        position. In this case all lines in the window are scrolled to ensure
        that the cursor is always visible. This mode is only useful when
        dealing with large blocks of text whose line lengths do not vary.


cEcENOTES cEcA


    The scrolling is an attribute of the WINDOW and not the BUFFER. If the
    window is closed, or contents swapped to a different buffer then the
    scroll setting is reset for the next buffer. A return to the previous
    buffer does not restore the scroll setting. The only case where scrolling
    is inherited is when a window is split (see lslmsplit-window-vertically(2)le).

    When binding cDscroll-leftcA to the keyboard then it is important to note that
    when no argument is specified the resolution is cCframe-widthcA's. A key
    binding would operate on character multiples, hence the command should be
    bound with a numeric argument to perform the perform the keyboard action.
    e.g.
sB
        1 global-bind-key scroll-left  "A-left"
        1 global-bind-key scroll-right "A-right"

sA
    To move 5 columns on a key stroke, for an accelerated scroll, then the
    binding may be re-written as:-
sB
        5 global-bind-key scroll-left  "A-left"
        5 global-bind-key scroll-right "A-right"

sA

cEcESEE ALSO cEcA


    lslm$scroll(5)le, lslmscroll-up(2)le, lslmscroll-down(2)le, lslm$window-x-scroll(5)le.
! 2 save-some-buffers
cEcENAME cEcA


    save-some-buffers - Save contents of all changed buffers to file (with
    query)
$a


cEcESYNOPSIS cEcA


    cCncA cDsave-some-bufferscA


cEcEDESCRIPTION cEcA


    cDsave-some-bufferscA cycles through all visible buffers (buffers without mode
    lslmhide(2m)le set) and attempts to save all modified ones, writing the contents
    back to the file from where it was read. For each buffer that has been
    modified the user is prompted to save the buffer, the following responses
    can be given:

    cDycA
        Saves the buffer and moves to the next modified buffer.

    cDncA
        Does not save the buffer and moves to the next modified buffer. cDacA
        Saves all remaining modified buffers including the current one without
        further prompting. cDocA Skips all remaining buffers including the current
        one. cDgcA Display the buffer and aborts the command.

    The argument cCncA can be used to change the default behavior of
    save-some-buffers described above, cCncA is a bit based flag where:-

    cD0x01cA
        Enables the user prompt before the buffer is saved (default). If this
        flag is not supplied then all modified visible buffers will be
        written.


cEcESEE ALSO cEcA


    lslmsave-buffer(2)le, lslmsave-buffers-exit-emacs(2)le, lslmwrite-buffer(2)le, lslmhide(2m)le.
! 2 split-window-horizontally
cEcENAME cEcA


    split-window-horizontally - Split current window into two (horizontally)
$a


cEcESYNOPSIS cEcA


    cCncA cDsplit-window-horizontallycA (cDC-x 3cA)


cEcEDESCRIPTION cEcA


    cDsplit-window-horizontallycA splits the current window horizontally into two
    near equal windows, each displaying the buffer displayed by the original
    window.

    A numeric argument cCncA of 1 forces the left window to be the new current
    window, and an argument of 2 forces the right window to be the new current
    window. The default when omitted is the left window.


cEcESEE ALSO cEcA


    lslm$scroll-bar(5)le, lslm$scroll-bar-scheme(5)le, lslm$window-chars(5)le,
    lslmgrow-window-horizontally(2)le, lslmsplit-window-vertically(2)le.
! 2 change-window-width
! 2 grow-window-horizontally
! 2 shrink-window-horizontally
! 2 resize-window-horizontally
cEcENAME cEcA


|change-window-width
    change-window-width - Change the width of the current window
|grow-window-horizontally
    grow-window-horizontally - Enlarge current window horizontally (relative)
|shrink-window-horizontally
    shrink-window-horizontally - Shrink current window horizontally (relative)
|resize-window-horizontally
    resize-window-horizontally - Resize current window horizontally (absolute)
$a


cEcESYNOPSIS cEcA


    cCncA cDchange-window-widthcA [ "cCwidthcA" ]

    cCncA cDgrow-window-horizontallycA
    cCncA cDshrink-window-horizontallycA
    cCncA cDresize-window-horizontallycA


cEcEDESCRIPTION cEcA


    cDchange-window-widthcA changes the width of the current window, if the
    numeric argument cCncA is given then the window width is changed by cCncA
    characters. If cCncA is not specified the user is prompted for the new cCwidthcA
    and the window width will be changed to this value. The command aborts if
    the requested size cannot be achieved (the window becomes too small or a
    neighbouring does).


cEcEEXAMPLE cEcA


    Refer to cGmouse.emfcA for an example of window growth using the mouse to
    manipulate the size of the windows.


cEcENOTES cEcA


    Commands cDgrow-window-horizontallycA, cDshrink-window-horizontallycA and
    cDresize-window-horizontallycA were replaced by the new cDchange-window-widthcA
    command in April 2002. Following are macro implementations of the old
    commands:
sB
        define-macro grow-window-horizontally
            @# change-window-width
        !emacro

        define-macro shrink-window-horizontally
            &neg @# change-window-width
        !emacro

        define-macro resize-window-horizontally
            !if &not @?
                !abort
            !endif
            change-window-width @#
        !emacro

sA

cEcESEE ALSO cEcA


    lslmchange-window-depth(2)le, lslmresize-all-windows(2)le,
    lslmsplit-window-horizontally(2)le.
! 2 resize-all-windows
cEcENAME cEcA


    resize-all-windows - Automatically resize the windows
$a


cEcESYNOPSIS cEcA


    cCncA cDresize-all-windowscA


cEcEDESCRIPTION cEcA


    cDresize-all-windowscA performs an automatic layout of the windows on the
    screen, reorganizing the windows such that each window has an equal amount
    of space. The argument cCncA determines which axes reorganization is performed
    in.

        * A positive argument reorganizes the windows vertically, leaving the
          horizontal arrangement as is.
        * A negative argument rearranges the windows horizontally, leaving the
          vertical arrangement as is.
        * An argument of zero performs no vertical or horizontal arrangement.
        * No argument re-arranges both the vertical and horizontal window
          layout.


cEcESEE ALSO cEcA


    lslmresize-window-vertically(2)le, lslmresize-window-horizontally(2)le,
    lslmsplit-window-vertically(2)le.
! 2 mark-registry
cEcENAME cEcA


    mark-registry - Modify the operating mode of a registry node


cEcESYNOPSIS cEcA


    cCncA cDmark-registrycA "cCrootcA" "cCmodecA"


cEcEDESCRIPTION cEcA


    cDmark-registrycA modifies the cCmodecA of a registry node cCrootcA. If an argument cCncA
    is supplied then the cCncAth register node down from cDrootcA (as viewed from
    lslmlist-registry(2)le output) is modified instead. The cCmodecA is string
    specifying the modes, each mode is represented by a character. Lower case
    characters add a mode, upper case characters delete a mode. The modes are
    defined as:-

    cD?cA - Query Name
        Returns the full name, including path, of the given registry node in
        the variable lslm$result(5)le. This does not alter the registry.

    cD!cA - Hide Value
        Hides the value of the given registry node, i.e. the node is displayed
        but its value will not be displayed in the output of lslmlist-registry(2)le.
        Once set, this mode cannot be removed.

    cDacA - Autosave
        Automatically saves the registry when it is deleted or unloaded from
        the registry. The user is not prompted for a save.

    cDbcA - Backup
        Automatically performs a backup of the registry file whenever a save
        operation is performed.

    cDccA - Create
        If the registry file cannot be loaded then the cCrootcA node is created
        and the invocation succeeds. If this mode is omitted then the call
        fails if the cCfilecA cannot be found.

    cDdcA - Discard
        Marks the registry as discardable. This is typically used for
        registries that are not saved.

    cDfcA - File
        The registry node is marked as a file root, the value must be set to
        the registry file name.

    cDgcA - Get Modes
        Returns the list of modes currently set on the given registry node in
        the variable lslm$result(5)le. This does not alter the registry.

    cDhcA - Hierarchy Hidden
        The registry node is marked as cCHiddencA, i.e. its children will not be
        shown in lslmlist-registry(2)le output. A node is marked has hidden when it
        is folded up.

    cDicA - Invisible
        The registry node is not displayed in the lslmlist-registry(2)le output.

    cDmcA - Merge
        Marks the registry to enable merging, see lslmread-registry(2)le.

    cDrcA - Reload
        Marks the registry to enable reload, see lslmread-registry(2)le.

    cDucA - Updated
        Marks the registry as modified. The modified bit is removed when the
        registry file is saved. If the modified bit is applied to a registry
        node the user will be prompted to save the registry when it is deleted
        (or it will be automatically saved when the cCAutosavecA mode is used).

    cDycA - Encryption
        Marks the registry node for encryption. The value of the registry node
        is encrypted using the internal encryption algorithm. The value will
        not appear in plain text when using lslmsave-registry(2)le. This is
        typically used for password information etc.

    Multiple modes may be applied.


cEcEEXAMPLE cEcA


    A history registry can be hidden with the following invocation:-
sB
        mark-registry "/history" "h"

sA
    It could then be made visible again using:-
sB
        mark-registry "/history" "H"

sA

cEcEBUGS cEcA


    At exit only registry nodes attached to the root are saved.


cEcEDIAGNOSTICS cEcA


    cDmark-registrycA fails if cCrootcA does not exist.


cEcESEE ALSO cEcA


    lslmcopy-registry(3)le, lslmdelete-registry(2)le, lslmfind-registry(2)le, lslmlist-registry(2)le,
    lslmread-registry(2)le, lslmsave-registry(2)le, lslmset-registry(2)le, lslm&reg(4)le, lslmerf(8)le.
! 2 delete-some-buffers
cEcENAME cEcA


    delete-some-buffers - Delete buffers with query
$a


cEcESYNOPSIS cEcA


    cCncA cDdelete-some-bufferscA


cEcEDESCRIPTION cEcA


    cDdelete-some-bufferscA cycles through all visible buffers (buffers without
    mode lslmhide(2m)le set) and prompts the user [cDycA/cDncA] as to whether the buffer
    should be deleted. A cDycA response deletes the buffer, a cDncA response retains
    the buffer.

    If a cDycA response is given, the buffer has been edited, and its name does
    not start with a 'cD*cA' then the user is prompted as to whether the changes
    should be discarded. Also if the buffer has an active process running in
    it then confirmation is sort from the user before the process is killed.

    The argument cCncA can be used to change the default behavior of
    delete-some-buffers described above, cCncA is a bit based flag where:-

    cD0x01cA
        Enables all checks (default). These include the initial y/n prompt on
        each buffer, the buffer has not been modified check, if so the user is
        prompted. Also if a process is running then user must confirm that the
        process can be killed. If this flag is not supplied then all visible
        buffers are killed without any user prompts (useful in macros).


cEcESEE ALSO cEcA


    lslmdelete-buffer(2)le, lslmnext-buffer(2)le, lslmhide(2m)le.
! 2 insert-tab
cEcENAME cEcA


    insert-tab - Insert tab(s) into current buffer
$a


cEcESYNOPSIS cEcA


    cCncA cDinsert-tabcA (cDC-icA)


cEcEDESCRIPTION cEcA


    cDinsert-tabcA inserts cCncA tab characters at the current cursor position, moving
    the cursor. The command is not affected by the lslmtab(2m)le mode as it always
    inserts literal tab characters.


cEcESEE ALSO cEcA


    lslminsert-space(2)le, lslminsert-string(2)le, lslminsert-newline(2)le, lslmtab(2)le,
    lslmnormal-tab(3)le, lslmtab(2m)le.
! 2 read-registry
cEcENAME cEcA


    read-registry - Read in a registry definition file
$a


cEcESYNOPSIS cEcA


    cDread-registrycA "cCrootcA" "cCfilecA" "cCmodecA"


cEcEDESCRIPTION cEcA


    cDread-registrycA loads a registry file lslmerf(8)le into the internal registry
    memory, where the information may be queried via the registry macro
    commands. The arguments are defined as follows:-

    cCrootcA
        The root node in the registry to into which the registry contents are
        attached. The root name is limited to 32 characters in length and is
        specified without a leading forward slash 'cG/cA'. The node cCrootcA is
        created at the root of the registry.

    cCfilecA
        The name of the registry file lslmerf(8)le to load. This may be an absolute,
        relative or a lslm$search-path(5)le specified file; typically it is located
        on ls$search-path(5)lm$search-pathle.

    cCmodecA
        The cCmodecA is string specifying the registry node loading and saving
        modes, each mode is represented by a character. Lower case characters
        add a mode, upper case characters delete a mode. The modes are defined
        as follows:-

        cDacA - Autosave
            Automatically saves the registry when it is deleted or unloaded
            from the registry. The user is not prompted for a save.

        cDbcA - Backup
            Automatically performs a backup of the registry file whenever a
            save operation is performed.

        cDccA - Create
            If the registry file cannot be loaded then the cCrootcA node is
            created and the invocation succeeds. If this mode is omitted then
            the call fails if the cCfilecA cannot be found.

        cDdcA - Discard
            Marks the registry as discardable. This is typically used for
            registries that are not saved.

        cDrcA - Reload
            If the registry node already exists then it is deleted and
            reloaded, see also the merge flag (cDmcA). By default, when both the cDrcA
            and cDmcA flags are omitted and the registry node already exists the
            read operation is not performed and the existing node is used.

        cDmcA - Merge
            The registry file is merged with the contents of any existing
            registry node. (i.e. the existing registry tree nodes are not
            deleted if they already exist). See also the reload flag (cDrcA).

        cDhcA - Hidden
            The registry node is created in the cCHiddencA state. (i.e. children
            will not be shown in lslmlist-registry(2)le output). Refer to
            lslmmark-registry(2)le for hiding modes.

        cDucA - Updated
            Marks the registry as modified. The modified bit is removed when
            the registry file is saved. If the modified bit is applied to a
            registry node the user will be prompted to save the registry when
            it is deleted (or it will be automatically saved when the cCAutosavecA
            mode is used).

        Multiple modes may be applied.


cEcEEXAMPLE cEcA


    The following example is a typical call made from a macro using a registry
    file where the user may edit the registry file. In this case this a reload
    of the registry is forced to ensure that the most up-to-date contents are
    retrieved. Note that the name of the registry file is actually retrieved
    from the cChistorycA registry.
sB
        set-variable #l1 &reg "/history/address" $user-name
        !if &seq &set #l0 &find #l1 ".ab" "ERROR"
            set-variable #l0 &reg "/history" ""
            set-variable #l0 &spr "%s%s.ab" &lef #l0 &rsin "/" #l0 #l1
        !endif
        read-registry "AddressBook" #l0 "rc"

sA

cEcEBUGS cEcA


    At exit only registry nodes attached to the root are saved.


cEcESEE ALSO cEcA


    lslmcopy-registry(3)le, lslmdelete-registry(2)le, lslmfind-registry(2)le, lslmlist-registry(2)le,
    lslmmark-registry(2)le, lslmsave-registry(2)le, lslmset-registry(2)le, lslm&reg(4)le,
    lslm$search-path(5)le, lslmerf(8)le.
! 2 file-op
cEcENAME cEcA


    file-op - File system operations command
$a


cEcESYNOPSIS cEcA


    cCncA cDfile-opcA [ ( [ "cCfrom-filecA" "cCto-filecA" ] ) |
        ( ["cCdelete-filecA"] ) | ( ["cCdir-namecA"] ) |
        ( [ "cCchmod-filecA" "cCmodecA" ] ) ]


cEcEDESCRIPTION cEcA


    cDfile-opcA can be used to perform numerous file system operations. The given
    argument cCncA must be used to determine the required operation, the value is
    a bit based flag denoting the operation as follows:

    cD0x010cA
        Log-off and close down the current ftp connect (not a file system
        operation but functionality was required and it had to go somewhere).

    cD0x020cA
        When this bit is set the command functionality is changed to
        delete-file, the single argument cCdelete-filecA is deleted. Note this can
        also delete a directory if the directory is empty.

    cD0x040cA
        When this bit is set the command functionality is changed to
        move-file, the specified cCfrom-filecA is moved to cCto-filecA.

    cD0x080cA
        When this bit is set the command functionality is changed to
        copy-file, the specified cCfrom-filecA is copied to cCto-filecA.

    cD0x100cA
        When this bit is set the command functionality is changed to making a
        new directory, the specified cCdir-namecA is the name of the new
        directory. A file or directory of the given name must not already
        exist.

    cD0x200cA
        When this bit is set the command functionality is changed to a change
        mode type of operation. cCchmod-filecA is the name of the file (or
        directory) to change and cCmodecA is the integer mode to apply. Note that
        the cCmodecA value is operating system specific. The file attributes may
        be retrieved with the lslm&stat(4)le command.

    Only one operation can be performed per invocation. The following bits in
    the given argument cCncA can be used to effect the behaviour of these
    operations:

    cD0x01cA
        Enables validity checks, these include a check that the proposed file
        does not already exist, if so confirmation of writing is requested
        from the user. Also MicroEmacs checks all other current buffers for
        one with the proposed file name, if found, again confirmation is
        requested. Without this flag the command will always succeed wherever
        possible.

    cD0x02cA
        Creates a backup of any file about to be deleted or over-written. Set
        help on lslm$buffer-backup(5)le for backup file-name generation.

    cD0x04cA
        When validity checks are enabled (see bit 0x01 above) and this bit is
        set, if a problem is found the command aborts rather than prompting
        the user. Also see the error return codes in the notes section below.

    cD0x80cA
        When this bit is set then the files time stamp is preserved.


cEcENOTES cEcA


    cDhttpcA files are not supported except as the source file when copying. cDftpcA
    files are fully supported with the restriction that the from and to files
    cannot both be url (http or ftp) files. The one exception to this is when
    moving a file on the same ftp site in which case ME will attempt to use an
    ftp rename command.

    The command is used by lslmfile-browser(3)le and lslmftp(3)le which provides an easy
    to use interfaces for file manipulation.

    When the command fails an error code is returned in the lslm$result(5)le
    variable, which will be one of the following:

    cD0cA
        User aborted.

    cD1cA
        General error.

    cD2cA
        Failure due to a read error.

    cD3cA
        Failure due to a write error.

    cD4cA
        Failure due to a directory creation error.

    cD5cA
        Failure due to a file or directory deletion error.

    cD6cA
        Failure due to file write checks, i.e. file already exists etc.

    cD7cA
        Failure due to directory creation checks, i.e. the directory or file
        already exists.

    cD8cA
        Failure due to file delete checks, i.e. file is read only.

    cD9cA
        Failure due to source and destination files are URLs.


cEcESEE ALSO cEcA


    lslmfile-browser(3)le, lslmftp(3)le, lslmfind-file(2)le, lslmwrite-buffer(2)le, lslm&stat(4)le,
    lslm$result(5)le, lslm$temp-name(5)le.
! 2 kill-rectangle
! 2 yank-rectangle
cEcENAME cEcA


|kill-rectangle
    kill-rectangle - Delete a column of text
|yank-rectangle
    yank-rectangle - Insert a column of text
$a


cEcESYNOPSIS cEcA


    cDkill-rectanglecA (cDesc C-wcA)
    cCncA cDyank-rectanglecA (cDesc C-ycA)


cEcEDESCRIPTION cEcA


    cDkill-rectanglecA deletes a rectangle (or column) of text defined between the
    cursor and the lsset-mark(2)lmset-markle position. The text between the mark column and the
    cursor column is removed from every line between the mark line and the
    cursor line inclusive and copied to the kill buffer. The delete text may
    then be extracted from the kill buffer using lslmyank(2)le, cDyank-rectanglecA or
    lslmyank-rectangle-overwrite(3)le.

    The mark position may be ahead or behind the current cursor position. If
    the rectangle column boundary divides a tab character which spans multiple
    columns, the tab character is replaced with the equivalent number of
    spaces. Similarly if the boundary divides an unprintable character which
    is displayed using multiple characters (e.g. 'cG^AcA' for character 0x01) then
    spaces are inserted before the character to move it to the right of the
    boundary.

    cDyank-rectanglecA inserts the current kill buffer (which may or may not have
    been generated using cDkill-rectanglecA) into the current buffer in a column
    fashion. That is to say that the first line of text in the kill buffer is
    inserted into the current line of text in the current buffer from the
    current cursor column, the cursor is then moved the the next line and
    placed at the same column. The process is then repeated for the second
    line of text in the kill buffer etc.


cEcESEE ALSO cEcA


    lslmcopy-rectangle(3)le, lslmcopy-region(2)le, lslmkill-region(2)le, lslmreyank(2)le, lslmset-mark(2)le,
    lslmstring-rectangle(3)le, lslmundo(2)le, lslmyank(2)le, lslmyank-rectangle-overwrite(3)le.
! 2 command-wait
cEcENAME cEcA


    command-wait - Conditional wait command
$a


cEcESYNOPSIS cEcA


    cCncA cDcommand-waitcA


cEcEDESCRIPTION cEcA


    When a positive argument cCncA is given cDcommand-waitcA waits for cCncA milliseconds
    before returning, this wait cannot be interrupted. If a negative argument
    is given, cDcommand-waitcA waits for -cCncA milliseconds but the command will
    return if the user interrupts with any input activity (i.e. presses a
    key).

    When no argument or an argument of 0 is given cDcommand-waitcA waits until
    either the calling command's cD.waitcA command variable is undefined or it is
    set to false (cG0cA). When no argument is given events such as user input,
    screen updates etc. are still processed, this interface is best used when
    a main macro must wait and process input until an exit criteria has been
    met, the user input is best processed by setting the lslm$buffer-input(5)le
    variable to a second macro. The macro lslmgdiff(3)le uses this command in this
    way, also see a comprehensive example below.

    When no argument is given user input and screen update events are ignored,
    this is typically used when MicroEmacs is used in pipe mode, see option cD-pcA
    of lslmme(1)le, see the example below.


cEcEEXAMPLE cEcA


    The following macro code will display a message on the screen for a fixed
    5 seconds:
sB
        16 screen-poke 10 10 0 "Hello World!"
        5000 command-wait

sA
    Similarly the following macro code will display a message for up to 5
    seconds or till the user presses a key:
sB
        16 screen-poke 10 10 0 "Hello World!"
        -5000 command-wait

sA
    The following example shows how command-wait can be used to run a system
    process making MicroEmacs wait until the process has completed before
    continuing, yet giving feedback from the process to the user and allowing
    the user to kill the launched process. The process run is a recursive
    directory listing which will take a long time and give a lot of feed back,
    to kill the process with a prompt use delete-buffer (bound to 'cGC-x kcA') or
    use abort-command (bound to 'cDC-gcA') to kill immediately:
sB
        0 define-macro test-ipipe-macro
            ; add extra macro code to process output here
            !if &not @#
                ; the process has finished
                set-variable .test.wait 0
            !endif
        !emacro

        0 define-macro test-input-macro
            !if &seq @cck "redraw"
                @# screen-update
                !return
            !elif &seq @cck "callback"
                !force execute-named-command @cc
                !return
            !elif &seq @cck "idle-pick"
                !abort
            !elif &seq @cc "delete-buffer"
                !force !force set-variable #l0 @mc1 "Abort test [y/n]? " "nNyY"
                !if &and &iseq #l0 "y" .test.wait
                    !force ipipe-kill
                !endif
            !elif &seq @cc "abort-command"
                !force ipipe-kill
                set-variable .test.wait 0
            !endif
        !emacro

        define-macro test
            set-variable #l0 &con &band $system 0x100 "dir /s c:\\" "ls -R /"
            set-variable .wait 1
            !force !force !force 0x82 ipipe-shell-command #l0 "*test*" test-ipipe-macro
            set-variable #l2 $status
            !if &band #l1 1
                !force 0 delete-buffer "*cc-cmdline*"
            !endif
            find-buffer "*test*"
            set-variable $buffer-input test-input-macro
            !force !force !force command-wait
            set-variable $buffer-input ""
            ml-write "[test complete]"
        !emacro

sA
    The following macro code demonstrates how MicroEmacs can be used as a
    command-line tool, piping the output of another sub-process as it goes. In
    this example MicroEmacs executes a system directory listing command and
    prints the output to stdout using ml-write.
sB
        ml-write "Loading pipetest.emf"

        define-macro pipetest-ipipe
            !if &not @#
                end-of-buffer
            !else
                goto-alpha-mark "I"
            !endif
            ml-write &spr "In pipetest-ipipe %d %d %d" @# .line $window-line
            set-variable #l0 $window-line
            set-variable $window-line .line
            !while &les $window-line #l0
                -1 ml-write @wl
                forward-line
            !done
            set-variable .line $window-line
            !if &not @#
                -2 ml-write "Process finished"
                set-variable .start-up.wait 0
            !endif
        !emacro


        define-macro start-up
            ml-write "Got into start-up"
            set-variable .wait 1
            set-variable .pipetest-ipipe.line 1
            set-variable #l0 &con &band $system 0x100 "dir" "ls -l"
            -2 ml-write &cat "About to execute: " #l0
            0xc0 ipipe-shell-command #l0 "*test*" pipetest-ipipe
            0 command-wait
            ml-write "start-up continues"
            exit-emacs
        !emacro

        ml-write "Loading pipetest.emf complete"

sA
    To run this example, save the above macro code to cGpipetest.emfcA and then
    run:

        cDme -n -p @pipetest.emfcA

    Use the cD-PcA option for additional debug lines, printed to stderr. Windows
    users must use a console capable version of MicroEmacs, i.e. mec32.exe or
    mecw32.exe.


cEcESEE ALSO cEcA


    lslmml-write(2)le, lslm$buffer-input(5)le.
! 2 create-frame
cEcENAME cEcA


    create-frame - Create a new frame
$a


cEcESYNOPSIS cEcA


    cCncA cDcreate-framecA (cDC-x 5 1cA, cDC-x 5 2cA)


cEcEINTODUCTION cEcA


    A cDframecA in MicroEmacs is the screen canvas on which all of the windows are
    attached. MicroEmacs allows the creation of new frames, creating a new
    blank canvas, which may be populated with new windows. Frames may be
    swapped and the window layout for a given frame is preserved until the
    frame is displayed again. There are two types of frame:

    Internal
        An internal frame uses the same display window (or console) hiding any
        other frames. On creation, any existing frame is hidden and a new
        frame blank takes its place. Internal frames are supported on all
        platforms.

    External
        An external frame creates a new display window allowing both the
        original frame and new frame to be visible in different windows.
        External frames are only available on windowing platforms such as
        X-Windows and Microsoft Windows. External frames may include internal
        frames which are paged.

    This is shown in the following diagram:-

                 +-----------------+           +-----------------+
                 |                 +-+         |                 +-+
                 |                 | +-+       |                 | |
                 |                 | | |       |                 | |
                 |                 | | |       |                 | |
                 +-+---------------+ | |       +-+---------------+ |
                   +-+---------------+ |         +-----------------+
                     +-----------------+

                  Three Internal Frames        External Frame with
                                               two internal frames


    The user may move to the next frame using lslmnext-frame(2)le which swaps the
    current frame for the next frame. External frames may also be accessed via
    the window manager by selecting the window.

    A frame may be subsequently deleted with lslmdelete-frame(2)le.


cEcEDESCRIPTION cEcA


    cDcreate-framecA creates a new frame for the current MicroEmacs session, the
    new frame is assigned a unique identity lslm$frame-id(5)le which exists for the
    life of the frame.

    The numeric argument cCncA defines the type of frame to be created. An
    argument of cG2cA creates an external frame, an internal frame is created with
    an argument of cG1cA. Where no argument is specified an external frame is
    created by default on systems which support them otherwise an internal
    frame is created.


cEcENOTES cEcA


    MicroEmacs is not multi-threaded and only one frame may be active at any
    one time (the complexity of being able to run a command in one frame while
    editing in another would rapidly lead it away from the 'Micro' status).
    Therefore if a command is left active (such as a search) in one frame and
    the focus is changed to another frame the input is cCsentcA to the frame with
    the active command and the message cG[NOT FOCUS]cA appears in the message-line
    of the frame with the focus.

    cDcreate-framecA is useful in macros that rely on a window layout, as the
    macro can preserve the users current window layout by creating a new
    internal frame in which to run.


cEcESEE ALSO cEcA


    lslmdelete-frame(2)le, lslmnext-frame(2)le, lslm$frame-id(5)le.
! 2 delete-frame
cEcENAME cEcA


    delete-frame - Delete the current frame
$a


cEcESYNOPSIS cEcA


    cCncA cDdelete-framecA (cDC-x 5 0cA)


cEcEDESCRIPTION cEcA


    cDdelete-framecA deletes the current frame and the next is displayed. If there
    is no next frame then the command fails.


cEcESEE ALSO cEcA


    lslmcreate-frame(2)le, lslmnext-frame(2)le. lslm$frame-id(5)le.
! 2 next-frame
cEcENAME cEcA


    next-frame - Change the focus to the next frame
$a


cEcESYNOPSIS cEcA


    cCncA cDnext-framecA (cDC-x 5 ocA)


cEcEDESCRIPTION cEcA


    cDnext-framecA changes the focus to the next frame. The numerical argument cCncA
    can be used to select the type of frame to change to, it is a bit based
    flag defined as follows:

    cD0x01cA
        Allow the selection of an internal frame.

    cD0x02cA
        Allow the selection of an external frame.

    The default operation when cCncA is omitted is to allow the selection of
    either type of frame, but an external frame is selected in preference.
    This is not the same as giving the command an argument of cG3cA where all
    frames are circled in creation order (i.e. no priority given to an
    internal or external frame).


cEcESEE ALSO cEcA


    lslmcreate-frame(2)le, lslmdelete-frame(2)le.
! 2 Bindings
cEcEDEFAULT KEY BINDINGS cEcA


    The default key bindings are presented below in four alphabetical lists,
    one for single key bindings and one for each of the 4 bound prefixes (cGesccA,
    cGC-xcA, cGC-hcA & cGC-ccA). See lskeyNames(2)lmKey Namesle for a list of valid key names.


cESingle-Key Sequences cA


    cGbackspacecA lsforward-delete-char(2)lmbackward-delete-charle Delete the previous character.
    cGdeletecA lsforward-delete-char(2)lmforward-delete-charle Delete character under the cursor.
    cGdowncA lsforward-line(2)lmforward-linele Move to next line.
    cGendcA lsbeginning-of-buffer(2)lmend-of-bufferle Move to the end of the buffer.
    cGesccA lsprefix(2)lmprefix 1le Meta character prefix.
    cGf1cA lsosd(2)lmosdle Open top main menu.
    cGhomecA lsbeginning-of-buffer(2)lmbeginning-of-bufferle Move to the start of the buffer.
    cGinsertcA lsbuffer-mode(2)lmbuffer-modele Toggle over-write mode.
    cGleftcA lsforward-char(2)lmbackward-charle Move backward one character (left).
    cGpage-downcA lsscroll-down(2)lmscroll-downle Move forward by one screen.
    cGpage-upcA lsscroll-down(2)lmscroll-uple Move backward by one screen.
    cGreturncA lsnewline(2)lmnewlinele Insert a new line.
    cGrightcA lsforward-char(2)lmforward-charle Move forward one character (right).
    cGtabcA lstab(2)lmtable Insert a tab character.
    cGupcA lsforward-line(2)lmbackward-linele Move to previous line.

    cGS-backspacecA lsforward-delete-char(2)lmbackward-delete-charle Delete the previous character.
    cGS-deletecA lsforward-delete-char(2)lmforward-delete-charle Delete character under the cursor.
    cGS-tabcA lsbackward-delete-tab(2)lmbackward-delete-table Delete white space to previous tab-stop.

    cGC-acA lsbeginning-of-line(2)lmbeginning-of-linele Move to beginning of line.
    cGC-bcA lsforward-char(2)lmbackward-charle Move backwards by one character
    cGC-ccA lsprefix(2)lmprefixle Control character prefix.
    cGC-dcA lsforward-delete-char(2)lmforward-delete-charle Delete character under the cursor.
    cGC-ecA lsbeginning-of-line(2)lmend-of-linele Move to end of line.
    cGC-fcA lsforward-char(2)lmforward-charle Move forward one character (right).
    cGC-gcA lsabort-command(2)lmabort-commandle Abort current command.
    cGC-hcA lsprefix(2)lmprefixle Control character prefix.
    cGC-icA lsinsert-tab(2)lminsert-table Insert tab character.
    cGC-kcA lskill-line(2)lmkill-linele Delete from cursor to the end of the line.
    cGC-lcA lsrecenter(2)lmrecenterle Redraw screen with current line in the center.
    cGC-mcA lsnewline(2)lmnewlinele Insert a new line.
    cGC-ncA lsforward-line(2)lmforward-linele Move to next line (down).
    cGC-ocA lsinsert-newline(2)lminsert-newlinele Open up a blank line.
    cGC-pcA lsforward-line(2)lmbackward-linele Move to previous line (up).
    cGC-qcA lsquote-char(2)lmquote-charle Insert literal character.
    cGC-rcA lsisearch-forward(2)lmisearch-backwardle Start incremental search backwards.
    cGC-scA lsisearch-forward(2)lmisearch-forwardle Start incremental search forwards.
    cGC-tcA lstranspose-chars(2)lmtranspose-charsle Transpose two letters.
    cGC-ucA lsuniversal-argument(2)lmuniversal-argumentle Repeat the next command cCncA times (default is 4).
    cGC-vcA lsscroll-down(2)lmscroll-downle Move forward by one screen.
    cGC-wcA lskill-region(2)lmkill-regionle Delete a marked region.
    cGC-xcA lsprefix(2)lmprefixle Control character prefix.
    cGC-ycA lsyank(2)lmyankle Restore what was copied or deleted.
    cGC-zcA lsscroll-down(2)lmscroll-uple Move backward by one screen.
    cGC-_cA lsundo(2)lmundole Undo the previous edit.
    cGC-spacecA lsset-mark(2)lmset-markle Set start of a region.
    cGC-downcA lsforward-line(2)lmforward-linele Move forward five lines.
    cGC-leftcA lsforward-word(2)lmbackward-wordle Move one word backward.
    cGC-page-downcA lsscroll-next-window-down(2)lmscroll-next-window-downle Scroll next window down a page.
    cGC-page-upcA lsscroll-next-window-down(2)lmscroll-next-window-uple Scroll the next window up a page.
    cGC-rightcA lsforward-word(2)lmforward-wordle Move one word forward.
    cGC-upcA lsforward-line(2)lmbackward-linele Move backward 5 lines.

    cGA-ecA lsfile-browser(3)lmfile-browserle Browse the file system.
    cGA-rcA lsreplace-all-string(3)lmreplace-all-stringle Replace string with new string in a list of files.
    cGA-downcA lsscroll-down(2)lmscroll-downle Scroll the current window down one line.
    cGA-leftcA lsscroll-left(2)lmscroll-leftle Scroll the current window left one character.
    cGA-rightcA lsscroll-left(2)lmscroll-rightle Scroll the current window right one character.
    cGA-upcA lsscroll-down(2)lmscroll-uple Scroll the current window up one line.


cEesc Prefix Sequences cA


    cGesc !cA lspipe-shell-command(2)lmpipe-shell-commandle Pipe a shell command to a buffer.
    cGesc %cA lsquery-replace-string(2)lmquery-replace-stringle Search and replace a string - with query.
    cGesc $cA lsspell-buffer(3)lmspell-wordle Spell a word.
    cGesc .cA lsset-mark(2)lmset-markle Set the start of a region.
    cGesc /cA lsexecute-file(2)lmexecute-filele Execute script lines from a file.
    cGesc <cA lsbeginning-of-buffer(2)lmbeginning-of-bufferle Move to the start of the buffer.
    cGesc >cA lsbeginning-of-buffer(2)lmend-of-bufferle Move to the end of the buffer.
    cGesc ?cA lshelp(2)lmhelple Help - high level introduction to MicroEmacs.
    cGesc @cA lspipe-shell-command(2)lmpipe-shell-commandle Pipe a shell command to a buffer.
    cGesc [cA lsforward-paragraph(2)lmbackward-paragraphle Goto the beginning of the paragraph.
    cGesc \cA lsipipe-shell-command(2)lmipipe-shell-commandle Incrementally pipe a shell command to a buffer.
    cGesc ]cA lsforward-paragraph(2)lmforward-paragraphle Move forward one paragraph
    cGesc ^cA lsdelete-indentation(3)lmdelete-indentationle Join 2 lines deleting white spaces.
    cGesc bcA lsforward-word(2)lmbackward-wordle Move one word backwards
    cGesc ccA lscapitalize-word(2)lmcapitalize-wordle Capitalize first letter of a word
    cGesc dcA lsforward-kill-word(2)lmforward-kill-wordle Delete word the cursor is on.
    cGesc ecA lsset-encryption-key(2)lmset-encryption-keyle Reset the encryption key.
    cGesc fcA lsforward-word(2)lmforward-wordle Move one word forward.
    cGesc gcA lsgoto-line(2)lmgoto-linele Goto a line.
    cGesc icA lstab(2)lmtable Insert a tab character.
    cGesc kcA lsglobal-bind-key(2)lmglobal-bind-keyle Bind a key to a command or macro.
    cGesc lcA lscapitalize-word(2)lmlower-case-wordle Lowercase word.
    cGesc mcA lsglobal-mode(2)lmglobal-modele Toggle a global mode.
    cGesc ncA lsforward-paragraph(2)lmforward-paragraphle Move forward one paragraph
    cGesc ocA lsfill-paragraph(2)lmfill-paragraphle Reformat (fill) current paragraph.
    cGesc pcA lsforward-paragraph(2)lmbackward-paragraphle Goto the beginning of the paragraph.
    cGesc qcA lsifill-paragraph(3)lmifill-paragraphle Reformat (fill) current paragraph.
    cGesc rcA lsreplace-string(2)lmreplace-stringle Search and replace text (no query).
    cGesc tcA lsfind-tag(2)lmfind-tagle Find a tag.
    cGesc ucA lscapitalize-word(2)lmupper-case-wordle Uppercase word.
    cGesc vcA lsscroll-down(2)lmscroll-downle Move to the previous screen.
    cGesc wcA lscopy-region(2)lmcopy-regionle Copy region to the kill buffer.
    cGesc xcA lsexecute-named-command(2)lmexecute-named-commandle Execute the named command.
    cGesc ycA lsreyank(2)lmreyankle Kill current yank data and restore previous kill buffer data.
    cGesc zcA lsquick-exit(2)lmquick-exitle Save all buffers and exit.

    cGesc ~cA lsbuffer-mode(2)lmbuffer-modele Remove edited status from current buffer.
    cGesc backspacecA lsforward-kill-word(2)lmbackward-kill-wordle Delete the word under the cursor.
    cGesc esccA lsexpand-abbrev(2)lmexpand-abbrevle Expand an abbreviation.
    cGesc spacecA lsset-mark(2)lmset-markle Set the start of a region.

    cGesc C-ccA lscount-words(2)lmcount-wordsle Count words in a region.
    cGesc C-fcA lsgoto-matching-fence(2)lmgoto-matching-fencele Reposition the cursor at an opposing bracket.
    cGesc C-gcA lsabort-command(2)lmabort-commandle Abort current command.
    cGesc C-icA lstab(2)lmtable Insert tab character.
    cGesc C-kcA lsglobal-bind-key(2)lmglobal-unbind-keyle Unbind a key from a command or macro
    cGesc C-ncA lschange-buffer-name(2)lmchange-buffer-namele Rename current buffer.
    cGesc C-rcA lsquery-replace-string(2)lmquery-replace-stringle Search and replace with query.
    cGesc C-vcA lsscroll-next-window-down(2)lmscroll-next-window-downle Scroll next window down a page.
    cGesc C-wcA lskill-paragraph(2)lmkill-paragraphle Delete current paragraph.
    cGesc C-zcA lsscroll-next-window-down(2)lmscroll-next-window-uple Scroll the next window up a page.

    cGesc A-rcA lsquery-replace-all-string(3)lmquery-replace-all-stringle Query replace string in a list of files.


cEC-x Prefix Sequences cA


    cGC-x #cA lsfilter-buffer(2)lmfilter-bufferle Filter the buffer through a shell filter.
    cGC-x (cA lsstart-kbd-macro(2)lmstart-kbd-macrole Start recording a keyboard macro.
    cGC-x )cA lsstart-kbd-macro(2)lmend-kbd-macrole Stop recording a keyboard macro.
    cGC-x /cA lsisearch-forward(2)lmisearch-forwardle Start incremental search forwards.
    cGC-x 0cA lsdelete-window(2)lmdelete-windowle Delete the current window.
    cGC-x 1cA lsdelete-window(2)lmdelete-other-windowsle Delete other windows.
    cGC-x 2cA lssplit-window-vertically(2)lmsplit-window-verticallyle Split the current window into two.
    cGC-x 3cA lssplit-window-horizontally(2)lmsplit-window-horizontallyle Split current window horizontally into
    two.
    cGC-x 5-1cA lscreate-frame(2)lmcreate-framele Create a new internal frame.
    cGC-x 5-2cA lscreate-frame(2)lmcreate-framele Create a new external frame.
    cGC-x 8cA lsfind-bfile(3)lmfind-cfilele Find and load an encrypted file for editing.
    cGC-x 9cA lsfind-bfile(3)lmfind-bfilele Find and load a file for binary editing.
    cGC-x <cA lsscroll-left(2)lmscroll-leftle Scroll the window left by one screen width.
    cGC-x =cA lsbuffer-info(2)lmbuffer-infole Show cursor position information
    cGC-x >cA lsscroll-left(2)lmscroll-rightle Scroll the window right by one screen width.
    cGC-x ?cA lsdescribe-key(2)lmdescribe-keyle Describe binding of command to key.
    cGC-x @cA lspipe-shell-command(2)lmpipe-shell-commandle Pipe a shell command to buffer.
    cGC-x [cA lsscroll-down(2)lmscroll-uple Move backward by one screen.
    cGC-x ]cA lsscroll-down(2)lmscroll-downle Move forward by one screen.
    cGC-x ^cA lschange-window-depth(2)lmgrow-window-verticallyle Enlarge the current window by a line.
    cGC-x `cA lsget-next-line(2)lmget-next-linele Find the next command line.
    cGC-x acA lsgoto-alpha-mark(2)lmgoto-alpha-markle Move the cursor to an alphabetic mark.
    cGC-x bcA lsnext-buffer(2)lmfind-bufferle Switch window to a buffer.
    cGC-x ccA lsshell(2)lmshellle Start a new command processor.
    cGC-x ecA lsexecute-kbd-macro(2)lmexecute-kbd-macrole Execute a macro.
    cGC-x hcA lshunt-forward(2)lmhunt-forwardle Continue search in forward direction.
    cGC-x kcA lsdelete-buffer(2)lmdelete-bufferle Delete buffer.
    cGC-x mcA lsbuffer-mode(2)lmbuffer-modele Toggle a local buffer mode.
    cGC-x ncA lschange-file-name(2)lmchange-file-namele Rename current buffer file name.
    cGC-x ocA lsnext-window(2)lmnext-windowle Move to the next window.
    cGC-x pcA lsnext-window(2)lmprevious-windowle Move to the previous window.
    cGC-x qcA lskbd-macro-query(2)lmkbd-macro-queryle Query keyboard macro.
    cGC-x rcA lssearch-forward(2)lmsearch-backwardle Search in a reverse direction.
    cGC-x scA lssearch-forward(2)lmsearch-forwardle Search in a forward direction.
    cGC-x ucA lsundo(2)lmundole Undo the previous edit.
    cGC-x vcA lsset-variable(2)lmset-variablele Assign a new value to a variable.
    cGC-x wcA lschange-window-depth(2)lmresize-window-verticallyle Resize the window.
    cGC-x xcA lsnext-buffer(2)lmnext-bufferle Switch to the next buffer.
    cGC-x zcA lschange-window-depth(2)lmgrow-window-verticallyle Enlarge the current window.
    cGC-x {cA lschange-window-width(2)lmshrink-window-horizontallyle Shrink current window horizontally.
    cGC-x }cA lschange-window-width(2)lmgrow-window-horizontallyle Enlarge current window horizontally.

    cGC-x C-acA lsset-alpha-mark(2)lmset-alpha-markle Mark the current position with an alphabetic mark.
    cGC-x C-bcA lslist-buffers(2)lmlist-buffersle Display buffer list.
    cGC-x C-ccA lsquick-exit(2)lmsave-buffer-exit-emacsle Exit MicroEmacs 2009.
    cGC-x C-ecA lsexecute-kbd-macro(2)lmexecute-kbd-macrole Execute a macro.
    cGC-x C-fcA lsfind-file(2)lmfind-filele Find a file and load into buffer.
    cGC-x C-gcA lsabort-command(2)lmabort-commandle Abort current command.
    cGC-x C-hcA lshunt-forward(2)lmhunt-backwardle Resume search in backwards direction.
    cGC-x C-icA lsinsert-file(2)lminsert-filele Insert file into the current buffer.
    cGC-x C-lcA lscapitalize-word(2)lmlower-case-regionle Lowercase region.
    cGC-x C-ncA lsscroll-down(2)lmscroll-downle Scroll the current window down one line.
    cGC-x C-ocA lsdelete-blank-lines(2)lmdelete-blank-linesle Delete blank lines about the cursor.
    cGC-x C-pcA lsscroll-down(2)lmscroll-uple Scroll the current window up one line.
    cGC-x C-qcA lsrcs-file(2)lmrcs-filele Interact with RCS to check in/out a file.
    cGC-x C-rcA lsread-file(2)lmread-filele Read a file from disk.
    cGC-x C-scA lssave-buffer(2)lmsave-bufferle Save current file to disk.
    cGC-x C-tcA lstranspose-chars(2)lmtranspose-linesle Swap adjacent lines.
    cGC-x C-ucA lscapitalize-word(2)lmupper-case-regionle Uppercase region.
    cGC-x C-vcA lsview-file(2)lmview-filele Read a file for viewing (read only).
    cGC-x C-wcA lswrite-buffer(2)lmwrite-bufferle Write a file to disk witn new name.
    cGC-x C-xcA lsexchange-point-and-mark(2)lmexchange-point-and-markle Exchange cursor with mark position.
    cGC-x C-ycA lsinsert-file-name(2)lminsert-file-namele Insert filename into current buffer.
    cGC-x C-zcA lschange-window-depth(2)lmshrink-window-verticallyle Reduce size of current window.


cEC-h Prefix Sequences cA


    cGC-h acA lscommand-apropos(2)lmcommand-aproposle List commands involving a concept.
    cGC-h bcA lsdescribe-bindings(2)lmdescribe-bindingsle Show current command/key binding.
    cGC-h ccA lslist-commands(2)lmlist-commandsle List available commands.
    cGC-h dcA lsdescribe-variable(2)lmdescribe-variablele Describe current setting of a variable.
    cGC-h kcA lsdescribe-key(2)lmdescribe-keyle Describe keyboard binding.
    cGC-h vcA lslist-variables(2)lmlist-variablesle List defined variables.

    cGC-h C-ccA lshelp(2)lmhelp-commandle Display command help information.
    cGC-h C-icA lshelp(2)lmhelp-itemle Display item help information.
    cGC-h C-vcA lshelp(2)lmhelp-variablele Display variable help information.
! 2 Compatibility
cEcECOMPATIBILITY cEcA


    JASSPA MicroEmacs is based on the original version of cDMicroEMACScA produced
    by Danial Lawrence at revision 3.8, the source files were obtained in
    approximately 1990. The exact origin of the files is unknown. In that
    period of time the source files have undergone an awful lot of change,
    without reference to the subsequent releases made of MicroEMACS by Danial
    Lawrence (due to no network access). As a result the JASSPA version of
    cDMicroEmacscA does not include any modifications or features that may have
    been implemented since. This version of cDMicroEmacscA has been tailored to
    suite the requirements of a small group of individuals who have used the
    editor on a daily basis across a limited number of platforms, for a
    variety of very different tasks and operating requirements.

    This version of MicroEmacs is biased towards UNIX environments, MS-DOS and
    Microsoft Windows ports have been performed however they are heavily
    influenced by UNIX and inherit UNIX characteristics wherever possible. The
    intention is that programmers, and alike, may move across platforms using
    a common editor environment without being frustrated by the idiosyncrasies
    of different platforms. The most noticeable platform is the Microsoft
    Windows platform which mimics the X-Windows cut and paste mechanism within
    the MicroEmacs environment. If you want a Windows style environment then
    use cDNotepad(1)cA or cDWordpad(1)cA, this editor is not for you !!

    The gross changes to cDMicroEmacs 2009cA are summarized as follows:-

        * Macro language interpreter re-written allowing an unlimited number
          of named macros to be supported. The macro implementation allows new
          commands to be created by the user, as opposed to continually
          extending the underlying command set. The named macros are
          transparent to the user, appearing as built in commands on the
          command line. Macro command set significantly increased. Support for
          global, buffer and register variables within the macro language.

        * Display drivers re-written providing color hilighting support on
          most platforms. A macro interface allows information to be written
          directly to the display canvas allowing the screen to be annotated
          with additional transient information.

        * Support for X-Window screen type in UNIX environments. Microsoft
          Window's environments (3.x, '95, NT) treated in the same was as
          X-Windows - this may be unorthodox for existing Window's users, UNIX
          users will find it more comfortable.

        * Introduction of integrated spell checker. Support includes
          correction word guessing, word auto-correction and double word
          detection. Ignore and personal dictionaries supported.

        * Horizontal window splitting.

        * Introduction of scroll bars on all platforms that support a mouse.
          The scroll bar implementation is platform independent.

        * Command and file completion available on all platforms. Most
          commands support a command history allowing previous command
          invocations to be recalled.

        * Session history file kept, allowing the previous edit session to be
          reinstated.

        * Undo capability, allows previous edits to be undone when mistakes
          are made.

        * Backup capability, Includes a periodic timed backup while an editing
          session is in progress. The timed backup is automatically recovered
          by the next session in situations where the system (or editor)
          crashes.

        * A regular expression incremental search becomes the default search
          forward mechanism.

        * Support for abbreviation files allowing frequently used constructs
          to be automatically expanded.

        * Automatic time stamping of files, allowing the edit time to be
          automatically maintained in the source file(s).

        * Introduction of an electric 'C' mode. Editor intelligently handles
          the layout of 'C' files (under user control).

        * Improved documentation text mode providing left/right/center and
          both justification methods with inclusion for bullet points.
          Automatic justification may be continually performed as text is
          entered, thereby maintaining the paragraph in the correct format.

        * Integrated on-line help facilities. All commands are documented
          on-line. New macros may be documented within the macro files and
          become part of the help system.

        * File type determination system, based on either the file name or
          embedded file text allows file type specific macros (hooks) to be
          applied, thereby configuring the editor into the correct mode for
          the file type.

        * Introduction of special MicroEmacs search path allowing all of the
          standard configuration files to be utilized from a shared directory.

    The name space of JASSPA MicroEmacs differs from the original MicroEMACS
    and has become more compliant with the GNU implementation of Emacs. A list
    of the original MicroEMACS verses the new command name set is as follows,
    executing the compatibility macro file cGmeme3_8.emfcA will create macro
    versions of these commands:

        cDadd-global-modecA => lsglobal-mode(2)lmglobal-modele
        cDadd-modecA => lsbuffer-mode(2)lmbuffer-modele
        cDaproposcA => lscommand-apropos(2)lmcommand-aproposle
        cDbackward-charactercA => lsforward-char(2)lmbackward-charle
        cDbegin-macrocA => lsstart-kbd-macro(2)lmstart-kbd-macrole
        cDbeginning-of-filecA => lsbeginning-of-buffer(2)lmbeginning-of-bufferle
        cDbind-to-keycA => lsglobal-bind-key(2)lmglobal-bind-keyle
        cDbuffer-positioncA => lsbuffer-info(2)lmbuffer-infole
        cDcase-region-lowercA => lscapitalize-word(2)lmlower-case-regionle
        cDcase-region-uppercA => lscapitalize-word(2)lmupper-case-regionle
        cDcase-word-capitalizecA => lscapitalize-word(2)lmcapitalize-wordle
        cDcase-word-lowercA => lscapitalize-word(2)lmlower-case-wordle
        cDcase-word-uppercA => lscapitalize-word(2)lmupper-case-wordle
        cDchange-screen-depthcA => lschange-frame-depth(2)lmchange-frame-depthle
        cDchange-screen-widthcA => lschange-frame-depth(2)lmchange-frame-widthle
        cDclear-message-linecA => lsml-write(2)lm0 ml-writele
        cDctlx-prefixcA => lsprefix(2)lmprefix 2le
        cDdelete-global-modecA => lsglobal-mode(2)lmglobal-modele
        cDdelete-modecA => lsbuffer-mode(2)lmbuffer-modele
        cDdelete-next-charactercA => lsforward-delete-char(2)lmforward-delete-charle
        cDdelete-next-wordcA => lsforward-kill-word(2)lmforward-kill-wordle
        cDdelete-previous-charactercA => lsforward-delete-char(2)lmbackward-delete-charle
        cDdelete-previous-wordcA => lsforward-kill-word(2)lmbackward-kill-wordle
        cDend-macrocA => lsstart-kbd-macro(2)lmend-kbd-macrole
        cDend-of-filecA => lsbeginning-of-buffer(2)lmend-of-bufferle
        cDexecute-command-linecA => lsexecute-buffer(2)lmexecute-linele
        cDexecute-macrocA => lsexecute-kbd-macro(2)lmexecute-kbd-macrole
        cDexecute-macro-#cA => cCDeletedcA
        cDfile-name-insertcA => lsinsert-file-name(2)lminsert-file-namele
        cDforward-charactercA => lsforward-char(2)lmforward-charle
        cDgrow-windowcA => lschange-window-width(2)lmgrow-window-horizontallyle
        cDhandle-tabcA => lstab(2)lmtable
        cDi-shellcA => lsshell(2)lmshellle
        cDincremental-searchcA => lsisearch-forward(2)lmisearch-forwardle
        cDkill-to-end-of-linecA => lskill-line(2)lmkill-linele
        cDmeta-prefixcA => lsprefix(2)lmprefix 1le
        cDmove-window-downcA => lsscroll-down(2)lmscroll-downle
        cDmove-window-upcA => lsscroll-down(2)lmscroll-uple
        cDname-buffercA => lschange-buffer-name(2)lmchange-buffer-namele
        cDnext-linecA => lsforward-line(2)lmforward-linele
        cDnext-pagecA => lsscroll-down(2)lmscroll-downle
        cDnext-paragraphcA => lsforward-paragraph(2)lmforward-paragraphle
        cDnext-wordcA => lsforward-word(2)lmforward-wordle
        cDopen-linecA => lsinsert-newline(2)lminsert-newlinele
        cDpipe-commandcA => lspipe-shell-command(2)lmpipe-shell-commandle
        cDprevious-linecA => lsforward-line(2)lmbackward-linele
        cDprevious-pagecA => lsscroll-down(2)lmscroll-uple
        cDprevious-paragraphcA => lsforward-paragraph(2)lmbackward-paragraphle
        cDprevious-wordcA => lsforward-word(2)lmbackward-wordle
        cDquote-charactercA => lsquote-char(2)lmquote-charle
        cDredraw-displaycA => lsrecenter(2)lmrecenterle
        cDrestore-windowcA => lsset-position(2)lmgoto-positionle
        cDreverse-incremental-searchcA => lsisearch-forward(2)lmisearch-backwardle
        cDsave-filecA => lssave-buffer(2)lmsave-bufferle
        cDsave-windowcA => lsset-position(2)lmset-positionle
        cDscroll-next-downcA => lsscroll-next-window-down(2)lmscroll-next-window-downle
        cDscroll-next-upcA => lsscroll-next-window-down(2)lmscroll-next-window-uple
        cDsearch-reversecA => lssearch-forward(2)lmsearch-backwardle
        cDselect-buffercA => lsnext-buffer(2)lmfind-bufferle
        cDsetcA => lsset-variable(2)lmset-variablele
        cDshrink-windowcA => lschange-window-depth(2)lmshrink-window-verticallyle
        cDsplit-current-windowcA => lssplit-window-vertically(2)lmsplit-window-verticallyle
        cDtop-bottom-switchcA => cCDeletedcA
        cDtranspose-characterscA => lstranspose-chars(2)lmtranspose-charsle
        cDunbind-keycA => lsglobal-bind-key(2)lmglobal-unbind-keyle
        cDupdate-screencA => lsscreen-update(2)lmscreen-updatele
        cDwrite-messagecA => lsml-write(2)lmml-writele
! 2 fileHooks
cEcEFILE HOOKS cEcA


    File hooks provide a mechanism to automatically invoke a set of macros for
    a given buffer type when the following events occur:

        * Loading of a file into a buffer
        * Moving into a buffer (i.e. making a buffer current)
        * Moving out of a buffer (i.e. making another buffer current)
        * Deleting an active buffer

    The file hook selection (see below) is performed on the file name /
    extension and on the textual content of the buffer using lsadd-file-hook(2)lmadd-file-hookle.

    Refer to lslanguageTemplates(2)lmLanguage Templatesle for a description of how the file hooks are
    used to define a new template for a new text format.

    The hook macros allow buffer modes and highlighting, applicable to the
    text type of the file, to be applied to the buffer. In addition, the
    associated hook macros may be located in a separate file and are loaded on
    demand when the file reading determines that a set of hook macros are
    required.

    Consider a file hook definition of the form;
sB
        add-file-hook ".c .h" "fhook-c"

sA
    which binds the file hook cDfhook-ccA to any files that are loaded with the
    extension cD.ccA and cD.hcA. The operations undertaken by MicroEmacs 2009 are
    defined as follows when a file cGfoo.ccA is loaded:-

        * Attempt to load file cGfoo.ccA, if cGfoo.ccA is not found then create a new
          buffer and assign file name cGfoo.ccA.

        * If cGfoo.ccA is found then load file into buffer. Search the first
          line(s) of the buffer for magic hook text (cCadd-file-hookcA with
          argument).

        * If magic hook was not found then determine hook name from the file
          extension (cCadd-file-hookcA information).

        * If a hook command is located, assign the file hook cDfhook-ccA to the
          buffer, assign the buffer entry (begin) hook macro of cDbhook-ccA;
          assign a buffer exit hook of cDehook-ccA.

        * If the macro cDfhook-ccA is undefined then execute the macro file
          cDhkc.emfcA from the MicroEmacs home directory in an attempt to load the
          macro. If the file cDmyc.emfcA is defined, then the modifications to the
          language template are applied after cDhkc.emfcA is loaded.

        * If the macro cDfhook-ccA is (now) defined then cGfoo.ccA is TEMPORARILY made
          the current buffer and the file hook macro cDfhook-ccA is executed to
          completion and the previous current buffer is restored. [cCTEMPORARYcA
          here implies that no buffer hooks are executed on the flip in/out of
          cGfoo.ccA].

        * The current buffer is officially swapped to cGfoo.ccA. At this point the
          cCehookcA of the old current buffer is executed (while its still
          current) and then cGfoo.ccA is swapped in to become the current buffer;
          the begin buffer hook cCbhook-cmodecA is then executed for cGfoo.ccA (if it
          exists).

        * If the user moves to another buffer execute the end hook macro
          cDehook-cmodecA (if it exists) and move to the new buffer, executing
          it's begin hook.

        * If the user subsequently returns to buffer cGfoo.ccA execute the
          previous buffers end hook macro, set the current buffer to cCfoo.ccA and
          execute the begin hook macro cDbhook-ccA (if it exists).

        * If the user kills buffer cGfoo.ccA, if cGfoo.ccA is the current buffer then
          an alternative buffer is made current, cGehookcA and cGbhookcA executed as
          normal. If macro cDdhook-ccA is defined then cGfoo.ccA is TEMPORARILY made
          the current buffer and the delete hook macro cDdhook-ccA is executed to
          completion and the previous current buffer is restored.

    The name of the file hook macro name is important, hook commands must
    commence with the text cDfhook-cAcCmodecA where cCmodecA is an identifier for the
    operating mode. The name space is decomposed as follows:-

        * The initial cDfcA is removed and replaced with cDbcA for the begin hook
          macro and cDecA for the end hook macro.

        * When the cDfhookcA macro is undefined the cCmodecA component is removed and
          the file cDhkcAcCmodecAcD.emfcA is executed from the MicroEmacs home directory
          in an attempt to define the macro.

    The cDfhook-cA nomenclature may be omitted provided that the name is less than
    6 characters, however the file, begin and end hook macros MUST commence
    with cDfcA, cDbcA and cDecA respectively. In addition the macros must be defined as no
    auto file loading is performed.


cEBuffer Hook Variables cA


    The macros bound to a buffer may be interrogated, the variables
    lslm$buffer-fhook(5)le, lslm$buffer-bhook(5)le, lslm$buffer-ehook(5)le and lslm$buffer-dhook(5)le
    contain the names of any associated macro attached as a macro hooks,
    defining the cCfilecA, cCbegincA, cCendcA and cCdeletecA hooks respectively. If a macro is
    not bound then the empty string cG""cA is returned. Setting the variables has
    the effect of defining the hook and is a method by which the buffer hooks
    may be affected after the buffer has been loaded.


cEDetermination of a new file cA


    The cCfilecA hook cDfhook-XXXcA numeric argument may be used to determine if the
    file associated with a buffer is a new file created by the user, or an
    existing file. Typically this distinction is used to determine whether a
    boiler template is added to the file or not. The macro argument cD@#cA is
    defined as zero (0) if this is a new file that has been created, or
    non-zero otherwise.

    The macro argument status is typically tested on entry to the macro as
    follows:-
sB
        define-macro fhook-mode
            !if &not @#
                ; This is a new file. Do new file things
            !else
                ; This is an existing file
            !endif
            ; Set up bindings
        !emacro

sA
    An example of a generic cDhookcA file is given at the end of this section
    which elaborates on the file hooks.


cEBegin and End hooks cA


    The cCbegincA and cCendcA hooks are usually used to save and restore global states
    which require special settings for a particular buffer type. This
    typically involves saving and restoring global variables which are used by
    other buffers in a different configuration. For example the following is
    used to reformat the time stamp string; the time stamp is a global
    variable lslm$timestamp(5)le and if it is changed in one buffer, it must be
    restored ready for another. In this case the old time stamp is retained in
    a local buffer variable whenever the buffer is entered, the time stamp is
    then modified for the buffers requirements. On exit from the buffer the
    old time stamp format is restored to it's former state.
sB
        0 define-macro bhook-foo
            set-variable .timestamp $timestamp      ; Save old time stamp.
            set-variable $timestamp "19%Y/%M/%D %h:%m:%s"
        !emacro

        0 define-macro ehook-foo
            set-variable $timestamp .bhook-foo.timestamp
        !emacro

sA
    Note that in both cases the lslmdefine-macro(2)le invocation is defined as zero,
    this merely hides the macro from the command line since both are private
    macros not normally invoked by the user.


cEcEFILE HOOK SELECTION cEcA


    MicroEmacs 2009 may be reconfigured to operate in different modes
    (referred to a cCMajor ModescA in GNU cDemacs(1)cA) using the lsadd-file-hook(2)lmmacro file hooksle.
    The file hooks allow the working environment to be customized for the
    editing of text of a particular sort, by importing text specific macros,
    key rebinding and highlighting.

    MicroEmacs 2009, by default, loads a file into a buffer with default
    global modes with no highlighting. There are no mode specific key
    bindings, variable settings, macros or highlights, buffer interaction
    behaves in it's default state. The state of the buffer interaction may be
    modified through the use of the buffer modes (see lslmOperating Modesle), for
    example the 'C' programming language automatic indent lslmindent(2)le changes
    the characteristics of the cGtabcA character and performs language specific
    indentation of statements. When a text specific set of highlighting rules
    are applied to the buffer, the text becomes emphasized through the use of
    color applied selectively to the text i.e. comments, keywords, strings are
    shown in different colors, allowing them to be differentiated without
    studying the content.

    Setting the operating mode of the buffer would be tedious to perform from
    the command line, instead MicroEmacs 2009 uses three different prioritized
    criteria to endeavor to select the correct operating mode. The operating
    mode is applied to the buffer by execution of a set of file specific
    macros, referred to a hook commands. The selection criteria of the hook
    commands is performed as follows, ordered in lowest to highest priority:-

    cDFile NamecA
        MicroEmacs 2009 uses the filename and/or the file extension to select
        a start-up hook command. File names and extensions are bound to a set
        of macro hooks in a space separated list e.g.

            lsadd-file-hook(2)lmadd-file-hookle "cDc cppcA" "cDfhook-cmodecA"
            lsadd-file-hook(2)lmadd-file-hookle "cDdoc txt READMEcA" "cDfhook-doccA"

        The space separated list of names are interpreted as either file
        extensions or filenames. In this case any file with the extension cD.ccA,
        cD.cppcA is bound to a file hook called cDfhook-cmodecA e.g. cGfoo.ccA. Similarly
        files with the extension cD.doccA or cD.txtcA are interpreted as plain text
        documents and are bound to cDfhook-doccA. e.g. cGfoo.txtcA. The entry cDREADMEcA
        that exists in the documentation hook list may refer to a file cGREADMEcA
        and also cGfoo.READMEcA, both cases invoke the document hook.

        The file selection is the lowest priority selection criteria but
        usually satisfies most mode selection requirements.

    cDMagic StringscA
        There are cases when file extensions may be omitted from files,
        typically these files include an identifier, or magic string, on the
        first line of the file which is used to identify the file to the
        operating system or application e.g. shell scripts under UNIX.
        MicroEmacs 2009 automatically interrogates the top of every file that
        is loaded to locate some form of identification string. The
        identification strings are defined in a similar way to the file name
        hooks, except instead of defining a file extension the location and
        text content of the identifier is defined:

            1 lsadd-file-hook(2)lmadd-file-hookle "cD#!/bin/shcA" "cDfhook-shellcA"
            1 lsadd-file-hook(2)lmadd-file-hookle "cD#!/usr/local/bin/wishcA" "cDfhook-tclcA"

        In this case, any file that commences with "cD#!/bin/shcA" is interpreted
        as a shell script and invokes the shell hook cDfhook-shellcA. Where the
        identifier does not appear on the first non-blank line, the argument
        may be increased to the number of lines to be searched. Also it the
        magic sting should be search for without lslmexact(2m)le mode then the
        argument should be negated, e.g.

            -4 cDadd-file-hookcA "<html>" "cDfhook-htmlcA"

        invokes cDfhook-htmlcA whenever "cG<html>cA", "cG<HTML>cA" etc. is found in the
        first 4 lines of a file header, e.g.:

            <!-- Comment line -->
            <HtMl>


        A match on a string identifier is assigned a higher priority than the
        file extension. It is recommended that magic strings are only used
        where there are no predefined file extensions, or conflicts exist
        between files with the same extension containing data interpreted in a
        different context.

    cDExplicit StringscA
        The last method allows an explicit identifier string to be embedded
        into the text of the file informing MicroEmacs 2009 which mode it
        should adopt. GNU Emacs supports this (see cDMajor ModecA in the GNU Emacs
        documentation) type of operation by insertion of strings of the form:

            cD-*-cA cCmodecA cD-*-cA

        Where cCmodecA represents the major mode within GNU Emacs. The same format
        as used by cDMagic StringscA can be used to find and extract the cCmodecA,
        e.g.:

            cD-1cA lsadd-file-hook(2)lmadd-file-hookle "cD-[*!]-[ \t]nroff.*-[*!]-cA" "cDfhook-nroffcA"

        The definition would detect the GNU Emacs mode defined in an Nroff
        file e.g.

            .\" -*- nroff -*- "
            .TH man 1
            .SH NAME
            ...

        It should be stressed that the cD-*-cA syntax belongs to GNU Emacs and NOT
        MicroEmacs 2009, MicroEmacs 2009 provides a mechanism to locate,
        extract and interpret the string. The cD-*-cA syntax should only be
        applied to files if it is known that the cCmodecA is a GNU mode.

        A MicroEmacs 2009 specific string is also provided, defined as:

            cD-!-cA cCmodecA cD-!-cA

        where cCmodecA is an arbitrary string defined by cCadd-file-hookcA. User
        defined modes may be created and assigned to files with this syntax,
        this does not conflict with the GNU Emacs command. For example to
        assign a new mode cCmymodecA to a file we would define the following:-

            cD-1cA lsadd-file-hook(2)lmadd-file-hookle "cD-!-[ \t]mymode.*-!-cA" "cDfhook-mymodecA"

        Files containing a the following identifier would be loaded with
        cCmymodecA hook:

            # -!- mymode -!-
            #
            # Last Modified:  <120683.1014>


cEcEFILE HOOK SCRIPTS cEcA


    The buffer hook files cDhkcAcCnamecAcD.emfcA typically follow a standard layout, and
    are generally associated with hi-lighting as follows, cDmodecA in this case is
    the name of the file mode associated with the file:-
sB
        !if &seq .hilight.mode "ERROR"
            set-variable .hilight.mode &pinc .hilight.next 1
        !endif
        ;
        ; Define the hilighting
        ;
        0 hilight .hilight.mode 1                $global-scheme
        hilight .hilight.mode 2 "\*\*"           .scheme.comment
        hilight .hilight.mode 4 "\"" "\"" "\\"   .scheme.string
        hilight .hilight.mode 0 "'.'"            .scheme.quote

        hilight .hilight.mode 1 "if"             .scheme.keyword
        hilight .hilight.mode 1 "elif"           .scheme.keyword
        hilight .hilight.mode 1 "else"           .scheme.keyword
        ...

        ; Reset the hilighting printer format and define the color bindings.
        0 hilight-print .hilight.mode
        hilight-print .hilight.mode "i"  .scheme.comment
        hilight-print .hilight.mode "b"  .scheme.keyword .scheme.variable
        hilight-print .hilight.mode "bi" .scheme.string .scheme.quote
        ...

        ; Define the indentation tokens
        0 indent  .hilight.mode 2 10
        indent .hilight.mode n "if" 4
        indent .hilight.mode s "elif" -4
        indent .hilight.mode s "else" -4
        indent .hilight.mode o "endif" -4
        indent .hilight.mode n "while" 4
        ...

        define-macro fhook-mode
            ; if arg is 0 this is a new file so add template
            !if &not @#
                etfinsrt "mode"
            !endif
            set-variable $buffer-hilight .hilight.mode
            set-variable $buffer-indent .hilight.mode
            1 buffer-mode "time"
            1 buffer-mode "indent"
            buffer-abbrev-file "mode"
        !emacro

sA
    The previous example shows how the cDfhook-modecA numeric argument is used to
    determine if this is a new file. If the argument cD@#cA is zero then this is
    interpreted as a new file, in this case a standard template is inserted
    (from file cDmode.etfcA) and the generic strings such as cG$YEAR$cA replaced with
    construction information. The template is generally used for standard
    headers and skeleton text body.

    In addition an abbreviation file cDmode.eafcA (see lslmeaf(8)le) is bound to the
    buffer using the lslmbuffer-abbrev-file(2)le command and the buffer hi-lighting
    enabled by assignment of the lslm$buffer-hilight(5)le variable.


cEcEMODIFYING FILE HOOKS cEcA


    The standard hook files supplied with MicroEmacs 2009 should not be
    modified, changes to the file hooks may be applied using a separate macro
    file called cDmycAcCXXX.emfcA, this is automatically executed after the cDhkcAcCXXX.emfcA
    file is executed.

    The extended hook functions may be defined company wide, or by the user,
    to over-ride some of the standard hook functions, or to extend the syntax
    of the base files with locally defined extensions. As an example, consider
    the following file cDmyc.emfcA which extends the basic cDhkc.emfcA file set of
    hi-lighting tokens for the 'C' Language.
sB
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ;
        ;  Created By    : Steven Phillips
        ;  Created       : Thu Jun 18 15:34:05 1998
        ;  Last Modified : <230798.0854>
        ;
        ;  Description   Extension hilighting for the 'C' language.
        ;
        ;  Notes         Define the locally defined 'C' library types and definitions
        ;                as extensions to the 'C' programming language.
        ;
        ;  History
        ;
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

        ; MicroEmacs specific tokens
        hilight .hilight.c 1 "LINE"           .scheme.type
        hilight .hilight.c 1 "BUFFER"         .scheme.type
        hilight .hilight.c 1 "WINDOW"         .scheme.type
        hilight .hilight.c 1 "REGION"         .scheme.type
        hilight .hilight.c 1 "KEYTAB"         .scheme.type
        hilight .hilight.c 1 "KILL"           .scheme.type
        hilight .hilight.c 1 "KLIST"          .scheme.type
        hilight .hilight.c 1 "HILNODE"        .scheme.type
        hilight .hilight.c 1 "HILNODEPTR"     .scheme.type
        hilight .hilight.c 1 "HILCOLOR"       .scheme.type
        hilight .hilight.c 1 "SELHILIGHT"     .scheme.type
        hilight .hilight.c 1 "VIDEO"          .scheme.type
        hilight .hilight.c 1 "VVIDEO"         .scheme.type
        hilight .hilight.c 1 "FRAMELINE"      .scheme.type
        hilight .hilight.c 1 "IPIPEBUF"       .scheme.type
        hilight .hilight.c 1 "DIRNODE"        .scheme.type
        hilight .hilight.c 1 "UNDOND"         .scheme.type
        hilight .hilight.c 1 "meVARLIST"      .scheme.type
        hilight .hilight.c 1 "meVARIABLE"     .scheme.type
        hilight .hilight.c 1 "meCMD"          .scheme.type
        hilight .hilight.c 1 "meAMARK"        .scheme.type
        hilight .hilight.c 1 "meABREV"        .scheme.type
        hilight .hilight.c 1 "meMACRO"        .scheme.type
        hilight .hilight.c 1 "meNARROW"       .scheme.type
        hilight .hilight.c 1 "meREGISTERS"    .scheme.type
        hilight .hilight.c 1 "meSTAT"         .scheme.type
        hilight .hilight.c 1 "osdITEM"        .scheme.type
        hilight .hilight.c 1 "osdDIALOG"      .scheme.type
        hilight .hilight.c 1 "osdCHILD"       .scheme.type
        hilight .hilight.c 1 "meSCROLLBAR"    .scheme.type
        hilight .hilight.c 1 "osdCONTEXT"     .scheme.type
        hilight .hilight.c 1 "osdDISPLAY"     .scheme.type
        hilight .hilight.c 1 "RNODE"          .scheme.type
        hilight .hilight.c 1 "REGHANDLE"      .scheme.type
        hilight .hilight.c 1 "meDIRLIST"      .scheme.type
        hilight .hilight.c 1 "meNAMESVAR"     .scheme.type
        hilight .hilight.c 1 "meDICTADDR"     .scheme.type
        hilight .hilight.c 1 "meSPELLRULE"    .scheme.type
        hilight .hilight.c 1 "meDICTWORD"     .scheme.type
        hilight .hilight.c 1 "meDICTIONARY"   .scheme.type
        hilight .hilight.c 1 "meMODE"         .scheme.type

sA

cEcESEE ALSO cEcA


    lslmOperating Modesle, lslanguageTemplates(2)lmLanguage Templatesle, lslmadd-file-hook(2)le, lslmindent(2)le.
! 2 keyNames
cEcEKEY BINDING NAMES cEcA


    Every key which can be generated in MicroEmacs 2009 has a character string
    or name representation which can be used to bind and unbind the key to a
    command. The name of simple keys like "cGacA" or "cG$cA" is simply the character,
    i.e. "cGacA" and "cG$cA". Following is a list of other parts to a key name.


cEModify Keys cA


    There are 3 modifying keys, Shift, Control and Alt, these are represented
    as "cGS-cA", "cGC-cA", "cGA-cA" respectively. For example the key "cGA-C-S-upcA" is
    generated when the up cursor key is pressed when Shift, Control and Alt
    keys where also pressed.

    The Control and Alt modifiers are case insensitive so cGC-acA is the same as
    cGC-AcA and cGC-S-acA.


cEPrefix Keys cA


    Many binding are single stroke key sequences (e.g. "cGC-acA" =>
    beginning-of-line). However MicroEmacs 2009 has a lslmprefix(2)le command which
    can be used to bind up to 8 single stroke keys, turning them into two
    stroke keys; this greatly increasing the number of available bindable key
    sequences. For example cDprefix 1cA is bound to the escape character (cGesccA),
    this allows key sequences like "cGesc acA" to be used. Following is a list of
    prefixes and their default bindings

        lsprefix(2)lmprefix 1le => cGesccA
        lsprefix(2)lmprefix 2le => cGC-xcA
        lsprefix(2)lmprefix 3le => cGC-hcA
        lsprefix(2)lmprefix 4le => cGC-ccA


cESpecial Keys cA


    Following is a complete list of recognized keyboard key names, not all are
    able to be generated on every platform:-

        cGbackspacecA, cGdeletecA, cGdowncA, cGendcA, cGesccA, cGf1cA, cGf2cA, cGf3cA, cGf4cA, cGf5cA, cGf6cA, cGf7cA, cGf8cA, cGf9cA,
        cGf10cA, cGf11cA, cGf12cA, cGf13cA, cGf14cA, cGf15cA, cGf16cA, cGf17cA, cGf18cA, cGf19cA, cGf20cA, cGhomecA, cGinsertcA,
        cGkp-0cA, cGkp-1cA, cGkp-2cA, cGkp-3cA, cGkp-4cA, cGkp-5cA, cGkp-6cA, cGkp-7cA, cGkp-8cA, cGkp-9cA, cGkp-addcA,
        cGkp-begincA, cGkp-decimalcA, cGkp-deletecA, cGkp-dividecA, cGkp-downcA, cGkp-endcA, cGkp-entercA,
        cGkp-homecA, cGkp-insertcA, cGkp-leftcA, cGkp-multiplycA, cGkp-page-downcA, cGkp-page-upcA,
        cGkp-rightcA, cGkp-subtractcA, cGkp-upcA, cGleftcA, cGpage-downcA, cGpage-upcA, cGreturncA, cGrightcA,
        cGspacecA, cGtabcA, cGupcA

    The name of any key can be obtained by using lslmdescribe-key(2)le.


cEMouse Keys cA


    Following is a list of mouse related keys:-

    cDmouse-pick-1cA, cDmouse-pick-2cA, cDmouse-pick-3cA, cDmouse-pick-4cA, cDmouse-pick-5cA
        These keys are generated when the user presses a mouse button, these
        key events are always created. On most systems button 1 is the left, 2
        the middle and 3 the right mouse button. If the system only has a 2
        button mouse then a cGmouse-pick-2cA cannot be generated. The order of the
        buttons can be revered (i.e. 1 becomes right) and the number of
        buttons can be set using the lslm$system(5)le variable. Note that X-servers
        support up to 5 buttons and with the growing popularity of pilot
        'wheel' mice, the 4th and 5th button are often used to report wheel
        spin up and down events. The lslmtranslate-key(2)le command can be used to
        translate these buttons to the mouse wheel keys.

    cDmouse-drop-1cA, cDmouse-drop-2cA, cDmouse-drop-3cA, cDmouse-drop-4cA, cDmouse-drop-5cA
        These keys are generated when the user release a mouse button, these
        key events are always created.

    cDmouse-move-1cA, cDmouse-move-2cA, cDmouse-move-3cA, cDmouse-move-4cA, cDmouse-move-5cA,
    cDmouse-movecA
        These key events are generated when the user moves the mouse and are
        only if they are bound to a command. The key generated depends on
        whether a button is being held down by the user, if the user is
        pressing button 1 then a cGmouse-move-1cA key is created etc.

    cDmouse-time-1cA, cDmouse-time-2cA, cDmouse-time-3cA, cDmouse-time-5cA, cDmouse-time-5cA,
    cDmouse-timecA
        These key events are generated only when they are bound to a command.
        They are pseudo keys created when the user hold the mouse buttons done
        for a period of time, see cDPseudo KeyscA below for more information.

    cDmouse-wheel-upcA, cDmouse-wheel-downcA
        Pilot mouse wheel events, generated when the wheel is spun up or down
        respectively.


cEModifier Keys cA


    The Shift, Control and Alt modifier keys will also generate key input
    whenever pressed or released. The keys are however only generated if they
    are bound to a command. The key names are as follows:

    cDS-pickcA, cDS-dropcA
        Shift modifier.

    cDC-pickcA, cDC-dropcA
        Control modifier.

    cDA-pickcA, cDA-dropcA
        Alt modifier.

    Note that the keys are only generated when another key is pressed, i.e. if
    the user presses and holds only the shift key, no "cGS-pickcA" key will be
    generated until another key, such as cGdowncA, is also pressed. If the shift
    key is released before another key is pressed the event will not be
    reported.


cEPseudo Keys cA


    Pseudo keys events cannot be directly created by the user, they are
    created internally by MicroEmacs. They are treated like normal keys to
    allow the user to handle the events properly themselves. Following is a
    complete list of the system generated pseudo keys:-

    cDbellcA
        The pseudo key is generated when the bell is rung.

    cDcallbackcA
        The pseudo key when a lslmcreate-callback(2)le macro is executed, this
        allows the executed macro to know it was executed via a
        create-callback as lslm@cck(4)le will be set to this.

    cDidle-pickcA, cDidle-dropcA, cDidle-timecA
        The commands bound to these keys are executed when the system becomes
        idle for a period of time. See help on lslm$idle-time(5)le for more
        information.

    cDmouse-time-1cA, cDmouse-time-2cA, cDmouse-time-3cA, cDmouse-time-4cA, cDmouse-time-5cA,
    cDmouse-timecA
        The command bound to these keys are executed when mouse button 1, 2,
        3, 4, 5 or a combination are held bound for a period of time. See help
        on lslm$delay-time(5)le for more information.

    cDredrawcA
        The command bound to this pseudo key is executed whenever the screen
        needs redrawing, by default it is bound to lslmscreen-update(2)le. If the
        user unbinds this key then cDscreen-updatecA is still called, but if the
        user binds it to a function which does not redraw the screen, such as
        lslmvoid(2)le, then the screen will not be up-dated.

    The command executed is always given an argument, a non-zero argument
    indicates a forced complete redraw, an argument of zero indicates that
    just an up-date is required.


cEAlt Key cA


    The cDAlt KeycA has special binding priorities defined as follows:-

        * Direct key binding (e.g. cDA-bcA executes lsfile-browser(3)lmfile-browserle)
        * Main menu hot key (e.g. cDA-fcA opens the File menu)
        * Meta key binding (e.g. cDA-spacecA -> cDesc spacecA -> lsset-mark(2)lmset-markle)

    If the cGALTcA key is to be used strictly as the Emacs Meta key then the
    bindings for the menu should be over-ridden by cCDirect Key BindingscA from
    the user configuration file i.e. to re-map the default MicroEmacs Alt key
    to equivalent cGesccA keys then the following keys should be re-bound.
sB
        global-bind-key forward-word "A-f"      ; Over-ride File menu binding
        :                                       ; For all of the other menu items.
        :
        global-bind-key backward-word "A-b"     ; Over-ride the file browser.
        global-bind-key replace-string "A-r"    ; Over-ride tools binding.

sA
    This creates a higher priority binding which overrides the underlying
    default. The commands that are displaced would have to be re-bound to
    different keys if required.


cEcEKEYBOARD MACROS cEcA


    Keyboard macros do not store the name of keys, instead a more machine
    oriented format is used (usually in the form "cG\s??cA") these will work
    across platforms (assuming the key bindings are the same) but they may not
    work across different releases.

    As a result it is advised that any long term macro should avoid named keys
    like cGupcA in favor of using a standard key binding such as cGC-pcA. See help on
    lslmexecute-string(2)le for more information.
! 2mauto
cEcENAME cEcA


    auto - Automatic source file line type detection


cEcESYNOPSIS cEcA


    cDauto ModecA

    cDAcA - mode line letter.


cEcEDESCRIPTION cEcA


    When this mode is enabled the line style of the source file, with respect
    to cGCR/LF/CTRL-ZcA characters, are automatically detected and the file (if
    saved) is written out in the same style as it was read in. This mode is
    designed to solve the problems of MS-DOS which utilize a 'cD\r\ncA' with every
    new line and a cDctrl-ZcA as a file terminator, conversely UNIX utilizes only
    'cD\ncA' as a line terminator.

    cDautocA mode therefore allows files to be edited across file system types
    without corrupting the line style of the native platform.

    At load time, if cDautocA detects CR/LF style line feeds then it enables the
    buffer modes lslmcr(2m)le and lslmlf(2m)le; if a CTRL-Z is found at the end of the
    file then mode lslmctrlz(2m)le is enabled. Otherwise these modes are cleared.

    At write time, if cDautocA mode is enabled then the file is written out is a
    style determined by modes cDcrcA, cDlfcA and cDctrlzcA. For example, if cDcrcA and cDlfcA were
    enabled and cDctrlzcA disabled then the file would be written out with new
    lines as 'cD\r\ncA' and with no ending ctrl-z.

    If auto is not enabled then the file is written out in the style of the
    current platform, regardless of the current settings on modes cDcrcA, cDlfcA and
    cDctrlzcA.


cEcESUMMARY cEcA


    The operation on the modes may be summarized as follows:-


cEUNIX Systems cA


        * cDauto EnabledcA UNIX and MS-DOS files may be edited normally, edits are
          saved in the format read by the system.
        * cDauto DisabledcA UNIX files may be edited normally, files saved as UNIX
          files. MS-DOS files show a cG^McA character at the end of each line
          (editing is not advised if the purity of the MS-DOS is to be
          maintained), any edits are written back as displayed on the screen.


cEMS-DOS Systems cA


        * cDauto EnabledcA UNIX and MS-DOS files may be edited normally, edits are
          saved in the format read by the system.
        * cDauto DisabledcA on reading all files are read and editing may be
          undertaken normally. On writing, 'cD\rcA's and a cDctrl-ZcA are
          automatically added. The act of reading a UNIX file and re-writing
          it translates it to an MS-DOS file.


cEcENOTES cEcA


    This mode MUST be enabled globally when the file is loaded for the file
    style to be correctly detected.

    It is cDstrongly advisedcA that auto mode is permanently enabled.

    Windows systems tend to use a 'cD\r\ncA' style line feed but with no trailing
    ctrl-z.


cEcESEE ALSO cEcA


    lslmOperating Modesle, lslmglobal-mode(2)le, lslmbuffer-mode(2)le, lslmcr(2m)le, lslmlf(2m)le,
    lslmctrlz(2m)le, lslm$buffer-fmod(5)le.
! 2mbackup
cEcENAME cEcA


    backup - Automatic file backup of last edit


cEcESYNOPSIS cEcA


    cDbackup ModecA

    cDBcA - mode line letter.


cEcEDESCRIPTION cEcA


    cDbackupcA mode, when enabled, performs an automatic backup of the last edit
    when a save file operation is performed. The backup file name is derived
    from the base file name and is written into the same directory as the
    source file, the backup file name can be obtained from the variable
    lslm$buffer-backup(5)le.

    On unlimited file name length systems the naming convention used depends
    on bit cD0x400cA of variable lslm$system(5)le, if this bit is set then the system
    simulates a DOS style 8.3 file naming convention. If this bit is clear
    then variable lslm$kept-versions(5)le can be used to create multiple backup
    files.

    Where an existing backup file already exists, then the old backup file is
    removed and replaced by the newer backup file. The naming convention for
    backup files is defined as follows:-

        On unlimited length file name systems (UNIX and some Windows systems)
        with a single backup file, the following file naming conventions are
        used for file cGxxxxxcA:

            cGxxxxx -> xxxxx~cA

        On unlimited length file name systems with multiple backup files, the
        following file naming conventions are used for file cGxxxxxcA:

            cGxxxxx -> xxxxx.~?~cA

        Where cG?cA is the backup number, the most recent backup file is always
        "cG.~0~cA".

        On systems with an cGxxxxxxxx.yyycA file name (MS-DOS etc), the following
        file naming conventions are used:

            cGxxxxxxxx      -> xxxxxxxx.~~~cA
            cGxxxxxxxx.yyy  -> xxxxxxxx.yy~cA
            cGxxxxxxxx.yyyy -> xxxxxxxx.yyy~cA

    The environment variables lslm$MEBACKUPPATH(5)le and lslm$MEBACKUPSUB(5)le can be used
    to modify this behaviour.


cEcENOTES cEcA


    cDbackupcA is enabled by default.

    Reference should also be made to lslmundo(2)le which allows previous edits to be
    removed. Also see lslm$auto-time(5)le and lslmautosv(2m)le which allows a timed backup
    of a running edit to be periodically performed.

    The user is warned to be extra careful if files ending in 'cG~cA' or 'cG#cA's are
    used, it is advisable to disable backup creation (see lslmglobal-mode(2)le) and
    auto-saving (cG$auto-time = 0cA). The author denies all responsibility (yet
    again) for any loss of data! Please be careful.


cEcESEE ALSO cEcA


    lslmOperating Modesle, lslm$buffer-backup(5)le. lslm$system(5)le, lslm$kept-versions(5)le,
    lslm$MEBACKUPPATH(5)le, lslm$MEBACKUPSUB(5)le, lslmbuffer-mode(2)le, lslmglobal-mode(2)le,
    lslmundo(2m)le, lslmautosv(2m)le, lslm$auto-time(5)le.
! 2mcrypt
cEcENAME cEcA


    crypt - Encrypted file mode


cEcESYNOPSIS cEcA


    cDcrypt ModecA

    cDYcA - mode line letter.


cEcEDESCRIPTION cEcA


    cDcryptcA mode enables encrypted files to be loaded and saved for security
    purposes. The key can be set at any time using the command
    lslmset-encryption-key(2)le. Warning, take care if setting this as a global
    mode, it can have side-effects.

    The encryption algorithm is a Beaufort Cipher with a variant key. This is
    reasonably difficult to decrypt. When you write out text, if cGcryptcA mode is
    active and there is no encryption key, MicroEmacs 2009 will ask:

        cGEncryption String:cA

    Type in a word or phrase of at least five and up to 128 characters for the
    encryption to use. If you look at the file which is then written out, all
    the printable characters have been scrambled. To read such a file later,
    use lslmfind-cfile(3)le to load cCciphertextcA files, you will be asked the
    encryption key before the file is read.


cEcESEE ALSO cEcA


    lslmOperating Modesle, lslmbuffer-mode(2)le, lslmfind-cfile(3)le, lslmglobal-mode(2)le,
    lslmset-encryption-key(2)le.
! 2mexact
cEcENAME cEcA


    exact - Searching and sorting case sensitivity


cEcESYNOPSIS cEcA


    cDexact ModecA

    cDEcA - mode line letter.


cEcEDESCRIPTION cEcA


    cDexactcA mode sets the searching and line sorting commands to case sensitive
    when enabled (case insensitive when disabled). See lslmsearch-forward(2)le and
    lslmsort-lines(2)le.


cEcESEE ALSO cEcA


    lslmOperating Modesle, lslmbuffer-mode(2)le, lslmglobal-mode(2)le, lslmsearch-forward(2)le,
    lslmsort-lines(2)le.
! 2mindent
cEcENAME cEcA


    indent - Automatic indentation


cEcESYNOPSIS cEcA


    cDindent ModecA

    cDIcA - mode line letter.


cEcEDESCRIPTION cEcA


    cDindentcA mode, when enabled, ensures that a new text line is automatically
    indented to the same left hand column as the previous line's first
    non-white character. If the previous line contains no non-white characters
    then the line will not be indented. Automatic indentation is disabled when
    using cCcentercA or cCrightcA justification. cDIndentcA is usually used in conjunction
    with lslmwrap(2m)le and lslmjustify(2m)le.


cEcESEE ALSO cEcA


    lslmOperating Modesle, lslmbuffer-mode(2)le, lslmglobal-mode(2)le, lslmwrap(2m)le lslmjustify(2m)le.
! 2mjustify
cEcENAME cEcA


    justify - Justification Mode


cEcESYNOPSIS cEcA


    cDjustify ModecA

    cDJcA - mode line letter.


cEcEDESCRIPTION cEcA


    cDjustifycA mode, when enabled, performs paragraph justification as designated
    by lslm$fill-mode(5)le - capable of cCleftcA, cCrightcA, cCbothcA or cCcentercA justification of
    text. Justify removes all white spaces at the end of the line, if there
    are no non-white characters on the line then the line is always left
    empty. If the justification method is cCcentercA or cCrightcA then all white
    spaces are removed at the beginning of the line. If the line is longer
    than the lslm$buffer-fill-col(5)le or the method is cCleftcA then nothing more is
    done, else the line is appropriately justified. The method used is set by
    the variable lslm$buffer-fill-mode(5)le. Justify is usually used in conjunction
    with lslmwrap(2m)le and lslmindent(2m)le.


cEcESEE ALSO cEcA


    lslmOperating Modesle, lslmbuffer-mode(2)le, lslmglobal-mode(2)le, lslmwrap(2m)le lslmindent(2m)le,
    lslm$buffer-fill-col(5)le, lslm$buffer-fill-mode(5)le, lslm$fill-col(5)le, lslm$fill-mode(5)le.
! 2mmagic
cEcENAME cEcA


    magic - Regular expression search


cEcESYNOPSIS cEcA


    cDmagic ModecA

    cDMcA - mode line letter.


cEcEDESCRIPTION cEcA


    cDmagiccA mode enables the regular expression search capability used in the
    search and the replace commands such as lslmsearch-forward(2)le and
    lslmquery-replace-string(2)le.

    In the magic mode of MicroEmacs 2009, certain characters gain special
    meanings when used in a search pattern. Collectively they are know as
    regular expressions, and a limited number of them are supported in
    MicroEmacs 2009. They grant greater flexibility when using the search
    commands (note that they also affect lslmisearch-forward(2)le commands).

    The symbols that have special meaning in magic mode are cG^cA, cG$cA, cG.cA, cG\|cA, cG*cA, cG[cA
    cG]cA, cG\(cA cG\)cA, cG\{cA cG\}cA and cG\cA.

    The characters cG^cA and cG$cA fix the search pattern to the beginning and end of
    line, respectively. The cG^cA character must appear at the beginning of the
    search string, and the cG$cA must appear at the end, otherwise they loose
    their meaning and are treated just like any other character. For example,
    in magic mode, searching for the pattern "cGt$cA" would put the cursor at the
    end of any line that ended with the letter 'cGtcA'. Note that this is
    different than searching for "cGt<NL>cA", that is, 'cGtcA' followed by a newline
    character. The character cG$cA (and cG^cA, for that matter) matches a position,
    not a character, so the cursor remains at the end of the line. But a
    newline is a character that must be matched, just like any other
    character, which means that the cursor is placed just after it - on the
    beginning of the next line.

    The character 'cG.cA' has a very simple meaning - it matches any single
    character, except the newline. Thus a search for "cGbad.ercA" could match
    "cGbadgercA", "cGbaddercA" (slang), or up to the 'cGrcA' of "cGbad errorcA".

    The character cG*cA is known as closure, and means that zero or more of the
    preceding character will match. If there is no character preceding, cG*cA has
    no special meaning, and since it will not match with a newline, cG*cA will
    have no special meaning if preceded by the beginning of line symbol cG^cA or
    the literal newline character cG<NL>cA. The notion of zero or more characters
    is important. If, for example, your cursor was on the line

        This line is missing two vowels.


    and a search was made for "cGa*cA", the cursor would not move, because it is
    guaranteed to match no letter 'cGacA', which satisfies the search conditions.
    If you wanted to search for one or more of the letter 'a', you would
    search for "cGaa*cA", which would match the letter cGacA, then zero or more of
    them, note that this pattern is better searched using "cGa+cA".

    The character "cG+cA" is the same as "cG*cA" except that it searches for one or
    more occurrences of the preceding character.

    The character cG[cA indicates the beginning of a character class. It is
    similar to the cCanycA (cG.cA) character, but you get to choose which characters
    you want to match. The character class is ended with the character cG]cA. So,
    while a search for "cGba.ecA" will match "cGbanecA", "cGbadecA", "cGbalecA", "cGbatecA", et
    cetera, you can limit it to matching "cGbabecA" and "cGbakecA" by searching for
    "cGba[bk]ecA". Only one of the characters inside the cG[cA and cG]cA will match a
    character. If in fact you want to match any character except those in the
    character class, you can put a cG^cA as the first character. It must be the
    first character of the class, or else it has no special meaning. So, a
    search for cG[^aeiou]cA will match any character except a vowel, but a search
    for cG[aeiou^]cA will match any vowel or a cG^cA. If you have a lot of characters
    in order that you want to put in the character class, you may use a dash
    (cG-cA) as a range character. So, cG[a-z]cA will match any letter (or any lower
    case letter if exact mode is on), and cG[0-9a-f]cA will match any digit or any
    letter 'cGacA' through 'cGfcA', which happen to be the characters for hexadecimal
    numbers. If the dash is at the beginning or end of a character class, it
    is taken to be just a dash.

    The cG?cA character provides a simple zero or one occurrence test of the
    previous character e.g. "cGca?rcA" matches "cGcrcA" and "cGcarcA", it will not match
    "cGcaarcA".

    Where a previous item has a range of repetitions then the cG\{N,M\}cA syntax
    may be used to denote the minimum and maximum iterations of the previous
    item. Where a set quantity of repetitions is required then the simpler
    syntax of cG\{N\}cA may be used. i.e. "cGca\{2\}rcA" matches "cGcaarcA", "cGca\{2,3\}rcA"
    matches "cGcaarcA" and "cGcaaarcA".

    The escape character cG\cA is for those times when you want to be in magic
    mode, but also want to use a regular expression character to be just a
    character. It turns off the special meaning of the character. So a search
    for "cGit\.cA" will search for a line with "cGit.cA", and not "cGitcA" followed by any
    other character. The escape character will also let you put cG^cA, cG-cA, or cG]cA
    inside a character class with no special side effects.

    In lsquery-replace-string(2)lmsearch-replacele strings the cG\(cA cG\)cA pair may be used to group characters
    for in the search string for recall in the replacement string. The cG\(cA cG\)cA
    bracket pair is recalled using cG\1cA-cG\9cA in the replace string, cG\1cA is the
    first pair, cG\1cA the second and so on. Hence to replace cG%dgdg%name%dhdh%cA
    with cG%dgdg%names%dhdh%cA then we could use the following search replace
    string cG\(%[a-z]+%\)\([a-z]*\)\(%[a-z]+%\)cA replacing with cG\1\2s\3cA.

    cG\0cA in the replace string implies the whole string.

    A summary of magic mode special characters are defined as follows:-

        cD^cA
            Anchor search at beginning of line

        cD$cA
            Anchor search at end of line

        cD.cA
            Match any character except cG<NL>cA

        cD*cA
            Match zero or more occurrences of the preceding item.

        cD\|cA
            Match either/or i.e. cGcar\|bikecA matches the work cGcarcA and matches
            the word cGbikecA.

        cD+cA
            Match one or more occurrences of the preceding item.

        cD?cA
            Match zero or one occurrences of the preceeding item.

        cD[]cA
            Match a class of characters (cG[a-z]cA would be all alphabetics)

        cD\cA
            Take next literally

        cD\{cAcCNcAcD,cAcCMcAcD\}cA
            Match a minimum of cCNcA occurrences and maximum of cCMcA occurrences of
            the preceeding item.

        cD\{cAcCNcAcD\}cA
            Match a cCNcA occurrences of the preceeding item.

        cD\(...\)cA
            Delimit pattern to replicate in replace string. Max of 9 allowed.
            Called in replace string with cG\1cA,..,cG\9cA. 1 being 1st etc. cG\0cA or cG\&cA
            in the replace string is the whole string. i.e.

            Search: cD\(ab\)\(dc\)cA
            Replace: cD\1\2 \1\2cA
            on "cDabdccA" => "cDabdc abdccA"


cEcESEE ALSO cEcA


    lslmOperating Modesle, lslmbuffer-mode(2)le, lslmglobal-mode(2)le, lslmquery-replace-string(2)le,
    lslmsearch-forward(2)le.
    lsRegularExpressions(2)lmRegular Expressionsle
! 2mover
cEcENAME cEcA


    over - Over-strike Mode


cEcESYNOPSIS cEcA


    cDover ModecA

    cDOcA - mode line letter.


cEcEDESCRIPTION cEcA


    cDovercA mode, when enabled, over writes existing text in a buffer as opposed
    to inserting text. over maintains the position of text aligned with cGtabcA
    characters.


cEcESEE ALSO cEcA


    lslmOperating Modesle, lslmbuffer-mode(2)le, lslmglobal-mode(2)le.
! 2mcr
cEcENAME cEcA


    cr - File's carriage return (CR) style


cEcESYNOPSIS cEcA


    cDcrlf ModecA

    cDccA - mode line letter.


cEcEDESCRIPTION cEcA


    When enabled cDcrcA indicates that a carriage return should be written out at
    the end of the line. Typically enabled independently for different line
    ending styles used in DOS and UNIX. When 1 then cD\rcA is included in the line
    ending; when 0 then cD\rcA is not included in the line ending.


cEcENOTES cEcA


    This mode only effects the style in which the buffer is written if
    lslmauto(2m)le mode is enabled. cDcrcA mode is used in conjunction with lslmlf(2m)le to
    control the line feed.


cEcESEE ALSO cEcA


    lslmOperating Modesle, lslmauto(2m)le, lslmlf(2m)le, lslmctrlz(2m)le, lslmsave-buffer(2)le,
    lslmfind-file(2)le, lslm$buffer-fmod(5)le.
! 2mtab
cEcENAME cEcA


    tab - Tabulation mode


cEcESYNOPSIS cEcA


    cDtab ModecA

    cDTcA - mode line letter.


cEcEDESCRIPTION cEcA


    cDtabcA mode, when enabled, simulates all tab stops with spaces. This allows
    'cCvariablecA' tab sizes and fixes indentation. If cDtabcA mode is not enabled
    literal tab characters are inserted, their displayed width is controlled
    on a buffer basis with the variable lslm$buffer-tab-width(5)le.


cEcESEE ALSO cEcA


    lslmOperating Modesle, lslmbuffer-mode(2)le, lslmglobal-mode(2)le. lslm$buffer-tab-width(5)le,
    lslm$tab-width(5)le, lslmtabs-to-spaces(3)le.
! 2mtime
cEcENAME cEcA


    time - File time stamping


cEcESYNOPSIS cEcA


    cDtime ModecA

    cDtcA - mode line letter.


cEcEDESCRIPTION cEcA


    cDtimecA mode, when enabled, performs automatic time stamping of files on file
    write operations. A time stamp string, defined by lslm$timestamp(5)le is
    searched for in the file and updated with the current data and time
    information, providing a record in the file of the last edit.


cEcESEE ALSO cEcA


    lslmOperating Modesle, lslmbuffer-mode(2)le, lslmglobal-mode(2)le. lslm$timestamp(5)le.
! 2mundo
cEcENAME cEcA


    undo - Retain edit modifications


cEcESYNOPSIS cEcA


    cDundo ModecA

    cDUcA - mode line letter.


cEcEDESCRIPTION cEcA


    cDundocA mode, when enabled, stores a history of all user edits so that the
    command lslmundo(2)le may be used to undo the last cCncA edits to a buffer. If this
    mode is not enabled the cDundocA command has no effect.

    Obviously memory is required to store this information, particularly
    storing deleted, reformed or replaced text, users editing large files or
    operating in restricted memory environments may wish to use this mode
    selectively.


cEcENOTES cEcA


    The cDundocA information is flushed, and is effectively lost, when a save
    operation is performed on the buffer.


cEcESEE ALSO cEcA


    lslmOperating Modesle, lslmbuffer-mode(2)le, lslmglobal-mode(2)le. lslmundo(2)le.
! 2musr
!32musr1..usr8
cEcENAME cEcA


    usr1 - usr8 - User buffer modes


cEcESYNOPSIS cEcA


    cDusr1-usr8 ModecA

    cD1cA-cD8cA - mode line letters.


cEcEDESCRIPTION cEcA


    cDusr1cA through cDusr8cA modes have no predefined purpose, they are present to
    provide the user with the ability to store some buffer state. All of these
    modes are off by default. For example, the user may wish to have two
    commands bound to the same key, with another command to toggle which one
    is currently active.


cEcENOTES cEcA


    The toolbar 'Buffer File Info' tool uses cDusr8cA mode to track the status of
    the buffer, when using this tool the mode should not be used.


cEcESEE ALSO cEcA


    lslmOperating Modesle, lslmbuffer-mode(2)le, lslmglobal-mode(2)le.
! 2mview
cEcENAME cEcA


    view - Read only


cEcESYNOPSIS cEcA


    cDview ModecA

    cDVcA - mode line letters.


cEcEDESCRIPTION cEcA


    cDviewcA mode sets the buffer to read-only, disabling the ability to alter the
    contents of the buffer. This mode is automatically set for any files
    attributed with a read-only status on the file system when read into
    MicroEmacs 2009. Files loaded via lslmview-file(2)le are also assigned cDviewcA
    mode.

    While in cDviewcA mode, any attempt to alter the buffer contents results in
    the following message:-

        cG[Key Illegal in view Mode]cA


cEcESEE ALSO cEcA


    lslmOperating Modesle, lslmbuffer-mode(2)le, lslmglobal-mode(2)le, lslmview-file(2)le.
! 2mwrap
cEcENAME cEcA


    wrap - Line wrap entered text


cEcESYNOPSIS cEcA


    cDwrap ModecA

    cDWcA - mode line letters.


cEcEDESCRIPTION cEcA


    cDwrapcA mode causes automatic text wrapping when text passes then fill column
    (see lslm$buffer-fill-col(5)le), allowing text to be entered non-stop on a
    standard screen without bothering to use the cGRETURNcA key.

    cDwrapcA mode is usually used in conjunction with the lslmjustify(2m)le and
    lslmindent(2m)le modes for editing text documents.

    cDwrapcA mode also automatically wraps long lines in the output of an
    lslmipipe-shell-command(2)le to the width of the MicroEmacs window.


cEcESEE ALSO cEcA


    lslmOperating Modesle, lslm$buffer-fill-col(5)le, lslm$fill-col(5)le, lslmbuffer-mode(2)le,
    lslmglobal-mode(2)le, lslmipipe-shell-command(2)le lslmjustify(2m)le, lslmindent(2m)le, lslmpipe(2m)le.
! 2mbinary
cEcENAME cEcA


    binary - Binary editor mode


cEcESYNOPSIS cEcA


    cDbinary ModecA

    cDbcA - mode line letter.


cEcEDESCRIPTION cEcA


    cDbinarycA mode is enabled when a file is edited in binary mode. The mode is
    automatically enabled when a file is loaded as a binary file via
    lslmfind-bfile(3)le.

    When a file is loaded using binary mode, every 16 bytes is converted into
    a line of text giving the hex address of the current position in the file,
    the bytes as hexadecimal numbers and all printable characters at the end
    of the line (all non-printable characters are displayed as a 'cG.cA').
    However, This format makes it memory hungry in that every 16 bytes of the
    file requires a 78 character line (approximately 5 times more memory!).
    For a more memory efficient binary mode see lslmrbin(2m)le.

    When writing out a file which has binary mode enabled the format of each
    line must have the binary mode format which is as follows:

        <address>: XX XX XX XX XX .... XX XX | <text-form>


    Only the hex values (the cGXXcA's) between the starting 'cC:cA' marker and the
    terminating '|' character are used, the cC<address>cA and cC<text-form>cA are
    ignored.


cEcEEXAMPLE cEcA


    Given a single line MSDOS file:-

        Live long and prosper.


    When loaded in using cDbinarycA mode the following 2 line buffer will be
    produced:-

        00000000: 4C 69 76 65 20 6C 6F 6E 67 20 61 6E 64 20 70 72  |  Live long and pr
        00000010: 6F 73 70 65 72 2E 0D 0A 1A                       |  osper....


    Note the "cG0D 0A 1AcA" at the end, this is due to MSDOS's "cG\n\rcA" carriage
    returns and cG^ZcA file termination, these characters are unprintable and are
    shown as 'cG.cA' at the end of the line.

    When saving a binary file, only the text between the 'cG:cA' and 'cG|cA' is
    considered and it may contain any number of hexadecimal numbers. The given
    file could be made UNIX compatible by editing the buffer to:-

        00000000: 4C 69 76 65 20 6C 6F 6E 67 20 61 6E 64 20 70 72  |  Live long and pr
        00000010: 6F 73 70 65 72 2E 0D                       |  osper....


    If the word "cDlongcA" is required to be removed, the following would not
    work:-

        00000000: 4C 69 76 65 20 6C 6F 6E 67 20 61 6E 64 20 70 72  |  Live and pr
        00000010: 6F 73 70 65 72 2E 0D 0A 1A                       |  osper....


    The ASCII end letters are ignored, instead the following operation must be
    performed which removes the characters from the binary representation:-

        00000000: 4C 69 76 65 20 61 6E 64 20 70 72  |  Live long and pr
        00000010: 6F 73 70 65 72 2E 0D 0A 1A                       |  osper....


    One could be nasty by doing the following:-

        00000000: 4C 69 76 65 20 73 68 6F 72 74 20 61 6E 64 20 |
        00000010: 64 6F 6E 27 74 20 70 72 6F 73 70 65 72 2E 0D 0A 1A           |


    ("Live short and don't prosper").


cEcENOTES cEcA


    cDrbincA and cDbinarycA modes are mutually exclusive, i.e. they cannot both be
    enabled at the same time.


cEcESEE ALSO cEcA


    lslmOperating Modesle, lslmfind-bfile(3)le, lslmfind-file(2)le, lslmrbin(2m)le.
! 2mautosv
cEcENAME cEcA


    autosv - Automatic file save


cEcESYNOPSIS cEcA


    cDautosv ModecA

    cDacA - mode line letter.


cEcEDESCRIPTION cEcA


    When this mode is enabled when the buffer is changed it will be
    automatically saved to a temporary file lslm$auto-time(5)le later.

    Automatic saving for a buffer will not occur if

        The buffer name starts with a '*', this is considered a temporary
        system buffer.

        lslm$auto-time(5)le is set to 0, this disables auto-saving for all buffers.

        The buffer does not a file name from which to generate a temporary
        file name. When this occurs the error message:

        cG[Auto-writeout failure for buffer xxxxx]cA

        MicroEmacs 2009 can not write to the generated temporary file name.
        When this occurs the error message:

        cG[Auto-writeout failure for file xxxxx#]cA

    On unlimited length file name systems (UNIX), the temporary file naming
    convention used for file cGxxxxxcA:

        cGxxxxx -> xxxxx#cA

    On systems with an cGxxxxxxxx.yyycA file name (DOS etc), the following file
    naming convention is used:

        cGxxxxxxxx     -> xxxxxxxx.###cA
        cGxxxxxxxx.y   -> xxxxxxxx.y##cA
        cGxxxxxxxx.yy  -> xxxxxxxx.yy#cA
        cGxxxxxxxx.yyy -> xxxxxxxx.yy#cA


cEcENOTES cEcA


    This mode MUST be enabled globally when the file is loaded for the file
    style to be correctly detected.

    It is cDstrongly advisedcA that autosv mode is permanently enabled.

    Auto-save files of URL files (i.e. "cGftp://...cA" and "cGhttp://...cA") are
    written to the system's temporary directory. This avoids potentially slow
    auto-saves. This can however lead to recovery problems as the buffer name
    must be used to avoid auto-saving conflict with other buffers with the
    same base file name but different paths.


cEcESEE ALSO cEcA


    lslmOperating Modesle, lslm$auto-time(5)le, lslmbackup(2m)le, lslmfind-file(2)le, lslmftp(3)le.
! 2mpipe
cEcENAME cEcA


    pipe - Incremental Pipe running


cEcESYNOPSIS cEcA


    cDpipe ModecA

    cDPcA - mode line letter.


cEcEDESCRIPTION cEcA


    This mode indicates whether an incremental pipe (started by
    lslmipipe-shell-command(2)le) is running in the current buffer. This mode is
    automatically set and can not be changed by the user. pipe modes main use
    is in macros.

    Modes lslmlock(2m)le and lslmwrap(2m)le effect the output behavior of a piped command.


cEcESEE ALSO cEcA


    lslmOperating Modesle, lslmipipe-shell-command(2)le, lslmlock(2m)le, lslmwrap(2m)le.
! 2mlock
cEcENAME cEcA


    lock - Pipe cursor position lock


cEcESYNOPSIS cEcA


    cDlock ModecA

    cDkcA - mode line letter.


cEcEDESCRIPTION cEcA


    This mode can only be used while an incremental pipe (started by
    lslmipipe-shell-command(2)le) is running in the current buffer, denoted by the
    lslmpipe(2m)le being set. When this mode is enabled and MicroEmacs 2009 buffer
    cursor is at the same location as the process shell cursor, the buffer
    cursor is automatically moved with the shell cursor.

    This mode is automatically enabled for a piped buffer.


cEcESEE ALSO cEcA


    lslmOperating Modesle, lslmipipe-shell-command(2)le, lslmpipe(2m)le.
! 2mhide
cEcENAME cEcA


    hide - Hide buffer


cEcESYNOPSIS cEcA


    cDhide ModecA

    cDHcA - mode line letter.


cEcEDESCRIPTION cEcA


    This mode can only be set on a buffer and when enabled the buffer is
    effectively hidden from the user. When set the buffer is hidden from the
    buffer completion list used by commands such as lslmfind-buffer(2)le, the buffer
    is also ignored by commands lslmlist-buffers(2)le, lslmsave-some-buffers(2)le and
    lslmdelete-some-buffers(2)le.


cEcESEE ALSO cEcA


    lslmOperating Modesle, lslmfind-buffer(2)le, lslmlist-buffers(2)le.
! 2mnact
cEcENAME cEcA


    nact - Buffer not active


cEcESYNOPSIS cEcA


    cDnact ModecA

    cDncA - mode line letter.


cEcEDESCRIPTION cEcA


    This mode can not be set and is used to indicate that the buffer has not
    been activated, i.e. the buffer has not been displayed in a window. If the
    buffer is linked to a file but has not been displayed, so is not active,
    the file will not have been loaded into the buffer.

    The lslmlist-buffers(2)le command output denotes active buffers with a '@'
    character in the left hand column, inactive buffers have a ' '.

    This mode can not be tested using the more usual lslm&bmode(4)le macro command
    as it only operates on the current buffer as which point the mode cannot
    be set. Instead the lslm&nbmode(4)le macro command must be used.


cEcESEE ALSO cEcA


    lslmOperating Modesle, lslmlist-buffers(2)le, lslm&nbmode(4)le, lslm&bmode(4)le.
! 2mlf
cEcENAME cEcA


    lf - File's line feed style


cEcESYNOPSIS cEcA


    cDlf ModecA

    cDlcA - mode line letter.


cEcEDESCRIPTION cEcA


    When enabled cDlfcA indicates that a line feed should be written out including
    the cD\ncA character. When set then a cD\ncA is included on each line ending. When
    clear then cD\ncA is not included in the line ending.


cEcENOTES cEcA


    This mode only effects the style in which the buffer is written if
    lslmauto(2m)le mode is enabled. cDlfcA mode is used in conjunction with lslmcr(2m)le to
    control the carriage return.


cEcESEE ALSO cEcA


    lslmOperating Modesle, lslmauto(2m)le, lslmcr(2m)le, lslmctrlz(2m)le, lslmsave-buffer(2)le,
    lslmfind-file(2)le, lslm$buffer-fmod(5)le.
! 2mnarrow
cEcENAME cEcA


    narrow - Buffer contains a narrow


cEcESYNOPSIS cEcA


    cDnarrow ModecA

    cDNcA - mode line letter.


cEcEDESCRIPTION cEcA


    This mode can not be set and is used to indicate whether the buffer
    contains a narrow, created by the lslmnarrow-buffer(2)le command. The the
    location of any narrow region lines contained within the buffer may be
    determined with lslm$line-flags(5)le.


cEcESEE ALSO cEcA


    lslmOperating Modesle, lslm$line-flags(5)le, lslmnarrow-buffer(2)le,
    lslmnarrow-search-backward(3)le, lslmnarrow-search-forward(3)le.
! 2mdel
cEcENAME cEcA


    del - Flag buffer to be deleted


cEcESYNOPSIS cEcA


    cDdel ModecA

    cDdcA - mode line letter.


cEcEDESCRIPTION cEcA


    This mode cannot be set globally and is used to flag that the buffer is to
    be deleted. The state of the mode is displayed in the output of
    lslmlist-buffers(2)le, if the first column is a 'D' the mode is set, otherwise
    it is not. Only the execute command in lslmlist-buffers(2)le (bound to 'x') uses
    this flag to actually delete the buffer.


cEcESEE ALSO cEcA


    lslmOperating Modesle, lslmlist-buffers(2)le, lslmsave(2m)le.
! 2msave
cEcENAME cEcA


    save - Flag buffer to be saved


cEcESYNOPSIS cEcA


    cDsave ModecA

    cDScA - mode line letter.


cEcEDESCRIPTION cEcA


    This mode cannot be set globally and can only be set on a buffer which
    needs saving. The mode is used to flag that the buffer is to be saved, the
    state of the mode is displayed in the output of lslmlist-buffers(2)le. If the
    second column is an 'S' the mode is set, otherwise it is not. Only the
    execute command in lslmlist-buffers(2)le (bound to 'x') uses this flag to
    actually save the buffer and the flag is automatically removed as soon as
    the buffer is saved.


cEcESEE ALSO cEcA


    lslmOperating Modesle, lslmlist-buffers(2)le, lslmdel(2m)le.
! 2mdir
cEcENAME cEcA


    dir - Buffer is a directory listing


cEcESYNOPSIS cEcA


    cDdir ModecA

    cDDcA - mode line letter.


cEcEDESCRIPTION cEcA


    This mode can not be set and is used to indicate that the buffer is a
    directory listing, created by the lslmfind-file(2)le command when the file name
    given is a directory.


cEcESEE ALSO cEcA


    lslmOperating Modesle, lslmfind-file(2)le.
! 2medit
cEcENAME cEcA


    edit - Buffer has be changed


cEcESYNOPSIS cEcA


    cDedit ModecA

    cDecA - mode line letters.


cEcEDESCRIPTION cEcA


    cDeditcA mode indicated that the buffer has been edited. Many commands and
    typing 'edit' the current buffer, automatically setting this mode.
    Commands which save these edits, such as lslmsave-buffer(2)le, automatically
    remove this mode.

    A '*' character, 3 characters from the left on the mode line is used to
    indicate that this mode is set, see lslm$mode-line(5)le. lslmlist-buffers(2)le also
    displays the state of this mode in its output, as a '*' in the second
    column.

    When this mode is set and lslmundo(2m)le mode is enabled, the lslmundo(2)le command
    can be used to undo all edits and the removal of this mode.


cEcESEE ALSO cEcA


    lslmOperating Modesle, lslmsave-buffer(2)le, lslmundo(2)le, lslmlist-buffers(2)le, lslm$mode-line(5)le,
    lslmundo(2m)le.
! 2mctrlz
cEcENAME cEcA


    ctrlz - File's termination style


cEcESYNOPSIS cEcA


    cDctrlz ModecA

    cDzcA - mode line letter.


cEcEDESCRIPTION cEcA


    When enabled cDctrlzcA indicates that an MS-DOS style 'cDctrl-zcA' file
    termination character should be written out. When clear, a UNIX style of
    no termination character should be used.


cEcENOTES cEcA


    This mode only effects the style in which the buffer is written if
    lslmauto(2m)le mode is enabled.


cEcESEE ALSO cEcA


    lslmOperating Modesle, lslmauto(2m)le, lslmcr(2m)le, lslmlf(2m)le, lslmsave-buffer(2)le, lslmfind-file(2)le,
    lslm$buffer-fmod(5)le.
! 2mrbin
cEcENAME cEcA


    rbin - Reduced binary editor mode


cEcESYNOPSIS cEcA


    cDrbin ModecA

    cDrcA - mode line letter.


cEcEDESCRIPTION cEcA


    cDrbincA mode is enabled when a file is edited in reduced binary mode. The
    mode is automatically enabled when a file is loaded as a binary data file
    via lslmfind-file(2)le.

    When a file is loaded using cDrbincA mode, every 256 bytes is converted into a
    line of text, the line is a single list of hex numbers 512 characters
    long, 2 bytes for each character. This format is not very user friend
    unlike lslmbinary(2m)le mode, but is much more memory efficient (requiring
    approximately 2 times more memory than the file size).

    When writing out a file which has rbin mode enabled the format of each
    line must be correct, namely an even number of hex numbers with no other
    characters.


cEcEEXAMPLE cEcA


    Given a single line MSDOS file:-

        Live long and prosper.


    When loaded in using cDbinarycA mode the following 2 line buffer will be
    produced:-

        4C697665206C6F6E6720616E642070726F737065722E0D0A1A


    Note the "cG0D 0A 1AcA" at the end, this is due to MSDOS's "cG\n\rcA" carriage
    returns and cG^ZcA file termination. The given file could be made UNIX
    compatible by editing the buffer to:-

        4C697665206C6F6E6720616E642070726F737065722E0D


cEcENOTES cEcA


    cDrbincA and cDbinarycA modes are mutually exclusive, i.e. they cannot both be
    enabled at the same time.


cEcESEE ALSO cEcA


    lslmOperating Modesle, lslmfind-file(2)le, lslmbinary(2m)le.
! 2mfence
cEcENAME cEcA


    fence - Auto fence matching mode


cEcESYNOPSIS cEcA


    cDfence ModecA

    cDfcA - mode line letter.


cEcEDESCRIPTION cEcA


    cDfencecA mode can be used to enable or disable the automatic displaying of
    and open fence when the corresponding closing fence is typed. When the
    mode is enabled and the closing fence ('cG)cA' 'cG]cA' or 'cG}cA') is typed the cursor
    is temporarily move to the position of the opening fence. The duration of
    the move can be controlled by the lslm$pause-time(5)le variable; any user input
    interrupts the display.

    If the buffer is configured to use a cCCcA style auto lslmindent(2)le, the search
    algorithm used is 'cCCcA' aware and if a matching fence is not found then the
    bell is rung as a warning. Otherwise any closing fence which cannot be
    matched is ignored.

    The cursor can be moved to the matching fence using the
    lslmgoto-matching-fence(2)le command.


cEcENOTES cEcA


    The following are considered closing fences:

        }  )  ] > */ #endif


    These are match with the following opening fences respectively:

        {  (  [ < /* #if


    In MicroEmacs the use of fence mode has been depreciated. Matching fence
    hilighting has been implemented as a macro and configured via the Platform
    page of lslmuser-setup(3)le.


cEcESEE ALSO cEcA


    lslmOperating Modesle, lslm$pause-time(5)le, lslmuser-setup(3)le, lslmgoto-matching-fence(2)le,
    lslmindent(2)le.
! 2 languageTemplates
cEcEFILE LANGUAGE TEMPLATES cEcA


    MicroEmacs 2009 provides a large range of macros and templates to deal
    with the most commonly occurring types of ASCII file that may be edited.
    However, there is a requirement for users to extend this capability to
    include more obscure file types, in addition to bespoke files found
    internally within organizations, or devised by the user.

    For each file type, MicroEmacs 2009 may be tailored to recognize the file
    and modify it's hilighting, key binding configuration, osd display and
    indentation to accommodate the file. In addition, new shorthand macros may
    be introduced to help deal with the contents of the file.

    This section outlines the steps to be taken to integrate a new file
    language template into MicroEmacs 2009. lslmbuffer-init(3)le automates many of
    the operations defined below and it is suggested that this is a preferable
    method to add a new language template into MicroEmacs.


cEThe scope of the File Type cA


    The first step is to decide the scope of the file, this will determine
    where the file hook should be defined. The options are:-

    cDA standard file type not supportedcA
        If this is a standard file type not supported by MicroEmacs 2009 then
        it should be added to cGme.emfcA, in addition lsMicroEmacs - Contact Informationlmcontact usle and we will add
        it to the standard release. Any macro files associated with this file
        type should be available globally and are added to the MicroEmacs
        cCmacrocA directory.

    cDLocal To your organizationcA
        If it is a file type local to your organization then it should be
        added to your cCcompanycA.emf file. Any macro files associated with the
        file type should be added to your local company MicroEmacs 2009
        directory.

    cDLocal to an individualcA
        If this is a file type that is only used by a limited number of
        individuals then it should be added to the cCusercA.emf file. Any files
        associated with the file type are added to your local user MicroEmacs
        2009 directory.


cERecognizing the File Type cA


    The next step to adding a new file type is to get MicroEmacs 2009 to
    recognize the file as the new type. Recognition is performed by the lsfileHooks(2)lmFileln
    lnHooksle which perform recognition on the file extension and/or the file
    content. The name of the file type must be determined, this is typically
    the name of the file prepended by cGhkcA. e.g. a file with extension cCfoocA uses
    the file cGhkfoo.emfcA for it's language specific definitions.

    Using the lslmadd-file-hook(2)le invocation the file recognition is bound to the
    file hook macro whenever the file type is loaded. The file hook is added
    to the appropriate global, company or user start up file as determined in
    step 1. The file hooks for file cCfoocA might be defined as follows, depending
    upon the recognition method:-

    cDRecognizing the extensioncA
        To recognize the file extension, then a space separated list of
        extensions may be defined, including the dot 'cG.cA' (or other) extension
        separator.
sB
            add-file-hook ".foo"       fhook-foo

sA
    cDRecognizing a magic editor string in the filecA
        If the file type adopts multiple extensions (or does not use a file
        extension) then an editor specific string may be inserted into the
        file to enable the editor to recognize it, typically of the form cG-!-cA
        cCtypecA cG-!-cA, if the string is GNU Emacs compatible then the cG-*-cA
        convention may be used. The binding is defined as:-
sB
            -1 add-file-hook "-!-[ \t]*foo.*-!-"           fhook-foo

sA
    cDRecognizing a magic string in the filecA
        UNIX files use a "cG#!<path>cA" notation for executable ASCII files. If
        the file is this type of file (or uses any other type of common string
        in the as the first characters of a file) then the binding may be
        defined as follows, in this case we have assumed cCfoocA is the UNIX
        executable variety i.e. cG#!/usr/local/bin/foocA:-
sB
            1 add-file-hook "^#!/.*foo" fhook-foo

sA
    Any, or all of the above recognition methods may be employed to invoke the
    language specific macro. Note that the methods are evaluated in a LIFO
    order, hence it is possible to over-ride an existing method.


cEDefining the Macro File cA


    Once the hook has been defined, the language specific file must be
    created. Create the language specific file with the same name as defined
    in the hooks, removing the cDfhook-cA prefix and replacing it with cDhkcA, i.e.
    cGfhook-foocA invokes the language specific file cGhkfoo.emfcA. Create, the file
    and add the file hook macro. for example hkcCfoocA.emf contents may be defined
    as:
sB
        define-macro fhook-foo
            ; Temporary comment to make sure that it works.
            ml-write "Loaded a foo file"
        !emacro
        ml-write "[MicroEmacs foo file hook loaded]"

sA
    The file hook may be tested by exiting and re-loading MicroEmacs 2009, or
    simply by executing the file containing the cGadd-file-hookcA function. Once
    the file bindings are installed a cCfoocA file may be loaded and the hook
    message should be displayed.

    The best way to create a new file hook is to find an existing file type
    with similar support to the new file hook you wish to create and re-use
    the hook code to create the new one.


cEModifying an Existing file hook cA


    The standard file hooks supplied with MicroEmacs 2009 should not be
    modified, typically a user will want to extend the repertoire of
    hi-lighting tokens to encompass locally defined programming libraries or
    syntactical extensions, in addition to extending support macros that are
    associated with the file type. In this case, an extension to the hook
    function is required. The hook file cDmycAcCXXXcAcD.emfcA, allows extensions to be
    made to the cDhkcAcCXXXcAcD.emfcA, without editing the original file. This may be
    considered to be an cCincludecA file and is executed, if it exists, after the
    cDhkcA file has been executed. i.e. if the hook file cDhkfoo.emfcA is already
    defined and extensions are added to cDmyfoo.emfcA.

    Note that the cDmycAcCXXXcAcD.emfcA files do not typically include any cDfhook-XXXcA
    functions, the original cCfhookcA functions would be used. However, if a
    different buffer environment is required from the one created be the hook,
    such as a different setting of lslmtab(2m)le mode, the hook function should be
    copied to cDmycAcCXXXcAcD.emfcA and altered appropriately.

    Most extensions and changes to the buffer environment may be performed
    using cDmycAcCXXXcAcD.emfcA. If the extension macro file includes a macro definition
    cDmy-fhook-cAcCXXXcA, then cDmy-fhookcAcCXXXcA is automatically executed after cDfhookcAcCXXXcA
    has been run.


cEAdding Hilighting definitions cA


    File specific hilighting is used to pick out key words and tokens used
    within the file type, it greatly improves readability; the hilighting is
    also used for lsprint-buffer(2)lmprintingle. The hilighting is defined within the body of the
    file and is executed once when the hook file is loaded, this occurs when
    the hook function is executed. During development of the hilighting code,
    it is usually necessary to lsexecute-buffer(2)lmexecutele the hook buffer to view the effects of
    any changes to the hilighting.

    The hilighting is defined using the command lslmhilight(2)le which requires a
    hilighting identifier, used to identify the hilighting scheme. This
    identifier is dynamically allocated when the hook file is loaded, again
    using cCfoocA, the identifier is allocated at the top of the file and is
    protected such that a value is assigned once only.
sB
        !if &sequal .hilight.foo "ERROR"
            set-variable .hilight.foo &pinc .hilight.next 1
        !endif

sA
    The variable cG.hilight.nextcA allocates unique hilighting numbers, typically
    a single hilighting number is consumed, incrementing the cG.hilight.nextcA
    variable ready for the next allocation. The hilighting color scheme is
    defined in a macro variable cD.hilight.cAcCextcA, where cCextcA is the name of the
    language scheme (i.e. cCfoocA).

    Given a hilighting number, the hilighting scheme may be defined. Each of
    the tokens in the language is assigned a hilighting color, for our simple
    cCfoocA file type:-
sB
        0 hilight .hilight.foo 1                $global-scheme
        hilight .hilight.foo 2 "#"              .scheme.comment
        hilight .hilight.foo 4 "\"" "\"" "\\"   .scheme.string
        hilight .hilight.foo 0 "'.'"            .scheme.quote
        hilight .hilight.foo 0 "'\\\\.'"        .scheme.quote ; '\?' quoted char

        hilight .hilight.foo 1 "if"             .scheme.keyword
        hilight .hilight.foo 1 "then"           .scheme.keyword
        hilight .hilight.foo 1 "else"           .scheme.keyword
        hilight .hilight.foo 1 "endif"          .scheme.keyword

sA
    When the hilighting tokens have been defined, the hilighting scheme is
    bound to the buffer. This is performed by assigning lslm$buffer-hilight(5)le
    with the hilighting scheme within the cCfhookcA macro body, e.g.
sB
        define-macro fhook-foo
            ; Assign the hilighting
            set-variable $buffer-hilight .hilight.foo
            ; Temporary comment to make sure that it works.
            ml-write "Loaded a foo file"
        !emacro

sA
    Putting it all together cGhkfoo.emfcA now comprises:-
sB
        !if &sequal .hilight.foo "ERROR"
            ; Allocate a hilighting scheme number
            set-variable .hilight.foo &pinc .hilight.next 1
        !endif

        ; Define the hilighting scheme
        0 hilight .hilight.foo 1                $global-scheme
        hilight .hilight.foo 2 "#"              .scheme.comment
        hilight .hilight.foo 4 "\"" "\"" "\\"   .scheme.string
        hilight .hilight.foo 0 "'.'"            .scheme.quote
        hilight .hilight.foo 0 "'\\\\.'"        .scheme.quote ; '\?' quoted char

        hilight .hilight.foo 1 "if"             .scheme.keyword
        hilight .hilight.foo 1 "then"           .scheme.keyword
        hilight .hilight.foo 1 "else"           .scheme.keyword
        hilight .hilight.foo 1 "endif"          .scheme.keyword

        ; File hook - called when new file is loaded.
        define-macro fhook-foo
            ; Assign the hilighting
            set-variable $buffer-hilight .hilight.foo
            ; Temporary comment to make sure that it works.
            ml-write "Loaded a foo file"
        !emacro

        ; Notification that hook is loaded.
        ml-write "[MicroEmacs foo file hook loaded]"

sA

cEAdding a Template cA


    A template inserts initial text into a new file that is created. This
    mechanism is typically used to insert a standard header into the file on
    creation. The insertion text is defined within a template file, given the
    file extension lslmetf(8)le, which is created in the corresponding global,
    company or user directory as determined in step 1. The template is named
    cCextcA.etf, so for our example file cCfoocA, the template file is called cGfoo.etfcA.
    We shall simply add a file header, our comment is cG#cA (as defined by the
    hilighting tokens). Our example cCfoocA template file cGfoo.etfcA may be defined
    as follows:-

        #-!- foo -!- #################################
        #
        #  Created By    : $USER_NAME$
        #  Created       : $ASCII_TIME$
        #  Last Modified : <160495.1521>
        #
        #  Description
        #
        #  Notes
        #
        #  History
        #
        #  Copyright (c) $YEAR$ $COMPANY_NAME$.
        ##############################################


    The template file must be explicitly loaded by the hook file, within the
    cDfhookcA function. A new file condition may be tested within the fhook macro
    by checking the numerical argument, an argument of 0 indicates that this
    is a new file. The template file is inserted with an invocation of
    lslmetfinsrt(3)le. The cDfhookcA macro checks the argument and inserts the template
    file as follows:-
sB
        ; File hook - called when new file is loaded.
        define-macro fhook-foo
            ; if arg is 0 this is a new file so add template
            !if &not @#
                etfinsrt "foo"
            !endif
            ; Assign the hilighting
            set-variable $buffer-hilight .hilight.foo
            ; Temporary comment to make sure that it works.
            ml-write "Loaded a foo file"
        !emacro

sA

cEAdding abbreviations cA


    Abbreviations are short-cut expansions which may be defined for the
    language specific file. The abbreviations are defined in a lslmeaf(8)le file,
    cCextcA.eaf, located in the appropriately defined MicroEmacs directory. The
    abbreviation file defines the key sequences which may be automatically
    inserted, under user intervention, using lslmexpand-abbrev(2)le. An abbreviation
    file for cCfoocA, cGfoo.eafcA, may be defined as:-

        if "if \p\rthen\rendif\P"
        el "else\r\p\P"


    The binding to the hook is defined in the cCfhookcA macro using
    lslmbuffer-abbrev-file(2)le. For the example language file cCfoocA the cCfhookcA macro
    becomes:-
sB
        ; File hook - called when new file is loaded.
        define-macro fhook-foo
            ; if arg is 0 this is a new file so add template
            !if &not @#
                etfinsrt "foo"
            !endif
            ; Assign the hilighting
            set-variable $buffer-hilight .hilight.foo
            ; Set the abbreviation file
            buffer-abbrev-file "foo"
            ; Temporary comment to make sure that it works.
            ml-write "Loaded a foo file"
        !emacro

sA

cEAutomatic Indentation cA


    Automatic indentation may be applied to the file, such that the
    indentation is automatically performed when new lines are entered into the
    file. Indentation also benefits from automatic re-styling operations using
    lslmrestyle-region(3)le and lslmrestyle-buffer(3)le.

    The indentation style is declared by defining language tokens that
    constitute positions in the syntax where the indentation is changed. The
    indentation requires a unique identifier to identify the indentation
    style, the hilighting identifier is used. If hilighting is not defined,
    then the language template may still obtain an identifier as described in
    the hilighting section.

    The indention is create with an argument of cG0cA to the lslmindent(2)le command,
    the subsequent tokens are defined using cDindentcA with no argument. For our
    simple cCfoocA syntax then the indentation might be defined as follows:-
sB
        0 indent  .hilight.foo 2 10
        indent .hilight.foo n "then" 4
        indent .hilight.foo s "else" -4
        indent .hilight.foo o "endif" -4

sA
    This provides an indentation of the form:-

        if condition
        then
            XXXX
        else
            if condition
            then
                XXXX
            endif
        endif


    The indentation is bound to the buffer in the cCfhookcA macro by defining
    lslm$buffer-indent(5)le. For the example file cCfoocA then the cCfhookcA is defined as:-
sB
        ; File hook - called when new file is loaded.
        define-macro fhook-foo
            ; if arg is 0 this is a new file so add template
            !if &not @#
                etfinsrt "foo"
            !endif
            ; Assign the hilighting
            set-variable $buffer-hilight .hilight.foo
            ; Assign the buffer indentation
            set-variable $buffer-indent .hilight.foo
            ; Set the abbreviation file
            buffer-abbrev-file "foo"
            ; Temporary comment to make sure that it works.
            ml-write "Loaded a foo file"
        !emacro

sA

cESetting Buffer Modes cA


    Buffer modes which are to be adopted (or discarded) by the language
    specific file are defined in the cCfhookcA macro. Typical modes that are
    applied are:-

    lstime(2m)lmtimele
        Enables time stamping on the file, modifying the time stamp field with
        the modification date and time.

    lsindent(2m)lmindentle
        Automatic indentation, where the cursor is returned to the same column
        on entering a new line, rather than to the start of the line.

    As an example, the cCfoocA cCfhookcA file becomes:-
sB
        ; File hook - called when new file is loaded.
        define-macro fhook-foo
            ; if arg is 0 this is a new file so add template
            !if &not @#
                etfinsrt "foo"
            !endif
            ; Assign the hilighting
            set-variable $buffer-hilight .hilight.foo
            ; Assign the buffer indentation
            set-variable $buffer-indent .hilight.foo
            ; Set the abbreviation file
            buffer-abbrev-file "foo"
            ; Set up the buffer modes
            1 buffer-mode "time"
            1 buffer-mode "indent"
            ; Temporary comment to make sure that it works.
            ml-write "Loaded a foo file"
        !emacro

sA

cEAssigning New Bindings cA


    New bindings and language specific macros may be added to the language
    specific file. New macros, to extend the repertoire of commands
    specifically developed for the language file are defined within the macro
    body using lslmdefine-macro(2)le these are automatically loaded when the hook
    file is loaded, which in turn is loaded when the file type is identified
    and loaded.

    New bindings, which may be associated with new macros or existing
    commands, are assigned within the cCfhookcA macro. As an example, we shall
    extend the cCfoocA language file to include a commenting and uncommenting
    macros, locally binding the macros to the keys "cGC-c C-ccA" and "cGC-c C-dcA"
    respectively. The macro definitions are defined as follows:-
sB
        ; Macro to comment a line
        define-macro foo-comment-line
            !while &gre &pdec @# 1 0
                beginning-of-line
                insert-string "#"
                beginning-of-line
                forward-line
            !done
        !emacro

        ; Macro to remove a comment from a line
        define-macro foo-uncomment-line
            !while &gre &pdec @# 1 0
                beginning-of-line
                -1 search-forward "#"
                backward-delete-char
                forward-line
            !done
        !emacro

sA
    The key bindings for the macros are defined for the local buffer ONLY, as
    such are added using lslmbuffer-bind-key(2)le. The bindings are declared in the
    cCfhookcA macro as follows:-
sB
        ; File hook - called when new file is loaded.
        define-macro fhook-foo
            ; if arg is 0 this is a new file so add template
            !if &not @#
                etfinsrt "foo"
            !endif
            ; Assign the hilighting
            set-variable $buffer-hilight .hilight.foo
            ; Assign the buffer indentation
            set-variable $buffer-indent .hilight.foo
            ; Set the abbreviation file
            buffer-abbrev-file "foo"
            ; Set up the buffer modes
            1 buffer-mode "time"
            1 buffer-mode "indent"
            ; Set up local bindings
            buffer-bind-key foo-comment-line "C-c C-c"
            buffer-bind-key foo-uncomment-line "C-c C-d"
            ; Temporary comment to make sure that it works.
            ml-write "Loaded a foo file"
        !emacro

sA

cEAllowing Other to Modify the Hook cA


    Other users of the file hook may need to modify or extend the file hook,
    the most common form is the addition of user specific hilight tokens.
    MicroEmacs uses a simple mechanism of executing a user hook extension file
    if it exists. The extension file name must be of the form cDmycAcCXXXcAcD.emfcA, i.e.
    for our example it must be "cGmyfoo.emfcA". This is performed at the end of
    the macro file so that anything within the file can be altered, it is
    executed as follows:-
sB
        ; load in user extensions if found
        !force execute-file "myfoo"

sA
    Note the lslm!force(4)le directive is used as the file may not exist.


cESumming Up cA


    The previous sections have presented the basic steps involved in setting
    up a new language file template. They cater for simple file types, for
    more complex examples then browse the cDhkcAcCxxxcA.emf files.

    The completed files that should have been generated by following the
    previous examples are now presented:-

    cDfile.foocA

        # This is a comment.
        if condition
        then
            do something
        else
            if condition
            then
                do something
            endif
        endif


    cDhkfoo.emfcA
sB
        !if &sequal .hilight.foo "ERROR"
            ; Allocate a hilighting scheme number
            set-variable .hilight.foo &pinc .hilight.next 1
        !endif

        ; Define the hilighting scheme
        0 hilight .hilight.foo 1                $global-scheme
        hilight .hilight.foo 2 "#"              .scheme.comment
        hilight .hilight.foo 4 "\"" "\"" "\\"   .scheme.string
        hilight .hilight.foo 0 "'.'"            .scheme.quote
        hilight .hilight.foo 0 "'\\\\.'"        .scheme.quote ; '\?' quoted char

        hilight .hilight.foo 1 "if"             .scheme.keyword
        hilight .hilight.foo 1 "then"           .scheme.keyword
        hilight .hilight.foo 1 "else"           .scheme.keyword
        hilight .hilight.foo 1 "endif"          .scheme.keyword

        ; File hook - called when new file is loaded.
        define-macro fhook-foo
            ; Assign the hilighting
            set-variable $buffer-hilight .hilight.foo
            ; Temporary comment to make sure that it works.
            ml-write "Loaded a foo file"
        !emacro

        ; Define the indentation scheme
        0 indent  .hilight.foo 2 10
        indent .hilight.foo n "then" 4
        indent .hilight.foo s "else" -4
        indent .hilight.foo o "endif" -4

        ; Reset the hilighting printer format and define the color bindings.
        0 hilight-print .hilight.foo
        hilight-print .hilight.foo "i"  .scheme.comment
        hilight-print .hilight.foo "b"  .scheme.keyword
        hilight-print .hilight.foo "bi" .scheme.string .scheme.quote

        ; Macro to comment a line
        define-macro foo-comment-line
            !while &gre &pdec @# 1 0
                beginning-of-line
                insert-string "#"
                beginning-of-line
                forward-line
            !done
        !emacro

        ; Macro to remove a comment from a line
        define-macro foo-uncomment-line
            !while &gre &pdec @# 1 0
                beginning-of-line
                -1 search-forward "#"
                backward-delete-char
                forward-line
            !done
        !emacro

        ; File hook - called when new file is loaded.
        define-macro fhook-foo
            ; if arg is 0 this is a new file so add template
            !if &not @#
                etfinsrt "foo"
            !endif
            ; Assign the hilighting
            set-variable $buffer-hilight .hilight.foo
            ; Assign the buffer indentation
            set-variable $buffer-indent .hilight.foo
            ; Set the abbreviation file
            buffer-abbrev-file "foo"
            ; Set up the buffer modes
            1 buffer-mode "time"
            1 buffer-mode "indent"
            ; Set up local bindings
            buffer-bind-key foo-comment-line "C-c C-c"
            buffer-bind-key foo-uncomment-line "C-c C-d"
            ; Temporary comment to make sure that it works.
            ml-write "Loaded a foo file"
        !emacro

        ; Notification that hook is loaded.
        ml-write "[MicroEmacs foo file hook loaded]"

        ; load in user extensions if found
        !force execute-file "myfoo"

sA
    cDfoo.eafcA

        if "if \p\rthen\rendif\P"
        el "else\r\p\P"


    cDfoo.etfcA

        #-!- foo -!- #################################
        #
        #  Created By    : $USER_NAME$
        #  Created       : $ASCII_TIME$
        #  Last Modified : <160495.1521>
        #
        #  Description
        #
        #  Notes
        #
        #  History
        #
        #  Copyright (c) $YEAR$ $COMPANY_NAME$.
        ##############################################


cEcESEE ALSO cEcA


    lslmadd-file-hook(2)le, lslmbuffer-abbrev-file(2)le, lslmbuffer-init(3)le, lslmetfinsrt(3)le,
    lslmexecute-buffer(2)le, lslmexpand-abbrev(2)le, lslmglobal-abbrev-file(2)le, lslmhilight(2)le,
    lslmscheme-editor(3)le, lslmindent(2)le, lslmindent(2m)le, lslmrestyle-buffer(3)le,
    lslmrestyle-region(3)le, lslmtime(2m)le, lslm$buffer-hilight(5)le, lslm$buffer-indent(5)le,
    lslmetf(8)le, lslmeaf(8)le,
    lsfileHooks(2)lmFile Hooksle.
! 1 Installation
cEcEINSTALLATION cEcA


    This page describes introductory notes for the installation and setup of
    MicroEmacs 2009.


cEQuick Install cA


    The quickest way to install MicroEmacs for testing without reading the
    rest of this document is to:-

        * Create a new directory i.e. cGjasspacA.
        * Unpack the macros archive into this directory.
        * Unpack the executable into this directory.
        * Run cGmecA from this directory.

    On starting, you will be prompted for a default directory, accept the
    defaults. Use the mouse and configure the user from the menu bar:-

        Tools -> User Setup


    This allows the user and screen settings to be altered. On becoming more
    accustomed to the editor then a fuller installation may be performed.

    cDGetting HelpcA
        See lslmContact Informationle for full contact information. A mail archive
        exists at:-

            http://groups.yahoo.com/group/jasspa/


        If you wish to participate in the list then you must first register by
        sending an empty mail message body to:-

            jasspa-subscribe@yahoogroups.com


        You will then be able to mail any questions into the group.
        Registration is required in order to prevent cCspamcA mailings from
        entering into the lists.


cEDistribution cA


    MicroEmacs is distributed in the following files:-

    cDComplete Installations cA
        The Microsoft 95/98/NT/2K/XP, Solaris, HP-UX, Linux and the more
        popular platforms may be installed using a package and do not require
        the components specified in later sections as these are all bundled
        together (these packages do not include spelling).

        cGjasspa-me-YYYYMMDD-1.i386.rpmcA - Linux RedHat 9.x package.
        cGjasspa-me-YYYYMMDD-1.src.rpmcA - Linux RedHat 9.x source package.
        cGjasspa-mepkg-hpux-pa-10.20-YYYYMMDD.depot.gzcA - HP-UX 10 package.
        cGjasspa-mepkg-hpux-pa-11.00-YYYYMMDD.depot.gzcA - HP-UX 11 package.
        cGjasspa-mepkg-ms-win32-2004030.zipcA  - 95/98/NT/2K/XP Install Shield
        cGjasspa-mepkg-sun-i386-58-YYYYMMDD.zipcA - Sun 2.8(i386) package.
        cGjasspa-mepkg-sun-i386-59-YYYYMMDD.zipcA - Sun 2.9(i386) package.
        cGjasspa-mepkg-sun-sparc-56-YYYYMMDD.zipcA - Sun 2.6(Sparc) package.
        cGjasspa-mepkg-sun-sparc-58-YYYYMMDD.zipcA - Sun 2.8(Sparc) package.
        cGjasspa-mepkg-sun-sparc-59-YYYYMMDD.zipcA - Sun 2.9(Sparc) package.

    cDExecutable Source Code cA
        The source code release for MicroEmacs 2009 contains makefiles (cG*.makcA)
        for all supported platforms. Microsoft '95/'98/NT/2K/XP makefiles
        contain options at the top of the makefile to enable/disable console
        and URL support.

        cGjasspa-mesrc-YYYYMMDD.zipcA - Source code for all platforms
        cGjasspa-mesrc-YYYYMMDD.tar.gzcA - Source code

    cDExecutable Images cA
        cGjasspa-me-cygwin-YYYYMMDD.exe.gzcA - Cygwin Executable (X-Windows)
        cGjasspa-me-hpux-pa-10.20-YYYYMMDD.gzcA - Hewlett Packard HP-UX 10
        Executable
        cGjasspa-me-hpux-pa-11.00-YYYYMMDD.gzcA - Hewlett Packard HP-UX 11
        Executable
        cGjasspa-me-ibm-aix-4-YYYYMMDD.gzcA - IBM's AIX 4.3 Executable
        cGjasspa-me-linux-i386-2.4-YYYYMMDD.gzcA - Linux 2.2.x/2.4.x Executable
        cGjasspa-me-linux-i386-2.6-YYYYMMDD.gzcA - Linux 2.6.x Executable
        cGjasspa-me-ms-win32-YYYYMMDD.zipcA - Windows 32' (95/98/NT/2K/XP)
        Executable
        cGjasspa-me-ms-win32s-YYYYMMDD.zipcA - Windows win32s (Win3.1/3.11)
        Executable
        cGjasspa-me-msdos-djgpp1-YYYYMMDD.zipcA - DOS Executable (DJGPP v1.x)
        cGjasspa-me-msdos-djgpp2-YYYYMMDD.zipcA - DOS Executable (DJGPP v2.x)
        cGjasspa-me-openbsd-i386-3.4-YYYYMMDD.gzcA - Open BSD 3.4 Executable
        cGjasspa-me-sgi-irix-6-YYYYMMDD.gzcA - Silicon Graphics Irix 6 Executable
        cGjasspa-me-sun-i386-58-YYYYMMDD.gzcA - Sun Solaris 2.8 Intel Platform
        Executable
        cGjasspa-me-sun-i386-59-YYYYMMDD.gzcA - Sun Solaris 2.9 Intel Platform
        Executable
        cGjasspa-me-sun-sparc-56-YYYYMMDD.gzcA - Sun OS 5.5 Executable
        cGjasspa-me-sun-sparc-58-YYYYMMDD.gzcA - Sun OS 5.8 Executable
        cGjasspa-me-sun-sparc-59-YYYYMMDD.gzcA - Sun OS 5.9 Executable
        cGjasspa-mec-apple-darwin-6.6-YYYYMMDD.gzcA - Apple console Executable
        cGjasspa-mec-cygwin-YYYYMMDD.exe.gzcA - Cygwin Executable (Console)

    cDHelp File ImagescA (all platforms)
        cGjasspa-mewinhlp-YYYYMMDD.zipcA - Windows Help file
        cGjasspa-mehtm-YYYYMMDD.zipcA  - HTML Help files for 8.3 file systems
        (.htm)
        cGjasspa-mehtml-YYYYMMDD.tar.gzcA - HTML Help files (.html)

    cDMacro File ImagescA (all platforms)
        cGjasspa-memacros-YYYYMMDD.tar.gzcA - Macro files
        cGjasspa-memacros-YYYYMMDD.zipcA - Macro files

        cGjasspa-metree-YYYYMMDD.tar.gzcA - Complete install tree + help
        cGjasspa-metree-YYYYMMDD.zipcA - Complete install tree + help

    cDSpelling DictionariescA (all platforms)
        One of the following base dictionaries is required for spelling. The
        extended dictionaries require the base dictionary and are recommended
        for a more comprehensive spelling list. Other languages are supported.

        cGls_dede.zipcA - German rules and base + extended dictionary.
        cGls_engb.zipcA - British rules and base + extended dictionary.
        cGls_enus.zipcA - American rules and base + extended dictionary.
        cGls_eses.zipcA - Spanish rules and dictionary.
        cGls_frfr.zipcA - French rules and dictionary.
        cGls_itit.zipcA - Italian rules and dictionary
        cGls_plpl.zipcA - Polish rules and dictionary.
        cGls_ptpt.zipcA - Portuguese rules and dictionary.
        cGls_ruye.zipcA - Russian YE rules and dictionary.
        cGls_ruyo.zipcA - Russian YO rules and dictionary.

        cGls_dede.tar.gzcA - German rules and base + extended dictionary.
        cGls_engb.tar.gzcA - British rules and base + extended dictionary.
        cGls_enus.tar.gzcA - American rules and base + extended dictionary.
        cGls_eses.tar.gzcA - Spanish rules and dictionary.
        cGls_frfr.tar.gzcA - French rules and dictionary.
        cGls_itit.tar.gzcA - Italian rules and dictionary
        cGls_plpl.tar.gzcA - Polish rules and dictionary.
        cGls_ptpt.tar.gzcA - Portuguese rules and dictionary.
        cGls_ruye.tar.gzcA - Russian YE rules and dictionary.
        cGls_ruyo.tar.gzcA - Russian YO rules and dictionary.

        cDNOTE:cA The binary versions of the executables held on the site include
        the platform name as part of the executable name i.e. cDmecA for cGDOScA is
        called cDmedos.execA. On installing the binaries onto the target machine,
        you should rename the executable to cDmecA or cDme.execA, whatever is
        appropriate. The ONLY exception to this rule is the Microsoft Windows
        executable where cDmewin32.execA should be renamed to cDme32.execA. Our reason
        for this naming is to allow the executables to be unpacked in the same
        directory and not be confused with each other.


cEInstallation Directories cA


    The suggested installation structure for all platforms is defined as:-

                  jasspa
                  / | \
                 /  |  \
                /   |   \
         spelling macros company


    This directory structure is suggested to facilitate upgrades in the future
    and to keep user data separate from the system macros. MicroEmacs
    understands this directory structure.

    The directory structures are defined as:

    cDmacroscA
        The standard macro distribution, as supplied by JASSPA.

    cDspellingcA
        Spelling dictionaries.

    cDcompanycA
        Company wide local definitions for the local site. This directory may
        be omitted if not applicable. Header templates (cG.etfcA are typically
        copied from the cGmacrocA directory to the cGcompanycA directory and modified
        for the local site.

    The search order is defined as cGrootcA, cGcompanycA, cGmacroscA, cGspellingcA.


cEUNIX Installation (System Wide) cA


    A system wide installation on UNIX for multiple users adheres to
    conventional package installation methods.

    cDDistribution Components Required:cA
    cGjasspa-me-cAcC<unix>cAcG-YYYYMMDD.gzcA
    cGjasspa-metree-YYYYMMDD.tar.gzcA
    cC<spelling>cAcG.gzcA
    cGjasspa-mehtml-YYYYMMDD.tar.gzcA (optional)

    cDInstallation:cA
    It is recommended that the macro files are placed in a standard shared
    system directory. The standard directory locations searched by MicroEmacs
    are defined on a per-platform basis, only one of the directory locates is
    selected, as follows:

                                    HP-UX     SunOS      AIX      Cygwin
                               IRIX     UnixWare   ***BSD    Linux      NeXT
        /opt/jasspa:             y    y    y    y    y    y    n    n    n
        /usr/share/jasspa:       y    y    y    y    y    y    y    n    n
        /usr/local/jasspa:       y    y    y    y    y    y    y    y    y
        /usr/local/share/jasspa: n    n    n    n    y    n    n    n    n


        * Create the directory cG/usr/local/jasspacA.
        * Unpack and install the cGjasspa-metree-YYYYMMDD.tar.gzcA into this
          directory.
        * If spelling dictionaries are required then place them in the
          cCspellingcA sub-directory created when cCmetreecA was unpacked. Unpack and
          install the cGspellingcA into this directory.
        * If the standard icons are required for Gnome, KDE or some other
          window manager then create the sub-directory cG/usr/local/jasspa/iconscA
          and unpack and install the icons into the new directory.
        * Unpack (or build) the executable and place in "cG/usr/local/bincA"

    The executable may now be run by all users. If the macros are placed in a
    non-standard directory location then the environment variable
    ls$MEINSTALLPATH(5)lmMEINSTALLPATH(5)le to define the root jasspa tree.

    For cDcsh(1)cA users execute a "cGrehashcA" command and then lslmme(1)le can be executed
    from the command line.

    By default a X-Windows terminal is displayed, ensure that cG$DISPLAYcA and
    cG$TERMcA are correctly configured. To execute a terminal emulation then
    execute cDmecA with the cG-ncA option i.e. "cGme -ncA". Note that this is not required
    if you are using a cGvt100cA emulation.

    When MicroEmacs is executed the local directory cG~/.jasspacA is created for
    the user settings. The user home directory may be changed by setting the
    environment variable lslm$MEPATH(5)le.


cEUNIX Installation (Single User) cA


    Where the user is not permitted to install 3rd party applications in the
    system directories then MicroEmacs may be installed locally as follows:-

        * Create the directory cG~/.jasspacA.
        * Unpack and install the cGjasspa-metree-YYYYMMDD.tar.gzcA into this
          directory.
        * If spelling dictionaries are required then place them in the
          cCspellingcA sub-directory created when cCmetreecA was unpacked. Unpack and
          install the cGspellingcA into this directory.
        * If the standard icons are required for Gnome, KDE or some other
          window manager then create the sub-directory cG~/.jasspa/iconscA and
          unpack and install the icons into the new directory.
        * The user files will be placed in the cG~/.jasspacA directory by default.
          To keep the user macros separate then the directory
          cG~/.jasspa/$LOGNAMEcA may be created and will identified as the users
          home directory.
        * Unpack (or build) the executable and place in "cG~/bincA"

    MicroEmacs may be executed after it has been re-hashed (depending on the
    shell).


cEDOS Installation cA


    MS-DOS has no concept of a standard installation directory. The location
    of the MicroEmacs macros is generally determined from the directory
    location of the executable.

    cDExecutable:cA
    Compiled with DJGPP V1.0

    Distribution components required:
        cGjasspa-me-msdos-djgpp1-YYYYMMDD.zipcA
        cGjasspa-metree-YYYYMMDD.zipcA
        cC<spelling>cAcG.zipcA

        cGmewinhlp.zipcA if you are using windows 3.1/3.11

    Recommended installed components:
        cGgrepcA - Version of grep (djgpp recommended)
        cGmakecA - Version of make (djgpp recommended)
        cGdiffcA - Version of diff (djgpp recommended)

    cDInstallation:cA
    This installation relies on the executable position.

        * Create the directory cGc:\jasspacA (or other location)
        * Unpack and install the cGjasspa-metree-YYYYMMDD.zipcA into this
          directory.
        * If spelling dictionaries are required then place them in the
          cCspellingcA sub-directory created when cCmetreecA was unpacked. Unpack and
          install the cGspellingcA into this directory.
        * Unzip the executable and place it in the jasspa root directory
          cGc:\jasspacA.
        * Edit "cGc:\autoexec.batcA" and add the following lines:-


            SET PATH=%PATH%;c:\jasspa


        * Reboot the system.
        * MicroEmacs may be run from the command line using cDmecA.

    cDGraphics Cards:cA
    MicroEmacs may be configured to the text modes of your graphics card.
    Refer to you graphics card DOS text modes to identify the text modes
    supported by your monitor. The text mode number may be entered into the
    user monitor configuration, defined in cDToolscA -> cDUser SetupcA.

    Running DOS Version From Windows (3.x)
        The MS-DOS version of MicroEmacs may be executed from a cD.pifcA file. Use
        the pif editor to create a new cD.pifcA file to launch MicroEmacs. The
        size of the DOS window may be configured from the command line, set
        the terminal size using one of the following command lines:-

                me -c -v$TERM=E80x50        - 80 x 50 window
                me -c -v$TERM=E80x25        - 80 x 25 window.


        We usually add the cG-ccA option so that MicroEmacs is executed with
        history information. This may be omitted if required.


cEMicrosoft Windows 3.1/3.11 cA


    cDExecutable:cA
    Compiled with Microsoft Developer 2.0

    cDHelper DLL:cA
    Under cDWin32scA a helper DLL cDmethnk16.dllcA is required to perform the
    lslmpipe-shell-command(2)le in a synchronous manner. This should be installed
    into the cGC:\WINDOWS\SHELLcA directory. This (rather inelegantly) gets around
    the problems of spawning a process under cDwin32scA due to a number of
    Microsoft bugs in the operating system. Note: that on a spawn operation a
    cGMS-DOScA window is visible, this is due to the nature of the command shell
    on this platform which has a tendency to prompt the user at every
    opportunity, hence a certain amount of interaction (which is out of our
    control) is necessary.

    The helper DLL is compiled with a 16-bit Windows compiler - MSVC 1.5.

    cDDistribution components required:cA

        cGjasspa-me-ms-win32s-YYYYMMDD.zipcA
        cGjasspa-metree-YYYYMMDD.zipcA
        cGjasspa-mewinhlp-YYYYMMDD.zipcA
        cC<spelling>cAcG.zipcA

    cDRecommended installed components:cA

        cG4doscA - command shell (giving cCstderrcA redirection)
        cGgrepcA - Version of grep (GNU port of grep recommended)
        cGdiffcA - Version of diff (GNU port of grep recommended)
        cGmakecA - use nmake or GNU port of make.

        IfcDwin32scA is a requirement on this platform, typically taken from
        cDpw1118.execA which freely available on the Internet.

    cDInstallation:cA
    This version of Windows does not have a cCinstallcA directory as '95/'98 and
    it is expected that the cGMS-DOScA version will coexist. No cCInstallcA cCShieldcA
    installation is provided. Install in a directory structure similar to
    cGMS-DOScA. Install the helper DLL cDmethnk16.dllcA in the cGC:\WINDOWS\SHELLcA
    directory. Create a lslmme32.ini(8)le file in the cGC:\WINDOWScA directory to
    identify the location of the MicroEmacs 2009 components, this much the
    same as the '95/'98 file, change the directory paths to suite the install
    base.

    cDSupport Status:cA
    The cDwin32scA release has not been used with vengeance, although no specific
    problems have been reported with this release.


cEWindows 95/98/NT/2K/XP cA


    cDExecutable:cA

        Compiled with Microsoft Developer 6.x

    cDInstall ShieldcA

        An cDInstall ShieldcA version of MicroEmacs is available which includes
        all of the distribution components.

    cDDistribution components required:cA

        cGjasspa-mepkg-ms-win32-2004030.zipcA

    cDRecommended installed components:cA

        cGgrepcA - Version of grep (GNU port of grep recommended)
        cGdiffcA - Version of diff (GNU port of grep recommended)
        cGmakecA - use nmake or GNU port of make.

        A good source of UNIX native tools is

       cG http://unxutils.sourceforge.net/cA - for native windows grep, diff, zip
        etc.
       cG http://www.cygwin.comcA - for a shell environment.

    cDInstallation:cA

        * Create the directory "cGc:\Program Files\Jasspa\MicroEmacscA" (or other
          location)
        * Create the sub-directory cGc:\Program Files\Jasspa\MicroEmacs\macroscA.
          Unpack and install the cGmemacros.zipcA into this directory
        * If spelling dictionaries are required then create the directory
          cGc:\Program Files\Jasspa\MicroEmacs\spellingcA. Unpack and install the
          cGspellingcA into this directory.
        * Unzip the executable components into "cGC:\Program
          Files\Jasspa\MicroEmacscA"
        * Create a short cut to MicroEmacs for the Desktop

        Right click on the desk top

        cG=> NewcA
        cG=> ShortcA
        cG=> Command Line: "c:\Program Files\Jasspa\MicroEmacs\me.exe -c"cA
        cG=> Short Cut Name: "MicroEmacs"cA

        MicroEmacs may be executed from the shortcut.

    cDOpen ActionscA Microsoft Windows 95/98/NT provide short cut actions,
    assigning an open action to a file. The short cuts may be installed from
    the cDInstall ShieldcA installation, but may alternatively be explicitly
    defined by editing the registry file with cDregedit(1)cA.

    A file open action in the registry is bound to the file file extension, to
    bind a file extension cC.foocA to the editor then the following registry
    entries should be defined:-

        [HKEY_CLASSES_ROOT\.foo]
        "MicroEmacs_foo"
        [HKEY_CLASSES_ROOT\MicroEmacs_foo\DefaultIcon]
        "C:\Program File\JASSPA\MicroEmacs\meicons,23"
        [HKEY_CLASSES_ROOT\MicroEmacs_foo\Shell\open]
        "&Open"
        [HKEY_CLASSES_ROOT\MicroEmacs_foo\Shell\open\command]
        "C:\Program File\JASSPA\MicroEmacs\me32.exe -o "%1""


    In the previous example the cCDefaultIconcA entry is the icon assigned to the
    file. This may be an icon taken from cGmeicons.execA (in this case icon number
    23), or may be some other icon. The open action in the example uses the cD-ocA
    option of the cCclient-servercA, which loads the file into the current
    MicroEmacs 2009 session, alternatively the cD-ccA option may be used to retain
    the previous context, or no option if a new session with no other files
    loaded is started.

    A generic open for ALL files may be defined using a wild-card, this may be
    used to place a cCMicroEmacscA edit entry in the right-click pop-up menu, as
    follows:-

        [HKEY_CLASSES_ROOT\*\shell]
        [HKEY_CLASSES_ROOT\*\shell\MicroEmacs]
        "&MicroEmacs"
        [HKEY_CLASSES_ROOT\*\shell\MicroEmacs\command]
        "C:\Program File\JASSPA\MicroEmacs\me32.exe -o "%1""


cEcEORGANIZING A LOCAL USER PROFILE cEcA


    MicroEmacs uses local user configuration profiles to store user specific
    information. The user information may be stored in the MicroEmacs
    directory, or more typically in a users private directory. On login
    systems then the user name and user private directory location is
    automatically determined from the system.

    The user name identified by MicroEmacs is lslm$user-name(5)le this value may be
    set or re-defined using the environment variable lslm$MENAME(5)le. On MS-DOS and
    early windows systems where there is no user login then then lslm$MENAME(5)le
    may be defined in the environment.

    The location of the user information depends upon your platform and
    installation configuration. The private directory identified by MicroEmacs
    is lslm$user-path(5)le this location may be changed by defining the environment
    variable lslm$MEUSERPATH(5)le.

    Microsoft Windows users may use the lslmme32.ini(8)le file to define MicroEmacs
    configuration path and name information.


cEUser Profile Files cA


    Files contained in the user profiles typically include:-

    cC<name>cAcG.emfcA - The users start up profile - cC<user>cA.emf.
    cC<name>cAcG.edfcA - The users spelling dictionary.
    cC<name>cAcG.erfcA - The users registry configuration file.

    These files are automatically set up by MicroEmacs. These files are
    established from the menu "cDToolscA -> cDUser SetupcA". The "cDSetup PathcA" item
    defines the location of the files, but must be MANUALLY included in the
    cG$MEPATHcA environment.


cECompany Profiles cA


    Company profiles include standard files and extensions to the standard
    files which may be related to a company, this is typically cC<company>cA.emf
    where cC<company>cA is the name of the company.

    The directory may also include template files lslmetf(8)le files which defines
    the standard header template used in the files. Files in the "cGcompanycA"
    directory would over-ride the standard template files.


cEcESEE ALSO cEcA


    lslm$user-name(5)le, lslm$user-path(5)le, lslm$MEINSTALLPATH(5)le, lslm$MENAME(5)le, lslm$MENAME(5)le,
    lslm$MEPATH(5)le, lslm$MEUSERPATH(5)le, lsCompanyProfiles(2)lmCompany Profilesle, lsfileHooks(2)lmFile Hooksle, lslanguageTemplates(2)lmFile Languageln
    lnTemplatesle, lsUserProfiles(2)lmUser Profilesle.
! 2 CompanyProfiles
cEcECOMPANY PROFILES cEcA


    This section describes how a company profile should be incorporated into
    MicroEmacs 2009. A company profile defines a set of extensions to
    MicroEmacs which encapsulate settings which are used on a company wide
    basis. This type of configuration is typically used with a networked
    (shared) installation. The company profile would typically include:-

        * Name of the company.
        * Standard header files including company copyright statements.
        * Standard file layouts
        * Company defined language extensions.


cELocation Of The Company Information cA


    It is suggested that all of the company extensions applied to MicroEmacs
    2009 are performed in a separate directory location which shadows the
    MicroEmacs standard macro file directory. This enables the original files
    to be sourced if a user does not want to include the company files. This
    method also allows MicroEmacs to be updated in the future, whilst
    retaining the company files.

    The company files are generally placed in the cGcompanycA sub-directory
    described in the installation notes.


cEContent Of The Company Information cA


    cDCompany macro file cA
        The company file is typically called by the company name (i.e.
        cGjasspa.emfcA) create a new company file. The file includes your company
        name and hook functions for any new file types that have been defined
        for the company, an example company file for cDJasspacA might be defined
        as:-
sB
            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
            ;
            ;  Author        : Jasspa
            ;  Created       : Thu Jul 24 09:44:49 1997
            ;  Last Modified : <090829.1633>
            ;
            ;  Description     Extensions for Jasspa
            ;
            ;  Notes
            ;
            ;  History
            ;
            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
            ; Define the name of the company.
            set-variable %company-name "Jasspa"
            ; Add Jasspa specific file hooks
            ; Make-up foo file hook
            add-file-hook ".foo"    fhook-foo
            1 add-file-hook "-!-[ \t]*foobar.*-!-" fhook-foo ; -!- foobar -!-
            ; Override the make with localised build command
            set-variable %compile-com "build"

sA
        The file contains company specific file hooks and the name of the
        company.

    cDOther Company Files cA
        Files defined on behalf of the company are included in the company
        directory. These would include:-

                * Template header files lslmetf(8)le.
                * Hook file definitions (cDhkcAcCXXXcAcD.emfcA) for company specific
                  files, see lslmadd-file-hook(2)le.
                * Extensions to the standard hook definitions (cDmycAcCXXXcAcD.emfcA) for
                  company specific language extensions to the standard hook
                  files. See lsfileHooks(2)lmFile Hooksle and lslanguageTemplates(2)lmFile Language Templatesle.


cEcESEE ALSO cEcA


    lslm$MEINSTALLPATH(5)le, lslm$MENAME(5)le, lslm$MEPATH(5)le, lsfileHooks(2)lmFile Hooksle, lslanguageTemplates(2)lmFile Languageln
    lnTemplatesle, lsInstallation(1)lmInstallationle, lslmuser-setup(3)le, lsUserProfiles(2)lmUser Profilesle.
! 2 UserProfiles
cEcEUSER PROFILES cEcA


    This section describes how a user profile should be incorporated into
    MicroEmacs 2009. A user profile defines a set of extensions to MicroEmacs
    which encapsulates settings which are used by an individual user.

    The user profile allows:-

        * Saving of the last session (history), allowing the next invocation
          of MicroEmacs 2009 to restore your previous session. The cD-ccA option
          to lslmme(1)le restores a previous sessions buffers to the same state
          prior to exiting the editor.
        * Personalized spelling dictionaries.
        * Redefinition of MicroEmacs 2009 operation, allowing the editor to be
          tailored to an individual's requirements. Including the re-binding
          of keys, modification of the screen colors. Definition of personal
          macros etc.


cEIdentification cA


    In order to identify a user MicroEmacs 2009 uses information in the system
    to determine the name of the user, and in turn the configuration to use.
    On all systems the value of the environment variable lslm$MENAME(5)le takes
    priority over any other means of user identification. If this variable is
    not defined then the host system typically provides a mechanism to
    determine the current user. MS-DOS and Microsoft Windows systems present
    problems where a login prompt is not used.

    Each of the supported platforms are now described.

    cDUNIX cA
        The login name is determined from the cG/etc/passwdcA file and defines
        lslm$user-name(5)le. The environment variable lslm$MENAME(5)le may be defined
        alter the default user configuration file name.

    cDDOS cA
        MS-DOS typically has no concept of the user name. The user name may be
        defined in the cGautoexec.batcA file, choose a name of 8 characters or
        less, i.e. to fix the user name to cGfredcA then add the following line:-

            SET MENAME=fred


        Remember to re-boot the system before the new command takes effect.
        (see the next step, there is another change to cGautoexec.batcA).

    cDMicrosoft Windows cA
        Microsoft windows environments may, or may not, have login enabled. If
        login is enabled then lslm$user-name(5)le is set to the login user name. The
        login name may be overridden by setting the environment variable
        lslm$MENAME(5)le this may be performed in the environment or through the
        lslmme32.ini(8)le file.


cEShared Platforms cA


    Platforms may share the same set of configuration files. Consider a system
    which may boot under MS-DOS, Windows '98, NT and Linux. Provided that the
    macro files are located on a file system that may be mounted by all of the
    other operating systems and the lslm$MEUSERPATH(5)le and lslm$MEPATH(5)le are set
    appropriately to point to the users private MicroEmacs and system
    directories, then a single set of macro files may be shared across all
    platforms.


cEPersonal MicroEmacs Directory cA


    The private user profile is stored in a separate directory. The directory
    that MicroEmacs uses is typically automatically created at start up, but
    may be created manually by the user. If the directory is to be placed in a
    special location then the lslm$MEUSERPATH(5)le environment variable should be
    defined and set to point at this directory location.

    cDUNIX cA
        In the UNIX environment then the local directory is typically created
        in the users home directory obtained from the cG/etc/passwdcA file and is
        called cG~/.jasspacA. MicroEmacs will automatically look for this
        directory and set the lslm$user-path(5)le variable to this value. The
        location may be overridden by setting the environment variable
        lslm$MEUSERPATH(5)le to reference a different directory location.

    cDDOS cA
        For MS-DOS environments, there is typically no user directory, it is
        suggested that the user directory is created in the MicroEmacs
        directory, use the cG$MENAMEcA defined in the previous step i.e.

            mkdir c:\jasspa\fred


        Change or add the environment variable lslm$MEUSERPATH(5)le in the
        cDautoexec.batcA to include the new directory i.e.

            SET MEUSERPATH=c:\jasspa\fred


    cDWindows cA
        In Microsoft Windows environment using Explorer 4.0 or later then a
        user application data directory exists (cG$APPDATAcA) and MicroEmacs will
        create a directory cGjasspacA in this directory location to hold private
        data. If there is no such data area then all user configuration is
        stored in the executable directory location (or a sub-directory called
        lslm$user-name(5)le).

        The user data area lslm$user-path(5)le may be modified by creating a new
        directory and setting the environment variable lslm$MEUSERPATH(5)le to point
        to this new directory location. The location be specified by a
        cDmeuserpathcA entry in the lslmme32.ini(8)le file rather than setting the
        environment variable lslm$MEUSERPATH(5)le.


cECreating Your Profile cA


    On starting MicroEmacs for the first time then the user is guided through
    the configuration file setup to create any local configuration files. Once
    set up then MicroEmacs may be configured using the lslmuser-setup(3)le dialog:-

        Tools -> User Setup


cEThe User Profile cA


    Files created in the user directory include:-

        * Setup registry and previous session history ls$user-name(5)lm$user-namele.erf (see
          lslmerf(8)le). This stores the cDuser-setupcA settings and the context from
          previous edit sessions.
        * Users start-up file ls$user-name(5)lm$user-namele.emf (see lslmemf(8)le). This is typically
          referred to as "cCuser.emfcA" in the documentation and means the users
          private MicroEmacs macro file. The user may make local changes to
          MicroEmacs in this file, this may include definition of new key
          bindings, defining new hook functions etc. You should override the
          standard MicroEmacs settings from your start-up file rather than
          modifying the standard MicroEmacs files.
        * Personal spelling dictionary cDlsdpcAcClangcA.edf (see lslmedf(8)le). Multiple
          spelling dictionaries may be created, one for each language. Any
          words that are added to the spelling dictionary are stored in these
          files.

    In addition to the above, if new private macro files are constructed then
    they should be added to this directory (if they are not global to the
    company).


cEcEEXAMPLE cEcA


    The following are examples of some individuals start-up files:-
sB
        ; Jon's special settings
        ;
        ; Last Modified <190698.2226>
        ;
        ; Macro to delete the whitespace, or if an a word all of the
        ; word until the next word is reached.
        define-macro super-delete
            set-variable #l0 0
            !while &not &sin @wc " \t\n"
                forward-char
                set-variable #l0 &add #l0 1
            !done
            !repeat
                !force forward-char
                !if $status
                    set-variable #l0 &add #l0 1
                !endif
            !until &or &seq @wc "" &not &sin @wc " \t\n"
            #l0 backward-delete-char
            !return
        !emacro
        ; Make a previous-buffer command.
        define-macro previous-buffer
            &neg @# next-buffer
        !emacro
        ; spotless; Perform a clean and remove any multi-blank lines.
        define-macro spotless
            -1 clean
        !emacro
        ; comment-adjust; Used for comments in electric-c mode (and the other
        ; electic modes. Moves to the comment fill position, saves having to mess
        ; around with comments at the end of the line.
        0 define-macro comment-adjust
            ; delete all spaces up until the next character
            !while &sin @wc " \t"
                forward-delete-char
            !done
            ; Fill the line to the current $c-margin. We use this as
            ; this is the only variable that tells us where the margin
            ; should be.
            !if &gre $window-acol 0
                backward-char
                !if &sin @wc " \t"
             forward-delete-char
                    !jump -4
                !else
                    forward-char
                !endif
            !endif
            ; Now fill to the $c-margin
            &sub $c-margin $window-acol insert-string " "
        !emacro
        ; Macro to force buffer to compile buffer for C-x '
        define-macro compile-error-buffer
            !force delete-buffer *compile*
            change-buffer-name "*compile*"
        !emacro
        ;
        ; Set up the bindings.
        ;
        global-bind-key super-delete            "C-delete"
        global-bind-key beginning-of-line       "home"
        global-bind-key end-of-line             "end"
        global-bind-key undo                    "f4"
        !if &seq %emulate "ERROR"
            global-bind-key comment-adjust      "esc tab"
            global-bind-key comment-adjust      "C-insert"
            ; Like a korn shell please.
            ml-bind-key tab "esc esc"
        !endif
        ;
        ; Setup for windows and UNIX.
        ;
        ; Define my hilighting colour for Windows and UNIX.
        !if &equ &band $system 0x001 0
            !if &not &seq $platform "win32"
                ; Small bold font is better for me.
                change-font "-*-clean-medium-r-*-*-*-130-*-*-*-*-*-*"
            !endif
        !endif
        ; Change the default diff command-line for GNU diff utility all platforms
        set-variable %diff-com "diff --context --minimal --ignore-space-change --report-identical-files --recursive"
        set-variable %gdiff-com "diff --context --ignore-space-change -w"
        ; Setup for cygwin
        !if &seq $platform "win32"
            set-variable %cygwin-path "c:/cygwin"
            set-variable %cygwin-hilight 1
        !endif
        ; Set up the ftp flags. The letters have the following meaning:
        ; c   - Create a console (*ftp-console* for ftp, *http-console* for http)
        ; s   - Show the console
        ; p   - Show download progress ('#' every 2Kb downloaded)
        set-variable %ftp-flags "csp"
        ; Info files
        ;To hilight the .info and also the dir file
        add-file-hook ".info dir"                                   fhook-info   ; Info-files
        ;To hilight all info files without the extension .info
        ;but starting with the text "This is info file..
        -2 add-file-hook "This is Info file"                        fhook-info

        ; Finished
        ml-write "Configured to Jon's requirements"

sA

cEcESEE ALSO cEcA


    lslmuser-setup(3)le, lslm$search-path(5)le, lslm$user-name(5)le, lslm$user-path(5)le,
    lslm$MEINSTALLPATH(5)le, lslm$MENAME(5)le, lslm$MEPATH(5)le, lslm$MEUSERPATH(5)le, lslmme32.ini(8)le,
    lsCompanyProfiles(2)lmCompany Profilesle, lsfileHooks(2)lmFile Hooksle, lslanguageTemplates(2)lmFile Language Templatesle, lsInstallation(1)lmInstallationle.
! 2 Interfacing
cEcEINTERFACING cEcA


    This sections describes how MicroEmacs 2009 may be interfaced to external
    components.


cEShells cA


    A shell window may be opened within the context of the editor using the
    command lslmishell(3)le, whereby an interactive command shell is presented
    within a buffer.

    In the Microsoft Windows environment a cDcygwincA UNIX style BASH shell may be
    realised with the lslmcygwin(3)le command.


cEDebugger cA


    Within the UNIX environment the GNU cDgdb(1)cA or native UNIX cDdbx(1)cA debuggers
    may be invoked from the editor using lslmgdb(3)le or lslmdbx(3)le. respectively This
    invokes the debugger and follows the debugging process in the editor
    window, automatically opening the source files as the debugger calls for
    them.


cEMicrosoft Developer Studio cA


    In the Microsoft windows environment, the lslmmemsdev(1)le DLL may be attached
    to the cDMicrosoft Developer StudiocA to enable MicroEmacs 2009 to be used in
    place of the in-built editor.


cEFile Searching cA


    File searching is performed using cDgrep(1)cA using the lslmgrep(3)le command. For
    Windows then the GNU grep utility is recommended, for MS-DOS then the
    DJGPP version of GNU grep is recommended.


cEFile Differencing cA


    Differencing files, or directories is performed using the cDdiff(1)cA utility
    using the lslmdiff(3)le command. For all platforms the GNU diff utility is
    recommended as this provides a comprehensive differencing that is not
    typically available with native UNIX diff utilities.


cETag Files cA


    A cDtagcA capability exists (see lslmfind-tag(2)le) such that source functions and
    alike may be located quickly using a cDtagscA file. The standard cDctags(1)cA
    format is used by MicroEmacs. The cDtagscA file itself may be generated by
    MicroEmacs 2009 from the menu (cCTools->XX Tools->Create Tags FilecA).
    Alternatively a cDtagscA file may be generated by the cDctags(1)cA utility. This
    is typically standard on UNIX platforms. For Windows and DOS platforms
    then the cDExuberant CtagscA is recommended, this is available from:-

       cG http://darren.hiebert.comcA

    A MicroEmacs 2009 compatible tags file may be generated using the command
    line "cGctags -N --format=1 ."cA cataloging the current directory. To generate
    cDtagscA for a directory tree then use "cGctags -NR --format=1 .cA". Refer to the
    cDExuberant CtagscA documentation for a more detailed description of the
    utility.


cECompilation cA


    Compilation is performed using the lslmcompile(3)le command. This invokes a
    command shell, typically using cDmake(1)cA to initiate a build sequence.


cEClient-Server cA


    The lsClient-Server(2)lmClient-Serverle interface allows other client applications to inject
    commands into an already existing MicroEmacs 2009 session (the server),
    thereby controlling the editor remotely. This is typically used to inject
    new files into the editor to be presented to the user.

    The cCClient-ServercA interface is available in both the UNIX and Microsoft
    Windows environments. This mechanism is used in the Microsoft windows
    environment by the lslmmemsdev(1)le DLL to attach the cDMicrosoft Developer StudiocA
    to MicroEmacs 2009. This may be used with similar effects within the UNIX
    environments from the X-Window managers desktop in addition to other
    utilities such as cDTkDesk(1)cA.


cECommand Line Filer cA


    MicroEmacs may be invoked as a command filter in it's own right, macro
    scripts have been developed to perform a cDdos2unix(1)cA conversion operation,
    generate tags files etc. See lslmCommand Line Filtersle.


cEcESEE ALSO cEcA


    cDctags(1)cA, lslmcompile(3)le, lslmcygwin(3)le, lslmdbx(3)le, lslmdiff(3)le, lslmfind-tag(2)le lslmgdb(3)le,
    lslmgrep(3)le, lslmishell(3)le, lslmmemsdev(1)le,
    lsClient-Server(2)lmClient-Serverle, lslmCommand Line Filtersle.
! 2 Client-Server
cEcECLIENT-SERVER cEcA


    This sections describes how MicroEmacs 2009 may be interfaced to external
    components through the cDClient-ServercA interface.

    The cDClient-ServercA interface of MicroEmacs 2009 provides a capability for
    other applications to inject commands into a running version of the
    editor, which are interpreted and executed. The interface is only
    available on multi-tasking operating systems such as UNIX and Microsoft
    Windows; it is not available on MS-DOS systems.

    Within the following discussions, the cDServercA is a running version of the
    MicroEmacs 2009 editor; the cDclientcA is the application (or shell script)
    that communicates a new command to the cCservercA.

    The cDClient-ServercA interface may provide a bidirectional interface such
    that a cCclientcA may submit a command to the cCservercA and may also retrieve a
    response to that command.


cEcEDESCRIPTION cEcA


    The cDClient-ServercA interface operates by making an external interface
    available which is continually monitored by the cCservercA. The external
    interface may be provided by a file, named pipe or socket (depending upon
    the platform) with a well know location in the file system. Typically two
    files are provided, an input file into which the cCclientcA writes commands
    (cC$TEMPcAcD/mecAcC$MENAMEcAcD.cmdcA); and an output file where responses to those
    commands my be read (cC$TEMPcAcD/mecAcC$MENAMEcAcD.rspcA).

    Within MicroEmacs, the client server interface appears as a hidden
    lslmipipe-shell-command(2)le buffer, with the name cG*server*cA. Commands are
    received through this buffer and responses are written back to the buffer.


cEClient Commands cA


    cCClientscA may write directly to the cCcommandcA through the use of explicit
    embedded code, or may use a lslmme(1)le invocation with the cD-mcA option. Commands
    to the client interface take the form "cDC:cAcC<client>cAcD:cAcC<command>cA".

    cC<client>cA
        cC<client>cA is an identification string that may be used to identify the
        client, this information may be used when the command is handled to
        interpret the command if some special client specific action is
        required.

    cC<command>cA
        The cC<command>cA is an editor command (or macro) of the given name with
        any arguments. Standard command escape sequences must be adhered to.
        i.e. to write "cGHello WorldcA" on the message line then a client may
        issue the command:-

            me -m "C:<client>:ml-write \"Hello world\"


        A new line character may be included in the string using cG\\ncA, if the
        message is not terminated with a new line then on is automatically
        added. The cCclient-servercA interface is typically used to load a file,
        this may be performed as follows:-

            me -m "C:<client>:find-file \"/path/foo.bar\""


        The absolute path is specified in this type of transaction as the
        current working directory of the active MicroEmacs session is unknown.
        The cD-mcA option de-iconize's the existing editor session and bring it to
        the foreground.


cEClient Responses cA


    Responses from cCclientcA commands are written to the response file, responses
    take a similar form to cCclientcA commands except they are prefixed by an cDRcA,
    i.e. "cDR:cAcC<client>cAcD:cAcC<data>cA".

    As multiple cCclientscA may be utilizing the cCclient-servercA mechanism then the
    cC<client>cA sting passed in the command is typically returned in the response
    to allow the cCclientcA to identify it's own response (rather than any other
    cCclientscA. It is the cCclientscA responsibility that this string is unique in
    order that it may be differentiated.

    The returned cC<data>cA format is undefined and would be generated by a macro
    command used to handle the cCclientcA command; sufficient to say that the data
    should exist on a single line.


cEServer Side cA


    On the cCservercA side, the cDClient-ServercA interface is managed like an
    lslmipipe-shell-command(2)le using the hidden buffer cG*server*cA (as previously
    mentioned).

    The cCClient-ServercA interface is enabled from the lslmuser-setup(3)le interface,
    the user setting of the interface is confirmed by checking bit cG0x20000cA of
    the lslm$system(5)le variable.

    The client server interface is typically initialized within the cGme.emfcA
    initialization file, whereby the cCipipecA input handler is bound to the
    client pipe buffer and the buffer is hidden, so it is not available when
    the buffers are swapped. (Note that the client buffer may be explicitly
    interrogated using lsnext-buffer(2)lmfind-bufferle cG*server*cA). The client handler is installed
    as follows:-
sB
        ; Setup the Client Server
        !if &band $system 0x20000
            define-macro-file meserver server-input
            find-buffer "*server*"
            set-variable :last-line 2
            set-variable :client-list ":"
            set-variable $buffer-ipipe server-input
            beginning-of-buffer
            goto-alpha-mark  "I"
            -1 find-buffer "*server*"
        !endif

sA
    This binds a MicroEmacs macro called cCserver-inputcA to handle the client
    commands as they arrive on the input, an lsgoto-alpha-mark(2)lmalpha-markle is used to record the
    processed position at the end of the buffer. The pipe handler itself
    decodes the client request and executes it. The default handler supplied
    with MicroEmacs 2009 is defined within the macro file cGmeserver.emfcA

    Responses to the client are inserted into the response file by writing
    directly into the ipipe buffer (cG*server*cA) using the lslmipipe-write(2)le
    command. It is the calling macros responsibility to ensure that the
    response string adheres to the format outlined above in the previous
    sections.


cEcENOTES cEcA


    It is not possible to kill the cG*server*cA buffer, and lslmipipe-kill(2)le is
    ignored within the context of the buffer.


cEcEFILES cEcA


    cGmeserver.emfcA - Default Client-Server ipipe handler.
    cC$TEMPcAcD/mecAcC$MENAMEcAcD.cmdcA - Command file.
    cC$TEMPcAcD/mecAcC$MENAMEcAcD.rspcA - Response file.


cEcEBUGS cEcA


    The first MicroEmacs 2009 session that executes becomes the editor server,
    additional editor sessions that are executed do not become server
    processes. In the event that the cCservercA editor is terminated, any other
    sessions do not take over the role of server. Subsequently issuing a
    client command may fail, or invoke a new editor session which adopts the
    role of server.


cEcESEE ALSO cEcA


    lslmme(1)le, lslmipipe-shell-command(2)le
! 2 RegularExpressions
cEcEREGULAR EXPRESSIONS cEcA


    Regular Expressions are used in the search (and replace) operations. The
    following notes are applicable when lslmmagic(2m)le mode is enabled.


cEOverview cA


    A "cCregular expressioncA" (or "cCregexcA", or "cCpatterncA") is a text string that
    describes some (mathematical) set of strings. A regex cDRcA "cCmatchescA" a string
    cDScA if cDScA is in the set of strings described by cDRcA.

    Some regular expressions match only one string, i.e., the set they
    describe has only one member. For example, the regular expression 'cGfoocA'
    matches the string 'cGfoocA' and no others. Other regular expressions match
    more than one string, i.e., the set they describe has more than one
    member. For example, the regular expression 'cGf*cA' matches the set of
    strings made up of any number (including zero) of 'cGfcA's. As you can see,
    some characters in regular expressions match themselves (such as 'cGfcA') and
    some don't (such as 'cG*cA'); the ones that do not match themselves instead
    let you specify patterns that describe many different strings.


cESyntax of Regular Expressions cA


    Regular expressions have a syntax in which a few characters are special
    constructs and the rest are "cCordinarycA". An ordinary character is a simple
    regular expression which matches that same character and nothing else. The
    special characters are 'cG$cA', 'cG^cA', 'cG.cA', 'cG*cA', 'cG+cA', 'cG?cA', 'cG[cA', 'cG]cA' and 'cG\cA'. Any
    other character appearing in a regular expression is ordinary, unless a
    'cG\cA' precedes it.

    For example, 'cGfcA' is not a special character, so it is ordinary, and
    therefore 'cGfcA' is a regular expression that matches the string 'cGfcA' and no
    other string. (It does cDnotcA match the string 'cGffcA'.) Likewise, 'cGocA' is a
    regular expression that matches only 'cGocA'. (When case distinctions are
    being ignored, these regexs also match 'cGFcA' and 'cGOcA', but we consider this a
    generalization of "cCthe same stringcA", rather than an exception.)

    Any two regular expressions cGAcA and cGBcA can be concatenated. The result is a
    regular expression which matches a string if cGAcA matches some amount of the
    beginning of that string and cGBcA matches the rest of the string.

    As a simple example, we can concatenate the regular expressions 'cGfcA' and
    'cGocA' to get the regular expression 'cGfocA', which matches only the string
    'cGfocA'. Still trivial. To do something nontrivial, you need to use one of
    the special characters. Here is a list of them.

    cD.cA (Period)
        is a special character that matches any single character except a
        newline. Using concatenation, we can make regular expressions like
        'cGa.bcA', which matches any three-character string that begins with 'cGacA'
        and ends with 'cGbcA'.

    cD*cA (asterisk)
        is not a construct by itself; it is a postfix operator that means to
        match the preceding regular expression repetitively as many times as
        possible. Thus, 'cGo*cA' matches any number of 'cGocA's (including no 'cGocA's).

        'cG*cA' always applies to the cDsmallestcA possible preceding expression.
        Thus, 'cGfo*cA' has a repeating 'cGocA', not a repeating 'cGfocA'. It matches 'cGfcA',
        'cGfocA', 'cGfoocA', and so on.

        The matcher processes a 'cG*cA' construct by matching, immediately, as
        many repetitions as can be found. Then it continues with the rest of
        the pattern. If that fails, backtracking occurs, discarding some of
        the matches of the 'cG*cA'-modified construct in case that makes it
        possible to match the rest of the pattern. For example, in matching
        'cGca*arcA' against the string 'cGcaaarcA', the 'cGa*cA' first tries to match all
        three 'cGacA's; but the rest of the pattern is 'cGarcA' and there is only 'cGrcA'
        left to match, so this try fails. The next alternative is for 'cGa*cA' to
        match only two 'cGacA's. With this choice, the rest of the regex matches
        successfully.

        cD+cA (plus) is a postfix operator, similar to 'cG*cA' except that it must
        match the preceding expression at least once. So, for example, 'cGca+rcA'
        matches the strings 'cGcarcA' and 'cGcaaaarcA' but not the string 'cGcrcA',
        whereas 'cGca*rcA' matches all three strings.

    'cD?cA' (question mark)
        is a postfix operator, similar to 'cG*cA' except that it can match the
        preceding expression either once or not at all. For example, 'cGca?rcA'
        matches 'cGcarcA' or 'cGcrcA'; nothing else.

    cD[cA ... cD]cA
        is a "character set", which begins with 'cG[cA' and is terminated by 'cG]cA'.
        In the simplest case, the characters between the two brackets are what
        this set can match.

        Thus, 'cG[ad]cA' matches either one 'cGacA' or one 'cGdcA', and 'cG[ad]*cA' matches
        any string composed of just 'cGacA's and 'cGdcA's (including the empty
        string), from which it follows that 'cGc[ad]*rcA' matches 'cGcrcA', 'cGcarcA',
        'cGcdrcA', 'cGcaddaarcA', etc.

        You can also include character ranges in a character set, by writing
        the starting and ending characters with a 'cG-cA' between them. Thus,
        'cG[a-z]cA' matches any lower-case ASCII letter. Ranges may be intermixed
        freely with individual characters, as in 'cG[a-z$%.]cA', which matches any
        lower-case ASCII letter or 'cG$cA', 'cG%cA' or period.

        The word and digit special characters (i.e. cG\wcA, cG\lcA, etc.) are
        recognized within the character set.

        To include a 'cG]cA' in a character set, you must make it the first
        character. For example, 'cG[]a]cA' matches 'cG]cA' or 'cGacA'. To include a 'cG-cA',
        write 'cG-cA' as the first or last character of the set, or put it after a
        range. Thus, 'cG[]-]cA' matches both 'cG]cA' and 'cG-cA'.

        To include 'cG^cA' in a set, put it anywhere but at the beginning of the
        set.

        When you use a range in case-insensitive search, you should write both
        ends of the range in upper case, or both in lower case, or both should
        be non-letters. The behavior of a mixed-case range such as 'cGA-zcA' is
        somewhat ill-defined, and it may change in future Emacs versions.

    cD[^cA ... cD]cA
        'cG[^cA' begins a "cCcomplemented character setcA", which matches any
        character except the ones specified. Thus, 'cG[^a-z0-9A-Z]cA' matches all
        characters *cDexceptcA* letters and digits.

        'cG^cA' is not special in a character set unless it is the first
        character. The character following the 'cG^cA' is treated as if it were
        first (in other words, 'cG-cA' and 'cG]cA' are not special there).

        A complemented character set can match a newline, unless newline is
        mentioned as one of the characters not to match. This is in contrast
        to the handling of regexs in programs such as cDgrep(1)cA.

    cD^cA (caret)
        is a special character that matches the empty string, but only at the
        beginning of a line in the text being matched. Otherwise it fails to
        match anything. Thus, 'cG^foocA' matches a 'cGfoocA' that occurs at the
        beginning of a line.

    cD$cA (dollar)
        is similar to 'cG^cA' but matches only at the end of a line. Thus, 'cGx+$cA'
        matches a string of one 'cGxcA' or more at the end of a line.

    cD\cA (backslash)
        has two functions: it quotes the special characters (including 'cG\cA'),
        and it introduces additional special constructs.

        Because 'cG\cA' quotes special characters, 'cG\$cA' is a regular expression
        that matches only 'cG$cA', and 'cG\[cA' is a regular expression that matches
        only 'cG[cA', and so on.

        cDNote:cA for historical compatibility, special characters are treated as
        ordinary ones if they are in contexts where their special meanings
        make no sense. For example, 'cG*foocA' treats 'cG*cA' as ordinary since there
        is no preceding expression on which the 'cG*cA' can act. It is poor
        practice to depend on this behavior; it is better to quote the special
        character anyway, regardless of where it appears.

        For the most part, 'cG\cA' followed by any character matches only that
        character. However, there are several exceptions: two-character
        sequences starting with 'cG\cA' that have special meanings. The second
        character in the sequence is always an ordinary character when used on
        its own. Here is a table of 'cG\cA' constructs.

        cD\|cA (bar)
            specifies an alternative. Two regular expressions cGAcA and cGBcA with
            'cG\|cA' in between form an expression that matches some text if
            either cGAcA matches it or cGBcA matches it. It works by trying to match
            cGAcA, and if that fails, by trying to match cGBcA.

            Thus, 'cGfoo\|barcA' matches either 'foo' or 'bar' but no other
            string.

            'cG\|cA' applies to the largest possible surrounding expressions. Only
            a surrounding 'cG\( ... \)cA' grouping can limit the grouping power of
            'cG\|cA'.

            Full backtracking capability exists to handle multiple uses of
            'cG\|cA'.

        cD\(cA ... cD\)cA
            is a grouping construct that serves three purposes:

                    * To enclose a set of 'cG\|cA' alternatives for other
                      operations. Thus, 'cG\(foo\|bar\)xcA' matches either 'cGfooxcA'
                      or 'cGbarxcA'.
                    * To enclose a complicated expression for the postfix
                      operators 'cG*cA', 'cG+cA' and 'cG?cA' to operate on. Thus,
                      'cGba\(na\)*cA' matches 'cGbanananacA', etc., with any (zero or
                      more) number of 'cGnacA' strings.
                    * To record a matched substring for future reference. This
                      last application is not a consequence of the idea of a
                      parenthetical grouping; it is a separate feature that is
                      assigned as a second meaning to the same 'cG\( ... \)cA'
                      construct. In practice there is no conflict between the
                      two meanings.

        'cD\DcA'
            matches the same text that matched the Dth occurrence of a `cG\(cA ...
            cG\)cA' construct.

            After the end of a 'cG\( ... \)cA' construct, the matcher remembers
            the beginning and end of the text matched by that construct. Then,
            later on in the regular expression, you can use 'cG\cA' followed by
            the digit cGDcA to mean "match the same text matched the cGDcAth time by
            the 'cG\(cA ... cG\)cA' construct."

            The strings matching the first nine 'cG\(cA ... cG\)cA' constructs
            appearing in a regular expression are assigned numbers 1 through 9
            in the order that the open-parentheses appear in the regular
            expression. So you can use 'cG\1cA' through 'cG\9cA' to refer to the text
            matched by the corresponding 'cG\(cA ... cG\)cA' constructs.

            For example, 'cG\(.*\)\1cA' matches any newline-free string that is
            composed of two identical halves. The 'cG\(.*\)cA' matches the first
            half, which may be anything, but the 'cG\1cA' that follows must match
            the same exact text.

            If a particular 'cG\( ... \)cA' construct matches more than once
            (which can easily happen if it is followed by 'cG*cA'), only the last
            match is recorded.

        cG\`cA
            matches the empty string, but only at the beginning of the buffer
            or string being matched against.

            cDNOTE:cA This currently only matches the start of the current line -
            it does not match the start of the buffer.

        cG\'cA
            matches the empty string, but only at the end of the buffer or
            string being matched against.

            cDNOTE:cA This currently only matches the end of the current line - it
            does not match the end of the buffer.

        cG\=cA
            matches the empty string, but only at point.

        cG\<cA
            matches the empty string, but only at the beginning of a word.
            'cG\<cA' matches at the beginning of the buffer only if a
            word-constituent character follows.

        cG\>cA
            matches the empty string, but only at the end of a word. 'cG\>cA'
            matches at the end of the buffer only if the contents end with a
            word-constituent character.

        cG\acA
            matches any alpha characters.

        cG\AcA
            matches any non-alpha characters.

        cG\bcA
            matches the empty string, but only at the beginning or end of a
            word. Thus, 'cG\bfoo\bcA' matches any occurrence of 'cGfoocA' as a
            separate word. 'cG\bballs?\bcA' matches 'cGballcA' or 'cGballscA' as a
            separate word. 'cG\bcA' matches at the beginning or end of the buffer
            regardless of what text appears next to it.

        cG\BcA
            matches the empty string, but *not* at the beginning or end of a
            word.

        cG\dcA
            matches any digit character.

        cG\DcA
            matches any non-digit character.

        cG\hcA
            matches any hexadecimal digit character.

        cG\HcA
            matches any non-hexadecimal character.

        cG\lcA
            matches any lowercase word-constituent character. The syntax table
            determines which characters these are.

        cG\LcA
            matches any character that is not a lowercase word-constituent.

        cG\mcA
            matches any alphanumeric characters

        cG\McA
            matches any non alphanumeric characters.

        cG\scA
            matches any white-space character, including new-line.

        cG\ScA
            matches any character that is not white-space.

        cG\ucA
            matches any uppercase word-constituent character. The syntax table
            determines which characters these are.

        cG\UcA
            matches any character that is not a uppercase word-constituent.

        cG\wcA
            matches any word-constituent character. The syntax table
            determines which characters these are.

        cG\WcA
            matches any character that is not a word-constituent.

        cG\{N,M\}cA
            Matches an integer number of the previous item, where cGNcA and cGMcA are
            integer constants interpreted as follows:-

            cG\{N\}cA
                The preceeding item is matched exactly cGNcA times.

            cG\{N,\}cA
                The preceeding item is matched cGNcA or more times.

            cG\{N,M\}cA
                The preceeding item is matched at least cGNcA times, but no more
                than cGMcA times.

            cG\{,M\}cA
                The preceeding item is optional and is matched at most cGMcA
                times.

    The constructs that pertain to words and syntax are controlled by the
    setting of the syntax table.


cESyntax of Replacement Expressions cA


    A regular expression replacement, lslmquery-replace-string(2)le command (with
    lslmmagic(2m)le mode enabled), replaces exact matches for a single string or
    pattern. The replacement pattern may be a constant; it may also refer to
    all or part of what is matched by the regular expression search string.

    cD\&cA
        In the replacement pattern, cD\&cA stands for the entire match being
        replaced. (as does cG\0cA).

    cD\DcA
        In the replacement pattern, where cDDcA is a digit 1-9, stands for
        whatever matched the Dth parenthesized grouping (cG\( .. \)cA) in search
        pattern. To include a 'cG\cA' in the text to replace with, you must enter
        'cG\\cA'. For example,

            M-x query-replace-string<RET> c[ad]+r <RET> \&-safe <RET>


        replaces (for example) "cGcadrcA" with "cGcadr-safecA" and "cGcddrcA" with
        "cGcddr-safecA".

            M-x query-replace-string<RET> \(c[ad]+r\)-safe <RET> \1 <RET>


        performs the inverse transformation.

        cD\0cA is a special case, this represents the whole of the search pattern,
        it is equivalent to cD\&cA.

    cD\ccAcCDcA
        In the replacement pattern capitalizes the string, where cCDcA is a digit
        cG0-9cA or cG&cA, stands for whatever matched the Dth parenthesized grouping
        (cG\(..\)cA) in search pattern.

    cD\lcAcCDcA
        In the replacement pattern down-cases the string, where cDDcA is a digit
        cG0-9cA of cG&cA, stands for whatever matched the Dth parenthesized grouping
        (cG\(..\)cA) in search pattern.

    cD\ucAcCDcA
        In the replacement pattern up-cases the string, where cDDcA is a digit cG0-9cA
        or cG&cA, stands for whatever matched the Dth parenthesized grouping
        (cG\(..\)cA) in search pattern.


cESearching and Case cA


    Searching may be either case sensitive or case insensitive, and is
    controlled by the lslmexact(2m)le mode. When cCexactcA mode is enabled (default) the
    then searches are case sensitive; disabled then case is ignored. The
    lslmexact(2m)le mode is set on a per-buffer basis.


cEcENOTES cEcA


    The search engine searches for the longest string that matches a given
    pattern, the longest pattern is sometimes the pattern that is not actually
    required. For instance, consider searching for an HTML bracket set. The
    simplest search is:-

        M-x search-forward "<.*>"


    Unfortunately, this pattern is not specific enough, given an HTML line:-

        <a href="www.jasspa.com">Jasspa Site</a>


    Then the pattern matched is actually the whole line as the cG.*cA matches
    everything to the last cG>cA, this is the longest string. To rectify the
    pattern then we must be more specific, the correct search pattern to use
    in this instance is:-

        M-x search-forward "<[^>]*>"


    In this case we match any character excluding the closing character, this
    guarantees that we always find the shortest string match. A search of our
    HTML line locates two separate instances of the regular expression cG<a
    href="www.jasspa.com">cA and cG</a>cA.


cEcEHISTORY cEcA


    As of March 2005 then the existing Emacs search string syntax of "cG\s?cA" and
    "cG\S?cA" has been discarded in favor of Perl's simpler syntax of "cG\scA" and
    "cG\ScA" for a whitespace character class. Added new character classes "cG\dcA" =
    digits, "cG\DcA" != digits "cG\hcA" = hexdigits "cG\HcA" != hexdigits "cG\lcA" = lowercase
    "cG\LcA" != lowercase "cG\ucA" = uppercase and "cG\UcA" != uppercase. The regular
    expression replacement string characters include "cG\c#cA" "cG\l#cA" and "cG\u#cA" to
    change the case of groups.


cEcESEE ALSO cEcA


    lslmsearch-forward(2)le, lslmsearch-backward(2)le, lslmbuffer-mode(2)le, lslmexact(2m)le,
    lslmhunt-backward(2)le, lslmhunt-forward(2)le, lslmisearch-forward(2)le, lslmmagic(2m)le,
    lslmreplace-string(2)le.
! 2 Build
cEcEBUILD cEcA


    MicroEmacs 2009 may be compiled from the source files using the command
    shell build scripts cCbuildcA (UNIX Bourne Shell) or cCbuild.batcA (DOS/Windows).
    A default compile sequence may be achieved with a simple:

        build


    from the command line. The build script attempts to detect the host system
    and available compiler and build the editor.

    The build script recognizes the following options:-

    cD-CcA
        Build clean. Delete all of the object files.

    cD-dcA
        Build a debugging version, the output is cGmedcA (or cGmed32cA for 32-bit
        Windows versions).

    cD-hcA
        Display a simple help page

    cD-lcA cClogfilecA
        Redirect all compilation output to the cClogfilecA, this may not work on
        DOS or Windows systems.

    cD-lacA cClogfilecA
        Append all compilation output to the end of cClogfilecA, this may not work
        on DOS or Windows systems.

    cD-mcA cCmakefilecA
        Build using the specified makefile. over-riding the auto system
        detect. The supplied makefiles include:-

                * cGaix4.makcA IBM AIX 4.x native.
                * cGaix5.makcA IBM AIX 5.x native.
                * cGaix4.gmkcA IBM AIX 4.x using GNU tools.
                * cGaix5.gmkcA IBM AIX 5.x using GNU tools.
                * cGcygwin.gmkcA Cygwin using GNU tools under Windows.
                * cGdarwin.gmkcA Apple Darwin (console and X-Windows).
                * cGdosdj1.makcA Microsoft DOS build using djgpp version 1.
                * cGdosdj2.makcA Microsoft DOS build using djgpp version 2.
                * cGfreebsd.gmkcA Free BSD using GNU tools.
                * cGhpux9.gmkcA HP-UX 9.x using GNU tools.
                * cGhpux9.makcA HP-UX 9.x native
                * cGhpux10.gmkcA HP-UX 10.x using GNU tools.
                * cGhpux10.makcA HP-UX 10.x native
                * cGhpux11.gmkcA HP-UX 11.x using GNU tools.
                * cGhpux11.makcA HP-UX 11.x native
                * cGirix5.gmkcA Silicon Graphics IRIX 5.x using GNU tools
                * cGirix5.makcA Silicon Graphics IRIX 5.x native
                * cGirix6.gmkcA Silicon Graphics IRIX 6.x using GNU tools
                * cGirix6.makcA Silicon Graphics IRIX 6.x native
                * cGlinux2.gmkcA Linux 2.2/4 kernels using GNU tools
                * cGlinux26.gmkcA Linux 2.6 kernels using GNU tools
                * cGmingw.gmkcA minGW http://www.MinGW.org using GNU tools.
                * cGosf1.gmkcA OSF1 using GNU tools.
                * cGopenbsd.gmkcA OpenBSD using GNU tools.
                * cGopenstep.makcA Openstep 4.2 on NeXTstep (BSD 4.3).
                * cGsunos5.gmakcA Sun Solaris 5.5/6/7/8/9/10 using GNU tools
                * cGsunos5.makcA Sun Solaris 5.6/7/8/9/10 native
                * cGsunosx86.gmkcA Sun Solarais 2.6/7/8/9/10 (Intel) using GNU
                  tools.
                * cGwin32bc.makcA Borland C, 32-bit Windows version.
                * cGwin32b55.makcA Borland C 5.5, 32-bit Windows version (Free
                  compiler).
                * cGwin32sv2.makcA Microsoft Developer v2.x, Win32s (for Win 3.xx)
                * cGwin32sv4.makcA Microsoft Developer v4.2, Win32s (for Win 3.xx)
                * cGwin32v2.makcA Microsoft Developer v2.x, 32-bit Windows.
                * cGwin32v5.makcA Microsoft Developer v5.x, 32-bit Windows.
                * cGwin32v6.makcA Microsoft Developer v6.x, 32-bit Windows.
                * cGzaurus.gmkcA Zauras palm using GNU tools.

    cD-necA
        Build NanoEmacs (a cut down version aimed as a vi replacement), the
        output is cGnecA (or cGned32cA for 32-bit Windows versions).

    cD-ScA
        Build spotless. Deletes all of the object files and any backup files,
        tag files etc.

    cD-tcA cCtypecA
        Set the build type, where cCtypecA can be one of the following:

                * cGccA Build a console only version (i.e. no window support), the
                  output is cGmeccA (or cGmec32cA on Windows).
                * cGwcA Build a windows only version (i.e. no console support),
                  the output is cGmewcA (or cGmew32cA on Windows).
                * cGcwcA Build a version which supports both console and windows,
                  the output is cGmecwcA (or cGmecw32cA on Windows).


cEMakefiles cA


    The supplied makefiles are provided in two forms:-

        * cD.gmkcA - GNU make, using gcc.
        * cD.makcA - Native make, consistent with the compiler and platform.

    The makefiles are supplied with the following targets:-

        * cDallcA - Default build.
        * cDcleancA - Removes intermediate files.
        * cDspotlesscA - Removes intermediate files and any backup files.
        * cDmecA - Builds the default MicroEmacs executable.
        * cDmedcA - Builds a debugging version.
        * cDmeccA - Builds a console only version.
        * cDmewcA - Builds a windows only version.
        * cDmecwcA - Builds a version which supports both console and windows.
        * cDnecA - Builds NanoEmacs executable.


cEcEWINDOWS ENVIRONMENT cEcA


    The Windows environment is a little more difficult than UNIX because it
    does not have a good native command line environment. There are two
    Microsoft Developer options for building. If you have not purchased MS-DEV
    then use the FREE Borland compiler which runs on the command line.


cEMinGW Build cA


    A collection of freely available and freely distributable Windows specific
    header files and import libraries combined with GNU toolsets that allow
    one to produce native Windows programs that do not rely on any 3rd-party C
    runtime DLLs. Available from http://www.mingw.org, cDmingwcA allows a
    Microsoft Windows version MicroEmacs to bu built and maintained.


cEMS-Dev GUI Build cA


    MicroEmacs is supplied with a MS-Dev 6.x project for building. This has
    only been set up for debugging and has limited build options, it will also
    produce a large executable image. The MS-Windows images shipped by JASSPA
    are built using the command line build environment which is detailed in a
    later section.


cEMS-Dev Command Line Build cA


    The command line build with MS-Dev is a little messy to set up, in the
    following sections we discuss MS-Dev 6.x under Windows 2000. There will be
    differences with different operating systems versions, different install
    paths and different versions of the MS-Dev toolkit. Use the following
    information as an outline ONLY, JASSPA will not take responsibility for
    the configuration of the command line environment, if in doubt then use
    the GUI builder.

    To run cDnmake(1)cA from a DOS box then the MS-Dev compiler tools must be
    available in the command path. The MS-Dev kit V6.x is supplied with the
    necessary file to set up the path which is called cGVCVARS32.BATcA and is
    typically located in directory:

        C:\Program Files\Microsoft Visual Studio\VC98\Bin


    This should be run first and then the command line make files may be run
    using nmake i.e. to build ME:-

        nmake -f win32v6.mak me


    To build NE:-

        nmake -f win32v6.mak ne


    To clean up after:-

        nmake -f spotless


    If you are going to perform a lot of command line building then it is
    easier to set up the environment and not have to run cGVCVARS32.BATcA every
    time you compile.

    You can add the variables to your environment, you will need to expand the
    cGVCVARS32.BATcA script and then add the results. The following example is for
    MS-Dev 6.0 under W2K, the settings will differ depending on what O/S
    variant you are running and where you have installed software. The
    following ONLY serves as an example, you need to tailor for your
    installation.

        * To set up the variables then cDStartcA -> cDSettingscA -> cDControlcA cDPanelcA
          which displays the Control Panel items.
        * Select cDSystemcA -> cDAdvancedcA -> cDEnvironment variablescA
        * In cDUser Variables forcA cC<User>cA then cDNew...cA or cDEdit...cA the cGPATHcA
          variable. Add the command line tools execution paths to the
          environment variable, this will be something like the following (but
          without newlines):-

                Variable Name:  PATH
                Variable Value: %PATH%;
                                C:\PROGRA~1\MICROS~3\Common\msdev98\BIN;
                                C:\PROGRA~1\MICROS~3\VC98\BIN;
                                C:\PROGRA~1\MICROS~3\Common\TOOLS\WINNT;
                                C:\PROGRA~1\MICROS~3\Common\TOOLS;

        *
        Similarly add the cGINCLUDEcA variable:-

                Variable Name:  INCLUDE
                Variable Value: C:\PROGRA~1\MICROS~3\VC98\ATL\INCLUDE;
                                C:\PROGRA~1\MICROS~3\VC98\INCLUDE;
                                C:\PROGRA~1\MICROS~3\VC98\MFC\INCLUDE;
                                %INCLUDE%

        *
        Similarly add the cGLIBcA variable:-

                Variable Name:  LIB
                Variable Value: C:\PROGRA~1\MICROS~3\VC98\LIB;
                                C:\PROGRA~1\MICROS~3\VC98\MFC\LIB;
                                %LIB%

        *
        Accept the entries and close down the dialog. Start a new DOS command
        line and the variables should be set up ready for the build.


cEcENOTES cEcA


    Other UNIX ports should be fairly easy from the base set of ported
    platforms. If any new platform ports are performed by individuals then
    please submit the makefiles and any source changes back to JASSPA - see
    lslmContact Informationle.
! 2 localeSupport
cEcELOCALE SUPPORT cEcA


    Locale support within MicroEmacs handles the hardware and software
    configuration with respect to location, including:-

        Displayed Character Set
        Keyboard Support
        Word characters
        Spell Support

    There are many other locale problems which are not addressed in this help
    page. Supporting different locale configurations often requires specific
    hardware (a locale specific keyboard) and knowledge of the language and
    customs of the region. This makes it a very difficult area for one
    localized development team to support, as such, JASSPA rely heavily on the
    user base to report locale issues.


cENote on Names and IDs cA


    The language name is not sufficient to identify a locale (Mexican Spanish
    is different to Spanish Spanish) neither is the country name (two
    languages are commonly used in Belgium), so before we've really started
    the first problem of what to call the locale has no standard answer! Call
    it what you like but please try to call it something meaningful so others
    may understand and benefit from your work.

    In addition, the cCinternal idcA and cCdata filecA names have a length limit of
    just four characters due to the "cG8.3cA" naming conversion of MS-DOS. The
    standard adopted by JASSPA MicroEmacs for the internal locale id is to
    combine the 2 letter ISO language name (ISO 639-1) with the 2 letter ISO
    country name (ISO 3166-1). Should the locale encompasses more than one
    country, then the most appropriate cCcountry idcA is selected.


cEcEDisplayed Character Set cEcA


    A character set is the mapping of an integer number to a display symbol
    (i.e. character). The ASCII standard defines a mapping of numbers to the
    standard English characters, this standard is well defined and accepted,
    as a result the character set rarely causes a problem for plain English.

    Problems occur when displaying characters found outside the ASCII
    standard, such as letters with accents, letters which are not Latin based
    (e.g. Greek alphabet) and graphical characters (used for drawing dialog
    boxes etc.). There are many different character sets to choose between and
    if the wrong character set is selected then the incorrect character
    translation is performed resulting in an incorrect character display. If
    the character display looks incorrect then first try changing the font and
    character-set setting, these can be configured using the platform page of
    lslmuser-setup(3)le.

    If the problem persists (i.e. because the character set used to write the
    text is not supported on your current system) use the lslmcharset-change(3)le
    command to convert the text to the current character set.

    If your character-set is not supported then first make sure that
    MicroEmacs will draw all of the characters to be used. By default
    MicroEmacs does not draw some characters directly as the symbol may not be
    defined. When a character is not defined then there will typically be a
    gap or space in the text at the unknown character, in some cases there may
    be no space at all which will make it very hard to use. The
    lslminsert-symbol(3)le command (cDEdit->Insert SymbolcA) is a good way of looking at
    which characters can be used with the current character set.

    For a character to be rendered (when in main text) or poked (drawn by
    lslmscreen-poke(2)le or lslmosd(2)le) is defined by the lslmset-char-mask(2)le command. The
    characters that are used when drawing MicroEmacs's window boarders or cDosdcA
    dialogs is set via the lslm$box-chars(5)le and lslm$window-chars(5)le variables.

    MicroEmacs attempts to improve the availability of useful graphics
    characters on Windows and UNIX X-Term interfaces. The characters between 0
    and 31 are typically control characters with no graphical representation
    (e.g. new-line, backspace, tab etc.) if bit 0x10000 of the lslm$system(5)le
    variable is set then MicroEmacs renders its own set of characters. These
    characters are typically used for drawing boxes and scroll-bars.

    With so many character sets, each with their own character mappings, then
    the problem of spelling dictionary support is also tied to the locale.
    MicroEmacs uses the ISO standard character sets (ISO 8859) internally for
    word and spelling support and therefore a mapping between the ISO standard
    and the user character set is required. This mapping is defined by using
    the 'cGMcA' flag of the lslmset-char-mask(2)le command.

    The user may declare the current character set in the platform page of
    lslmuser-setup(3)le. All the settings required for supporting each character set
    may be found in the cGcharset.emfcA macro file, so if your character set is
    not supported, this is the file to edit.


cEcEKeyboard Support cEcA


    The keyboard to character mapping is defined in the Start-Up page of
    lslmuser-setup(3)le, where the keyboard may be selected from a list of known
    keyboards. If your keyboard is not present, or is not working correctly,
    then this section should allow you to fix the problem (please send JASSPA
    the fix).

    Most operating systems seem to handle keyboard mappings with the exception
    of MS-Windows which requires a helping hand. The root of the problems with
    MS-Windows is it's own locale character mappings which change the
    visibility status of the keyboard messages which conflict with Emacs
    keystroke bindings. To support key-bindings like 'cGC-tabcA' or 'cGS-returncA' a
    low level keyboard interface is required, but this can lead to strange
    problems with the more obscure keys, particularly with the 'cGAlt GrcA'
    accented letter keys. For example on American keyboards pressing 'cGC-#cA'
    results in two 'cGC-#cA' key events being generated, this peculiarity only
    occurs with this one key. On a British keyboard the same key generates a
    'cGC-#cA' followed by a 'cGC-\cA'.

    This problem can be diagnosed using the lslm$recent-keys(5)le variable. Simply
    type an obvious character, e.g. 'cGAcA' then the offending key followed by
    another obvious key ('cGBcA'), then look for this key sequence in the
    cD$recent-keyscA variable (use the lslmlist-variables(2)le or lslmdescribe-variable(2)le
    command). So for the above British keyboard problem the recent-keys would
    be:

            B C-\\ C-# A


    ($recent-keys lists the keys backwards). Once you have found the key
    sequence generated by the key, the problem may be fixed using the
    lslmtranslate-key(2)le to automatically convert the incorrect key sequence into
    the required key. For the problem above the following line is required:
sB
        translate-key "C-# C-\\" "C-#"

sA
    Note that once a key sequence has been translated everything, including
    cD$recent-keyscA, receive only the translated key. So if you a suspected a
    problem with the existing definition, change the keyboard type in
    cDuser-setupcA to cDDefaultcA so no translations are performed, quit and restart
    MicroEmacs before attempting to re-diagnose the problem.

    All the settings required for supporting each keyboard may be found in the
    cGkeyboard.emfcA macro file, so if your keyboard is not supported, this is the
    file you need to edit.


cEcEWord characters cEcA


    Word characters are those characters which are deemed to be part of a
    word, numbers are usually included. Many MicroEmacs commands use the
    'Word' character set such as lslmforward-word(2)le and lslmupper-case-word(2)le. The
    characters that form the word class are determined by the language being
    used and this can be set in the Start-Up page of lslmuser-setup(3)le.

    If your language is not supported you will need to add it to the list and
    define the word characters, these settings may be found in the
    cGlanguage.emfcA macro file. The 'cGacA' flag of command lslmset-char-mask(2)le is used
    to specify whether a character is part of a word, you must specify the
    uppercase letter and then the lowercase equivalent so the case conversion
    functions work correctly.

    A list of characters to be removed from the word character set is stored
    in the cD.set-char-mask.rm-charscA variable. This is done so that the language
    may be changed many times in the same session of MicroEmacs without any
    side effects (such as the expansion of the word character set to include
    all letters of all languages). This makes MicroEmacs ideal for writing
    multi-language documents.

    This may unfortunately be made a little more tricky by the requirement
    that this list must be specified in the most appropriate ISO standard
    character set (see cDDisplayed Character SetcA section). When extending the
    word character set the characters have to be mapped to the current
    character set which may not support all the required characters. For
    example in the PC-437 DOS character set there is an e-grave (cG`ecA) but no
    E-grave so the E-grave is mapped to the normal E. As a result, if trying
    to write French text the case changing commands will behave oddly, for
    example:

            r`egle -> REGLE -> r`egl`e


    The conversion of all 'cGEcA's to 'cG`ecA' is an undesirable side effect of 'cG`EcA'
    being mapped to cGEcA. This can be avoided by redefining the base letter again
    at the end of the word character list, for example:
sB
        set-char-mask "a" "`E`eEe"

sA

cEcESpell Support cEcA


    The current language is set using the Language setting on General page of
    lslmuser-setup(3)le, if your required language is not listed you must first
    create the basic language support by following the guide lines in the cDWord
    CharactercA section above. If you Language is listed, select it and enable
    it by either pressing cDCurrentcA or saving and restarting MicroEmacs. in a
    suitable test buffer run the lsspell-buffer(3)lmspelling checkerle, one of three things will
    happen:

    The cGSpelling CheckercA dialog opens and spelling is checked

        The spelling checker is supported by the current language and can be
        used (the rules and dictionaries have been downloaded and installed).

    Dialog opens with the following error message:

            Rules and dictionaries for language "XXXX"
               are not available, please download.


        The spelling checker is supported by the current language but the
        required rules and dictionaries have not been downloaded. You should
        be able to download them from the JASSPA website, see lsMicroEmacs - Contact InformationlmContactln
        lnInformationle. Once downloaded they must be placed in the MicroEmacs
        ls$search-path(5)lmsearch pathle, i.e. where the other macro files (like cGme.emfcA) are
        located.

    Dialog opens with the following error message:

            Language "XXXX" not supported!


        The spelling checker is not supported by the current language, see the
        following cDAdding Spell SupportcA section.


cEAdding Spell Support cA


    To support a language MicroEmacs's spelling checker requires a base word
    dictionary and a set of rules which define what words can be derived from
    each base word in the dictionary. The concept and format of the word list
    and rules are compatible with the cDFree Software FoundationcA GNU cDispell(1)cA
    package.

    The best starting point is to obtain cDispellcA rules and word lists in plain
    text form, the web can usually yield these. Once these have been obtained
    the rules file (or affix file) must be converted to a MicroEmacs macro
    file calling the lslmadd-spell-rule(2)le command to define the rules. The rule
    file should be named "cGlsrcAcC<lang-id>cAcG.emfcA" where "cC<lang-id>cA" is the spelling
    language id, determined by the cD.spell.languagecA variable set in the
    cGlanguage.emfcA macro file.

    The cGspellutl.emfcA macro file contains the command cDspell-conv-aff-buffercA
    which will attempt to convert the buffer but due to formatting anomalies
    this process often goes wrong so using the command cDspell-conv-aff-linecA
    (also contained in cGspellutl.emfcA) to convert a single line is often
    quicker. See existing spelling rule files (cGlsr*.emfcA) for examples and help
    on command lslmadd-spell-rule(2)le.

    cDNotecA: the character set used by the rules should be the most appropriate
    ISO standard (see cDDisplayed Character SetcA section), this can make the
    process much more difficult if the current character set not compatible,
    if you are having difficulty with this please e-mail lsMicroEmacs - Contact InformationlmJASSPA Supportle.

    Once the rules have been created, create a dictionary for the language
    from the word lists, see help on command lslmadd-dictionary(2)le. The dictionary
    file name should be "cGlsdmcAcC<lang-id>cAcG.edfcA", if the dictionary is large and
    can be split into two sections, a set of common words and a set of more
    obscure ones, create two dictionaries calling the dictionary containing
    obscure words "cGlsdxcAcC<lang-id>cAcG.edfcA" and the other as above.

    Once the generated word and dictionary files have been place in the
    MicroEmacs ls$search-path(5)lmsearch pathle, the spelling checker should find and use them.
    Please submit your generated support to MicroEmacs for others to benefit.


cEcESEE ALSO cEcA


    lslmset-char-mask(2)le, lslmtranslate-key(2)le, lslmcharset-change(3)le, lslmuser-setup(3)le,
    lslm$box-chars(5)le, lslm$recent-keys(5)le. lslm$search-path(5)le, lslm$user-path(5)le,
    lslm$window-chars(5)le.
! 1 Patching
cEcEPATCHING cEcA


    This page describes how to patch a MicroEmacs installation with a later
    release without re-installing.


cEWindows cA


    Windows requires careful patching in order not to disturb the registry
    settings The following procedure should be followed.

        * Move to the jasspa directory, cGc:\ProgramFiles\JASSPA\MicroemacscA.
        * COPY the executable cGme32.execA to a backup, you MUST copy the file
          otherwise the registry settings will change. DO NOT MOVE THE FILE.

                copy me32.exe me32_2002_12.exe

        *
        Save the macros directory, these may be moved i.e.

                rename macros macros_2002_12

        *
        Unpack and install the new Windows executable and COPY over the
        original executable that was previously backed up i.e.

                copy c:\path-to-executable\me32-win32-20040108-rc1.exe me32.exe

        *
        Create a new macros directory and install the macros into this new
        directory, do this manually or using a utility like WINZip.

                mkdir macros
                cd macros
                unzip c:\path-to\memacros-20040108-rc1.zip

        *
        The new version of MicroEmacs will now operate with the old
        installation environment. You may return to the old release by
        reversing the steps to patch the installation.


cEUNIX/Linux cA


    For cD*NIXcA package installations then patching is a little easier. The steps
    are defined as follows:-

        * Move to the jasspa directory.

                cd /opt/jasspa/bin

        *
        Save the original executable.

                mv me me_200212

        *
        Unpack the new executable and make it executable.

                gunzip me-sun-solaris-20040108-rc1.gz
                mv me-sun-solaris-20040108-rc1 me
                chmod a+x me

        *
        Save the existing macros directory.

                cd /opt/jasspa
                mv macros macros_200212

        *
        Create a new macros directory and install the new macros:-

                mkdir macros
                cd macros
                unzip /path-to/memacros-20040108-rc1.zip

        *
        Installed packages are built with the install path built into the
        executable, this may be different from the patch version of the
        executable so the environment variable lslm$MEINSTALLPATH(5)le may be
        defined in the environment with the macro installation search paths.


cEcESEE ALSO cEcA


    lslm$MENAME(5)le, lslm$MEINSTALLPATH(5)le, lsCompanyProfiles(2)lmCompany Profilesle, lsInstallation(1)lmInstallationle, lsfileHooks(2)lmFile Hooksle,
    lslanguageTemplates(2)lmFile Language Templatesle, lsUserProfiles(2)lmUser Profilesle.
! 4 macroWriting
cEcEMACROS cEcA


    cDMicroEmacscA is based on a core set of built in commands and variables that
    provide a a basic set of functionality, almost all of the visible features
    of MicroEmacs are implemented or controlled by its macro language.
    cDNanoEmacscA is quite simply this base set of commands of MicroEmacs with no
    macro support and provides a basic Emacs editor.

    MicroEmacs is extended with an interpreted script file that allows new
    commands to be defined using the base level commands and variables which
    is referred to as a Macro. Once a macro command has been defined then it
    appears as a built in command to the user, and as with the existing
    commands, may have a key binding to invoke the new command.

    In addition to the base commands, the macro language includes control
    statements and logical operators which allow loops and conditional command
    sequences to control the sequence of operations.


cEStarting to write Macros cA


    For new users to MicroEmacs writing macros can be quite daunting, some of
    the macros shipped with MicroEmacs are complex and have evolved over many
    years. Beginners should start with simple macros which has verifiable
    output and can be performed interactively. This makes the task of writing
    and testing easier, some of the cCbehind the scenecA macros like the mouse
    driver and auto-spell checker are difficult to get working and requires a
    greater understanding of MicroEmacs and experience in macro debugging.

    A good starting point is to try to write a macro to do something that you
    find yourself doing all the time, for example reread-file, write-region
    etc.

    cDEscape SequencescA
        The backslash character 'cG\cA' is an escape sequence in MicroEmacs macro
        files, therefore any backslash character that appears in a macro
        command must be also escaped. i.e. '\' will become '\\' when placed in
        a macro file.

    cDEditor ControlcA
        Remember when you write a macro you are placing the editor in control
        of your macro, when testing a new macro then start a new MicroEmacs
        session or make sure that if things go wrong you will not loose any
        work. If you loose control of the editor then cDabortcA (cGC-gcA) will
        typically regain control again.


cEDeveloping your First Macro cA


    In the following example then we walk through the steps to create a macro
    that saves a region of text to a file (i.e. the text between cDpointcA and
    cDmarkcA). The resultant macro will be called cDwrite-regioncA, note that this
    macro already exists in MicroEmacs.

    The first thing to do is walk through the macro that you wish to write
    interactively in MicroEmacs. Whilst doing this you should decide which
    approach to take and the commands (or keys) used. Our cDwrite-regioncA could
    either use narrows or copy the region to a temporary buffer, a decision
    has to be made which approach is best to use. Narrows would be more
    efficient but there are more complications (such as restoring edit mode,
    avoid changing the cDundocA stack etc.). For the moment then the temporary
    buffer approach is probably the best solution.

    Walking through the sequence of steps required to save a region of text
    then the following command sequence would be executed (assuming a marked
    up region has been selected):-

        esc w                       ; Copy the region.
        C-x b "tmp-buffer"          ; Create a new temporary buffer.
        C-y                         ; Yank copied region into temporary buffer.
        C-x C-w "write_region_file" ; Save the buffer to a file.
        C-x k RETURN                ; Kill the temporary buffer.


    This is a fairly easy sequence of steps, the history of key presses can be
    viewed in the variable lslm$recent-keys(5)le, the command lslmlist-variables(2)le
    includes this variable in its output.

    Macros are not written in key sequences, instead the commands associated
    with the key bindings are used. A key binding command name may be
    determined using lslmdescribe-key(2)le and lslmdescribe-bindings(2)le. Some command
    bindings include a numeric argument, the numeric argument is important
    (both the value and absence/presence of the argument) and can change the
    behavior of the command. cGC-upcA is not 'cDbackward-linecA', it is 'cD5cA
    cDbackward-linecA' to go back 5 lines, if you supply a numerical value to the
    command as well, e.g. 'cGesc 3 C-upcA' you must multiply the user argument
    with the numerical argument of the binding:

        3 up   -> 3   'backward-line' -> 3 * 1 backward-line ->  3 backward-line
        3 C-up -> 3 '5 backward-line' -> 3 * 5 backward-line -> 15 backward-line


    Translating the keys that we used into commands then our cDwrite-regioncA
    process becomes:-
sB
        copy-region
        find-buffer "tmp-buffer"
        yank
        write-buffer "write_region_file"
        delete-buffer RETURN

sA
    cDTIP:cA
        If you are in an MicroEmacs macro buffer (e.g. cGfoo.emfcA) use the
        cDemf-quote-commandcA command (bound to cGA-qcA) to make this process trivial.
        This converts the key binding into a command which is inserted into
        the buffer.

    The obvious problem here is the last line, cG'delete-buffer RETURN'cA. When
    running interactively you can simply press RETURN to delete the current
    buffer however you cannot do this in a macro so you must explicitly
    specify the buffer name to delete:
sB
        delete-buffer  "write_region_file"

sA
    The the process of writing the buffer has the side effect of changing the
    buffer name to reflect the output file name, as cDdelete-buffercA follows the
    cDwrite-buffercA then the name will have changed.

    Correcting the delete buffer name, the sequence of commands is wrapped
    with a macro definition, which binds a name to the command sequence, and a
    terminator which terminates the macro.
sB
        define-macro write-region
            copy-region
            find-buffer "tmp-buffer"
            yank
            write-buffer "write_region_file"
            delete-buffer "write_region_file"
        !emacro

sA
    This macro works but is not very effective as the output filename has been
    fixed, this creates a file "cGwrite_region_filecA" in the MicroEmacs start up
    directory - probably not what is required. The specific macro that has
    been created must be made interactive, this means it must get filenames
    from the user, cope with a failure and the user doing silly things. So
    what must we cope with ? The list of defects is surprisingly long
    considering we are doing so little:

    1.
        The temp buffer used ("cGtmp-buffercA") is not a temporary buffer,
        temporary buffers must always commence with a 'cG*cA' and should be
        identifiable with the generating macro.cDNote:cA knowledge that a buffer
        is temporary allows MicroEmacs to discard content when shutting down
        without prompting the user to save.
    2.
        What happens if the "cGtmp-buffercA" already exists ?
    3.
        What happens if the "cGwrite_region_filecA" buffer already exists ?
    4.
        We need to get the filename to write from the user.
    5.
        What happens if the user aborts during the macro ?
    6.
        What happens if the write fails (disk full or file exists etc.) ?
    7.
        What happens if the user has the current buffer displayed in more than
        one window ?
    8.
        Does this fit in with other MicroEmacs commands amd macros ? Do we
        want to use this new command from another context ?


    The list of issues is a re-occurring theme, once you have got the hang of
    this it does become easier. In short reliable macros must:

        * Check inputs
        * Check outputs
        * Handle errors
        * Where appropriate handle an unexpected failure.

    The last one is really reserved for low level drivers (i.e. mouse,
    directory listings etc.) which must be bomb proof.


cEGeneralising Macros cA


    In the previous section we have created a basic macro to save a region of
    text, in this section we look at that macro is transformed from a static
    sequence to commands to a fully interactive robust command. Reference
    should be made to lsmacroOverview(4)lmMicroEmacs Macro Language at a Glancele for a quick tour
    of the language syntax.


cE1. The temp buffer used is not a temporary buffer... cA


    Forming a temporary buffer is simply a naming issue, temporary buffer
    names are simply started with a "cG*cA", by convention for a simple buffer
    name then they are terminated with a "cG*cA" as well. The temporary buffer
    name should reflect the name of the original macro hence the buffer name
    should be something like cG*write-region-tmp*cA
sB
        define-macro write-region
            copy-region
            find-buffer "*write-region-tmp*"
            yank
            write-buffer "write_region_file"
            delete-buffer "write_region_file"
        !emacro

sA

cE2. What happens if the 'tmp-buffer' already exists ? cA


    Looking at the current implementation if the write fails the temporary
    buffer will be left lying around. This is very likely to happen and if it
    does then we will get the last region as well as the next region in the
    output file. The simple solution is to delete the temporary buffer first,
    our first attempt to correct this:
sB
        define-macro write-region
            copy-region
            delete-buffer "*write-region-tmp*"
            find-buffer "*write-region-tmp*"
            ....
        !emacro

sA
    Unfortunately this fails if the buffer does not exist, so we must tell
    MicroEmacs to ignore the failure by cDforcingcA the execution:
sB
        define-macro write-region
            copy-region
            !force delete-buffer "*write-region-tmp*"
            find-buffer "*write-region-tmp*"
            yank
            write-buffer "write_region_file"
            delete-buffer "write_region_file"
        !emacro

sA

cE3. What happens if the 'write_region_file' buffer already exists ? cA


    If the cDwrite_region_filecA buffer already exists the buffer being written is
    renamed to "cDwrite_region_file<1>cA" rather than "write_region_file" and so
    the cDdelete-buffercA will delete the wrong buffer. Therefore rather than
    delete an explicitly named buffer the environment variables are used to
    query the name of the current buffer. The variable lslm$buffer-bname(5)le
    returns the current buffer's buffer name and may be used instead of an
    explicit name.
sB
        define-macro write-region
            copy-region
            !force delete-buffer "*write-region-tmp*"
            find-buffer "*write-region-tmp*"
            yank
            write-buffer "write_region_file"
            delete-buffer $buffer-bname
        !emacro

sA
    Macro variables may be used to get just about any information you could
    possibly want. For example lslm$buffer-fname(5)le could be used after the
    cDbuffer-writecA to get the file name, lslm$window-line(5)le provides the current
    line number etc. See

        Help -> lslmVariable Glossaryle

    for a full list of system variables. There are also cDMacro VariablescA
    (cG@cA,cG#cA,...) which are also very useful, e.g. lsCurrentBufferVariables(4)lm@wlle gives the text on the
    current line as a string, see the lslmMacro Language Glossaryle for a full list
    of these and other macro features such as functions and directives.


cE4. We need to get the destination filename from the user. cA


    Getting input from the user is always dangerous, most macros run so
    quickly that the user will not have sufficient time to abort the process
    (cGC-gcA) and if they do there is not much that can be done. When collecting
    input from the user the macro must wait for some input, at this point the
    user can and should be able to abort the process which must be handled. If
    the user has not aborted the user still has this uncanny ability of doing
    the unexpected and the input has to be checked, better still get
    MicroEmacs to get the input and check it.

    There are two approaches to the input problem:

        * We get the filename ourselves and pass this to the cDwrite-buffercA
          command.
        * Make cDwrite-buffercA get the input from the user itself as the command
          would when run from the command key binding.

    We would need to use the first approach if we needed the entered value
    multiple times, in this case we are not so we can use the simpler second
    approach but for the sake of this document lets consider the first
    approach.

    First stab:
sB
        set-variable $write-region-file-name @ml "Write-region file"
        write-buffer $write-region-file-name

sA
    This does work but you really do not want to do this ! Consider what
    happens if the user aborts while entering the file name ? The user would
    be left in the "cG*write-buffer-tmp*cA" buffer and would have to clear up the
    mess themselves. This may be fixed by catching the abort from the input
    and deleting the buffer.
sB
        !force !force set-variable $write-region-file-name @ml "Write-region file"
        !if &not $status
            !force delete-buffer $buffer-bname
            !abort
        !endif
        write-buffer $write-region-file-name

sA
    cDNOTE:cA
        The call to lsset-variable(2)lmset-variablele requires a double ls!force(4)lm!forcele, a single cD!forcecA
        allows a macro to continue after a failed command but not after a user
        interrupt (i.e. a cGC-gcA abort), to continue after this requires a double
        cD!forcecA.

    The second problem is with the input type, the lsMessageLineVaraibles(4)lm@mlle does not indicate that
    a file name is required. The type of input should be qualified to first
    check the input type and to provide other features such as file completion
    on file name entry. Specifying the input type correctly:
sB
        !force !force set-variable $write-region-file-name @ml04 "Write-region file"
        !if &not $status
            !force delete-buffer $buffer-bname
            !abort
        !endif
        write-buffer $write-region-file-name

sA
    cDTIP:cA
        How did we find out about lsMessageLineVaraibles(4)lm@ml04le ? The best way to find out how to do
        something is find another macro (or command) that does something very
        similar and copy it, in this case the lsdiff(3)lmdiffle macro has to perform a
        similar operation. If you cannot find anything then look in the
        command documents, the documents generally provide this sort of
        information (for example see lslm@ml(4)le). If all else fails then use the
        News Group, somebody will be able to provide an answer to your
        question.

    In progressing through the example we have used the basic system variables
    (cG$varcA) as they are simple. Other variables exist: user (cG%varcA), buffer
    (cG:varcA) or command (cG.varcA). All of the previously mentioned variables use
    valuable system resource and consideration should be given as to whether
    the value is required once the macro has completed execution. In our case
    the file name is temporary and is not required outside of the scope of the
    macro, rather than waste memory then a register variable is preferred as
    they have zero cost and execute faster than the other variables.
    Re-writing the macro with register (cG#lxcA) variables:
sB
        !force !force set-variable #l1 @ml04 "Write-region file"
        !if &not $status
            !force delete-buffer $buffer-bname
            !abort
        !endif
        write-buffer #l1

sA
    cDTIP:cA
        Avoid using the global variables (cG#g1cA etc.) as these could be altered
        by other macros. Sub-macros (i.e. macros called by other macros) can
        pass values back to their calling macro via the parent's register
        variables (cG#p1cA etc.). When using parent register variables then ensure
        that the sub-macro does not destroy some context of the parent macro
        through altering a register variable that has been used for another
        purpose.

    At the start of this section we said that there were two techniques by
    which we could get user input, we selected the first (which was less
    desirable than the second). The approach that we have taken of passing the
    filename to cDwrite-buffercA appears to be correct, however the cDwrite-buffercA
    command probably expects a reasonable filename -- what happens if the user
    enters a directory name ? There are other potential esoteric problems with
    our current approach, all of which may be overcome, but not here.

    The second technique, which is by far the best solution, is to simply get
    the command lslmwrite-buffer(2)le to get its input directly from the user. The
    command does this by default when bound to a key and run from the command
    line however when run from a macro the behavior is different as there is
    no command line. We can force this behavior by asking the command to be
    executed as if it were run from the command line:-
sB
        write-buffer @mn

sA
    When cDwrite-buffercA asks the MicroEmacs macro processor for a file name the
    lsMessageLineVaraibles(4)lm@mnle argument tells it to go directly to the user even though ME is
    currently running a macro. This will only get a single argument from the
    user, if the file already exits cDwrite-buffercA asks for confirmation that
    over-writing the existing file is okay, but this argument has not been
    given so the command fails. To fix this we could do:
sB
        write-buffer @mn "y"

sA
    However this has now created even more issues, what happens if this file
    is already loaded into MicroEmacs, should we allow the user to decide ? We
    could allow the command line to handle all of the cases:
sB
        write-buffer @mn @mn @mn @mn ....

sA
    Which is rapidly becoming very messy for each individual argument, instead
    we use lsMessageLineVaraibles(4)lm@mnale to ask the command to handle all input associated with the
    command:
sB
        write-buffer @mna

sA
    Note that we should have used this for the first method to protect
    cDwrite-buffercA:
sB
        write-buffer #l1 @mna

sA
    In this case the file name is provided by the argument cG#l1cA but the
    remaining arguments are handled internally by the command itself as if
    invoked from the command line.

    Moreover, there is one subtle problem here that can cause a lot of
    problems especially for other macros trying to use this macro (uses tend
    to spot the problem themselves and correct it causing only minor
    frustration). The macro creates a new temporary buffer which has no file
    name, this means that saving to "cG./filecA" will write the region to "cGfilecA"
    in the startup directory rather than in the current buffer's file path.
    For example, if you start MicroEmacs from "cG/bincA", load file "cG/tmp/foo.txtcA"
    and cGwrite-regioncA "cG./bar.txtcA" you will create the file "cG/bin/bar.txtcA" not
    "cG/tmp/bar.txtcA".

    To solve this directory issue the file name of the temporary buffer has to
    be set to the same filename as the current buffer we are copying from.
    This is safe as this is a temporary buffer (starts with a 'cG*cA') so
    MicroEmacs will not attempt to auto save or allow the buffer to be saved
    using lswrite-buffer(2)lmwrite-bufferle and is performed as follows:
sB
        define-macro write-region
            copy-region
            set-variable #l0 $buffer-fname       ; ADDED to fix directory location
            !force delete-buffer "*write-region-tmp*"
            find-buffer "*write-region-tmp*"
            yank
            set-variable $buffer-fname #l0       ; ADDED to fix directory location
            write-buffer @mna
            delete-buffer $buffer-bname
        !emacro

sA
    After all of that, the solution is in fact very simple, however the
    underlying complexity of the user expectations as to the behavior of the
    command are complicated.


cE5. What happens if the user aborts during the macro ? cA


    This issue has already been touched on in the previous sections, by using
    the cD@mnacA only the cDwrite-buffercA is likely to be aborted while the user is
    prompted for a file name etc. and if the user manages to abort elsewhere
    there really is not much that can be done about it without severely
    impacting the complexity of the macro. Practically it is only necessary to
    catch the exception when the user is being prompted on the command line
    with cDwrite-buffercA, as with our existing user input a double cD!forcecA is
    required to catch an abort at a prompt.
sB
        define-macro write-region
            copy-region
            set-variable #l0 $buffer-fname
            !force delete-buffer "*write-region-tmp*"
            find-buffer "*write-region-tmp*"
            yank
            set-variable $buffer-fname #l0
            !force !force write-buffer @mna
            !if &not $status
                !force delete-buffer $buffer-bname
                !abort
            !endif
            delete-buffer $buffer-bname
        !emacro

sA
    The lslm$status(5)le variable allows us to catch the exit state of the forced
    command and test for an abort condition following the forced statement.
    Note that the cD$statuscA value is only valid immediately after the last
    executed command, executing another command changes the value of cD$statuscA.
    If the status is required after execution of another command then it may
    be saved in a variable and used later.


cE6. what happens if the write fails (disk full or file exists etc) ? cA


    As the cDwrite-buffercA command should handle write file failures sensibly,
    and we have enabled it to get input from the user, then the command will
    automatically handle the failure conditions. Within our macro then it is
    simply a case of detecting and handling the failure condition -- we have
    already done this by handling the user input so no additions are required
    to the macro.


cE7. What happens if the current buffer displayed in more than one window ? cA


    If the user has the current buffer displayed only once then the action of
    deleting the temporary buffer returns the current window to the previous
    buffer, as required. If however the buffer is displayed more than once
    then when the temporary buffer is deleted MicroEmacs will select a
    different non-displayed buffer to become the current window (unless this
    is the only buffer) and so the user will not be returned back to their
    original buffer.

    This may be fixed by storing the initial buffer name and explicitly
    returning to it after the cDdelete-buffercA:
sB
        define-macro write-region
            copy-region
            set-variable #l0 $buffer-fname
            set-variable #l1 $buffer-bname
            !force delete-buffer "*write-region-tmp*"
            find-buffer "*write-region-tmp*"
            yank
            set-variable $buffer-fname #l0
            !force !force write-buffer @mna
            !if &not $status
                !force delete-buffer $buffer-bname
                find-buffer #l1
                !abort
            !endif
            delete-buffer $buffer-bname
            find-buffer #l1
        !emacro

sA
    However, when there are two windows into the same buffer the command may
    inherit the other window's buffer location, i.e. if the current window is
    on line 100 and the other window display this buffer is at line 200 the
    above version will leave the user at line 200 and a different region. The
    commands lslmset-position(2)le and lslmgoto-position(2)le allow the current position
    to be saved and later restored, the commands both take a single character
    which identifies the saved position, this allows multiple positions to be
    saved. Re-writing our macro to save and restore the buffer position we
    get:
sB
        define-macro write-region
            copy-region
            set-variable #l0 $buffer-fname
            set-position "P"
            !force delete-buffer "*write-region-tmp*"
            find-buffer "*write-region-tmp*"
            yank
            set-variable $buffer-fname #l0
            !force !force write-buffer @mna
            !if &not $status
                !force delete-buffer $buffer-bname
                goto-position "P"
                !abort
            !endif
            delete-buffer $buffer-bname
            goto-position "P"
        !emacro

sA

cE8. Does this fit in with other MicroEmacs commands and macros ? cA


    Finally we should consider how to make the macro more like a built in
    command so that other users and macros can take advantage of this new
    feature. Firstly let us consider supporting the numerical argument which
    is passed to all commands and macros. Considering cDwrite-buffercA the command
    permits an invocation from the command line of:

        esc 0 C-x C-w


    or from a macro:

        0 write-buffer


    The cG0cA argument disables validity checks and therefore forces the write. It
    would be reasonable to expect that a new command that writes a region to a
    file behaves in exactly the same way, where the commands have consistent
    behavior it makes it far easier for the user to guess how like commands
    operate. Unfortunately this behavior is absent from our current macro
    command. To support the numerical argument then the lsMacroArguments(4)lm@?le and lsMacroArguments(4)lm@#le variables
    are used to test for and retrieve the numerical argument.
sB
        define-macro write-region
            copy-region
            set-variable #l0 $buffer-fname
            set-position "P"
            !force delete-buffer "*write-region-tmp*"
            find-buffer "*write-region-tmp*"
            yank
            set-variable $buffer-fname #l0
            !if @?
                !force !force @# write-buffer @mna
            !else
                !force !force write-buffer @mna
            !endif
            !if &not $status
                !force delete-buffer $buffer-bname
                goto-position "P"
                !abort
            !endif
            delete-buffer $buffer-bname
            goto-position "P"
        !emacro

sA
    cDNote:cA
        that the cD!elsecA and cD!endifcA directive lines do not effect the setting of
        cD$statuscA so this is safe, only the execution of commands effect this
        variable.

    We can optimize the macro a little by noting that the default behavior of
    "cDwrite-buffercA" is the same as "cD1 write-buffercA" (this is not always the
    case), re-writing:
sB
        define-macro write-region
            copy-region
            set-variable #l0 $buffer-fname
            set-position "P"
            !force delete-buffer "*write-region-tmp*"
            find-buffer "*write-region-tmp*"
            yank
            set-variable $buffer-fname #l0
            !force !force @# write-buffer @mna
            !if &not $status
                !force delete-buffer $buffer-bname
                goto-position "P"
                !abort
            !endif
            delete-buffer $buffer-bname
            goto-position "P"
        !emacro

sA
    After all of this work there are still some compatibility problems to be
    resolved for our macro to be a true command replacement. Considering our
    use of cDwrite-buffercA, we have effectively have:
sB
        write-buffer "myfile"

sA
    The command gets the filename from the macro line and allow us to invoke
    the command in our own macros. So what about our new cDwrite-regioncA macro ?
    It is not unreasonable to expect that some macro developer in the future
    will want to write the current region out to a file and if we write this
    one correctly they will be able to use this command directly. At the
    moment a command invocation of
sB
        write-region "myfile"

sA
    in another macro will not have the desired effect. The "cGmyfilecA" argument
    is ignored and the user is always prompted for the file name. This can be
    solved by providing an optional parameter to be passed to the command
    using the /Hl @1 @1 4 variable as follows:
sB
        define-macro write-region
            copy-region
            set-variable #l0 $buffer-fname
            set-position "P"
            !force delete-buffer "*write-region-tmp*"
            find-buffer "*write-region-tmp*"
            yank
            set-variable $buffer-fname #l0
            !force set-variable #l1 @1
            !if $status
                !force !force @# write-buffer #l1 @mna
            !else
                !force !force @# write-buffer @mna
            !endif
            !if &not $status
                !force delete-buffer $buffer-bname
                goto-position "P"
                !abort
            !endif
            delete-buffer $buffer-bname
            goto-position "P"
        !emacro

sA
    Setting the register variable cG#l1cA to the first argument passed to the
    command will fail if no argument was given, so we use a cD!forcecA to stop the
    macro from quitting and change the cD$statuscA of the cDset-variablecA command. If
    the assignment fails then we get the filename from the user as before, if
    it succeeds then the calling macro has provided the file name.

    The cDwrite-regioncA macro is now complete and provides both a command line
    and macro interface. It is important to note that there is a subtle
    difference between macros and built in commands even though their
    capabilities are the same. To execute cDwrite-buffercA in a macro and get the
    user to supply a file name you must do:
sB
        write-buffer @mna

sA
    However for a macro, it is not itself a command and you cannot ask a macro
    to behave like a command. For a macro you must call it as:
sB
        write-region

sA
    The use of 'cG@mnacA' is only valid for commands, this perhaps is a quirk of
    the language which should really be fixed in the future.


cEConcluding cA


    We started this tutorial with a unusable 5 line macro and now have a 20
    line version which should be indistinguishable from a built in MicroEmacs
    command. The same command is available as part of the macro release and
    this document was written as part of the process of writing that macro.
    The only change to be made in making it part of the macro release is to
    change the cDset-positioncA label from "cGPcA", which a user could use, to
    something like "cG\x88cA" which is much safer to use.

    The final macro release version becomes:
sB
        define-macro write-region
            copy-region
            set-variable #l0 $buffer-fname
            set-position "\x88"
            !force delete-buffer "*write-region-tmp*"
            find-buffer "*write-region-tmp*"
            yank
            set-variable $buffer-fname #l0
            !force set-variable #l1 @1
            !if $status
                !force !force @# write-buffer #l1 @mna
            !else
                !force !force @# write-buffer @mna
            !endif
            !if &not $status
                !force delete-buffer $buffer-bname
                goto-position "\x88"
                !abort
            !endif
            delete-buffer $buffer-bname
            goto-position "\x88"
        !emacro

sA
    It is perhaps surprising the number of steps it has taken to write
    something that appears to be simple, however in writing macros there are
    many re-occurring themes and once familiar with the concepts then then you
    will typically get them right first time. Creating a macro like this takes
    approximately half an hour.

    We have to question whether it is worth writing these extensions. If you
    find yourself doing the same thing all the time then definitely yes, it
    will save time and you will have less aches and pains in your hand.
    Spending the extra time to write a good macro saves time in the long run,
    it also provides a better base on which more sophisticated macros may be
    based. MicroEmacs has actually evolved like this. Hopefully this tutorial
    will encourage rather than frighten off budding macro writers.


cEcESEE ALSO cEcA


    lsMicroEmacs - Macro Language GlossarylmMacro Glossaryle
    lsmacroDebugging(4)lmMacro Debugging - A Crash Coursele
    lsmacroOverview(4)lmMicroEmacs Macro Language at a Glancele
! 4 macroDebugging
cEcEMACRO DEBUGGING cEcA


    In writing new macros then you need to debug them, there are various
    strategies as follows:-


cETracing cA


    The simplest method is to add debugging information that is printed on the
    message line that traces the execution sequence as it progresses through
    the macro.

    Use lslmml-write(2)le to print out values as you go, use
sB
        1000 ml-write &spr "Got here, value [%s]" #l1

sA
    to see the values. The integer argument is a delay in milliseconds, the
    command above will print the message and then wait 1 second before
    continuing with execution. The wait allows you to see the message.

    Once the macro is debugged then delete or comment out the trace messages.


cEDebugger cA


    The macro debugger is a built in debugger that allows the macro execution
    sequence to be traced and debugged. The debugger is operation is
    controlled by the variable lslm$debug(5)le by default the value is cG0cA which
    disables the debugger. The debugger displays the next command to execute
    in the message line and the user may single step through the macro and
    interrogate the variables.

    Use the cD$debugcA variable for interactive debugging. The best way is to
    insert the following line somewhere BEFORE the problem occurs where the
    macro needs to be debugged:
sB
        set-variable $debug 1

sA
    As soon as this variable is set then it drops the user into debug mode. If
    we applied this to our tutorial example then we would define it as:
sB
        define-macro write-region
            set-variable $debug 1       ; Enable debugger
            copy-region
            set-variable #l0 $buffer-fname
            set-position "\x88"
            !force delete-buffer "*write-region-tmp*"
            find-buffer "*write-region-tmp*"
            yank
            set-variable $buffer-fname #l0
            !force set-variable #l1 @1
            !if $status
                !force !force @# write-buffer #l1 @mna
            !else
                !force !force @# write-buffer @mna
            !endif
            !if &not $status
                !force delete-buffer $buffer-bname
                goto-position "\x88"
                !abort
            !endif
            delete-buffer $buffer-bname
            goto-position "\x88"
        !emacro

sA
    so as soon as we execute cDwrite-regioncA then we drop into debug mode. The
    mode line appears as follows:-

        macro-name:position:number [line] ?


    where cDmacro-namecA is the name of the macro that is executing, cDpositioncA is
    the line from the start of the macro definition. cDlinecA is the macro line
    that is being executed. i.e.

        display-matching-fenc:22:0 [4 show region] ?


    At the prompt the commands that are available are:-

    cG?cA
        Help, display the debugger commands.

    cG^GcA
        Abort the macro. Immediately terminates the macro sequence, the state
        of the buffers is undefined and leaves the windows in the state when
        the macro was aborted.

    cG^LcA
        Redraws the current screen.

    cGccA
        Continues macro execution the value of $debug is set to 0. Execution
        continues without user interaction up until the next cD$debugcA change.

    cGscA
        Single steps through the macro, if another macro is invoked then
        debugging with continue in the new sub-macro.

    cGvcA
        Display the value of a variable. The user is prompted for a variable
        value to show, once entered, the value of the variable is displayed.

    cC<any>cA
        Any other key will step onto the next instruction, unlike cCstepcA then
        any macros that are invoked are not debugged.

    See the lslm$debug(5)le help page for more information.

    It is important that you SAVE ALL YOUR WORK before starting to debug
    macros. It is possible to sometimes crash the editor up while developing
    macros, prior to the January 2005 build then the following example of
    infinite recursion would destroy the editor:
sB
        define-macro Test
            Test
        !emacro

sA
    This macro nesting is now caught the nesting is limited to 20 calling
    macros.

    For everyday macros that the typical user will write MicroEmacs will be
    robust and is not likely to result in any damage. If you start writing
    macros with for deeply nested macro hooks from the core of MicroEmacs
    (i.e. ipipe callbacks) then deleting buffers under the editor will cause
    stability problems when mistakes are made. For performance reasons it is
    not possible to check for all permutations of every command that could be
    issued that may possibly change the state of the editor and then recover.
    Provided that the calls are used within their calling remit then no ill
    effects will be observed.


cEcESEE ALSO cEcA


    lslm$debug(5)le,
    lsMicroEmacs - Macro Language GlossarylmMacro Glossaryle
    lsmacroOverview(4)lmMicroEmacs Macro Language at a Glance.le
    lsmacroWriting(4)lmWriting MicroEmacs Macrosle
! 4 macroOverview
cEcEMACRO LANGUAGE OVERVIEW cEcA


    MicroEmacs macro language is a run-time interpreted language and uses a
    prefix notation form, that is operators appear before their arguments,
    sometimes known as Polish notation, i.e. 'cG+ 3 4cA' rather than the more
    conventional infix notation 'cG3 + 4cA').

    Every line is self contained, you cannot make a single command span
    multiple line (by using something like a '\' character as in C or tcl).

    Comments start with semi-colon 'cG;cA', anything to the right of an unquoted
    semi-colon is ignored.
sB
        ; I'm a comment and exist to the end of line.
        set-variable #l1 1     ; I am a comment to the end of line.

sA
    There are three types of line

        * Blank or comment line
        * Process flow control lines using directives (i.e. 'cG!if #l1cA')
        * Executable command lines (i.e. cGforward-linecA)

    The first letter of any word or token on a line is very important and
    informs MicroEmacs and the user what type of token it is. The basic token
    start characters are:

        cG;cA Comment
        cG$cA System or environment variable
        cG%cA User variable
        cG:cA Buffer variable
        cG.cA Command variable
        cG#cA Register variable
        cG@cA Macro variable
        cG!cA Directive
        cG&cA Function
        cG"cA A string, which finishes at the next unquoted cG"cA.
        cG0-9cA A number, which is read as a string
        cG*cA A goto label

        If its not one of the above then it must be the first letter of a
        command name.


cEEscape Character cA


    cDBackslashcA 'cG\cA' cDis escape character in macro scripts, so every normalcA
    cDoccurrence needs to be doubled.cA

    The MicroEmacs macro language uses a backslash 'cG\cA' character as an escape
    character. In order to use a backslash character in macro arguments then
    all backslash characters should be themselves escaped with another
    backslash i.e. 'cG\cA' becomes 'cG\\cA' or 'cG\\cA' becomes 'cG\\\\cA'. If the escaping is
    omitted then it is likely that the command will receive an incorrect
    character sequence that will be misinterpreted and cause the command to
    fail or perform an incorrect action.


cEComments cA


    Comments may appear anywhere on a line and everything to the right of the
    semi-colon to the end of the line is ignored:
sB
        ; this is a comment
        set-variable #l0 1    ; this part of the line is a comment.

sA

cESystem or environment variables cA


    MicroEmacs system variables start with 'cG$cA' and are used to configure most
    aspects of the editor (such as tab widths, window drawing characters
    etc.). There are a fixed list of system variables, see lsMicroEmacs - Macro Language GlossarylmMicroEmacs - Macroln
    lnLanguage Glossaryle.

    If a given variable name is not a recognized system variable (e.g. cG$PATHcA)
    then MicroEmacs treats it as an environment variable, using
    lslmset-variable(2)le to change an environment variable. This is useful when
    used in conjunction with one of MicroEmacs's shell commands. If the
    environment variable does not exist its value is returned as the string
    "cGERRORcA".


cEUser variables cA


    User variables commence with a percentage character 'cG%cA' and have a global
    context within the editor, but unlike the cCsystemcA cCvariablescA they do not
    span into the environment space (i.e. private to MicroEmacs).

    The use of cDUser VariablescA is discouraged because of their scope,
    historically MicroEmacs only supported system and user variables. If two
    different macros use the same variable then things go wrong which is
    principally why they are no longer used. Macros have become a very large
    part of JASSPA's MicroEmacs and therefore they must be reliable by the
    nature of their global scope they are considered unreliable.

    A few commands still use them but this is more for historical reasons, for
    example xgrep's lslm%xgrep-com(5)le variable to set the default grep command
    would be better implemented as the command variable cG.xgrep.comcA, see below.


cEBuffer Variables cA


    Buffer variables are set in the context of a buffer, each buffer has its
    own independent list of buffer variables so this type of variable is used
    by macros which need to store buffer context information. As an example, a
    file hook may allow each buffer to have its own private lslm$fill-ignore(5)le
    value (the variable is global). It may stores each buffer's own fill
    ignore in the variable cG:fill-ignorecA. This is private to the buffer.
    Referencing the variable cG:fill-ignorecA retrieves the current buffer's
    cG:fill-ignorecA variable, if it not set its value is returned as "cGERRORcA".
    Referencing cG:*scratch*:fill-ignorecA retrieves the "cG*scratch*cA" buffer's
    cG:fill-ignorecA value.

    The operator lslm&exist(4)le may be used to determine if the buffer variable has
    been created and set.


cECommand Variables cA


    Command variables are set in the context of a command or macro and are
    similar to buffer variables. cG.varcA retrieves the the current macros command
    variable whereas cG.hilight.varcA will get command cDhilightcA command variable.

    It is important to understand that these variables are stored with the
    command and the command must exist before the variable is used. As an
    example of the command variable scope, consider the following macro
    definitions.
sB
        define-macro Test1
            ml-write &spr "Test1 .foo is [%s]" .foo
        !emacro
        set-variable .Test1.foo "hello world"
        define-macro Test2
            ml-write &spr "Test1 .foo is [%s]" .Test1.foo
        !emacro

sA
    On running cDTest1cA and cDTest2cA both will print "cGTest1cA cG.foocA cGiscA cG[hellocA cGworld]cA".
    The initialisation of cG.Test1.foocA is performed outside of the macro and is
    done only once, once the variable has been initialized the line is
    discarded. This discard reduces the run-time memory overhead.


cERegister Variables cA


    Most variables are used to store temporary information, once a macro
    completes the variable is no longer required. lsMicroEmacs - Macro Language GlossarylmRegister variablesle are used
    for this purpose, their scope is only the current macro's execution as
    such they are the most efficient variables to use.

    A new set of registers is created every time that a macro is executed,
    called cG#l0cA through to cG#l9cA. Where macros are nested then the parent
    registers are effectively stacked and may be access through cG#p0cA through to
    cG#p9cA, this is especially useful when writing recursive macros or macros
    which must return values as they may return a processed result in the
    parents register. A single set of registers always exists which is the
    global registers cG#g0cA through to cG#g9cA, for a first level macro then this
    forms its parent register variable.


cEMacro variables cA


    lsMicroEmacs - Macro Language GlossarylmMacro variablesle commence with a at-sign cG@cA and are only available in the
    context of a macro and are used to retrieve the numeric argument,
    parameters etc. The variables include:-

        cD@?cA - Boolean determines if a numeric argument was supplied
        cD@#cA - The value of the numeric argument

        cD@0cA - The name of the macro
        cD@1cA - The first argument of macro
        cD@2cA - The second argument of macro
        cD@3cA ... cD@cAcCncA

        cD@pcA - The name of the calling (or parent) macro.


cEDirectives cA


    The lsMicroEmacs - Macro Language GlossarylmMacro Directivesle are denoted by a cD!cA prefix and provide control over
    the command sequence. Directives are used to define macros and affect the
    macro execution sequence. i.e.
sB
        define-macro if-test
            set-variable #l0 1
            !if #l0
                ml-write "you will see this"
                !return
            !elif &not #l0
                ml-write "you will not see this"
                !abort
            !else
                ml-write "you will not see this"
                !abort
            !endif
        !emacro

sA
    The common directives are:-

    cD!abortcA
        ls!return(4)lm!abortle terminates a macro and exits with a cCfalsecA status.

    cD!returncA
        ls!return(4)lm!returnle terminates a macro and exits with a cCtruecA status.

    cD!whilecA/cD!continuecA/cD!donecA
        ls!while(4)lm!whilele defines a conditional loop that is tested before entry to the
        loop, the ls!while(4)lm!continuele statement within the loop allows the loop to be
        broken. cD!whilecA loops may not be nested, but may be contained within a
        ls!repeat(4)lm!repeat/!untille construct.

    cD!repeat/!untilcA
        ls!repeat(4)lm!repeatle defines a conditional loop that is tested on exit from the
        loop. cD!repeatcA loops may not be nested, but may be contained within a
        ls!while(4)lm!while/!donele construct.

    cDdefine-macro/!emacrocA
        lsdefine-macro(2)lmdefine-macrole defines a new macro which is terminated with a ls!emacro(4)lm!emacrole.

    !if/!elif/!else/!endif
        ls!if(4)lm!ifle defines a conditional statement, where there is more than one
        condition then the ls!if(4)lm!elifle directive may continue the conditional test.

    cD!goto/!tgotocA
        ls!goto(4)lm!gotole and ls!goto(4)lm!tgotole provide an absolute unconditional and conditional
        jump to a cD*labelcA in a file, respectively. A cD!gotocA label is defined as
        line commencing with a cG*cA followed by a name i.e. cD*labelcA.

    cD!forcecA cCcommandcA
        ls!force(4)lm!forcele ignores the return status of a cCcommandcA while executing a macro,
        thereby ignoring any exceptions which would otherwise halt macro
        execution.


cEFunctions cA


    All lsIntroduction to Variable Functionslmfunctionsle are denoted by a cD&cA prefix, they are perhaps miss named and
    should be called operators as they operate on variables and literal
    strings to produce a new result.

    There are different type of functions:

        * Numeric - interprets arguments as numbers i.e. add two numbers
          lslm&add(4)le.
        * String - interprets arguments as strings i.e. to concatenate two
          strings together lslm&cat(4)le.
        * Logical - boolean operators i.e. greater than lslm&great(4)le.
        * Key - key bindings i.e. key binding of command ls&cbind(4)lmkbind(4)le.
        * Bitwise - bit-wise numerical operators i.e. bitwise AND lslm&band(4)le.
        * File - file interaction i.e. find a file lslm&find(4)le.
        * Lists - string item lists i.e. find item in list lslm&lfind(4)le.
        * Miscellaneous - miscellaneous functions to which query and return
          information to the caller i.e. registry query lslm&reg(4)le.

    The functions use a postfix notation as the cCfunctioncA appears before the
    arguments.
sB
        set-variable #l0 2
        set-variable #l1 1
        !if &gre #l0 #l1
            ml-write "#l0 is greater than #l1"
        !endif

        ml-write &cat "#l0 + #l1 = " &add #l0 #l1

sA
    The interpretation of strings and numbers is discussed in the next
    section.


cEStrings and Numbers cA


    All variables are treated as strings within MicroEmacs so the integer
    value of 102 is the string cG"102"cA. Where functions require an integer
    argument (i.e. ls&abs(4)lm&addle) the strings are converted to integers, operated on
    and converted back to a string result. Floating point notation is not
    understood.

    Integers may be expressed in different bases:

        cG0xXXXcA - Hexadecimal notation i.e. cC0x12afcA.
        cG0oooocA - Octal notation requires a leading cC012673cA.
        cGdddddcA - Decimal notation cC12345cA.

    Strings do not necessarily need to be quoted, provided that the string is
    unambiguous and does not include any special characters then all input
    between white spaces is considered to be a string. Strings may be quoted
    'cG"string"cA', within a quoted string then a backslash 'cG\cA'is used as an
    escape character. the escape sequences that are interpreted include:

        cG\\cA - A backslash character.
        cG\tcA - A literal TAB character.
        cG\ncA - A literal NEWLINE character.
        cG\xxcA - A hexadecimal character.


cEcESEE ALSO cEcA


    lslmIntroduction to Variable Functionsle
    lsMicroEmacs - Macro Language GlossarylmMacro Glossaryle
    lsmacroDebugging(4)lmMacro Debugging Crash Coursele
    lsmacroWriting(4)lmWriting MicroEmacs Macrosle
! 3fgdiff
cEcENAME cEcA


    gdiff - Command line graphical file difference
$a


cEcESYNOPSIS cEcA


    cDmecA "@gdiff" "cCversion1cA" "cCversion2cA"


cEcEDESCRIPTION cEcA


    MicroEmacs may be executed from the command line to invoke the cCGraphical
    DifferencecA lslmgdiff(3)le macro, showing the difference(s) between two files.

    The editor is invoked in cDgdiffcA mode and shows the difference between the
    two files on the command line. The two files are presented side by side
    and the lines are matched together, the windows are effectively locked
    together, scrolling one window causes the other window to scroll.

    The changes are shown as color coded regions of highlighted text. Each
    block (or line) has to be accepted or rejected by the user, when all
    blocks have been accepted then the buffer may be written out merging the
    changes from both files depending on the accept/reject status. Blocks
    which have been accepted are typically shown in green, the rejected lines
    are shown in red.


cEKey Mapping cA


    The keyboard mapping in cDgdiffcA mode is defined as follows:

    cDesc-hcA
        Help information.

    cDC-upcA/cDpcA
        Advance to the previous difference.

    cDC-downcA/cDncA
        Advance to the next difference.

    cDesc-upcA/P
        Advance to the previous unassigned difference.

    cDesc-downcA/N
        Advance to the next unassigned difference.

    cDgcA
        Globally select all of the differences from the current window as
        assigned.

    cDGcA
        Globally un-select all of the assigned differences.

    cDrcA/cDspacecA/cDreturncA/cDleft-mousecA
        Selects the current difference, only operates within a highlighted
        difference region.

    cDRcA
        Un-selects the current difference, only operates within a highlighted
        difference region.

    cDlcA
        Selects the current line in a highlighted region for assignment.

    cDLcA
        Unselects the current line in a highlighted region for assignment.

    cDsave-buffercA
        Saves the current buffer, all of the assignment changes are merged and
        written out to the existing buffer.

    cDwrite-buffercA
        Saves the current buffer after merging all of the and assignment
        changes and prompts the user for the name of a new buffer.

    cDleftcA/cDrightcA
        Scrolls the buffer left or right.

    cDkill-buffercA/cDC-x C-ccA
        Quits cDgdiffcA, the user is prompted to save changes.


cEcENOTES cEcA


    The macro is defined in file cGgdiff.emfcA.


cEcESEE ALSO cEcA


    lslmgdiff(3)le, lslmstart-up(3)le, lslmxdiff(3)le.
! 3f2unix
! 3f2dos
! 3f2mac
! 3f2win
! 3fdos2unix
! 3funix2dos
! 3funix2win
cEcENAME cEcA


    2unix - Convert text files to UNIX format files
$a


cEcESYNOPSIS cEcA


    cDmecA "@2dos" cC<files>cA
    cDmecA "@2mac" cC<files>cA
    cDmecA "@2unix" cC<files>cA
    cDmecA "@2win" cC<files>cA


cEcEDESCRIPTION cEcA


    The start-up file cG2unix.emfcA may be invoked from the command line as a
    filter to convert all text files, which may be in MS-DOS, Windows,
    Macintosh format into UNIX text format.

    Each file specified on the command line is interrogated and the line
    ending modified to UNIX.

    cG2doscA, cG2wincA and cG2maccA similarly operate to provide conversion from any of
    these formats to MS-DOS, Macintosh or Windows file formats.


cEcEEXAMPLE cEcA


    When using ME as a command line filter it is advisable to control the
    backup command line options. Typically the backups and auto-save are
    disabled so that no backup files are generated i.e.

        me -a -B "@2dos" files...


    Performs a conversion from UNIX to MS-DOS and disables the generation of
    auto-save files and backups.

    NE may be used to run the filters, by default NE runs without backup and
    auto-save mode enabled and the flags should NOT be used.

        ne "@2dos" files...


cEcENOTES cEcA


    cGMS-DOScA files are defined to use a line ending of cG\r\ncA, the file is
    terminated with cGctrl-zcA.

    Macintosh files are defined to use a line ending of cG\rcA, there is no
    special end of file character.

    Microsoft Windows files are defined to use a line ending of cG\r\ncA, there is
    no special end of file character.

    UNIX files are defined to use a line ending of cG\ncA, there is no special end
    of file character.

    The unix2dos.emf, dos2unix.emf and unix2win.emf were renamed to 2dos.emf,
    2unix.emf and 2win.emf when 2mac.emf was added in October 2006 as the
    'from' format is not important and number of combinations became
    unmanageable.


cEcESEE ALSO cEcA


    lslmme(1)le, lslmstart-up(3)le, lslmfiletype(3f)le, lslmauto(2m)le, lslmcr(2m)le, lslmlf(2m)le, lslmctrlz(2m)le.
! 3fbenchmrk
cEcENAME cEcA


    benchmrk - Benchmark MicroEmacs macro processor speed
$a


cEcESYNOPSIS cEcA


    cDmecA "@benchmrk"


cEcEDESCRIPTION cEcA


    The start-up file cGbenchmrk.emfcA may be invoked from the command line to
    time the macro processor variable manipulation times.

    This macro suite was developed to optimize the macro processor
    performance, and allows comparable analysis of various macro variable
    manipulations. The macro is not important in it's own right and is not
    likely to be useful. Running it will provide an in-site into the speed of
    the macro language and should indicate to the user what are good and bad
    things to be doing.

    As an aside, as MicroEmacs interprets the macro code the it is important
    that the processing operates at a reasonable speed. Most extensions
    offering additional functionality are likely to be added to MicroEmacs by
    way of a macro implementation - this allows speedy development of new
    features. Obviously core changes do occur when we find that we cannot
    support certain new requirements, or when the macro code becomes too
    convoluted. In these cases, new commands are added to help us solve the
    problem. However, recent evolution of the code has indicated that the core
    set is now reasonably complete.


cEcESEE ALSO cEcA


    lslmstart-up(3)le.
! 3fctags
cEcENAME cEcA


    ctags - Generate a C tags file
$a


cEcESYNOPSIS cEcA


    cDmecA "@ctags" [cC-v%tag-option=<flags>cA] [cCfilescA]


cEcEDESCRIPTION cEcA


    The start-up file cGctags.emfcA may be invoked from the command line to
    generate a cDtagscA file for C and C++ source and header files.

    Given a list of cCfilescA a tags file cGtagscA is generated in the current
    directory, which may be used by the lslmfind-tag(2)le command. This is a good
    alternative on Microsoft platforms where a utility such as cDctags(1)cA is not
    typically available. If no cCfilescA are specified the default file list is
    "cG./cA", i.e. process the current directory. If a directory name is given
    (such as the default "cG./cA") all C and C++ source and header files within
    the directory will be processed.

    The value of variable cD%tag-optioncA is used to control the tag generation
    process, its value cC<flags>cA can contain any number of the following flags:

    cGacA
        Append new tags to the existing tag file, note that if also using flag
        'cGmcA' multiple 'tags' to the same item may be created.

    cGmcA
        Enable multiple tags. This enables the existence of 2 tags with the
        same tag name, but typically with different locations. See help on
        lslmfind-tag(2)le for more information on multiple tag support.

    cGrcA
        Enables recursive mode, any sub-directory found within any given
        directories will also be processed.

    cGvcA
        Add global variables to the tag file. (i.e. variables marked with
        cCexterncA).

    cGecA
        Add enumerated variables to the tag file (i.e. cCenumcA members).

    cGscA
        Add structure, type definitions and classes to the tag file (i.e.
        cCstuctcA, cCtypedefcA and cCclasscA).

    The generated tags file includes cG#definecA and C++ class names.


cEcENOTES cEcA


    This function is invoked from menu

        cDTools -> C Tools -> Create Tags FilecA

    when the user requests a tags file to be generated.

    The user setup file "cGmyctags.emfcA" is executed by ctags during start-up,
    this file can be used to over-ride any of the ctags configuration
    variables (see below).

    The following variables are set within "cGctags.emfcA" and are used to control
    the process:-

    cD%tag-optioncA
        Tags options flag, default value is "". See above for more
        information.

    cD%tag-filemaskcA
        A list of source file masks to be processed when a directory is given,
        default value is "cG:*.[cC]:*.cpp:*.cc:*.h:*.hpp:cA".

    cD%tag-ignoredircA
        A list of directories to be ignored when recursive option is used,
        default value is "cG:SCCS/:CVS/:cA".

    These variables can be changed using the -v command-line option or via the
    "cGmyctags.emfcA" file


cEcESEE ALSO cEcA


    lslmfind-tag(2)le, lslmstart-up(3)le, lslmc(9)le.
! 3fehftools
cEcENAME cEcA


    ehftools - Generate a MicroEmacs help file
$a


cEcESYNOPSIS cEcA


    cDmecA "@ehftools" *.htm


cEcEDESCRIPTION cEcA


    The start-up file cGehftools.emfcA may be invoked from the command line to
    generate a MicroEmacs help file from a set of HTML files (with the
    extension cG.htmcA).

    The MicroEmacs documentation suite of tools has not been officially
    released as part of the distribution. For reference, the sequence of
    operations that are performed from the command line or shell script are:-

        make meehf.hts
        hts2html -l .htm meehf.hts
        mv me.htm me/1.htm
        cd me
        me "@ehftools" *.htm


cEcENOTES cEcA


    The cCnroffcA to HTML generator leaves the special markers cG<!-- XI: %s -->cA in
    the generated HTML code which contain the hypertext link information.


cEcESEE ALSO cEcA


    lslmstart-up(3)le, lslmehf(8)le.
! 3femftags
cEcENAME cEcA


    emftags - Generate a MicroEmacs macro tags file
$a


cEcESYNOPSIS cEcA


    cDmecA "@emftags" [cC-v%tag-option=<flags>cA] [cCfilescA]


cEcEDESCRIPTION cEcA


    The start-up file cGemftags.emfcA may be invoked from the command line to
    generate a cDtagscA file for MicroEmacs macro files, lslmemf(8)le.

    Given a list of cCfilescA a tags file cGtagscA is generated in the current
    directory, which may be used by the lslmfind-tag(2)le command. If no cCfilescA are
    specified the default file list is "cG./cA", i.e. process the current
    directory. If a directory name is given (such as the default "cG./cA") all
    MicroEmacs macro files within the directory will be processed.

    The value of variable cD%tag-optioncA is used to control the tag generation
    process, its value cC<flags>cA can contain any number of the following flags:

    cGacA
        Append new tags to the existing tag file, note that if also using flag
        'cGmcA' multiple 'tags' to the same item may be created.

    cGmcA
        Enable multiple tags. This enables the existence of 2 tags with the
        same tag name, but typically with different locations. See help on
        lslmfind-tag(2)le for more information on multiple tag support.

    cGrcA
        Enables recursive mode, any sub-directory found within any given
        directories will also be processed.


cEcENOTES cEcA


    This function is invoked from menu

        cDTools -> Emf Tools -> Create Tags FilecA

    when the user requests a tags file to be generated.

    The user setup file "cGmyemftags.emfcA" is executed by emftags during
    start-up, this file can be used to over-ride any of the emftags
    configuration variables (see below).

    The following variables are set within "cGemftags.emfcA" and are used to
    control the process:-

    cD%tag-optioncA
        Tags options flag, default value is "". See above for more
        information.

    cD%tag-filemaskcA
        A list of source file masks to be processed when a directory is given,
        default value is "cG:*.emf:cA".

    cD%tag-ignoredircA
        A list of directories to be ignored when recursive option is used,
        default value is "cG:SCCS/:CVS/:cA".

    These variables can be changed using the -v command-line option or via the
    "cGmyemftags.emfcA" file


cEcESEE ALSO cEcA


    lslmfind-tag(2)le, lslmstart-up(3)le, lslmemf(8)le.
! 3fntags
cEcENAME cEcA


    ntags - Generate a nroff tags file
$a


cEcESYNOPSIS cEcA


    cDmecA "@ntags" cC<files>cA


cEcEDESCRIPTION cEcA


    The start-up file cGntags.emfcA may be invoked from the command line to
    generate a cDtagscA file for nroff files.

    Given a list of cCfilescA a tags file cGtagscA is generated in the current
    directory, which may be used by the lslmfind-tag(2)le command. If no cCfilescA are
    specified the default file list is "cG./cA", i.e. process the current
    directory. If a directory name is given (such as the default "cG./cA") all
    nroff files within the directory will be processed.

    The value of variable cD%tag-optioncA is used to control the tag generation
    process, its value cC<flags>cA can contain any number of the following flags:

    cGacA
        Append new tags to the existing tag file, note that if also using flag
        'cGmcA' multiple 'tags' to the same item may be created.

    cGmcA
        Enable multiple tags. This enables the existence of 2 tags with the
        same tag name, but typically with different locations. See help on
        lslmfind-tag(2)le for more information on multiple tag support.

    cGrcA
        Enables recursive mode, any sub-directory found within any given
        directories will also be processed.


cEcENOTES cEcA


    This function is invoked from menu

        cDTools -> Nroff Tools -> Create Tags FilecA

    when the user requests a tags file to be generated.

    The tags are generated from the nroff macro:-

        .XI <name> ......


    which indicates an index entry, where cC<name>cA is the tag name. cC<name>cA may
    be delimited by double quotes if any whitespace is present in the string.

    This is the macro definition used in the MicroEmacs documentation system.
    The cGntags.emfcA file should be edited and shadowed in the user directory if
    some other search criteria is used for nroff files. This macro file should
    provide a good starting point for any other search.

    The user setup file "cGmyntags.emfcA" is executed by ntags during start-up,
    this file can be used to over-ride any of the ntags configuration
    variables (see below).

    The following variables are set within "cGntags.emfcA" and are used to control
    the process:-

    cD%tag-optioncA
        Tags options flag, default value is "". See above for more
        information.

    cD%tag-filemaskcA
        A list of source file masks to be processed when a directory is given,
        default value is "cG:*.nrs:*.[1-9]:*.n:cA".

    cD%tag-ignoredircA
        A list of directories to be ignored when recursive option is used,
        default value is "cG:SCCS/:CVS/:cA".

    These variables can be changed using the -v command-line option or via the
    "cGmyntags.emfcA" file


cEcESEE ALSO cEcA


    lslmfind-tag(2)le, lslmstart-up(3)le, lslmnroff(9)le.
! 3fprintall
cEcENAME cEcA


    printall - Formatted print job
$a


cEcESYNOPSIS cEcA


    cDmecA "@printall" cC<files>cA


cEcEDESCRIPTION cEcA


    The start-up file cGprintalls.emfcA may be invoked from the command line to
    generate a print job for each file specified on the command line.

    Given a list of cC<files>cA, the files are loaded into the editor, and then
    printed through MicroEmacs printing formatter. This is an alternative to
    cDcgrind(1)cA or some other syntax smart cCpretty printcA filter.

    The operation of this macro assumes that the printer is functioning
    correctly.


cEcEBUGS cEcA


    As a guess, I would probably bet that this does not work very well on
    Windows as a dialog is invoked for the print.


cEcESEE ALSO cEcA


    lslmstart-up(3)le.
! 3ftcltags
cEcENAME cEcA


    tcltags - Generate a Tcl/Tk tags file
$a


cEcESYNOPSIS cEcA


    cDmecA "@tcltags" cC<files>cA


cEcEDESCRIPTION cEcA


    The start-up file cGtcltags.emfcA may be invoked from the command line to
    generate a cDtagscA file for lstcl(9)lmTcl/Tkle files.

    Given a list of cCfilescA a tags file cGtagscA is generated in the current
    directory, which may be used by the lslmfind-tag(2)le command. If no cCfilescA are
    specified the default file list is "cG./cA", i.e. process the current
    directory. If a directory name is given (such as the default "cG./cA") all
    Tcl/Tk files within the directory will be processed.

    The value of variable cD%tag-optioncA is used to control the tag generation
    process, its value cC<flags>cA can contain any number of the following flags:

    cGacA
        Append new tags to the existing tag file, note that if also using flag
        'cGmcA' multiple 'tags' to the same item may be created.

    cGmcA
        Enable multiple tags. This enables the existence of 2 tags with the
        same tag name, but typically with different locations. See help on
        lslmfind-tag(2)le for more information on multiple tag support.

    cGrcA
        Enables recursive mode, any sub-directory found within any given
        directories will also be processed.


cEcENOTES cEcA


    This function is invoked from menu

        cDTools -> Tcl Tools -> Create Tags FilecA

    when the user requests a tags file to be generated.

    The following variables are set within "cGtcltags.emfcA" and are used to
    control the process:-

    cD%tag-optioncA
        Tags options flag, default value is "". See above for more
        information.

    cD%tag-filemaskcA
        A list of source file masks to be processed when a directory is given,
        default value is "cG:*.tcl:*.tk:cA".

    cD%tag-ignoredircA
        A list of directories to be ignored when recursive option is used,
        default value is "cG:SCCS/:CVS/:cA".

    These variables can be changed using the -v command-line option or via the
    "cGmytcltags.emfcA" file


cEcESEE ALSO cEcA


    lslmfind-tag(2)le, lslmstart-up(3)le, lslmtcl(9)le.
! 3ftextags
cEcENAME cEcA


    textags - Generate a LaTeX/BibTeX tags file
$a


cEcESYNOPSIS cEcA


    cDmecA "@textags" cC<files>cA


cEcEDESCRIPTION cEcA


    The start-up file cGtextags.emfcA may be invoked from the command line to
    generate a cDtagscA file for lslatex(9)lmLaTeXle and lslatex(9)lmBibTeXle files.

    Given a list of cCfilescA a tags file cGtagscA is generated in the current
    directory, which may be used by the lslmfind-tag(2)le command. If no cCfilescA are
    specified the default file list is "cG./cA", i.e. process the current
    directory. If a directory name is given (such as the default "cG./cA") all
    LaTeX files within the directory will be processed.

    The value of variable cD%tag-optioncA is used to control the tag generation
    process, its value cC<flags>cA can contain any number of the following flags:

    cGacA
        Append new tags to the existing tag file, note that if also using flag
        'cGmcA' multiple 'tags' to the same item may be created.

    cGmcA
        Enable multiple tags. This enables the existence of 2 tags with the
        same tag name, but typically with different locations. See help on
        lslmfind-tag(2)le for more information on multiple tag support.

    cGrcA
        Enables recursive mode, any sub-directory found within any given
        directories will also be processed.


cEcENOTES cEcA


    This function is invoked from menu

        cDTools -> LaTeX Tools -> Create Tags FilecA

    when the user requests a tags file to be generated.

    The following variables are set within "cGtextags.emfcA" and are used to
    control the process:-

    cD%tag-optioncA
        Tags options flag, default value is "". See above for more
        information.

    cD%tag-filemaskcA
        A list of source file masks to be processed when a directory is given,
        default value is "cG:*.tex:*.bib:cA".

    cD%tag-ignoredircA
        A list of directories to be ignored when recursive option is used,
        default value is "cG:SCCS/:CVS/:cA".

    These variables can be changed using the -v command-line option or via the
    "cGmytextags.emfcA" file


cEcESEE ALSO cEcA


    lslmfind-tag(2)le, lslmstart-up(3)le, lslmtex(9)le.
! 3fjavatags
cEcENAME cEcA


    javatags - Generate a C tags file from Java sources.
$a


cEcESYNOPSIS cEcA


    cDmecA "@javatags" [cC-v%tag-option=<flags>cA] [cCfilescA]


cEcEDESCRIPTION cEcA


    The start-up file cGjavatags.emfcA may be invoked from the command line to
    generate a cDtagscA file for java source files.

    Given a list of cCfilescA a tags file cGtagscA is generated in the current
    directory, which may be used by the lslmfind-tag(2)le command. This is a good
    alternative on Microsoft platforms where a utility such as cDctags(1)cA is not
    typically available to process Java files. If no cCfilescA are specified the
    default file list is "cG./cA", i.e. process the current directory. If a
    directory name is given (such as the default "cG./cA") all Java source files
    within the directory will be processed.

    The value of variable cD%tag-optioncA is used to control the tag generation
    process, its value cC<flags>cA can contain any number of the following flags:

    cGacA
        Append new tags to the existing tag file, note that if also using flag
        'cGmcA' multiple 'tags' to the same item may be created.

    cGmcA
        Enable multiple tags. This enables the existence of 2 tags with the
        same tag name, but typically with different locations. See help on
        lslmfind-tag(2)le for more information on multiple tag support.

    cGrcA
        Enables recursive mode, any sub-directory found within any given
        directories will also be processed.

    cGvcA
        Add global variables to the tag file. (i.e. variables marked with
        cCexterncA).

    cGscA
        Add classes definitions to the tag file (i.e. cCclasscA).

    The generated tags file includes cG#definecA and C++ class names.


cEcENOTES cEcA


    This function is invoked from menu

        cDTools -> C Tools -> Create Tags FilecA

    when the user requests a tags file to be generated.

    The user setup file "cGmyjavatags.emfcA" is executed by javatags during
    start-up, this file can be used to over-ride any of the javatags
    configuration variables (see below).

    The following variables are set within "cGjavatags.emfcA" and are used to
    control the process:-

    cD%tag-optioncA
        Tags options flag, default value is "". See above for more
        information.

    cD%tag-filemaskcA
        A list of source file masks to be processed when a directory is given,
        default value is "cG:*.java:*.jav:cA".

    cD%tag-ignoredircA
        A list of directories to be ignored when recursive option is used,
        default value is "cG:SCCS/:CVS/:cA".

    These variables can be changed using the -v command-line option or via the
    "cGmyjavatags.emfcA" file


cEcESEE ALSO cEcA


    lslmfind-tag(2)le, lslmstart-up(3)le, lslmjava(9)le.
! 3ffiletype
cEcENAME cEcA


    filetype - Determine file type UNIX, DOS or Windows
$a


cEcESYNOPSIS cEcA


    cDmecA "@filetype" cC<files>cA


cEcEDESCRIPTION cEcA


    The start-up file cGfiletype.emfcA may be invoked from the command line as a
    filter to determine the file type (MS-DOS, Windows or UNIX). Each file
    specified on the command line is interrogated and the line ending is
    reported.

    When the command completes then the cG*scratch*cA buffer contains a list of
    the files and their file type.


cEcESEE ALSO cEcA


    lslmstart-up(3)le, lslmdos2unix(3f)le, lslmauto(2m)le, lslmcr(2m)le, lslmlf(2m)le, lslmctrlz(2m)le.
! 3 compile
cEcENAME cEcA


    compile - Start a compilation process
$a


cEcESYNOPSIS cEcA


    cCncA cDcompilecA "cCcompile-commandcA"


cEcEDESCRIPTION cEcA


    cDcompilecA gets and executes the compile command using a pipe execution
    (incremental pipe on UNIX platforms), loading the output into a buffer
    called "cD*compile*cA", with go to error parsing using the command
    lslmget-next-line(2)le. The default compile execution is set by variable
    lslm%compile-com(5)le, the error parsing is setup using the command
    lslmadd-next-line(2)le.

    Before the compile command is executed lslmsave-some-buffers(2)le is executed to
    allow the user to ensure that all relevant buffers are saved. If an
    argument is given to compile then it is passed on to this command, so if
    an argument of 0 is given, all buffers are automatically saved.

    By default the output lines in the window wrap, wrapping may be disabled
    during compilations by redefining the wrap mode as follows. Create the
    file cGmyipipe.emfcA to redefine the behavior and add the following lines:-
sB
        ; Macro to redefine the wrapping behavior of the *compile* buffer
        0 define-macro my-fhook-ipipe
            !if &seq $buffer-bname "*compile*"
                -1 buffer-mode "wrap"
            !endif
        !emacro

sA

cEcENOTES cEcA


    cDcompilecA is a macro defined in cGtools.emfcA.


cEcESEE ALSO cEcA


    lslmadd-next-line(2)le, lslm%compile-com(5)le, lslmget-next-line(2)le, lslmsave-some-buffers(2)le,
    lslmgrep(3)le.
! 3 xgrep
! 3 rgrep
cEcENAME cEcA


    xgrep - Execute grep command
    rgrep - Execute recursive grep command
$a


cEcESYNOPSIS cEcA


|xgrep
    cDxgrepcA "cCexpression files...cA"
|rgrep
    cDrgrepcA "cCexpressioncA" "cCbase-pathcA" "cCfile-maskcA"


cEcEDESCRIPTION cEcA


    cDxgrepcA executes the cDgrep(1)cA command with the command line set by the
    lslm%xgrep-com(5)le variable and the user supplied cCexpressioncA and file list
    cCfiles...cA. The output of the command is piped into the cD*grep*cA buffer ready
    for the lslmget-next-line(2)le command to step through all matched lines. The
    syntax from the grep output must be setup using lslmadd-next-line(2)le.

    If an argument is given then a lslmpipe-shell-command(2)le is used instead of
    lslmipipe-shell-command(2)le, this is useful when used in macros as it ensures
    that cDgrepcA has finished before the command returns.

    cDrgrepcA is similar to cDgrepcA in that it uses cDgrep(1)cA to search for all
    occurrences of cCexpressioncA, but cDrgrepcA also uses cDfind(1)cA to search for
    cCexpressioncA in all files matching the cCfile-maskcA in all directories from
    cCbase-pathcA down.


cEcENOTES cEcA


    cDxgrepcA is a macro defined in cGxfind.emfcA.

    cDgrep(1)cA must be executable on the system before grep or rgrep can
    function, cDfind(1)cA must also be available for rgrep to work. The cDfind(1)cA
    command is defined by variable lslm%xfind-com(5)le, the default when not defined
    is cGfindcA.


cEcEEXAMPLE cEcA


    The cDxgrepcA command is generally set up in the startup files as follows:-
sB
        ;
        ; setup the next-error stuff including grep and compiling
        ;
        set-variable $line-template "[0-9]+"
        set-variable $file-template "[a-zA-Z:]*[0-9a-zA-Z\_.]+"
        ;
        ; Definitions for GNU grep utility.
        ;
        set-variable %xgrep-com "grep -n "
        0 add-next-line "*grep*"
        add-next-line "*grep*" "%f:%l:"

sA

cEcESEE ALSO cEcA


    lslm%xfind-com(5)le, lslm%xgrep-com(5)le, lslmadd-next-line(2)le, lslmcompile(3)le. cDfind(1)cA,
    lslmxfind(3)le, lslmget-next-line(2)le, cDgrep(1)cA.
! 3 save-all
cEcENAME cEcA


    save-all - Save all modified files (with query)
$a


cEcESYNOPSIS cEcA


    cCncA cDsave-allcA


cEcEDESCRIPTION cEcA


    cDsave-allcA cycles through all buffers, dictionaries, registry files and
    current session writing back any changes made. For each buffer,
    dictionary, session or registry file which has been modified the user is
    prompted before the changes are saved, a value of cDycA initiates the save, cDncA
    skips the save.

    The argument cCncA can be used to change the default behavior of save-all
    described above, cCncA is a bit based flag where:-

    cD0x01cA
        Enables the user prompt before the file is saved (default). If this
        flag is not supplied then all modified files will automatically be
        written.


cEcENOTES cEcA


    cDsave-allcA is a macro defined in cGme.emfcA, using commands
    lslmsave-some-buffers(2)le, lslmsave-dictionary(2)le, lslmsave-session(3)le, and
    lslmsave-registry(2)le.


cEcESEE ALSO cEcA


    lslmsave-dictionary(2)le, lslmsave-registry(2)le, lslmsave-session(3)le,
    lslmsave-some-buffers(2)le.
! 3 paragraph-to-line
cEcENAME cEcA


    paragraph-to-line - Convert a paragraph to a single line
$a


cEcESYNOPSIS cEcA


    cCncA cDparagraph-to-linecA


cEcEDESCRIPTION cEcA


    cDparagraph-to-linecA is a variation of lslmfill-paragraph(2)le. cDparagraph-to-linecA
    reduces each of the next cCncA paragraphs of text to single lines. This
    command is typically used to prepare text for import into a word processor
    such as cDMicrosoft WordcA or cDWord PerfectcA. Reduction of text to a single line
    allows the word processor to import the raw text file and keep the text
    within paragraph blocks. If the text is not prepared then all of the
    line-feeds have to be manually deleted.

    cDparagraph-to-linecA allows text based documents to be prepared in MicroEmacs
    2009 and imported into the word processor at the final stage for
    formatting and layout.


cEcENOTES cEcA


    cDparagraph-to-linecA is a macro defined in cGformat.emfcA.


cEcESEE ALSO cEcA


    lslmfill-paragraph(2)le.
! 3 sort-lines-ignore-case
cEcENAME cEcA


    sort-lines-ignore-case - Alphabetically sort lines ignoring case"
$a


cEcESYNOPSIS cEcA


    cCncA cDsort-lines-ignore-casecA


cEcEDESCRIPTION cEcA


    cDsort-lines-ignore-casecA forces the current buffers lslmexact(2m)le mode to off
    and then calls lslmsort-lines(2)le which will perform a case insensitive
    alphabetical line sort from the mark position to the current cursor
    position. The state of the current buffers cDexactcA mode is restored on
    completion.


cEcENOTES cEcA


    cDsort-lines-ignore-casecA is a macro defined in cGformat.emfcA, see help on
    command lslmsort-lines(2)le for a complete definition.


cEcESEE ALSO cEcA


    lslmsort-lines(2)le, lslmbuffer-mode(2)le, lslmexact(2m)le, lslmtranspose-lines(2)le.
! 3 clean
cEcENAME cEcA


    clean - Remove redundant white spaces from the current buffer
$a


cEcESYNOPSIS cEcA


    cCncA cDcleancA


cEcEDESCRIPTION cEcA


    cDcleancA removes redundant white spaces from the current buffer, there are
    three types this command remove:

    1)
        Any space or tab character at the end of the line. All are removed
        until the last character is not a space or a tab, or the line is
        empty. Note that an empty line is not removed unless at the end of the
        buffer.

    2)
        Space characters are removed when the next character is a tab, making
        the space redundant, e.g. the strings "cG Hello WorldcA" and "cG Hello
        WorldcA" will look identical because the tab character ('cC cA') indents the
        text to the 8th column with or without the space so the space can be
        removed.

    3)
        Superfluous empty lines at the end of the buffer are removed, leaving
        only one empty line.

    4)
        If argument cCncA is given (value is not used) multiple blank lines are
        reduced to a single blank line.


cEcEDIAGNOSTICS cEcA


    cG[Command illegal in view mode]cA
        Caused by a redundant white space being found and the buffer being in
        view mode. Note that if clean completes while the buffer is in view
        mode then no superfluous white spaces where found.


cEcENOTES cEcA


    cDcleancA is a macro defined in cGformat.emfcA.

    Most of this command's operation is performed by simple regex search and
    replace strings:

    a)
        Search for: "[\t ]+$" Replace with: "\\0"

    b)
        Search for: "[ ]+\t" Replace with: "\t"

    c)
        Search for: "\n\n\n" Replace with: "\n\n"

    It is useful to define a new command called cDspotlesscA in the user macro
    file which cleans the file and removes blank lines. The new command is
    defined as follows:-
sB
        ; spotless; Perform a clean and remove any multi-blank lines.
        define-macro spotless
            -1 clean
        !emacro

sA

cEcESEE ALSO cEcA


    lslmreplace-string(2)le, lslmtab(2m)le, lslmdelete-blank-lines(2)le, lslmtabs-to-spaces(3)le.
! 3 replace-all-string
cEcENAME cEcA


    replace-all-string - Replace string with new string in a list of files
$a


cEcESYNOPSIS cEcA


    cCncA cDreplace-all-stringcA "cCfromcA" "cCtocA" "cCfilescA" ["cCgrep-fromcA"]


cEcEDESCRIPTION cEcA


    cDreplace-all-stringcA, similar to lslmreplace-string(2)le, replaces all occurrences
    of "cCfromcA" to "cCtocA" in the given list of files without prompting the user.

    The command finds all occurrences of "cCfromcA" by calling the command lslmgrep(3)le
    to search for string "cCfromcA" in files "cCfilescA". Thus all relevant edited
    files must be saved or cDgrepcA may return the wrong line numbers. This is
    achieved by a call to lslmsave-some-buffers(2)le which prompts the user to save
    any changed buffers one at a time.

    Each occurrence of "cCfromcA" is jumped to using lslmget-next-line(2)le and the
    string is replaced by the call:
sB
        -1 replace-string "from" "to"

sA
    This replaces all occurrences of "cCfromcA" to "cCtocA" on the current line only,
    hence the line numbers must be correct. This also means that the "cCfromcA"
    search string must be correctly formatted for both grep and
    replace-string, unless bit 0x02 is set (see below).

    The given argument cCncA is a bit based flag which changes the default
    behavior described above. The bits have the following effect:-

    cD0x01cA
        Prompt before saving any changed buffer, enabled by default. If this
        bit is not set then any changed buffer is automatically saved before
        the cDgrepcA is performed.

    cD0x02cA
        If set then a fourth argument "cCgrep-fromcA" must also be given. This
        string is used in place of the "cCfromcA" string for the cDgrepcA only.


cEcENOTES cEcA


    cDreplace-all-stringcA is a macro defined in cGsearch.emfcA.

    The cDgrepcA command must be working before this command can function
    properly.

    It is not recommended to use a "from" or "to" string which uses more that
    one line as the results may be unpredictable.

    As the change is likely to be over several files a single call to lslmundo(2)le
    at the end of execution will not undo all the changes made. To undo all
    the changes made, use lslmget-next-line(2)le to loop through all the occurrences
    and call cDundocA for each occurrence


cEcESEE ALSO cEcA


    lslmreplace-string(2)le, lslmsave-some-buffers(2)le, lslmgrep(3)le, lslmget-next-line(2)le,
    lslmundo(2)le, lslmquery-replace-all-string(3)le, lslmreplace-all-pairs(3)le,
    lslmsearch-forward(2)le.
! 3 query-replace-all-string
cEcENAME cEcA


    query-replace-all-string - Query replace string in a list of files
$a


cEcESYNOPSIS cEcA


    cCncA cDquery-replace-all-stringcA "cCfromcA" "cCtocA" "cCfilescA" ["cCgrep-fromcA"]


cEcEDESCRIPTION cEcA


    cDquery-replace-all-stringcA, similar to lslmquery-replace-string(2)le, replaces all
    occurrences of "cCfromcA" to "cCtocA" in the given list of files prompting the
    user before replacing each occurrence.

    The command finds all occurrences of "cCfromcA" by calling the command lslmgrep(3)le
    to search for string "cCfromcA" in files "cCfilescA". Thus all relevant edited
    files must be saved or cDgrepcA may return the wrong line numbers. This is
    achieved by a call to lslmsave-some-buffers(2)le which prompts the user to save
    any changed buffers one at a time.

    Each occurrence of "cCfromcA" is jumped to using lslmget-next-line(2)le and the
    string is replaced by the call:
sB
        -1 query-replace-string "from" "to"

sA
    This query-replaces all occurrences of "cCfromcA" to "cCtocA" on the current line
    only, hence the line numbers must be correct. This also means that the
    "cCfromcA" search string must be correctly formatted for both grep and
    query-replace-string, unless bit 0x02 is set (see below).

    The given argument cCncA is a bit based flag which changes the default
    behavior described above. The bits have the following effect:-

    cD0x01cA
        Prompt before saving any changed buffer, enabled by default. If this
        bit is not set then any changed buffer is automatically saved before
        the cDgrepcA is performed.

    cD0x02cA
        If set then a fourth argument "cCgrep-fromcA" must also be given. This
        string is used in place of the "cCfromcA" string for the cDgrepcA only.


cEcENOTES cEcA


    cDquery-replace-all-stringcA is a macro defined in cGsearch.emfcA.

    The cDgrepcA command must be working before this command can function
    properly.

    It is not recommended to use a "from" or "to" string which uses more that
    one line as the results may be unpredictable.

    As the change is likely to be over several files a single call to lslmundo(2)le
    at the end of execution will not undo all the changes made. To undo all
    the changes made, use lslmget-next-line(2)le to loop through all the occurrences
    and call cDundocA for each occurrence


cEcESEE ALSO cEcA


    lslmquery-replace-string(2)le, lslmsave-some-buffers(2)le, lslmgrep(3)le, lslmget-next-line(2)le,
    lslmundo(2)le, lslmreplace-all-string(3)le, lslmsearch-forward(2)le.
    lsRegularExpressions(2)lmRegular Expressionsle
! 3 tabs-to-spaces
cEcENAME cEcA


    tabs-to-spaces - Converts all tabs to spaces
$a


cEcESYNOPSIS cEcA


    cDtabs-to-spacescA


cEcEDESCRIPTION cEcA


    cDtabs-to-spacescA converts all tab characters found in the current buffer
    with spaces. The number of spaces a tab is replaced with depends on the
    column of the tab character and the setting of lslm$buffer-tab-width(5)le.

    The cursor is restored to the start of the current line after completion.


cEcENOTES cEcA


    cDtabs-to-spacescA is a macro defined in cGformat.emfcA.


cEcESEE ALSO cEcA


    lslm$buffer-tab-width(5)le, lslm$tab-width(5)le, lslmtab(2)le, lslmtab(2m)le, lslmclean(3)le,
    lslmspace-rectangle(3)le.
! 3 calc
cEcENAME cEcA


    calc - Integer calculator
$a


cEcESYNOPSIS cEcA


    cCncA cDcalccA "cCstringcA"


cEcEDESCRIPTION cEcA


    cDcalccA can perform simple integer based calculations given by "cCstringcA",
    where the "cCstringcA" takes the following form:-

        "[b]<s>"


    Where 'cCbcA' is an optional letter setting the required output base which can
    be one of the following:

        cGb   cA - Binary
        cGo   cA - Octal
        cGd   cA - Decimal
        cGx   cA - Hexadecimal

    Default when omitted is 'cCdcA' (decimal). "cCscA" is the sum to be calculated,
    which should be bodmas in form. Following is a list of valid symbols.

        cG(..)cA - Parentheses (contents calculated first)
        cG!   cA - Logical not
        cG&&  cA - Logical and
        cG||  cA - Logical or
        cG==  cA - Logical equals
        cG!=  cA - Logical not equals
        cG~   cA - Bitwise not
        cG&   cA - Bitwise and
        cG|   cA - Bitwise or
        cG^   cA - Bitwise xor
        cG/   cA - Divide
        cG*   cA - Multiply
        cG%   cA - Modulus
        cG+   cA - Addition
        cG-   cA - Subtraction
        cG0xNNcA - Hexadecimal number
        cG0NN cA - Octal number
        cGLR  cA - Last calculation recall

    Any MicroEmacs variables can be used in the calculation. The result of the
    calculation is stored in lslm.calc.result(5)le. The argument cCncA is a bitwise flag
    where:

    cD0x01cA
        Print out the result on the message-line.

    cD0x02cA
        Use string comparisons for == and != comparisons. This has the
        advantage of being able to calc "Foo" == "Bar" etc.

    When omitted the default argument is 1.


cEcEEXAMPLE cEcA


    To calculate the number of hours in a year:

        calc "365*24"


    To then calculate the number of seconds in the year:

        calc "LR*60*60"


cEcENOTES cEcA


    cDcalccA is a macro defined in cGcalc.emfcA.


cEcESEE ALSO cEcA


    lslm.calc.result(5)le.
! 3 time
cEcENAME cEcA


    time - Command time evaluator
$a


cEcESYNOPSIS cEcA


    cDtimecA "cCstringcA"


cEcEDESCRIPTION cEcA


    cDtimecA evaluates the time take to execute line "cCstringcA". cDtimecA uses command
    lslmexecute-line(2)le to execute the given string.


cEcEEXAMPLE cEcA


    The following example simply times the time take to save the current
    buffer:-

        time "save-buffer"


cEcENOTES cEcA


    cDtimecA is a macro defined in cGmisc.emfcA.

    On multi-task systems like UNIX cDtimecA cannot take into account the number
    of other processes running at the same time, it can only return the actual
    time elapse. This leads to inaccuracies and variation in results.


cEcESEE ALSO cEcA


    lslmexecute-line(2)le.
! 3 alarm
cEcENAME cEcA


    alarm - Set an alarm
$a


cEcESYNOPSIS cEcA


    cDalarmcA "cCmessagecA" "cChourscA" "cCminutescA"


cEcEDESCRIPTION cEcA


    cDalarmcA creates an alarm notification which displays "cCmessagecA" to the user.
    The alarm time is specified as an elapsed time in "cChourscA" and "cCminutescA"
    from the time of creation.

    The message is printed on the screen using lslmosd(2)le.


cEcENOTES cEcA


    cDalarmcA is a macro defined in cGosdmisc.emfcA.


cEcESEE ALSO cEcA


    lslmosd(2)le.
! 3 Mahjongg
cEcENAME cEcA


    Mahjongg - MicroEmacs 2009 version of the solitaire Mah Jongg game
$a


cEcESYNOPSIS cEcA


    cDMahjonggcA


cEcEDESCRIPTION cEcA


    Mah Jongg is an ancient Chinese game usually played by four players with
    tiles similar to dominos. This is a MicroEmacs 2009 version which was
    inspired by the X-Windows version of the same game. The X-Windows version
    for the solitaire game originally seen on the PC and later ported to
    SunView.


cETheory Of Play cA


    The object of the game is to remove all the tiles from the board. Tiles
    are removed by matching two identical tiles which have either an open left
    edge or open right edge. The only exception to this rule is that any open
    "cCflowercA" tile (bamboo cG[BAMB]cA, orchid cG[ORCH]cA, plum cG[PLUM]cA, or chrysanthemum
    cG[CHRY]cA) matches any other open "cCflowercA" tile and any open "cCseasoncA" tile
    (spring, summer, autumn, or winter) matches any other open "cCseasoncA" tile.

    Tiles are stacked on the board, the height of the tile is indicated by the
    color coding as follows:-

        cGLevel 5cA - White
        cGLevel 4cA - Red
        cGLevel 3cA - Yellow
        cGLevel 2cA - Green
        cGLevel 1cA - Cyan

    To remove a pair of tiles, click the left mouse button on a tile (which
    will show in the selection color) and then click the left mouse button on
    the matching tile. At this point, both tiles will disappear from the
    board. If after selecting the first tile, you decide that you don't wish
    to play that tile, simply reclick the left button on the selected tile,
    alternatively click the right button to deselect any selected tile.

    To the right of the board are a number of control buttons. To select an
    option, click the left mouse button on it.

    cDNEWcA
        Start a new game (keyboard n).

    cDSAMEcA
        Start the same game again (keyboard s).

    cDQUITcA
        Exit the game (keyboard q).

    cDHELPcA
        This help page (keyboard esc h).

    The counter shows the number of remaining tiles on the board, at the start
    of the game there are 144 tiles.


cEcENOTES cEcA


    Mahjongg is a macro defined in cGmahjongg.emfcA.

    Mah Jongg may only be played with a mouse, there is no keyboard support,
    with the exception of the re-start keys.


cEcEACKNOWLEDGEMENT cEcA


    Thanks to Jeff S. Young who (I think) wrote the original X-Windows
    version, and whose manual page formed the basis of this page.

    The tile patterns were inspired from the X-Windows tile patterns. The
    X-Windows tile patterns themselves are copyright 1988 by Mark A. Holm
    <tektronix!tessi!exc!markh>.


cEcESEE ALSO cEcA


    lsMicroEmacs - GameslmGamesle, lslmMatch-It(3)le, lslmPatience(3)le.
! 3 Match-It
cEcENAME cEcA


    Match-It - MicroEmacs 2009 version of the Match-It game
$a


cEcESYNOPSIS cEcA


    cDMatch-ItcA


cEcEDESCRIPTION cEcA


    The object of the game is to score the largest number of points, to do
    this the player must complete as many sheets as possible. A sheet is
    completed when all the tiles are removed from the board within the given
    time limit - ALL sheet are possible. If the player fails to remove all the
    tiles before the time runs out a life is lost, if all lives have been lost
    then the game is over.

    Tiles are removed from the board by matching two identical tiles which
    have an 'extraction' path between them. The only exception to this rule is
    that any open "cCflowercA" tile (bamboo cG[BAMB]cA, orchid cG[ORCH]cA, plum cG[PLUM]cA, or
    chrysanthemum cG[CHRY]cA) matches any other open "cCflowercA" tile and any open
    "cCseasoncA" tile (spring, summer, autumn, or winter) matches any other open
    "cCseasoncA" tile.

    An 'extraction' path is a straight line which uses 2 or less right angles,
    the following are legal extraction paths, 'cG*cA's denote the right angles:

                        A---*       *-----*     A----*
            A----A          A       AXXXXXA     XXXXX|
                                                A----*


    The following are illegal paths:

            *----*          *---*
            AXXXX|          |XXXA
            XXXXA*      A---*XXXX


    2 points are added to the score whenever a pair is successfully removed, a
    point is deducted whenever a pair is selected which can not be removed
    because there is no valid extraction path. There are 2 aids, pressing the
    right button on a tile when no other tile is selected will hilight all
    tiles of matching type, this costs 4 points. The other help is activated
    by a button at the top right of the screen and it removes a random
    removable pair (or informs the user that there are no removable pairs),
    there are a limited number of these helps.

    At the end of a successful sheet the score is increased be the time left,
    the number of lives and helps remaining and by the Pedigree and Internal
    bonuses if they were achieved.

    The Pedigree bonus is obtained when only identical tiles are paired, i.e.
    no differing flowers or seasons were paired, 50 points are awarded when
    achieved. Its status is indicated by a 'P' to the left of the 'Help'
    button and the top of the window.

    The internal bonus is obtained when the outer 4 margins are not used. If
    the left or right margins are not used then 10 points are awarded for
    each, if the top or bottom are not used then 20 points are awarded for
    each and if none are used then 400 points are awarded! The status on the
    Internal bonus is indicated by an 'cGIcA' surrounded by 'cG*cA's, one for each
    margin. This can be found next to the Pedigree bonus 'cGPcA'.


cEcEGAME CONTROLS cEcA


    To the right of the high score table on the main menu there are a number
    of control buttons. To select an option, click the left mouse button on
    it.

    cDNEWcA
        Start a new game.

    cDQUITcA
        Exit Match-It.

    cDHELPcA
        This help page (keyboard esc h).

    During a sheet, to remove a pair of tiles, click the left mouse button on
    a tile (which will show in the selection color) and then click the left
    mouse button on the matching tile. At this point, if the tiles can be
    removed, the extraction path is drawn and both tiles will disappear from
    the board. If after selecting the first tile, you decide that you don't
    wish to play that tile, simply reclick the left button on the selected
    tile, alternatively click the right button to deselect any selected tile.

    To the top right of the sheet there are a number of control buttons:-

    cDHELPcA
        Removes a tile pair.

    cDQUITcA
        Exit the game.

    cDBOSScA
        Hides Match-It, also acts as a pause. Execute Match-It again to return
        to the game.

    The top left shows the number of remaining lives, the current sheet level,
    the current score, time remaining for the current sheet and the status of
    the Internal and Pedigree bonuses.


cEcENOTES cEcA


    Match-It is a macro defined in cGmatchit.emfcA.

    Match-It may only be played with a mouse, there is no keyboard support,
    with the exception of the re-start keys.

    The sheet database file matchit.edf must be accessible for Match-It to
    work.


cEcESEE ALSO cEcA


    lsMicroEmacs - GameslmGamesle, lslmMahjongg(3)le, lslmMetris(3)le.
! 3 Metris
cEcENAME cEcA


    Metris - MicroEmacs 2009 version of the falling blocks game
$a


cEcESYNOPSIS cEcA


    cDMetriscA


cEcEDESCRIPTION cEcA


    Traditional falling blocks game, make solid horizontal lines out of the
    falling blocks. The blocks can be rotated and moved left or right by the
    user as they fall. Once a horizontal line is completely solid it will
    disappear and everything above it will drop down. A bonus is given if 3
    solid rows are made at the same time, i.e. using one block.

    Every line you make the game speeds up until it gets too fast!! The game
    ends when there is no more room to put a block.

    The keys used to control Metris are:

    cDleftcA or cDjcA
        Move the block left one character.

    cDrightcA or cDlcA
        Move the block right one character.

    cDdowncA or cDkcA
        Rotate the block counter-clockwise 90 degrees.

    cDspacecA
        Drop the current block.

    cDpcA
        Pause the current game.

    cDqcA
        Quit the current game.

    cDC-lcA
        Redraw the display.

    cDreturncA
        Start a new game.

    cDesc hcA
        View this help page.


cEcENOTES cEcA


    cDMetriscA is a macro defined in cGmetris.emfcA.


cEcESEE ALSO cEcA


    lsMicroEmacs - GameslmGamesle, lslmMatch-It(3)le, lslmPatience(3)le.
! 3 Patience
cEcENAME cEcA


    Patience - MicroEmacs 2009 version of Patience (or Solitaire)
$a


cEcESYNOPSIS cEcA


    cDPatiencecA


cEcEDESCRIPTION cEcA


    Patience (or Solitaire) is a solitaire game using a standard set of
    playing cards. The object of the game is to use all of the cards in the
    deck to build up four suit stacks from Ace to King.

    The board is laid out with the dealer pile at the top right hand corner,
    to the left are four suit stacks onto which cards of the same suit are
    placed, in ascending order from the Ace. Below these two areas of the
    board are seven row stacks, organized in a triangular shape with zero to
    six downward facing cards.

    Cards may be moved around the playing area by stacking alternative red and
    black cards in descending order on the row stacks. When a row stack has no
    upturned cards on the stack then the top card may be turned over and may
    be played. If a stack becomes empty then only a King may be moved into the
    vacant position. Cards may be removed from the dealer, they are
    over-turned in sets of three cards, the underlying 2 cards are visible,
    but are not accessible, only the top card may be removed and played from
    the dealer.

    Cards are moved around the board using the mouse. Cards may be moved from
    the dealer or between the row stacks by placing the mouse over the card to
    be moved and pressing the left mouse button. Move the cursor to the new
    card position and release the left mouse button. If the move is legal then
    the card(s) are moved to the new stack. Multiple cards may be moved from
    the row stacks, the appropriate card(s) to be moved is automatically
    determined.

    Cards may be moved onto the suit stacks by a single left mouse press and
    release on the same card, the card is moved to the appropriate suit stack.
    The same technique is used to turn cards over in the suit stacks, and to
    deal the next set of cards by the dealer. To deal, then click on the
    down-turned card stack, if there are no further cards at the dealer then
    click on the empty position and the dealer will turn over the dealer stack
    and deal from the top again.

    Note that once a card is played onto the suit stacks then it cannot be
    removed.

    To the right of the board are a number of control buttons. To select an
    option, click the left mouse button on it, the buttons are labeled:

    cDDEALcA
        Start a new game by dealing new cards.

    cDQUITcA
        Exit the game

    cDHELPcA
        This help page

    Note that the screen may be updated at any time using "cCC-lcA".


cEcENOTES cEcA


    cDPatiencecA is a macro defined in cGpatience.emfcA.

    The game is best played with a mouse, it is possible to play with the
    keyboard, as follows:-

        "cCesc hcA" for help

        To move a card between stacks enter the source and destination column
        number ("cC1cA","cC2cA",.."cC7cA"). To move from the dealer pile then the source
        is the "cCspacecA" key.

        "cCtabcA" deals the next cards.

        To overturn a card on the row stacks then enter the card column twice
        i.e. source and destination are the same.

        To move a card from the row to the suit stacks then either enter the
        card column twice, or enter the destination as "cChcA","cCdcA","cCccA","cCscA" (i.e.
        "cC2 2cA" or "cC2 scA" to move the card in column 2 to the spades stack).

        "cCC-c C-ccA" to deal the cards again.

        "cCC-lcA" redraw the screen.

        "cCqcA" to quit the game.


cEcESEE ALSO cEcA


    lsMicroEmacs - GameslmGamesle, lslmTriangle(3)le, lslmMahjongg(3)le.
! 3 Triangle
cEcENAME cEcA


    Triangle - MicroEmacs 2009 version of Triangle patience game
$a


cEcESYNOPSIS cEcA


    cDTrianglecA


cEcEDESCRIPTION cEcA


    cDTrianglecA is a solitaire game using a standard set of playing cards. The
    object of the game is to use all of the cards in the deck to build up four
    suit stacks from Ace to King.

    The board is laid out so that every card is used to create a triangle
    shape. In the first column there is one up-turned card, in the second
    column there is one down-turned card and 2 up-turned, third has 2 down 3
    up etc. The only break form this pattern is in the last 3 columns where
    there is an extra up-turned card so that all the deck is used.

    Cards may be moved around the playing area by stacking the same suit cards
    in descending order on the row stacks. When a row stack has no up-turned
    cards on the stack then the top card may be turned over and may be played.
    If a stack becomes empty then only a King may be moved into the vacant
    position.

    If the last card in a stack is an Ace then it can be moved to its suit
    stack, then the 2 of that suit etc. until finally the King is removed.

    Cards are moved around the board using the mouse. Cards may be moved from
    one row stack to another row stack by placing the mouse over the 'from'
    stack and pressing the left mouse button. Move the cursor to the 'to'
    stack and release the left mouse button. If the move is legal then the
    card(s) are moved to the new stack. Multiple cards may be moved from the
    row stacks, the appropriate card(s) to be moved is automatically
    determined.

    Cards may be moved onto the suit stacks by a single left mouse press and
    release on the same card, the card is moved to the appropriate suit stack.
    The same technique is used to turn cards over in the suit stacks.

    Note that once a card is played onto the suit stacks then it cannot be
    removed.

    To the right of the board are a number of control buttons. To select an
    option, click the left mouse button on it, the buttons are labeled:

    cDDEALcA
        Start a new game by dealing new cards.

    cDQUITcA
        Exit the game

    cDHELPcA
        This help page

    Note that the screen may be updated at any time using "cCC-lcA".


cEcENOTES cEcA


    cDTrianglecA is a macro defined in cGtriangle.emfcA.

    The game is best played with a mouse, it is possible to play with the
    keyboard, as follows:-

        "cCesc hcA" for help

        To move a card between stacks enter the source and destination column
        number ("cC1cA","cC2cA",.."cC7cA").

        To overturn a card on the row stacks then enter the card column twice
        i.e. source and destination are the same.

        To move a card from the row to the suit stacks then either enter the
        card column twice, or enter the destination as "cChcA","cCdcA","cCccA","cCscA" (i.e.
        "cC2 2cA" or "cC2 scA" to move the card in column 2 to the spades stack).

        "cCC-c C-ccA" to deal the cards again.

        "cCC-lcA" redraw the screen.

        "cCqcA" to quit the game.


cEcESEE ALSO cEcA


    lsMicroEmacs - GameslmGamesle, lslmPatience(3)le, lslmMahjongg(3)le.
! 3 c-hash-eval
! 3 c-hash-del
! 3 c-hash-set-define
! 3 c-hash-unset-define
cEcENAME cEcA


|c-hash-eval
    c-hash-eval - Evaluate C/C++ #defines
|c-hash-del
    c-hash-del - Remove C/C++ #define evaluation
|c-hash-set-define
    c-hash-set-define - Set a C/C++ #define
|c-hash-unset-define
    c-hash-unset-define - Unset a C/C++ #define
$a


cEcESYNOPSIS cEcA


    cCncA cDc-hash-evalcA
    cDc-hash-delcA
    cDc-hash-set-definecA "cCvariablecA" "cCvaluecA"
    cDc-hash-unset-definecA "cCvariablecA"


cEcEDESCRIPTION cEcA


    cDc-hash-evalcA evaluates C/C++ '#' lines, hiding sections of code which have
    been 'hashed' out. cDc-hash-evalcA evaluates the following '#' lines:-

        #define <variable> ....
        #ifdef <variable>
        #if ...
        #else
        #endif

    For cG#definecAs cDc-hash-evalcA creates a user variable "cG%cd<variable>cA", setting
    it to the value found. For cG#ifdefcA a simple check for the existence of
    variable "cG%cd<variable>cA" is made. If defined then code between the cG#ifdefcA
    and either its matching cG#elsecA or cG#endifcA is displayed and code between the
    cG#elsecA and cG#endifcA is hidden. If it is not defined then the reverse happens.

    The state of cG#ifcA's are evaluated using lslmcalc(3)le, the following code is then
    displayed as for cG#ifdefcA.

    Code is hidden by setting the lslm$line-scheme(5)le to a color similar to the
    back-ground. If an argument is given to the command the code is also
    narrowed out using lslmnarrow-buffer(2)le.

    cDc-hash-delcA undoes the effect of cDc-hash-evalcA by restores hidden code.

    cDc-hash-set-definecA and cDc-hash-unset-definecA can be used to manually set and
    unset cG#definecA variables.


cEcENOTES cEcA


    cDc-hash-evalcA, cDc-hash-delcA, cDc-hash-set-definecA and cDc-hash-unset-definecA are
    macros defined in cGcmacros.emfcA.

    Executing cDc-hash-evalcA in a project header file (h file) which contains all
    used cG#definecA definitions will set up all cG#definecA variables ready for the
    main C files.


cEcESEE ALSO cEcA


    lslmcalc(3)le, lslm$line-scheme(5)le, lslmnarrow-buffer(2)le.
! 3 etfinsrt
! 5 %company-name
cEcENAME cEcA


    etfinsrt - Insert template file into current buffer
$a


cEcESYNOPSIS cEcA


    cDetfinsrtcA "cCtemplatecA"


cEcEDESCRIPTION cEcA


    cDetfinsrtcA is generally called by file hooks when the new buffer has been
    created as opposed to loaded from a file (see lslm$buffer-fhook(5)le).

    cDetfinsrtcA uses lslm&find(4)le to locate and insert the required "cCtemplatecA.etf"
    file. If successful, cDetfinsrtcA then replaces the following strings in the
    template:

    cG$ASCII_TIME$cA
        To the current time. Inserts the output of lslmascii-time(3)le. The default
        format of the time string may be changed with lslm.ascii-time.format(5)le.

    cG$BUFFER_NAME$cA
        To the buffer name. The name is capitalized, '.'s are replaced with
        '_' and any trailing "cC<##>cA" digits (used to make the buffer name
        unique) are removed.

    cG$COMPANY_NAME$cA
        To the value of cD%company-namecA, or if not defined to the value used for
        cG$USER_NAME$cA. cD%company-namecA is usually set up in the company setup file
        defined in User setup.

    cG$USER_NAME$cA
        To the value of the registry entry "cG/history/user-namecA", or if not
        defined to the value "cG<unknown>cA". The user name is usually set up in
        the User setup dialog.

    cG$YEAR$cA
        To the current year (4 digit number).

    cG$CURSOR$cA
        To leave the cursor at this point, only one of these tokens should be
        used in the template and the token is removed.


cEcEEXAMPLE cEcA


    The following is taken from hkmake.emf and inserts the "cCmakefile.etfcA"
    template if the buffer has been created.
sB
        define-macro fhook-make
            ; if arg is 0 this is a new file so add template
            !if &not @#
                etfinsrt "makefile"
            !endif
            set-variable $buffer-hilight .hilight.make
            -1 buffer-mode "tab"  ; Normal tabs please !!!
            1 buffer-mode "indent"
            1 buffer-mode "time"
        !emacro

sA

cEcENOTES cEcA


    cDetfinsrtcA is a macro defined in cGetfinsrt.emfcA.

    lslmmagic(2m)le mode is always used to perform the the search/replace so the
    replace strings should be appropriate for cDmagiccA.


cEcESEE ALSO cEcA


    lslm.ascii-time.format(5)le, lslm$buffer-fhook(5)le, lslm&find(4)le, lslmascii-time(3)le.
! 3 ascii-time
! 5 .ascii-time.format
cEcENAME cEcA


    ascii-time - Return the current time as a string
$a


cEcESYNOPSIS cEcA


    cDascii-timecA


cEcEDESCRIPTION cEcA


    cDascii-timecA returns the current time as a formatted string in cG#p9cA which is
    equivalent to cG#l9cA for the calling macro. The format of the resultant
    string is determined by the variable cD.ascii-time.formatcA which is defined
    using the following escape characters:

        cG%% cA - cG%cA char
        cG%Y cA - 4 digit year
        cG%y cA - 2 digit year
        cG%B cA - Full month word
        cG%b cA - 3 letter month
        cG%m cA - 2 digit month
        cG%#mcA - 1 digit month
        cG%d cA - 2 digit day
        cG%#dcA - 1 digit day
        cG%A cA - Fill Week day word
        cG%a cA - 3 letter week day
        cG%H cA - 2 digit 24 hour
        cG%M cA - 2 digit minute
        cG%S cA - 2 digit second

    The default value of cD.ascii-time.formatcA when not defined is:

        "cG%a %b %d %H:%M:%S %YcA"

    To change the default date layout then cD.ascii-time.formatcA should be
    defined in cCusercAcD.emfcA. i.e.
sB
        set-variable .ascii-time.format "%H:%M:%S %Y-%m-%d"

sA

cEcEEXAMPLE cEcA


    The following is taken from etfinsrt.emf, it uses cDascii-timecA in replacing
    "cG$ASCII_TIME$cA" with the current.
sB
        0 define-macro etfinsrt
            .
            .
            ; Change the create date $ASCII_TIME$.
            beginning-of-buffer
            ; Get ASCII time in #l9
            ascii-time
            !force replace-string "\\$ASCII_TIME\\$" #l9
            .
            .
        !emacro

sA

cEcENOTES cEcA


    cDascii-timecA is a macro defined in cGutils.emfcA.


cEcESEE ALSO cEcA


    lslm$buffer-fhook(5)le, lslmetfinsrt(3)le, lslm&find(4)le.
! 3 replace-all-pairs
cEcENAME cEcA


    replace-all-pairs - Replace string pairs in a list of files
$a


cEcESYNOPSIS cEcA


    cCncA cDreplace-all-pairscA "cCfilescA"


cEcEDESCRIPTION cEcA


    cDreplace-all-pairscA uses the current buffer to extract "cCfromcA" and "cCtocA" pairs
    and then replaces all occurrences of "cCfromcA" to "cCtocA" in the given list of
    files without prompting the user. An optional third argument "cCgrepcA" can be
    given which will be used as the grep string, if not given the "cCfromcA"
    string is used. The format of the current buffer must be:

        /from1/to1/
        Xfrom2Xto2X
        ?from3?to3?
        /from4/to4/grep4/
          .
          .
        /fromN/toN/


    For each pair the command finds all occurrences of "cCfromcA" (or "cCgrepcA" if
    specified) by calling the command lslmgrep(3)le to search for string "cCfromcA" in
    files "cCfilescA". Thus all relevant edited files must be saved or cDgrepcA may
    return the wrong line numbers. This is achieved by a call to
    lslmsave-some-buffers(2)le between each replace pair, it is called with an
    argument of 0 to ensure that any changed buffers are automatically saved.

    Each occurrence of "cCfromcA" is jumped to using lslmget-next-line(2)le and the
    string is replaced by the call:
sB
        -1 replace-string "from" "to"

sA
    This replaces all occurrences of "cCfromcA" to "cCtocA" on the current line only,
    hence the line numbers must be correct. This also means that the "cCfromcA"
    search string must be correctly formatted for both grep and
    replace-string.

    The given argument cCncA is a bit based flag which changes the default
    behavior described above. The bits have the following effect:-

    cD0x01cA
        Prompt before saving any changed buffers FIRST time ONLY, enabled by
        default. If set then the user is also prompted to continue before any
        changes are made. If this bit is not set then the command executes
        without any user input.


cEcENOTES cEcA


    cDreplace-all-pairscA is a macro defined in cGsearch.emfcA.

    The cDgrepcA command must be working before this command can function
    properly.

    It is not recommended to use a "from" or "to" string which uses more that
    one line as the results may be unpredictable.

    As the change is likely to be several pair strings with each changed
    buffer being saved between pairs lslmundo(2)le cannot be used to undo the
    changes. Neither can the backups be relied on as a buffer may be saved
    more than once in this process, therefore it is strongly recommend that a
    backup of the files is made before commencing with this command.


cEcESEE ALSO cEcA


    lslmreplace-all-string(3)le, lslmreplace-string(2)le, lslmsave-some-buffers(2)le, lslmgrep(3)le,
    lslmget-next-line(2)le, lslmundo(2)le, lslmquery-replace-all-string(3)le, lslmsearch-forward(2)le.
    lsRegularExpressions(2)lmRegular Expressionsle
! 3 delete-indentation
cEcENAME cEcA


    delete-indentation - Join 2 lines deleting white spaces
$a


cEcESYNOPSIS cEcA


    cCncA cDdelete-indentationcA


cEcEDESCRIPTION cEcA


    cDdelete-indentationcA deletes all white characters between the beginning of
    the current line and the end of the previous line, including the
    line-feed. If the current line is not empty then a space is inserted to
    divide the two lines now joined.

    If a positive argument cCncA is given then the process is repeated cCncA times.
    Note that the deleted characters are not added to a kill buffer.


cEcENOTES cEcA


    cDdelete-indentationcA is a macro defined in cGformat.emfcA.


cEcESEE ALSO cEcA


    lslmdelete-blank-lines(2)le, lslmclean(3)le, lslmkill-line(2)le.
! 3 edit-dictionary
! 3 restore-dictionary
cEcENAME cEcA


|edit-dictionary
    edit-dictionary - Insert a dictionary in a buffer
|restore-dictionary
    restore-dictionary - Save dictionary user changes
$a


cEcESYNOPSIS cEcA


    cDedit-dictionarycA "cCdictionarycA"
    cDrestore-dictionarycA


cEcEDESCRIPTION cEcA


    cDedit-dictionarycA dumps the contents of "cCdictionarycA" into the temporary
    buffer "*cCdictionarycA*", if this buffer already exists then cDedit-dictionarycA
    simply swaps to this buffer. This enables the user to correct and prune
    the words in any dictionary. The given dictionary must have already been
    added as a main dictionary using lslmadd-dictionary(2)le.

    The format of the created buffer is one word on each line, each word takes
    one of the following 3 forms:

        cGxxxxcA - Good word cGxxxxcA with no spell rules allowed
        cGxxxx/abccA - Good word cGxxxxcA with spell rules cGabccA allowed
        cGxxxx>yyyycA - Erroneous word with an auto-replace to cGyyyycA

    Executing cDrestore-dictionarycA in a buffer created by cDedit-dictionarycA will
    first call lslmdelete-dictionary(2)le to remove the original dictionary from
    memory. It then uses lslmadd-dictionary(2)le to create a new dictionary with the
    same name and then uses lslmspell-add-word(3)le to add all the words in the
    current buffer into the new dictionary.

    cDrestore-dictionarycA does not save the new dictionary.


cEcENOTES cEcA


    cDedit-dictionarycA and cDrestore-dictionarycA are macros defined in file
    cGspellutl.emfcA. They are not defined by default so cCspellutl.emfcA must be
    executed first using lslmexecute-file(2)le.


cEcESEE ALSO cEcA


    lslmspell-add-word(3)le, lslmadd-dictionary(2)le, lslmsave-dictionary(2)le,
    lslmdelete-dictionary(2)le.
! 3 spell-add-word
cEcENAME cEcA


    spell-add-word - Add a word to the main dictionary


cEcESYNOPSIS cEcA


    cCncA cDspell-add-wordcA ["cCwordcA"]


cEcEDESCRIPTION cEcA


    cDspell-add-wordcA adds words to the last dictionary added using the command
    lslmadd-dictionary(2)le. If no argument is supplied the user is prompted for the
    word and rule flags, only a 'Good' word can be added (see below). If an
    argument cCncA is given then the next cCncA words from the current buffer are
    added. The words must take one of the following three forms:

        cGxxxxcA - Good word cGxxxxcA with no spell rules allowed
        cGxxxx/abccA - Good word cGxxxxcA with spell rules cGabccA allowed
        cGxxxx>yyyycA - Erroneous word with an auto-replace to cGyyyycA


cEcENOTES cEcA


    cDspell-add-wordcA is a macro defined in file cGspellutl.emfcA. It is not defined
    by default so cGspellutl.emfcA must be executed first using lslmexecute-file(2)le.


cEcESEE ALSO cEcA


    lslmadd-dictionary(2)le, lslmedit-dictionary(3)le, lslmsave-dictionary(2)le,
    lslmdelete-dictionary(2)le.
! 3 start-up
! 3 shut-down
cEcENAME cEcA


|start-up
    start-up - Editor startup callback command
|shut-down
    shut-down - Editor exit callback command
$a


cEcESYNOPSIS cEcA


    cDstart-upcA
    cDshut-downcA


cEcEDESCRIPTION cEcA


    By default cDstart-upcA is not defined, if the command is defined (via a user
    macro) then it is executed immediately after MicroEmacs 2009 has completed
    its initialization.

    This command may initially seem redundant as the user may execute any
    command at start-up by editing the "cGme.emfcA" file or using the 'cD@cA'
    command-line argument. At the point of "cGme.emfcA" file execution none of the
    files specified on the command-line will be loaded, thus any actions
    required on the given command-line files will not work (the only buffer
    present will be the "cD*scratch*cA" buffer).

    The cDstart-upcA command is executed AFTER the execution of "cGme.emfcA" and
    initialization of buffers, but before MicroEmacs 2009 waits for user
    input.

    The cDshut-downcA command is also not defined by default, but if it is defined
    during the running of MicroEmacs the command will be called when
    MicroEmacs exits. The command is not called if MicroEmacs has to perform
    an emergency exit (due to the system being shut down or process being
    killed etc).


cEcESEE ALSO cEcA


    lslmme(1)le.
! 3 restyle-buffer
! 3 restyle-region
cEcENAME cEcA


|restyle-buffer
    restyle-buffer - Automatically reformat a buffer's indentation.
|restyle-region
    restyle-region - Automatically reformat a regions indentation.
$a


cEcESYNOPSIS cEcA


    cDrestyle-buffercA (cDesc C-\cA)
    cDrestyle-regioncA


cEcEDESCRIPTION cEcA


    cDrestyle-buffercA automatically re-formats the indentation of a buffer. The
    indentation only operates if the indentation method is defined with
    lslm$buffer-indent(5)le, otherwise the command has no effect.

    cDrestyle-regioncA modifies the indentation between cCpointcA and cCmarkcA.


cEcENOTES cEcA


    cDrestyle-buffercA and cDrestyle-regioncA are macros defined in cGformat.emfcA.


cEcESEE ALSO cEcA


    lslmindent(2)le, lslm$buffer-indent(5)le.
! 3 ifill-paragraph
cEcENAME cEcA


    ifill-paragraph - Format a paragraph
$a


cEcESYNOPSIS cEcA


    cCncA cDifill-paragraphcA (cDesc qcA)


cEcEDESCRIPTION cEcA


    cDifill-paragraphcA, like cDfill-paragraphcA, fills the current paragraph from the
    left margin to the current fill column. In addition ifill-paragraph also
    recognizes joined bullet lists and fills each bullet paragraph separately.

    See lslmfill-paragraph(2)le for more information on the process of filling
    paragraphs.


cEcEEXAMPLE cEcA


    Following are 2 copies of the same paragraph, the first has been filled
    using cDifill-paragraphcA:

        This  is the  main  paragraph  which  can be as long as  required,
        following is a list of bullets, some with a sub-bullet  list. Here
        is the list:
            a) The bullet paragraph can also be as long as required and it
               also can have a bullet  list  following  (sub-bullet  list)
               which will also be filled correctly. Here is the sub-bullet
               list:
               1. First  sub-bullet - again no length  restrictions,  this
                  will be filled correctly.
               2. second sub-bullet - no problems.
               3. Third sub-bullet - again no length restrictions, this is
                  getting boring.
            b) This is the second  major bullet and this can just carry on
               for ever, but all things must come to an


    The following version has been filled using the normal cDfill-paragraphcA:

        This  is the  main  paragraph  which  can be as long as  required,
        following is a list of bullets, some with a sub-bullet  list. Here
        is the  list:  a) The  bullet  paragraph  can  also  be as long as
        required and it also can have a bullet list following  (sub-bullet
        list) which will also be filled  correctly. Here is the sub-bullet
        list: 1. First  sub-bullet  - again no length  restrictions,  this
        will be filled  correctly. 2. second  sub-bullet - no problems. 3.
        Third sub-bullet - again no length  restrictions,  this is getting
        boring. b) This is the second major bullet and this can just carry
        on for ever, but all things must come to an


cEcENOTES cEcA


    cDifill-paragraphcA is a macro defined in cGformat.emfcA.


cEcESEE ALSO cEcA


    lslmfill-paragraph(2)le, lslmparagraph-to-line(3)le.
! 3 file-browser
! 3 file-browser-close
! 3 file-browser-swap-buffers
cEcENAME cEcA


    file-browser - Browse the file system file-browser-close - Close the
    file-browser file-browser-swap-buffers - Swap between file-browser windows
$a


cEcESYNOPSIS cEcA


    cCncA cDfile-browsercA (cDf10cA)
    cDfile-browser-closecA
    cDfile-browser-swap-bufferscA


cEcEDESCRIPTION cEcA


    cDfile-browsercA can be used to browse around the file system. When first
    executed cDfile-browsercA creates 2 buffers, "cG*directory*cA" displaying the
    directory structure and "cG*files*cA" listing the files in the current
    directory with information on each file. cDfile-browsercA displays these
    buffers side by side, splitting the current window horizontally if
    required. cDfile-browsercA uses a single window only when invoked with a
    numerical argument cCncA of zero (0).

    Once open the user can browse through the system using the following keys
    in the cG*directory*cA buffer, use cDesc-hcA for help within the buffer:

    cGspacecA
        Selects the directory on the current line and up-dates the cG*files*cA
        buffer with the information on this directory. This can also be done
        by clicking the left mouse button on the directory name.

    cGreturncA
        Selects the directory on the current line, if open (sub-directories
        displayed) then closes it or if closed it is opened. The cG*files*cA
        buffer is up-dated with the information on the directory. This can
        also be done by clicking the left mouse button on the 'cG+cA' or 'cG-cA'
        symbol just before the directory name.

    cGC-returncA
        As with cGreturncA expect sub-directories are recursively opened or
        closed, note that this could take some time on large file systems.
        This can also be done by clicking the right mouse button on the 'cG+cA' or
        'cG-cA' symbol just before the directory name.

    cGtabcA
        Move to the cG*files*cA buffer.

    cGf10cA
        Closes file-browser.

    The following keys can be used in the cG*files*cA buffer:

    cGreturncA
        If the current line is a directory, this because the current
        directory, updating both the cG*directory*cA and cG*files*cA buffers. If the
        line is a file then it is opened using lslmfind-file(2)le. This can also be
        done by clicking the left mouse button on the file name.

        Where a cDfile-toolcA open action has been defined using
        lslmfile-tool-setup(3)le then the selected tool or utility is run to process
        the file. This may be used to launch viewers for PDF, image files etc.

    cGspacecA
        Toggles the tag state of the file on the current line, see cGxcA command.
        This can also be done by clicking the left mouse button anywhere
        before the file name, or for multiple files drag a region with the
        left mouse button.

    cGXcA or cGxcA
        Executes a lslmshell-command(2)le on all tagged files. The user is prompted
        for the command line which can contain the following special tokens:
            cG%p  cAFull file name, including path.
            cG%f  cAThe file name without the path.
        As the cDshell-commandcA is executed in the directory cG%fcA is safe to use in
        a command such as "cGdel %fcA".

    cGDcA or cGdcA or cGdeletecA
        Delete selected files or current file/directory.

    cGtabcA
        Move to the cG*directory*cA buffer.

    cGbackspacecA
        Move to the parent directory.

    cGlcA
        Refresh the listing from the file system.

    cGfcA
        Toggle the filter, enables/disables the display of back-up, object
        files etc.

    cGScA
        Initiates a search for files, at the command prompt then enter the
        leading characters to search for use cDC-scA and cDC-rcA to search forwards or
        backwards respectively. The cGscA version of this command is an
        incremental search and is easier to use.

    cGscA
        Launch an incremental search by name, at the prompt enter the search
        characters, use cDC-scA and cDC-rcA to search forwards or backwards
        respectively.

    cG1cA
        Sort list by selected state.

    cG2cA
        Sort list by attribute.

    cG3cA
        Sort list by size.

    cG4cA
        Sort list by modified time.

    cG5cA
        Sort list by name.

    cG6cA
        Sort list by extension.

    cGspacecA or cG+cA
        Select file.

    cG-cA
        Unselect file.

    cG*cA
        Invert selection.

    cGacA
        Select all.

    cGucA
        Unselect all.

    cGecA
        Edit file, opens the file in the editor for modification.

    cGicA
        Edit selected file, opens all of the selected file in the editor for
        modification.

    cGvcA
        View file, opens file for viewing only (write protected).

    cGrcA
        Rename file or directory, command line prompt for the new name.

    cGccA
        Copy file(s) and/or directory(s), command line prompt for directory to
        copy file(s).

    cGmcA
        Move file(s) and/or directory(s), command line prompt for directory to
        move file(s).

    cGncA
        Create a new directory (or folder), command line prompt for the name
        of the new directory to create.

    cGtcA
        Invokes the file tools menu to process the file, see
        lslmfile-tool-setup(3)le.

    cDfile-browser-swap-bufferscA swaps between the cG*directory*cA and cG*file*cA
    windows, making the other the current window, this is usually locally
    bound to the cGtabcA key.

    cDfile-browser-closecA hides both the cG*directory*cA and cG*file*cA windows, closing
    the file-browser, this is usually locally bound to the cGf10cA key. Note that
    this command is hidden and will not complete on the command line, but may
    be bound or input explicitly.


cEcEHISTORY cEcA


    The command line mapping was revised in the 2006 release for a more
    logical key to file operation mapping.


cEcESEE ALSO cEcA


    lslmdirectory-tree(2)le, lslmfile-tool-setup(3)le, lslmfind-file(2)le, lslmfind-zfile(3)le,
    lslmshell-command(2)le.
! 3 vm
! 3 mail-check
! 3 stop-mail-check
! 3 mail
cEcENAME cEcA


|vm
    vm - Email viewer
|mail-check
    mail-check - Check for new email
|stop-mail-check
    stop-mail-check - Disable the check for new email
|mail
    mail - Compose and send an email
$a


cEcESYNOPSIS cEcA


    cDvmcA
    cDmail-checkcA
    cDstop-mail-checkcA
    cDmailcA


cEcEDESCRIPTION cEcA


    cDvmcA is a simple email manager, it is configured to send and receive emails
    using the lslmuser-setup(3)le Mail dialog.

    cDmail-checkcA tests the size of this incoming mail box, a non-zero length
    indicates that new mail has arrived and cDmail-checkcA informs the user by
    inserting a 'cGMcA' in the mode-line (2nd character for the left) and ringing
    the system bell. cDmail-checkcA uses lslmcreate-callback(2)le to check for new mail
    every 10 minutes, this can be disabled by executing cDstop-mail-checkcA.

    When cDvmcA is executed it checks for new mail, if found it first copies the
    new mail to a file called "cGnew_mailcA" in the users mail directory. The
    incoming box is then emptied by truncating the file to zero length. The
    users main mail box is then loaded and the new mail (if any) is appended.
    The mail box is then processed after which 2 windows are created the
    bottom window listing all messages in the box and the top displaying the
    current message.

    cDvmcA is capable of:

        * Scrolling through the mail box displaying each message (cGupcA, cGpcA, cGdowncA,
          cGncA, cGreturncA, cGspacecA).
        * Check and get new mail messages (cGgcA).
        * Extract and cut embedded data files (cGxcA, cGCcA, cGccA).
        * Reply to and forward mail messages (cGRcA, cGrcA, cGzcA).
        * Delete mail messages (cGdcA, cGucA).
        * Archive messages to other mail boxes (cGAcA, cGacA).
        * Save changes to the current mail box (cGScA, cGscA).
        * Delete the current mail box (cGDcA).
        * Visit another mail box (cGvcA).
        * Send a mail message (cGmcA).
        * Hide vm windows (cGdeletecA).

    Use the vm help page (bound to "cGesc hcA") for further information.

    cDvmcA supports two types of embedded data, uuencode and mime encoding and
    uses lslmipipe-shell-command(2)le to extract the data, the commanding to use
    must be supplied by the user using the setup dialog, which can contain the
    following special tokens:

    cG%icA
        Temporary file name, if used, the embedded data is written to the this
        file first.

    cG%ocA
        User supplied output file name, if cG%icA is not used, the embedded data
        is written to this file first.

    cG%bcA
        The output base name, i.e. cG%ocA without the path.

    If no command line is supplied then the embedded data is written to the
    user supplied file name as a text file in the form found in the mail
    message.

    cDmailcA can be used to compose and send an email, it can insert embedded data
    in a similar way to cDvmcA's data extraction, the following special tokens can
    be used:

    cG%icA
        The user supplied data file to be embedded.

    cG%bcA
        The input base name, i.e. cG%icA without the path.

    cG%ocA
        Temporary file name used to output the processed data file, this file
        is inserted into the mail message using lslminsert-file(2)le.

    cDmailcA also uses cDipipe-shell-commandcA to send the mail message, the following
    special tokens can be used:

    cG%fcA
        The from user name.

    cG%scA
        The email subject.

    cG%tcA
        A comma separated list of 'To' recipients.

    cG%ccA
        A comma separated list of 'Cc' recipients.

    cG%ocA
        A file name of the mail message.

    Any field not used in the command-line is left at the head of the mail
    message.


cEcEEXAMPLE - UNIX cEcA


    The following command-line can be used on most UNIX systems to extract
    uuencoded data:

        rm -f %o ; uudecode %i ; rm -f %i


    The following command-line can be used on most UNIX systems to extract
    mime encoded data:

        rm -f /tmp/%b ; metamail -B -d -q -w -x -z %i ; mv -f /tmp/%b %o


    The following command-line can be used on most UNIX systems to uuencode a
    data file ready for it to be embedded, the original file is not changed:

        uuencode %b < %i > %o


    The following command-line can be used on most UNIX systems to send an
    email:

        /usr/lib/sendmail -oi -oem -odi -t < %o


cEcEEXAMPLE - WIN32 cEcA


    Typically the cDcygwin(1)cA utilities can be used for data insertion and
    extraction. These have the advantage of being very similar to the unix
    ones so only minor changes are required, i.e. try the following for data
    insertion and mime & uuencode extraction respectively:

        del %o ^ uudecode %i ^ del %i
        del c:\tmp\%b ^ metamail -B -d -q -w -x -z %i ^ move c:\tmp\%b %o
        uuencode %b < %i > %o


    This assumes that the shell you are using supports the 'cG^cA' multiple
    commands on a single line feature, this is supported by cD4dos(1)cA and
    cD4nt(1)cA. If your shell does not support this feature a simple batch file
    command could be used instead.

    cDpostie(1)cA is a freely available pop3/smpt e-mail support program,
    available on the net, which can be used to provide a fully working cDvmcA on
    windows systems. As it is typically used in a dial-up connect environment,
    the cDuser-setupcA 'Queue Outgoing Mail' option will be enabled while the
    'Check Mail' and 'VM Gets Mail' will be disabled. This ensures that a
    connection is only made when the cDvmcA 'cGgcA' command is used which sets all
    queued outgoing mail and gets any incoming mail.

    The following command-line can be used to get mail from your pop server
    using postie:

        postie -host:pop-mail-addr -user:user-addr -pass:password -file:inbox
                "-sep:From root Mon Jan 11 20:02:02 1999" -raw -rm


    Where the cGinboxcA is the 'Incoming Mail Box' file specified in user-setup.
    The cG-sepcA option is used to partition each mail message from the previous
    message, this string is used as it is in a unix standard form so the
    resulting mail box could be understood by unix mail systems such as
    netscape etc.

    NOTE: The cD-rmcA option is used to remove the incoming mail messages from the
    server. It is strongly recommended that the system is thoroughly tested
    without this option first.

    The following command-line can be used to send mail to your smtp server
    using postie:

        postie -host:smtp-mail-addr "-from:user@mail-addr" -use_mime:0
                "-to:%t" "-s:%s" "-cc:%c" "-file:%o"


    cDblat(1)cA is another freely available windows program which can be used to
    send mail with the following command-line:

        blat %o -f %f -s \"%s\" -t \"%t\" -c \"%c\"


cEcENOTES cEcA


    cDvmcA is a macro defined in cGvm.emfcA, cDmail-checkcA, cDstop-mail-checkcA and cDmailcA are
    macros defined in cGmail.emfcA.

    cDvmcA has only been tested in a couple of environments, the author will not
    except any responsibility for any loss of data, i.e. use at your own
    peril. You have been warned! Back-up all data files and test cDvmcA THOROUGHLY
    before using it.


cEcESEE ALSO cEcA


    lslmuser-setup(3)le, lslmipipe-shell-command(2)le, lslmcreate-callback(2)le, cDsendmail(1)cA.
! 3 collapse-current
! 3 collapse-all
cEcENAME cEcA


|collapse-current
    collapse-current - (un)Fold a region in the current buffer
|collapse-all
    collapse-all - (Un)Fold all regions in the current buffer
$a


cEcESYNOPSIS cEcA


    cDcollapse-currentcA
    cDcollapse-allcA


cEcEDESCRIPTION cEcA


    MicroEmacs 2009 provides a generic, albeit coarse, folding mechanism which
    is applied to some of the well known file modes. The folding mechanism
    allows parts of the buffer to be scrolled up and hidden, leaving a residue
    hilighting marker within the buffer indicating a folded region. A folded
    buffer typically allows a summary of the buffer contents to be viewed
    within several windows, hiding the detail of the buffer.

    The folding mechanism uses well defined cCstartcA and cCendcA markers which form
    part of the syntax of the well known file mode. i.e. in 'C' this is the
    open and closed braces that appear on the left-hand margin (cG{cA .. cG}cA). The
    intention is that the natural syntax of the text is used to determine the
    fold positions, requiring no additional text formating or special text
    tags to be inserted by the user.

    cDcollapse-currentcA opens and closes a folded region within the buffer. If
    the current cursor position lies between a cCstartcA and cCendcA marker then the
    region between the start and end is folded out and hidden from view,
    leaving a highlight marker in the buffer. If the fold already exists then,
    moving the cursor to the folded line and invoking cDcollapse-currentcA removes
    the fold marker and reveals the text.

    cDcollapse-allcA opens and closes all folded regions within the buffer, if the
    current state is unfolded then all of the cCstartcA/cCendcA markers are located
    and their regions folded. Conversely, if the buffer is currently folded
    and cDcollapse-allcA is invoked, then all folds are removed and the associated
    text revealed.


cEcECONFIGURATION cEcA


    In order to utilize the cDcollapse-current/allcA commands within a buffer, the
    cCstartcA and cCendcA markers have to be initialized for the syntactical contents
    of the buffer. This is performed within the hook function for the buffer,
    using the hook-name, the initialization is performed within
    lslmbuffer-init(3)le. Buffer specific variables are defined within the context
    of the buffer to configure that start and end fold handling. The buffer
    specific variables are defined as follows, where cCXXXcA is the file hook base
    name.

    cD.fhook-cAcCXXXcAcD-collapse-opencA
        A regular expression search string used to locate the start of the
        string. For speed the search string should include a regular
        expression start or end of line character whenever possible. i.e. in C
        the open is defined as "cG^{cA".

    cD.fhook-cAcCXXXcAcD-collapse-closecA
        A regular expression search string used to locate the end of the
        string. For speed the search string should include a regular
        expression start or end line character whenever possible. i.e. in C
        the close is defined as "cG^}cA".

    cD.fhook-cAcCXXXcAcD-collapse-mopencA
        An integer value that denotes the number of lines to move in a forward
        or (negative n) backward direction from the cCstartcA line located by the
        search string to the position in the buffer to be folded. If default
        value when cDmopencA is omitted is 0, starting the fold from the search
        string line.

    cD.fhook-cAcCXXXcAcD-collapse-mclosecA
        The relative displacement from the close fold line to the fold
        position, this is a positive or negative displacement depending on
        where the fold is to be positioned.

    cD.fhook-cAcCXXXcAcD-collapse-mnextcA
        Specifies the number of lines to advance before the next search is
        continued on the fold operation. This is only used by cDcollapse-allcA.


cEcEPRESENTATION cEcA


    The presentation of a collapsed region takes the form:

        cC<open line string>cA ... cC<close line string>cA

    Where cC<open line string>cA and cC<close line string>cA are automatically
    extracted from the originating buffer using the search string definition.
    Existing cDcollapsecA implementations used a simpler format:

        cC<open line string>cA ...

    In MicroEmacs '04 and later versions, then the cC<close line string>cA is
    always appended. Appending of the closing token is required to ensure that
    any lsindent(2)lmindentationle is maintained. This allows the indent processing to find
    both an cCopencA and cCclosecA character sequence and not introduce an unwanted
    indentation. To ensure that indentation consistency is maintained then the
    cD.fhook-XXX.collapse-closecA definition should minimally match the
    corresponding indentation close regular expression.


cEcEEXAMPLE cEcA


    The following examples show how the collapse variables are set up in each
    of the buffer modes.


cEC and C++ cA


    cDCcA and cDC++cA collapse on the open and close brace appearing in the left-hand
    margin. The collapse variables are defined in cGhkccA/cGhkcpp.emfcA as follows:-
sB
        set-variable .fhook-c.collapse-open  "^{"
        set-variable .fhook-c.collapse-close "^}"
        set-variable .fhook-c.collapse-mopen  "-1"
        set-variable .fhook-c.collapse-mclose "1"
        set-variable .fhook-c.collapse-mnext "-1"

sA
    Given a 'C' function definition:-

        static void
        myfunc (int a, int b)
        {
            /* Function body */
        }


    the folded version appears as follows:-

        static void
        myfunc (int a, int b) ... }


cEemf cA


    MicroEmacs macro files cDemfcA support folding of macro definitions, the
    collapse variables are defined in cGhkemf.emfcA as follows:-
sB
        set-variable .fhook-emf.collapse-open  "^0? ?define-macro[ \t]"
        set-variable .fhook-emf.collapse-close "^!emacro"
        set-variable .fhook-emf.collapse-mclose "1"
        set-variable .fhook-emf.collapse-mnext "-1"

sA
    Given a macro definition:-
sB
        0 define-macro mymacro
        ; This is the body of the macro
        ; ... and some more ...
        !emacro

sA
    the collapsed version of the macro is defined as:-
sB
        0 define-macro mymacro ... !emacro

sA

cEnroff cA


    cDnroffcA is configured for manual pages only and folds between cG.SHcA and cG.SScA
    sections, the hook variables are defined as follows:-
sB
        set-variable .fhook-nroff.collapse-open  "^\.S[SH]"
        set-variable .fhook-nroff.collapse-close "^\.S[SH]\|\'"
        set-variable .fhook-nroff.collapse-mnext "-1"

sA
    Given an nroff block of text defined as:-

        .SH SYNOPSIS
        .\" Some text
        .\" Some more text
        .SH DESCRIPTION


    Then the collapsed version appears as:

        .SH SYNOPSIS
        .SH DESCRIPTION


cEtcl/tk cA


    cDtcl/tkcA is configured to collapse procedures. The collapse variables are
    defined as:-
sB
        set-variable .fhook-tcl.collapse-open  "^proc "
        set-variable .fhook-tcl.collapse-close "^}"
        set-variable .fhook-tcl.collapse-mclose "1"
        set-variable .fhook-tcl.collapse-mnext "-1"

sA
    Given a tcl procedure definition:-

        proc tixControl:InitWidgetRec {w} {
            upvar #0 $w data

            tixChainMethod $w InitWidgetRec

            set data(varInited)   0
            set data(serial) 0
        }


    The collapsed version of the same section appears as:-

        proc tixControl:InitWidgetRec {w} { ... }


cEcENOTES cEcA


    cDcollapse-currentcA and cDcollapse-allcA are macros implemented in cGcollapse.emfcA.
    The collapsing is performed using the lslmnarrow-buffer(2)le command.

    cDcollapse-currentcA may also be bound to the mouse using the lslmuser-setup(3)le.
    The typical binding is cGC-mouse-drop-1cA.


cEcEHISTORY cEcA


    cDcollapsecA is the new name for cDfoldcA appearing in MicroEmacs 2004 version.
    The existing commands of cDfold-currentcA and cDfold-allcA have been replaced by
    cDcollapse-currentcA and cDcollapse-allcA respectively. cDcollapsecA now uses the
    private command variables.


cEcESEE ALSO cEcA


    lsfileHooks(2)lmFile Hooksle, lslmbuffer-init(3)le, lslmindent(2)le, lslmuser-setup(3)le, lslmnarrow-buffer(2)le.
! 3 find-bfile
! 3 find-cfile
cEcENAME cEcA


|find-bfile
    find-bfile - Load a file as binary data
|find-cfile
    find-cfile - Load a crypted file
$a


cEcESYNOPSIS cEcA


    cCncA cDfind-bfilecA "cCfile-namecA" (cDC-x 9cA)
    cCncA cDfind-cfilecA "cCfile-namecA"


cEcEDESCRIPTION cEcA


    cDfind-bfilecA and cDfind-cfilecA provide a simple interface to loading files in
    lslmbinary(2m)le and lslmcrypt(2m)le modes respectively. The numeric argument has the
    same effect as with the lslmfind-file(2)le command except the respective modes
    are always enabled. See documentation on the modes an cDfind-filecA command
    for more information.


cEcENOTES cEcA


    cDfind-bfilecA and cDfind-cfilecA are macros defined in file cGtools.emfcA.

    The command lslmfind-file(2)le is bound to key "cGC-x 9cA" with a numeric argument
    of 2, this is equivalent to executing cDfind-bfilecA with no argument.


cEcESEE ALSO cEcA


    lslmfind-file(2)le, lslmbinary(2m)le, lslmcrypt(2m)le.
! 3 man
! 3 man-clean
! 5 %man-com
cEcENAME cEcA


|man
    man - UNIX manual page viewer.
|man-clean
    man-clean - Clean UNIX manual page.
|%man-com
    %man-com - Man Command line
$a


cEcESYNOPSIS cEcA


    cDmancA
    cDman-cleancA
    cD%man-comcA


cEcEDESCRIPTION cEcA


    cDmancA provides a mechanism to display a UNIX manual page within the
    MicroEmacs window. On invoking cDmancA the user is prompted for the name of
    the manual page to display:-

        Man on ?


    The name of the manual page (and any options) are entered on the command
    line. The macro invokes the UNIX utility cDman(1)cA to generate the page and
    displays the results in a window. The man page executable may be defined
    with the variable cD%man-comcA this is defined as cGmancA by default.

    Another manual page can be selected by either moving the cursor to the
    link and pressing return or double clicking on it with the left mouse
    button. MicroEmacs will then attempt to load and display the selected
    manual page.

    cDman-cleancA removes any man-page formatting codes from the current buffer
    reducing a manual page to plain text. The formatting codes are used to
    create the bold and underline fonts. This allows the page to be treated as
    a normal buffer, i.e. string searches and other similar command will work
    as expected.


cEcENOTES cEcA


    cDmancA and cDman-cleancA are macros defined in cGhkman.emfcA.

    cDmancA is only made available within UNIX environments, the UNIX start up
    file cGunixterm.emfcA links in the macro. If the cDmancA utility is required on
    other platforms then the following definition is required in a start-up
    file.
sB
        define-macro-file hkman man

sA
    On Microsoft Windows environments, if the cDcygwincA directory is located then
    cDmancA is enabled and uses the cDcygwincA cDman(1)cA utility and manual pages.


cEcESEE ALSO cEcA


    cDman(1)cA, lslmman(9)le, lslmcygwin(3)le, lslmuser-setup(3)le, lslmspell-buffer(3)le.
! 3 draw
cEcENAME cEcA


    draw - Simple line drawing utility
$a


cEcESYNOPSIS cEcA


    cDdrawcA


cEcEDESCRIPTION cEcA


    cDdrawcA provides a simple way of drawing lines into the current buffer, this
    has a variety of uses such as drawing tables. cDdrawcA copies the current
    buffer into a temporary buffer and then allows the user to draw using
    simple commands until the user either aborts, discarding any changes, or
    exits insert the changes back into the buffer.

    The keys for cDdrawcA are defined as follows:-

    cDesc hcA
        Display a help dialog.

    cDupcA, cDdowncA, cDleftcA, cDrightcA
        The cursor keys (or any other keys bound the the same commands) will
        move the cursor, drawing in the current mode.

    cDdcA
        Change the current mode to cDdcAraw (default), cursor movement will result
        in drawing in the current style.

    cDecA
        Change the current mode to cDecArase, cursor movement will result in
        erasing to spaces.

    cDmcA
        Change the current mode to cDmcAove, no drawing is performed with cursor
        movement.

    cDucA
        Change the current mode to cDucAndo, cursor movement will result in
        undoing the character to the original or a space.

    cD-cA
        Sets the current horizontal line drawing style to use 'cG-cA's (default).

    cD=cA
        Sets the current horizontal line drawing style to use 'cG=cA's.

    cDC-gcA
        Abort - changes are lost.

    cDreturncA
        Exit, inserting any changes into the current buffer.


cEcENOTES cEcA


    cDdrawcA is a macro defined in cGdraw.emfcA.
! 3 cygwin
! 5 %cygwin-path
! 5 %cygwin-hilight
! 5 %cygwin-prompt
cEcENAME cEcA


|cygwin
    cygwin - Open a Cygwin BASH window
|%cygwin-path
    %cygwin-path - Cygwin root directory
|%cygwin-hilight
    %cygwin-hilight - Cygwin shell hilight enable flag
|%cygwin-prompt
    %cygwin-prompt - Cygwin shell prompt
$a


cEcEPLATFORM cEcA


    Windows '95/'98/NT/2K/XP - win32 ONLY


cEcESYNOPSIS cEcA


    cDcygwincA

    cD%cygwin-pathcA "cCpathcA"
    cD%cygwin-hilightcA [cG0cA|cG1cA]
    cD%cygwin-promptcA "cChilightStringcA"


cEcEDESCRIPTION cEcA


    cDcygwincA creates an interactive BASH shell window within a MicroEmacs buffer
    window, providing a UNIX command line facility within the Microsoft
    Windows environment. This is a preferable environment to the MS-DOS shell
    and is certainly far more comfortable for those familiar with UNIX.

    Within the window BASH commands may be entered and executed, the results
    are shown in the window. Within the context of the BASH shell window then
    directory naming conforms to the cDcygwincA standard conventions (as opposed
    to the Microsoft directory naming).

    On running cDcygwincA a new buffer is created called cG*cygwin*cA which contains
    the shell. Executing the command again creates a new shell window called
    cG*cygwin1*cA, and so on. If a cygwin window is killed off then the available
    window is used next time the command is run.

    Additional controls are available within the shell window to control the
    editors interaction with the window. The operating mode is shown as a
    digit on the buffer mode line (2/3/4) which is defined in the following
    sections. The operational mode is changed with the cDF3cA function key.

    cDMode 2 - Browse ModecA
        Locks the window and allows local editing to be performed. All
        commands entered into the window are interpreted by the editor. Mode 2
        is typically entered to cut and paste from the window, search for text
        strings etc. In mode 2, a cD2cA is shown on the mode line.

    cDMode 3 - Semi-immersioncA
        The normal operating mode, text typed into the window is presented to
        the shell window. Translation of MicroEmacs commands (i.e.
        beginning-of-word) are translated and passed to the shell. For
        interactive use this is the default mode. In mode 3, a cD3cA is shown on
        the mode line.

    cDMode 4 - Full ImmersioncA
        All input is passed to the shell, no MicroEmacs commands are
        interpreted and keys are passed straight to the shell window. This
        mode is used where none of the keys to be entered are to be
        interpreted by MicroEmacs. Note that you have to un-toggle mode 4
        before you can swap buffers as this effectively locks the editor into
        the window.

    cDF5cA
        Clears the buffer contents. This simply erases all of the historical
        information in the buffer. The operation of the shell is unaffected.

    To exit the shell then end the shell session using "cGexitcA" or "cGC-dcA" as
    normal and then close the buffer. A short cut "cGC-c C-kcA" is available to
    kill off the pipe. However, it is not recommended that this method is used
    as it effectively performs a hard kill of the buffer and attached process

    cD%cygwin-pathcA is a user defined variable that defines the file system
    location of the cCcygwincA directory, this is typically cGc:/cygwincA. If cCcygwincA
    is located at a different location then the variable MUST be defined
    within the user start up script in order for the cDcygwincA command to start
    the shell. With a default installation of cCcygwincA then the settings are
    typically defined as:-

    cDCurrent ReleasecA
sB
        set-variable %cygwin-path "c:/cygwin"

sA
    cD%cygwin-hilightcA is a boolean flag which controls how the cygwin command
    shell window is hilighted. This value MUST be defined within the user
    start up script prior to executing cygwin if hilighting is to be disabled;
    by default hilighting is enabled. A value of 0 disables shell hilighting
    i.e.
sB
        set-variable %cygwin-hilight 0

sA
    cD%cygwin-promptcA is an optional variable that is used in conjunction with
    cD%cygwin-hilightcA, it defines the hilighting string identifying the prompt.
    This allows the prompt to be rendered with a different color. The default
    prompt is cGbash-x.yyr$cA and may be hilighted using a definition:-
sB
        set-variable %cygwin-prompt "bash-2.01$"

sA
    The user typically overrides the prompt definition within the BASH startup
    file, a more appropriate definition of the prompt may be:-
sB
        set-variable %cygwin-prompt "^[a-z]*@[^>]*>"

sA

cEcENOTES cEcA


    The cDcygwincA command uses the lslmipipe-shell-command(2)le to manage the pipe
    between the editor and the cDbashcA shell. The window is controlled by the
    macro file cGhkcygwin.emfcA which controls the interaction with the shell.

    The macro cDcygwincA in cGhkcygwin.emfcA defines the parameter setup to connect to
    the cygwin bash shell, installed in the default location cGc:/cygwincA. If
    your installation of cygwin is in a different location then correct the
    macro to match your install location, preferably correct by creating a
    cCmycygwin.emfcA file in your user directory simply containing a re-defined
    cDcygwincA macro.

    If you have exported some of the cygwin environment variables in your
    cGautoexec.batcA then you will have to figure out for yourself what variables
    macro cCcygwincA needs to export - the current configuration is for a vanilla
    install.

    The cDbashcA shell is executed with options cD-icA, for interactive shell and cD-mcA
    to enable job control.

    As of the 2004 release then the cDCygwincA/cDCygnuscA support has been revised in
    light of the changes in cDcygwincA

        * Renamed the command from cDcygnuscA to cDcygwincA.
        * Following a change in the cDbash(1)cA command line operation, which now
          no longer echos user input, then the user input is processed by
          MicroEmacs. This does cause some problems with completion as the
          Cygwin environment has a different name space. The completion still
          requires some more work, but sufficient for smaller tasks.


cEcETESTED CONFIGURATIONS cEcA


    This configuration has only been tested on a Windows 2000 installation,
    whether this works on Windows 95/98/NT is unknown while XP is very likely
    to work.

    We have only been running "make" operations in the shell and do not know
    how the likes of "more", "man" or anything other terminal interaction
    works.

    cDTested ConfigurationscA
        Windows 2K (Pentium-4) and Windows 2K (SunPCi-III)

        cygwin latest version as of February 2004.


cEcEBUGS cEcA


    cDBreak KeycA
        A break in a bash shell is cGC-ccA, the macros define the key cGC-c C-ccA to
        perform the break. There does not appear to be a way to prevent this
        from happening as trapping the interrupt does not appear to be
        supported in Cygwin Bash i.e. "cGtrapcA cG''cA cGINTcA".

    cDCompletioncA
        Completion processing needs to be improved. The directory location is
        retrieved from cDbash(1)cA on each command line prompt, this is used for
        file completion. There is no command completion. Room for some
        improvement here.


cEcESEE ALSO cEcA


    lslmipipe-shell-command(2)le, lslmishell(3)le.
    Cygwin home site cDwww.cygwin.comcA
! 3 ishell
! 5 $ME_ISHELL
cEcENAME cEcA


|ishell
    ishell - Open a interactive shell window
|$ME_ISHELL
    $ME_ISHELL - Windows ishell command comspec
$a


cEcEPLATFORM cEcA


    Windows '95/'98/NT/2K/XP - win32
    Unix - All variants.


cEcESYNOPSIS cEcA


    cDishellcA

    cC[Windows Only]cA
    cD$ME_ISHELLcA cC= <comspec>cA


cEcEDESCRIPTION cEcA


    cDishellcA creates an interactive shell window within the a MicroEmacs buffer
    window, providing access to the native operating systems command shell.
    Within the window commands may be entered and executed, the results are
    shown in the window.

    On running cDishellcA a new buffer is created called cG*shell*cA which contains
    the shell. Executing the command again creates a new shell window called
    cG*shell1*cA, and so on. If a cG*shell*cA window is killed off then the available
    window is used next time the command is run.

    Additional controls are available within the shell window to control the
    editors interaction with the window. The operating mode is shown as a
    digit on the buffer mode line (2/3/4) which is defined in the following
    sections. The operational mode is changed with the cDF3cA function key.

    cDMode 2 - Browse ModecA
        Locks the window and allows local editing to be performed. All
        commands entered into the window are interpreted by the editor. Mode 2
        is typically entered to cut and paste from the window, search for text
        strings etc. In mode 2, a cD2cA is shown on the mode line.

    cDMode 3 - Semi-immersioncA
        The normal operating mode, text typed into the window is presented to
        the shell window. Translation of MicroEmacs commands (i.e.
        beginning-of-word) are translated and passed to the shell. For
        interactive use this is the default mode. In mode 3, a cD3cA is shown on
        the mode line.

    cDMode 4 - Full ImmersioncA
        All input is passed to the shell, no MicroEmacs commands are
        interpreted and keys are passed straight to the shell window. This
        mode is used where none of the keys to be entered are to be
        interpreted by MicroEmacs. Note that you have to un-toggle mode 4
        before you can swap buffers as this effectively locks the editor into
        the window.

    To exit the shell then end the shell session using the normal exit command
    i.e. "cGexitcA" or "cGC-dcA" as normal and then close the buffer. A short cut "cGC-c
    C-kcA" is available to kill off the pipe. However, it is not recommended
    that this method is used as it effectively performs a hard kill of the
    buffer and attached process.


cEcEUNIX cEcA


    The UNIX environment uses the native cDptycA support of the operating system.
    The shell that is opened is determined by the conventional cG$SHELLcA
    environment variable.

    The shell window assumes that the user is running some sort of Emacs
    emulation on the command line (i.e. cGVISUAL=emacscA for cDksh(1)cA, cDzsh(1)cA,
    cDbash(1)cA, cDtsch(1)cA) and passes Emacs controls for command line editing.

    The shell window understands re-size operations and provides a limited
    decoding of the cCtermiocA characters for a VT100 screen. From within the
    shell window it is possible to run the likes of cDtop(1)cA correctly. It is
    even possible to run another MicroEmacs terminal session !!


cEcEWINDOWS cEcA


    The Windows environment provides a very poor command shell facility, this
    is more of a fundamental problem with the operating system than anything
    else. Unfortunately NT/2K/XP are no better than Windows '95/'98, stemming
    from the fact that Microsoft Windows is actually a huge Window Manager
    (hindered by legacy issues of MS-DOS).

    For those familiar with the UNIX command shell then it is strongly
    recommended that the lslmcygwin(3)le BASH shell is used as an alternative. This
    is a far more responsive shell window and provides the familiar Emacs
    editing of the command line.

    The command shell under Microsoft Windows is slow and very unresponsive,
    this would appear to be a problem with the cCcommand.comcA as the same
    problems are not apparent with the lscygwin(3)lmcygwinle environment. However, the shell
    window is good for kicking off command line utilities (such as cCmakecA) or
    any command line processes that generates output on cCstdoutcA as all of the
    output is captured in the buffer window which can be scrolled backwards
    for post analysis. For this very reason it is more preferable to a
    standard MS-DOS box.

    It is not possible to run any utilities that use embedded screen control
    characters as these are not interpreted by the editor.


cEChanging the Shell cA


    The default shell that is executed is defined by the environment variable
    cD$COMSPECcA. Where the user is using a different command shell (i.e. 4-DOS),
    then problems may arise if this is an old 16-bit executable. The shell
    that MicroEmacs executes may be overridden by setting the environment
    variable cD$ME_ISHELLcA. This is typically set in the lslmme32.ini(8)le file i.e.

        [username]
        ME_ISHELL=c:\windows\command.com


cEBugs cA


    cDWinOldApcA
        cDWinoldapcA is created by the Microsoft environment whenever a shell is
        created. On occasions where processes have terminated badly the user
        may be prompted to kill these off; this is the normal behaviour of
        Windows. It is strongly advised that the shell is always exited
        correctly (i.e. cGexitcA) before leaving the editor. The Windows operating
        system for '95/'98 is not particularly resilient to erroneous
        processes and can bring the whole system down. NT/2K/XP do not appear
        to suffer from these problems (so much).

    cDLocked InputcA
        There are occasions after killing a process the editor appears to lock
        up. This is typically a case that the old application has not shut
        down correctly. Kill off the erroneous task (cGAlt-Ctrl-DelcA - cCEnd TaskcA)
        then bring the editor under control using a few cGC-gcA lslmabort-command(2)le
        sequences.


cEcENOTES cEcA


    The cDishellcA command uses the lslmipipe-shell-command(2)le to manage the pipe
    between the editor and the shell. The window is controlled by the macro
    file cGhkipipe.emfcA which controls the interaction with the shell.


cEcESEE ALSO cEcA


    lslmipipe-shell-command(2)le, lslmcygwin(3)le, lslmme32.ini(8)le.
! 3 diff
! 3 diff-changes
! 3 rdiff
! 5 %diff-com
cEcENAME cEcA


    diff - Difference files or directories
    diff-changes - Find the differences from a previous edit session
    rdiff - Recursively compare files or directories
    %diff-com - Diff command line
$a


cEcESYNOPSIS cEcA


|diff
    cDdiffcA "cCold-versioncA" "cCnew-versioncA"
|diff-changes
    cDdiff-changescA
|rdiff
    cDrdiffcA "cCold-versioncA" "cCnew-versioncA"
|%diff-com
    cG%diff-comcA "cCstringcA"; Default is "cGdiffcA"


cEcEDESCRIPTION cEcA


    cDdiffcA executes the cDdiff(1)cA command with the command line set by the
    lslm%diff-com(5)le variable and the user supplied cCold-versioncA and cCnew-versioncA.
    The output of the command is piped into the cD*diff*cA buffer and is hilighted
    to show the changes (GNU diff only).

    Your version of cDdiff(1)cA will determine whether it is possible to
    difference directories.

    cDdiff-changescA is a simple macro that differences the current buffer and the
    last backup of the associated file. It is a quick way to determine what
    has been modified recently. This macro only works if a backup file exists.

    cDrdiffcA operates in the same way as cDdiffcA except it launches the cDdiff(1)cA
    command with an extra cC-rcA option which enables recursive compare (i.e.
    compares the contents of sub-directories as well). Your version of cDdiffcA
    must support this option for cDrdiffcA to operate correctly.

    cD%diff-comcA is the command line that is used to execute a cDdiff(1)cA system
    command.

    For GNU diff then the following command line setting is recommended:-

        diff --context --minimal --ignore-space-change \
            --report-identical-files --recursive


    which should be defined in your personal user configuration. This is the
    default for Linux.


cEcENOTES cEcA


    cDdiffcA, cDdiff-changescA and cDrdiffcA are macros defined in cGtools.emfcA.

    cDdiff(1)cA must be executable on the system before diff or diff-changes can
    function.

    cDdiff(1)cA is a standard utility on UNIX systems. For Windows 95/NT a version
    of GNU cDdiffcA may be found at:

        cC<ftp.winsite.com/ftp/pub/pc/winnt/misc/gnudiff.zip>cA

    For MS-DOS users, a DJGPP port of cDdiffcA is also available on the net. A
    commercial version of cDdiffcA is also available from MKS.


cEcESEE ALSO cEcA


    lslmcompare-windows(2)le, lslmcompile(3)le, lslmgdiff(3)le, lslmxgrep(3)le, lslm%xgrep-com(5)le,
    lslmxdiff(3)le, lslm%xdiff-com(5)le.
! 3 copy-registry
cEcENAME cEcA


    copy-registry - Recursive copy of registry subtree


cEcESYNOPSIS cEcA


    cDcopy-registrycA "cCfromcA" "cCtocA"


cEcEDESCRIPTION cEcA


    cDcopy-registrycA is a macro language construct only that performs a recursive
    copy of a registry subtree, copying all child nodes of cCfromcA and recreating
    the subtree at cCtocA, where cCfromcA and cCtocA defines the paths to the registry
    tree.


cEcENOTES cEcA


    The cDcopy-registrycA command is not publically available from the command
    line, but may be used within macros to perform the copy.

    This command is implemented as a recursive macro in cGutils.emfcA.


cEcESEE ALSO cEcA


    lslmdelete-registry(2)le, lslmfind-registry(2)le, lslmlist-registry(2)le, lslmmark-registry(2)le,
    lslmread-registry(2)le, lslmsave-session(3)le, lslmset-registry(2)le, lslm&reg(4)le, lslmerf(8)le.
! 3 osd-dialog
! 3 osd-xdialog
! 3 osd-entry
cEcENAME cEcA


|osd-dialog
    osd-dialog - OSD dialog box
|osd-xdialog
    osd-xdialog - OSD Extended dialog box
|osd-entry
    osd-entry - OSD entry dialog box
$a


cEcESYNOPSIS cEcA


    cCncA cDosd-dialogcA "cCtitlecA" "cCpromptcA" [ "cCx-poscA" "cCy-poscA" ] "cCbut1cA"
    cCncA cDosd-xdialogcA "cCtitlecA" "cCpromptcA" cCdefaultcA [ "cCx-poscA" "cCy-poscA" ]
        "cCbut1cA" "cCbut2cA" ...
    cCncA cDosd-entrycA "cCtitlecA" "cCpromptcA" cCvariablecA [ "cCx-poscA" "cCy-poscA" ]
        [ [ "cCentry-xsizecA" | "cCentry-xsizecAxcCentry-ysizecA" ] [ "cCtypecA" ] ]


cEcEDESCRIPTION cEcA


    cDosd-dialogcA constructs a OSD dialog prompt with a title string cCtitlecA, a
    prompt string within the dialog of cCpromptcA. A single button, with text
    rendering cCbut1cA, is placed within the dialog. The dialog remains on the
    screen until the button is selected or the user aborts.

    cDosd-xdialogcA creates an extended dialog with multiple buttons similar to
    cDosd-dialogcA, the number of buttons created (cC#cA) is determined from the
    number of cCbutcA arguments. The cCdefaultcA integer argument specifies the
    default button (1..cC#cA), a value of 0 specifies that there is no default
    button.

    The commands return the button pressed in the variable lslm$result(5)le.

    cDosd-entrycA constructs a simple OSD entry dialog which prompts the user to
    type in a value. The value of the supplied variable is used as an initial
    entry value, the variable is set to the entered value when the user
    presses the "cGOkaycA" button but remains unchanged if the user Cancel or
    aborts.

    The size of the entry defaults to 30 characters if not specified by the
    user, when a size parameter is given it can take one of two forms, either
    simply "cGwcA" specifying the width, the height defaulting to 1, or "cGwcAcDxcAcGhcA"
    (i.e. "cG40x5cA") specifying both. The last optional argument cCtypecA sets the
    type of value being entered (e.g. file name, buffer name, etc) see flag cDhcA
    on the help page for lslm@ml(4)le for a list of entry types and the numerical
    value to be supplied.

    The argument cCncA can be used to change the default behavior of the commands
    described above, cCncA is a bit based flag where:-

    cD0x01cA
        Enables command abort (default), except cDosd-entrycA which ignores the
        setting of this bit. When enabled, if the user abort by either closing
        the dialog (top right button) or using the cDabort-commandcA the dialog
        command will also abort. If bit 0x01 is not set the command will not
        abort and cD$resultcA will be set to -1.

    cD0x02cA
        When set, flags that a dialog position has also been provided, extra
        arguments cDx-poscA and cDy-poscA must also be given. By default the dialog is
        placed under the mouse.


cEcEEXAMPLE cEcA


    A simple query dialog is typically constructed using cDosd-dialogcA, as
    follows:-
sB
        !if &seq %osd-search-str ""
            osd-dialog "Replace" "Error: Search string is empty!" "  &OK  "
            !return
        !endif

sA
    The following example uses multiple buttons within a single dialog, using
    cDosd-xdialogcA, as follows:-
sB
        0 define-macro osd-close
            !if &bmod "edit"
                set-variable #l0 &spr "Buffer \"%s\" changed" $buffer-bname
                osd-xdialog "Buffer Close" #l0 1 "&Save First" \
                                                "&Loose Changes" "&Cancel"
                !if &equ $result 3
                    !abort
                !elif &equ $result 2
                    -1 buffer-mode "edit"
                !else
                    !if &seq $buffer-fname ""
                        !nma write-buffer
                    !else
                        !nma save-buffer
                    !endif
                !endif
            !endif
            delete-buffer $buffer-bname @mna
        !emacro

sA
    The next example macro can be used to change the value of a user variable
    to a user supplied file name:
sB
        set-variable %source-root "~/"

        define-macro set-source-root
            osd-entry "Source Root" "&Path : " %source-root 35 1
        !emacro

sA

cEcENOTES cEcA


    cDosd-dialogcA, cDosd-xdialogcA and cDosd-entrycA are macros defined in cGosd.emfcA, using
    lslmosd(2)le to create the dialog.


cEcESEE ALSO cEcA


    lslm$result(5)le, lslmosd(2)le.
! 3 which
! 5 .which.result
cEcENAME cEcA


|which
    which - Program finder
|.which.result
    .which.result - Program path
$a


cEcESYNOPSIS cEcA


    cDwhichcA "cCprognamecA"
    cD.which.resultcA "cCstringcA"


cEcEDESCRIPTION cEcA


    cDwhichcA searches for the given program "cCprognamecA" on the system path (set by
    the environment variable cD$PATHcA). If found the location is printed on the
    message line, otherwise an error message is printed and the command fails.

    The variable cD.which.resultcA is set to the last found program or the string
    "cGERRORcA" if the program was not found.


cEcENOTES cEcA


    cDwhichcA is a macro defined in cGtools.emfcA, it uses the lslm&which(4)le macro
    function.


cEcESEE ALSO cEcA


    lslm&which(4)le.
! 3 auto-spell
! 3 auto-spell-menu
! 3 auto-spell-buffer
! 3 auto-spell-reset
! 3 auto-spell-ignore
cEcENAME cEcA


|auto-spell
    auto-spell - Auto-spell support
|auto-spell-menu
    auto-spell-menu - Auto-spell context menu
|auto-spell-buffer
    auto-spell-buffer - Auto-spell whole buffer
|auto-spell-reset
    auto-spell-reset - Auto-spell hilight reset
|auto-spell-ignore
    auto-spell-ignore - Auto-spell ignore current word
$a


cEcESYNOPSIS cEcA


    cCncA cDauto-spellcA
    cDauto-spell-buffercA
    cDauto-spell-resetcA
    cCncA cDauto-spell-ignorecA


cEcEDESCRIPTION cEcA


    cDauto-spellcA enables and disables the auto spell checking of the current
    buffer. Auto spell detects word breaks as you type and checks the spelling
    of every completed word hilighting any erroneous words in the error color
    scheme (usually red).

    The argument cCncA determines whether auto-spell is enabled or disabled, a
    positive argument enables and a negative argument disables. If no argument
    or cC0cA is supplied the auto-spell state is toggled.

    cDauto-spell-menucA opens the auto-spell context menu which lists suggested
    corrections for the current word and other useful auto-spell commands and
    configuration options. This menu can also be accessed via the main mouse
    context menu when the current buffer has auto spell enabled.

    cDauto-spell-buffercA checks all words within the current buffer for spell,
    hilighting any unknown or miss-spelled words found.

    cDauto-spell-resetcA resets the buffer hilighting scheme, removing any added
    erroneous words.

    cDauto-spell-ignorecA gets the current word and deletes the erroneous
    hilighting and adds the word to the current temporary ignore dictionary,
    auto-spell and the spelling-checker will now ignore the word. If an
    argument cDncA of 2 is given to the command the word is added to the users
    personal dictionary instead of the temporary ignore dictionary so the word
    is 'ignored' in all future sessions of MicroEmacs as well.


cEcENOTES cEcA


    cDauto-spellcA, cDauto-spell-buffercA, cDauto-spell-resetcA and cDauto-spell-ignorecA are
    macros defined in cGspellaut.emfcA.


cEcESEE ALSO cEcA


    lslmuser-setup(3)le, lslmspell-buffer(3)le, lslmspell(2)le.
! 3 find-zfile
! 3 zfile-setup
cEcENAME cEcA


|find-zfile
    find-zfile - Compressed file support
|auto-spell-reset
    zfile-setup - Compressed file support setup
$a


cEcESYNOPSIS cEcA


    cDfind-zfilecA "cCfile-namecA"
    cDzfile-setupcA "cCextensioncA" "cClist-commandcA" "cCcut-tocA"
        "cCcolumncA" "cCfile-endcA" "cCextract-commandcA"
        "cCremove-commandcA"


cEcEDESCRIPTION cEcA


    cDfind-zfilecA provides generic support for listing and extracting the
    contents of compressed files. cDfind-zfilecA also supports the extraction of
    the internal files into another buffer.

    cDfind-zfilecA must be configured for each compression format using
    cDzfile-setupcA. It relies on command-line programs to generate content lists
    which are used to generate the main file listing, and subsequently, the
    ability to extract individual files for file extraction support.

    For basic content listing support the first 3 arguments must be given to
    zfile-setup. The first argument "cCextensioncA" is used as the compressed file
    id string. The compressed file type is derived from the file extension,
    e.g. "cGzipcA" or "cGZcA" for UNIX compressed files. The exact case of the
    extension is checked first, followed by the lower case and upper case
    string.

    The compressed file contents list is generated from executing the user
    supplied "cClist-commandcA" and dumping the output into the list buffer. The
    command is run from the directory containing the compressed file and the
    following special tags may be used within the "cClist-commandcA" which get
    substituted as follows:-

    cD%zbcA
        The token is replaced with the compressed files base name, i.e. the
        file name without the path.

    cD%zfcA
        The token is replaced with the compressed files absolute file name,
        i.e. the file complete with the path.

    The head of the list output is often unwanted verbose printout, this can
    be automatically be removed by the use of the "cCcut-tocA" argument. The
    argument, if supplied (not an empty string), must be a lsRegularExpressions(2)lmregexle search string
    matching the start of the required list. If found, all text before it is
    removed.

    For single file extraction support the last 4 arguments must be specified
    by cDzfile-setupcA. The file to extract is selected either by selecting the
    file name using the left mouse button or by moving the cursor to the line
    containing the file name and pressing the "cGreturncA" key.

    cDfind-zfilecA assumes that the file name starts at a fixed column number,
    specified with the "cCcolumncA" argument. The end of the file name is obtained
    by searching for the regular expression "cCfile-endcA" string, the file name
    is assumed to end at the start of the search string match.

    The file is then extracted by executing the supplied "cCextract-commandcA" and
    then loading the extracted file into a new buffer. The command is run from
    the system temporary directory (i.e. "cG/tmp/cA" on UNIX or cG$TEMPcA on Windows
    etc.). The following special tags may be used within the "cCextract-commandcA"
    which get substituted as follows:-

    cD%zbcA
        The token is replaced with the compressed files base name, i.e. the
        file name without the path.

    cD%zfcA
        The token is replaced with the compressed files absolute file name,
        i.e. the file name complete with the path.

    cD%fbcA
        The name of the file to be extracted.

    The file is assumed to be extracted to the temp directory due to the way
    the command is run, this file is then loaded into a new buffer. The
    temporary file should then be removed using the supplied "cCremove-commandcA"
    with is run from the temp directory, the "cD%fbcA" special tag may be used in
    the command. This argument may be given as an empty string, thereby
    disabling the removal.


cEcEEXAMPLE cEcA


    For zip file support the freely available cDunzip(1)cA command can be used,
    following is the list of arguments with suitable entries:

        extension           zip
        list-command        unzip -v %zb
        cut-to              ^ Length
        column              58
        file-end            $
        extract-command     unzip -o %zf %fb
        remove-command      rm %fb


    For the zip file "cC/usr/jasspa/memacros.zipcA", after substitution the list
    command becomes "cGunzip -v memacros.zipcA" which will be executed in the
    "cC/usr/jasspa/cA" directory. This will produce the following form of output:

        Archive:  memacros.zip
         Length  Method   Size  Ratio   Date    Time   CRC-32     Name
         ------  ------   ----  -----   ----    ----   ------     ----
            565  Defl:N     258  54%  02-27-99  22:56  018a7f70   american.emf
           3409  Defl:N     872  74%  02-28-99  01:37  6a6f9722   americar.emf
           4201  Defl:N     772  82%  03-01-99  12:58  d4e3bc4a   benchmrk.emf
            565  Defl:N     258  54%  02-27-99  22:56  dd394e24   british.emf
           3408  Defl:N     872  74%  02-28-99  01:37  32f3eeca   britishr.emf
           7239  Defl:N    1923  73%  02-28-99  15:13  d408f0da   calc.emf
           7292  Defl:N    2072  72%  01-23-99  12:49  5979d6b2   cbox.emf
           7104  Defl:N    1402  80%  02-28-99  15:13  6faf4fc5   cmacros.emf
           5967  Defl:N    1239  79%  02-13-99  16:38  27601523   ctags.emf
           1097  Defl:N     489  55%  02-16-99  10:58  53a55e36   dos.emf
            562  Defl:N     310  45%  01-16-98  07:54  ec24f65e   dos2unix.emf
        .
        .
        .


    The top Archive line is not require, this is automatically removed by
    setting the "cCcut-tocA" to "cG^ LengthcA" which matches the start of the next
    line.

    For file extract, consider the file "cGctags.emfcA", the first character 'cGccA'
    is at column 58 and the first character after the end of the file name is
    the end-of-line character ('cG\ncA') which is matched by the lsRegularExpressions(2)lmregexle string "$",
    hence the settings on "cCcolumncA" and "cCfile-endcA". When this and the zip file
    name are substituted into the extract-command, it becomes "cGunzip -o
    /usr/jasspa/memacros.zip calc.emfcA" and is run from the "cC/tmp.cA" directory.
    Note that the "cG-ocA" option disables any overwrite prompts, these are not
    required as tests and prompting have already been performed by cDfind-zfilecA.
    The extracted file "cC/tmp/calc.emfcA" is then loaded into a new buffer.

    The temporary file is removed by executing the substituted remove-command
    which becomes "cGrm calc.emfcA" from the "cG/tmp/cA" directory.

    For gzipped tar files, extension "cDtgzcA" the following setup can be used on
    UNIX platforms:

        extension           tgz
        list-command        unzip -v %zb
        cut-to
        column              43
        file-end            $
        extract-command     gunzip -c %zf | tar xof - %fb
        remove-command      rm %fb


    For the tgz file "cC/usr/jasspa/memacros.tgzcA", this will produce the
    following listing:

        tgz file: /usr/jasspa/memacros.tgz


        rw-rw-r-- 211/200    565 Feb 27 22:56 1999 american.emf
        rw-rw-r-- 211/200   3409 Feb 28 01:37 1999 americar.emf
        rw-rw-r-- 211/200   4201 Mar  1 12:58 1999 benchmrk.emf
        rw-rw-r-- 211/200    565 Feb 27 22:56 1999 british.emf
        rw-rw-r-- 211/200   3408 Feb 28 01:37 1999 britishr.emf
        rw-rw-r-- 211/200   7239 Feb 28 15:13 1999 calc.emf
        rw-rw-r-- 211/200   7292 Jan 23 12:49 1999 cbox.emf
        rw-rw-r-- 211/200   7104 Feb 28 15:13 1999 cmacros.emf
        rw-rw-r-- 211/200   5967 Feb 13 16:38 1999 ctags.emf
        rw-rw-r-- 211/200   1097 Feb 16 10:58 1999 dos.emf
        rw-rw-r-- 211/200    562 Jan 16 07:54 1998 dos2unix.emf
        .
        .
        .


cEcENOTES cEcA


    cDfind-zfilecA and cDzfile-setupcA are macros defined in cGzfile.emfcA.


cEcESEE ALSO cEcA


    lslmfind-file(2)le.
! 3 charset-change
! 3 charset-iso-to-user
! 3 charset-user-to-iso
cEcENAME cEcA


|charset-change
    charset-change - Convert buffer; between two character sets
|charset-iso-to-user
    charset-iso-to-user - Convert buffer; ISO standard to user character set
|charset-user-to-iso
    charset-user-to-iso - Convert buffer; user to ISO standard character set
$a


cEcESYNOPSIS cEcA


    cDcharset-changecA
    cDcharset-iso-to-usercA
    cDcharset-user-to-isocA


cEcEDESCRIPTION cEcA


    cDcharset-changecA opens a dialog allowing the user to select a cDFromcA and cDTocA
    character set. If the cCConvertcA button is selected the current buffer is
    converted to the destination character set. The command assumes that the
    current buffer is written in the cDFromcA character set, no attempt is made to
    verify this.

    cDcharset-iso-to-usercA converts the current buffer, assumed to be in
    ISO-8859-1 (Latin 1) font format, to the current user's character set
    (defined by lslmuser-setup(3)le). This process typically corrects any foreign
    language display problems.

    Conversely, cDcharset-user-to-isocA converts the current buffer from the
    user's character set to ISO-8859-1 (Latin 1), this is typically used for
    the transfer of text files between different systems.

    The current character set is configured using the lslmuser-setup(3)le dialog
    (see lsuser-setup(3)lmDisplay Font Setle). This in turn uses the command lslmset-char-mask(2)le to
    create the low level character conversion tables.


cEcENOTES cEcA


    cDcharset-changecA, cDcharset-iso-to-usercA and cDcharset-user-to-isocA are macros
    defined in cGlangutl.emfcA.


cEcESEE ALSO cEcA


    lslmuser-setup(3)le, lslmset-char-mask(2)le, lslocaleSupport(2)lmLocale Supportle.
! 3 execute-tool
cEcENAME cEcA


    execute-tool - Execute a user defined shell tool
$a


cEcESYNOPSIS cEcA


    cCncA cDexecute-toolcA "cCtool-namecA"


cEcEDESCRIPTION cEcA


    cDexecute-toolcA launches a predefined shell tool, the tools are typically
    defined by the lslmuser-setup(3)le Tools page and executed using the MicroEmacs
    main Tools menu. See help on lslmuser-setup(3)le for more information on the
    basic facilities given by execute-tool.

    If the numeric argument cCncA is supplied it is used as the tool name to be
    executed, otherwise the argument "cCtool-namecA" must be given.

    A tool with a numeric name can be executed via a key binding, for example,
    to execute tool cD3cA (as defined by cDuser-setupcA) to 'cGC-3cA' add the following
    line to the user setup file:-
sB
        3 global-bind-key execute-tool "C-3"

sA

cEcENOTES cEcA


    The registry entries for a tool must be located in registry directory
    "cG/history/cAcD$platformcAcD/tool/cAcDtool-namecA" where cD$platformcA is the current setting
    of variable lslm$platform(5)le and cDtool-namecA is the name of the tool as given to
    the command. The following registry entries are used:-

    cDnamecA
        The name of the tool as displayed in the user-setup Tools dialog and
        the Main Tools menu. This is only used for tools cG0cA to cG9cA.

    cDcommandcA
        The command-line to be launched when the tool is executed, the
        following special tokens may be used in the command-line which are
        substituted at execution:-

        cD%ffcA
            The current buffer's full file name, including the path.

        cD%fpcA
            The current buffer's file path.

        cD%fncA
            The current buffer's file name without the path.

        cD%fbcA
            The current buffer's file base name, i.e. the file name without
            the path or the extension.

        cD%fecA
            The current buffer's file extension with the 'cC.cA' (e.g. "cC.emfcA"),
            set to the empty string if the file name does not have an
            extension.

        Note that "cD%ffcA" is always the same as "cD%fp%fncA" and "cD%fp%fb%fecA". If any
        of these tokens are used, the tool will fail to execute if the current
        buffer does not have a file name.

    cDflagcA
        A bit based flag setting the tool characteristics, where:-

        cD0x01cA
            Enable current buffer saving.

        cD0x02cA
            Enable prompt before saving current buffer.

        cD0x04cA
            Enable all edited buffers saving.

        cD0x08cA
            Enable prompt before saving an edited buffer.

        cD0x10cA
            Enable output capturing.

        cD0x20cA
            Enable concurrent running, not available on all platforms, see
            variable lslm$system(5)le.

    cDbnamecA
        The name of the buffer to be used if the output is captured. The
        following special tokens may be used in the buffer name which are
        substituted at execution:-

        cD%fncA
            The current buffer's file name without the path, set to the buffer
            name if the current buffer does not have a file name.

        cD%fbcA
            The current buffer's file base name, i.e. the file name without
            the path or the extension. Set to the buffer name if the current
            buffer does not have a file name.

        cD%fecA
            The current buffer's file extension with the 'cC.cA' (e.g. "cC.emfcA"),
            set to the empty string if the current buffer does not have a file
            name or it does not have an extension.
        Note that "cD%fncA" is always the same as "cD%fb%fecA". Default buffer name
        when this field is left empty is "cC*command*cA", or "cC*icommand*cA" if cGRun
        ConcurrentlycA is enabled.

    If more than 10 tools are required (maximum number definable by
    cDuser-setupcA) or names are preferred, it is recommended that the cDuser-setupcA
    dialog is used to define the tool and then use the registry copy utility
    bound to 'cGccA' in a lslmlist-registry(2)le buffer.


cEcESEE ALSO cEcA


    lslmuser-setup(3)le, lslmipipe-shell-command(2)le, lslmpipe-shell-command(2)le,
    lslmshell-command(2)le, ls$system(5)lmsystem(5)le.
! 3 info
! 3 info-on
! 3 info-goto-link
! 5 $INFOPATH
cEcENAME cEcA


|info
    info - Display a GNU Info database
|info-on
    info-on - Display Info on a given topic
|info-goto-link
    info-goto-link - Display Info on a given link
|$INFOPATH
    $INFOPATH - GNU info files base directory
|.info.path
    .info.path - Cached info search path
$a


cEcESYNOPSIS cEcA


    cDinfocA

    cDinfo-oncA cCtopic-strcA

    cDinfo-goto-linkcA cClink-strcA

    cD$INFOPATHcA cCstringcA

    cD.info.pathcA cCstringcA


cEcEDESCRIPTION cEcA


    cDinfocA interprets the GNU cCinfocA pages, and presents the info file information
    within a buffer window called cG*info XXXXXcA, where cGXXXXXcA is the name of the
    info file. The root of the info page is displayed and may be traversed by
    selecting the links with the mouse, or by using the standard cCinfocA
    traversal keys.

    The root of the cCinfocA tree is, by default, a file called cDdircA, which points
    to the other information sources. The default search paths for the cCinfocA
    directories are:-

        cGc:/infocA - MS-DOS and MS-Windows (all).
        cG/usr/local/infocA - All UNIX platforms.

    The root directory may also be specified with the cG$INFOPATHcA environment
    variable. This is a colon (cG:cA) or semi-colon (cG;cA) separated list of
    directory paths which specify the locations of the info files, for UNIX
    and Microsoft DOS/Windows environment's, respectively.

    cDinfo-oncA gets info on a user specified top level topic, e.g. "cGgcccA", the
    info file "cCtopic-strcAcG.infocA" must be found in the info search path.

    cDinfo-goto-linkcA gets and displays info on a user specified link or subject.
    The link may be within the currently displayed topic (the cClink-strcA need
    only specify the subject node name) or a subject within another topic (in
    which case the cClink-strcA takes the following form "cG(cAcCtopiccAcG)cA cCsubjectcA").


cEcENOTES cEcA


    cDinfocA is a macro implemented in file cGinfo.emfcA.

    When an cDinfocA command is run for the first time, the info search path is
    constructed and stored locally in the command variable cD.info.pathcA. This
    variable must be directly changed by the user if changes to the info
    search path are required.


cEcESEE ALSO cEcA


    lslminfo(9)le.
! 3 gdiff
! 5 %gdiff-com
cEcENAME cEcA


    gdiff - Graphical file difference
    %gdiff-com - Gdiff diff(1) command line
$a


cEcESYNOPSIS cEcA


|gdiff
    cDgdiffcA "cCversion1cA" "cCversion2cA"
|%gdiff-com
    cG%gdiff-comcA "cCstringcA"; Default is "cGdiff -c -wcA"


cEcEDESCRIPTION cEcA


    cDgdiffcA is a macro utility that facilitates the merging of two files
    (typically with different modification revisions). The changes between the
    revisions are hilighted with color, allowing modification regions and
    lines to be selected for the generation of a newer revision file, which
    might encompass selected modifications from each of the base revisions.

    cDgdiffcA executes the cDdiff(1)cA command with the command line set by the
    lslm%gdiff-com(5)le variable and the user supplied cCversion1cA and cCversion2cA. The
    output is displayed in two buffer windows, side by side, and the
    differences in the lines are hilighted to show the changes. In addition
    the content of the two buffers is cCnormalizedcA such that both windows are
    aligned at the same line position, allowing the changes in the text to be
    viewed in both windows at the same time.

    Whilst in cDgdiffcA view mode then both scroll bars (if visible) are cClockedcA,
    such that either scrolls BOTH windows at the same time. Other key commands
    are disabled, as are the menu interactions. The short cut keys are defined
    as follows:-

    cGesc h/A-hcA - View the help page.
        Invokes the display of a OSD help box, summarizing the interaction
        commands

    cGC-upcA - Move to previous difference
        Moves to the previous changed region above the current cursor
        position.

    cGC-downcA - Move to next difference
        Moves to the next changed region below the current cursor position.

    cGleft mouse buttoncA
    cGspacecA
    cGentercA
    cGrcA - Select difference version
        Selects the difference version of the currently selected window. The
        region is hilighted as the required region to be incorporated into the
        new revision.

    cGRcA - Select neither version.
        Marks both regions as not required.

    cGlcA - Line select current version
        Selects the current line from the region as being included, without
        including ALL of the region modifications.

    cGLcA - Line select neither version
        Discards lines from both revisions of the file.

    cGgcA - Globally selects the current version.
        Shortcut allows ALL modifications to the current side to be accepted.
        This is typically the fastest method to select all changes, minor
        region adjustment may then be performed on those regions which are
        inappropriately included by the selection.

    cGGcA - Globally selects neither version.
        Marks all regions as not being acceptable.

    cGC-x C-scA - Save current side
        Saves the current window to the specified file, merging the selected
        changes between the two revisions. Note that the save only operates
        iff all hilighted changes have been selected.

    cGC-x C-wcA - Save current side as
        Same as cDSave current sidecA except the user is prompted to enter a new
        filename to which the modifications are written.

    cGC-x kcA - Exit graphical diff
        Exits the cDgdiffcA utility.


cEHilighting cA


    The hilighting within the windows is dependent upon the color scheme
    selected, in general the following hilights apply:-

    normal text
        No change

    cyan/grey
        Addition/removal of line(s)/region(s) between files.

    yellow
        Modification in line(s)/region(s).

    green/red
        Selected region, red or green is attributed to a selection for each
        window.


cEcENOTES cEcA


    cDgdiffcA is a macro defined in cGgdiff.emfcA, inspired by the GNU utility of the
    same name cDgdiff(1)cA

    cDdiff(1)cA must be executable on the system before cDgdiffcA can function. The
    cDdiff(1)cA invocation must include the cCcontextcA difference, which annotates
    the differences with a cG+cA, cG-cA or cG!cA markers. cDdiff(1)cA is typically invoked
    with the options cD-c -wcA.

    cDdiff(1)cA is a standard utility on UNIX systems. For Windows 95/NT a version
    of GNU cDdiffcA may be found at:

        cC<ftp.winsite.com/ftp/pub/pc/winnt/misc/gnudiff.zip>cA

    For MS-DOS users, a DJGPP port of GNU cDdiffcA is also available on the net. A
    commercial version of cDdiffcA is also available from MKS.


cEcESEE ALSO cEcA


    lslmcompare-windows(2)le, lslmcompile(3)le, cDdiff(1)cA, lslmgdiff(3f)le, lslmxgrep(3)le,
    lslm%xgrep-com(5)le.
! 3 expand-iso-accents
! 3 iso-accents-mode
cEcENAME cEcA


|expand-iso-accents
    expand-iso-accents - Expand an ISO accent
|iso-accents-mode
    iso-accents-mode - Enable/disable ISO accent expansion short-cut mode
$a


cEcESYNOPSIS cEcA


    cDexpand-iso-accentscA
    cCncA cDiso-accents-modecA


cEcEDESCRIPTION cEcA


    cDexpand-iso-accentscA provides a facility to enter a plain text
    representation of an ISO accent and then to expand it into a proper ISO
    accented character. For example:-

        cG`acA => small a, grave accent
        cG^acA => small a, circumflex accent
        cG'acA => small a, acute accent
        cG"acA => small a, umlaut
        cG~acA => small a, tilde
        cG.acA => small a, ring
        cG14cA => fraction, one-quater
        cG12cA => fraction, one-half
        cG34cA => fraction, three-quaters
        cGaecA => ae ligature
        cGszcA => small sz ligature, German.
        cG+-cA => plus or minus (math.)
        cGcocA => copyright
        cGrgcA => registered trademark
        cGtmcA => trade mark
        cGoecA => small oe ligature
        cG/ocA => small o, slash

    The cDexpand-iso-accentscA can be called directly to expands the ISO
    abbreviated character sequence into it's ISO ASCII character equivalent.
    The command looks at the 2 characters to the left of the cursor and tries
    to find a matching abbreviation, if found the 2 characters are removed,
    replaced by the single ISO character.

    The more typical way of using this feature is by enabling its use in the
    lsexpand-abbrev-handle(3)lmabbreviation handlerle which is usually bound to "cGesc esc cA". It can be
    enabled by either by using the cDiso-accents-modecA command or, for a more
    permanent installation, from the lslmuser-setup(3)le => General => Abbrev
    Expansion settings.

    When using the cDiso-accents-modecA command, if a numeric argument cCncA is given
    (the value is not used) then the ISO accent expansion is installed locally
    into the current buffer. If cCncA is omitted then expansion is
    enabled/disabled globally (across all buffers).

    cDexpand-iso-accentscA is the macro command that This is by default bound to .
    If an ISO character is not located then lslmexpand-abbrev(2)le is invoked to try
    a standard abbreviation.


cEcENOTES cEcA


    cDiso-accents-modecA and cDexpand-iso-accentscA are implemented as macros in the
    file cGabbrev.emfcA, the repertoire of expansions may be enhanced by editing
    this file.

    Unlike the general lslmexpand-abbrev(2)le command which attempts to expand the
    current word, cDexpand-iso-accentscA only considers the last two characters
    regardless of whether they are word characters or start a word. Therefore
    the general cDexpand-abbrevcA command cannot be used to implement a similar
    feature.


cEcESEE ALSO cEcA


    lslmexpand-abbrev-handle(3)le, lslmbuffer-abbrev-file(2)le, lslmexpand-abbrev(2)le,
    lslmexpand-look-back(3)le, lslmexpand-word(3)le.
! 3 gdb
! 3 dbx
cEcENAME cEcA


|gdb
    gdb - GNU Debugger
|dbx
    dbx - UNIX Debugger
$a


cEcESYNOPSIS cEcA


    cDgdbcA "cCprogram-namecA" "cCadditional-argscA"
    cDdbxcA "cCprogram-namecA" "cCadditional-argscA"


cEcEDESCRIPTION cEcA


    cDgdbcA and cDdbxcA provide an editor interface to the GNU and native system
    debuggers, respectively. On running either command then an interactive
    shell window is opened to the debugger command line interface. MicroEmacs
    then interprets the information from the debugger interface and opens
    files and hilights the current line as required. The current line is
    maintained while single stepping through the code.

    Buffers opened and referenced by the debugger have the key cGF9cA bound to
    setting a break point.

    The input mode in the shell window may be toggled using key cDf3cA


cEcENOTES cEcA


    cDgdbcA and cDdbxcA are macros defined in file cGhkipipe.emfcA.


cEcESEE ALSO cEcA


    lslmperldb(3)le, lslmipipe-shell-command(2)le.
! 3 expand-abbrev-handle
cEcENAME cEcA


    expand-abbrev-handle - Expand an abbreviation handler
$a


cEcESYNOPSIS cEcA


    cDexpand-abbrev-handlecA (cDesc esccA)


cEcEDESCRIPTION cEcA


    cDexpand-abbrev-handlecA pulls together all forms of abbreviation expansion
    into a single command so that it can be bound to a single key. The
    abbreviation must be an alpha-numeric string and the cursor must be one
    position to the right of the abbreviation (which must not be
    alpha-numeric) when this command is called. The command attempts to expand
    the abbreviation using the following commands in turn:

    lslmexpand-abbrev(2)le

        Uses a buffer specific and global abbreviation files, if set, to look
        up the abbreviation. The use of the abbreviation file can be disabled
        using lslmbuffer-setup(3)le.

    lslmexpand-iso-accents(3)le

        Expands ISO accent letter if the expansion mode is enabled via either
        the lslmuser-setup(3)le General Page or by using the lslmiso-accents-mode(3)le
        command.

    lslmexpand-look-back(3)le

        Looks for a word starting the same in the current buffer's last 100
        lines, this can be enabled in the lslmuser-setup(3)le General page.

    cDBuffer specific expansioncA

        Executes a buffer specific abbreviation expansion if the current
        buffer's lsfileHooks(2)lmfile hookle supports abbreviation expansion.

    cDWord expansioncA

        If the current buffer does not support file type specific expansion
        and Word Expansion is enabled via the lslmuser-setup(3)le General page
        (cGDict'ncA setting) expansion is attempted using the lslmexpand-word(3)le
        command which expands the current partial word using the dictionary of
        the user's current language; warning - this can be slow!

    The command exits after first command to successfully expand or if none
    expand the command fails. See the help in the individual expansion
    commands for more help.


cEcESEE ALSO cEcA


    lslmuser-setup(3)le, lslmexpand-abbrev(2)le, lslmexpand-iso-accents(3)le,
    lslmexpand-look-back(3)le, lslmexpand-word(3)le.
! 3 expand-word
cEcENAME cEcA


    expand-word - Complete a word by invocation of the speller
$a


cEcESYNOPSIS cEcA


    cDexpand-wordcA


cEcEDESCRIPTION cEcA


    cDexpand-wordcA attempts to complete the word at the current position through
    the use of the current language dictionary. The user is presented with a
    list of endings for the given word portion. These may be selected with the
    cursor or mouse.

    cDexpand-wordcA is automatically invoked from the lslmexpand-abbrev-handle(3)le
    macro in response to an expansion command, it is only invoked if enabled
    in the lslmuser-setup(3)le => General => Abbrev Expansion => Dict'n setting is
    enabled.


cEcENOTES cEcA


    cDexpand-wordcA is a macro implemented in cGabbrev.emfcA.

    The cDuser-setupcA configuration simply sets the macro variable
    cG.expand-word.oncA to TRUE, i.e.:
sB
        set-variable .expand-word.on 1

sA
    It may be subsequently disabled by setting the variable back to 0.


cEcESEE ALSO cEcA


    lslmexpand-abbrev-handle(3)le, lslmspell-buffer(3)le, lslmfind-word(3)le.
! 3 uniq
cEcENAME cEcA


    uniq - Make lines in a sorted list unique
$a


cEcESYNOPSIS cEcA


    cDuniqcA


cEcEDESCRIPTION cEcA


    cDuniqcA reduces a sorted lines of text in the current buffer to a unique list
    such that no entries are repeated. The list is made unique from the lsset-mark(2)lmmarkle
    position to the current cursor position (point). The operation is case
    sensitive.


cEcENOTES cEcA


    cDuniqcA is a macro implemented in cGtools.emfcA.

    For cDuniqcA to operate correctly then the list must have been previously
    sorted, see lslmsort-lines(2)le.


cEcESEE ALSO cEcA


    lslmsort-lines(2)le, lslmsort-lines-ignore-case(3)le, lslmtranspose-lines(2)le,
! 3 ftp
cEcENAME cEcA


    ftp - Initiate an FTP connection
$a


cEcESYNOPSIS cEcA


    cDftpcA


cEcEDESCRIPTION cEcA


    cDftpcA initiates a File Transfer Protocol (FTP) connection to a remote host
    on the network. Using FTP, editing of files may be performed in much the
    same way as on the local file system. Directory listings may be retrieved
    and traversed using the mouse or cursor keys. Using the directory listing,
    files may be transfered to/from the remote host to the local machine.

    On issuing the command then a dialog is presented to the user which is
    used to open the connection. The dialog entries are defined as follows:-

    cDRegistry FilecA
        The name of a MicroEmacs registry file which is used to store the FTP
        information. If a registry name is provided then all FTP address
        information is stored in the registry file and saved for later
        sessions. Be aware that password information is saved in this file as
        plain text if a password is entered into the site information.

        If the registry information is omitted then the information is not
        saved between sessions.

    cDSite NamecA
        An ASCII pseudo name for the remote host. The pull-down menu may be
        used to select existing sites that have been previously entered.

    cDHost AddresscA
        The address of the host, this may be an IP address (cG111.222.333.444cA)
        or a DNS name (i.e. cGftp.mysite.comcA).

    cDUser NamecA
        The login name for the site. If this is omitted then lslm$user-name(5)le is
        used by default.

    cDPasswordcA
        The password used to enter the site for the given login name. If the
        password is NOT supplied then the user is prompted for the password
        when a transaction takes place. If the password is omitted and left to
        promt then it is not stored in the registry.

        Take note of the comments provided above regarding the password
        information.

    cDInitial Host PathcA
        The starting directory at the remote host. If this is omitted then the
        root directory ('cG/cA') is used by default.

    On selecting cDConnectcA then a FTP connection is opened and the initial
    directory appears as a directory listing, if the initial path is a file
    then the file is loaded into the editor.

    Thereafter the file may be edited within the editor as normal, on a write
    operation then the file is written back to the host, via FTP.

    On opening a FTP connection the progress of the transfer, and the FTP
    commands issued, may be viewed in the cG*ftp-console*cA buffer. This buffer
    may automatically appear depending upon the value of the lslm%ftp-flags(5)le
    variable.


cEcENOTES cEcA


    cDftpcA is a macro implemented in cGftp.emfcA. This uses the underlying command
    lslmfind-file(2)le to implement the FTP transfer.

    FTP files can be directly loaded and edited using the standard file
    commands such as lslmfind-file(2)le.

    The FTP addresses are retained in a registry file (see lslmerf(8)le). The
    registry file is automatically loaded when MicroEmacs starts up each
    session. The current site information may be viewed using lslmlist-registry(2)le
    and is located at the following registry addresses:-

    cD/urlcA
        Data value is file system location of the FTP registry file.

    cD/url/ftp/cAcC<hostName>cA
        The name of the host to which the connection is to be made.

    cD/url/ftp/cAcC<hostName>cAcD/hostcA
        The name or IP address of the remote host

    cD/url/ftp/cAcC<hostName>cAcD/usercA
        The user name used to log into the remote host.

    cD/url/ftp/cAcC<hostName>cAcD/passcA
        The user password to the remote host. If this entry is empty then the
        user is always prompted for the password when the connection is made.

    cD/url/ftp/cAcC<hostName>cAcD/pathcA
        The initial path at the remote site.

    When a FTP connection is initiated then the connection (socket) remains
    open for a period of approximately 4 minutes from the last transfer time,
    after that the connection is automatically closed and is re-initiated if
    required again.

    cDNOTE:cA For windows platforms then the resultant executable must be built
    with URL support enabled, for UNIX platforms socket support is
    automatically enabled.


cEcEBUGS cEcA


    Directory completion is not available when the current working directory
    is an FTP address. To work around this from the command line, select
    cG<RETURN>cA to get a directory listing of the current directory and select
    the file(s) from the directory to load.


cEcESEE ALSO cEcA


    lslm%ftp-flags(5)le, lslm$user-name(5)le, lslmerf(8)le, lslmfind-file(2)le, lslmfile-op(2)le,
    lslmlist-registry(2)le.
! 3 display-whitespaces
! 3 display-white-chars
cEcENAME cEcA


    display-whitespaces - Toggle the displaying of white characters
$a


cEcESYNOPSIS cEcA


    cDdisplay-whitespacescA


cEcEDESCRIPTION cEcA


    cDdisplay-whitespacescA toggles the displaying of white characters in the main
    display. By default white characters, space tab and new-lines, are
    represented with invisible characters such as one or more 'cG cA's for spaces
    and tabs and text moving to the next line for new-lines. The user can make
    this characters become 'visible' using this function.

    When this function is first called it toggle enables the displaying of
    these characters, other characters are drawn in their place to make them
    visible. A subsequent call will disable the displaying of them.


cEcENOTES cEcA


    cDdisplay-whitespacescA is a macro implemented in cGmisc.emfcA and uses bit
    cG0x80000cA of the lslm$system(5)le variable.

    The displaying of white characters can be enabled or disabled at start-up
    using lslmuser-setup(3)le.

    This feature may be more confusing on some terminals due to the lack of
    characters available for displaying the white characters. The characters
    used when displaying white characters are defined in the variable
    lslm$window-chars(5)le.

    The macro cDdisplay-white-charscA was renamed to cDdisplay-whitespacescA in
    September 2006.


cEcESEE ALSO cEcA


    lslm$system(5)le, lslmuser-setup(3)le, lslm$window-chars(5)le.
! 3 check-line-length
cEcENAME cEcA


    check-line-length - Check the length of text lines are valid
$a


cEcESYNOPSIS cEcA


    cDcheck-line-lengthcA


cEcEDESCRIPTION cEcA


    cDcheck-line-lengthcA checks that the length of each line of the current
    buffer, starting with the current line, is less than or equal to
    lslm$buffer-fill-col(5)le. The command aborts if a line too long is found,
    leaving the cursor on the offending line. If no invalid lines are found
    the command succeeds leaving the cursor at the end of the buffer.


cEcENOTES cEcA


    cDcheck-line-lengthcA is a macro implemented in cGmisc.emfcA.


cEcESEE ALSO cEcA


    lslm$buffer-fill-col(5)le.
! 3 reread-file
! 3 reread-all
cEcENAME cEcA


    reread-file - Reload the current buffer's file
$a


cEcESYNOPSIS cEcA


|reread-file
    cCncA cDreread-filecA
|reread-all
    cCncA cDreread-allcA


cEcEDESCRIPTION cEcA


    cDreread-filecA reloads from disk the file associated with the current buffer,
    this command is particularly useful when the file is continually updated
    by an external program. If the buffer has been edited and its name does
    not start with a 'cG*cA' then the user is prompted as to whether the changes
    should be discarded. Also if the buffer has an active process running in
    it then confirmation is sort from the user before the process is killed.

    The argument cCncA can be used to change the default behavior of reread-file
    described above, cCncA is a bit based flag where:-

    cD0x01cA
        Enables loss of work checks (default), if this flag is not supplied
        then the buffer is reread without any user prompts (useful in macros).

    cDreread-allcA reloads all out-of-date buffers. If the argument cCncA is specified
    as zero (0) then all buffers are re-read. The default with no numeric
    argument is reload out-of-date buffers only.


cEcENOTES cEcA


    cDreread-filecA is a macro implemented in cGtool.emfcA.


cEcESEE ALSO cEcA


    lslmfind-file(2)le, lslmread-file(2)le, lslmview-file(2)le.
! 3 normal-tab
cEcENAME cEcA


    normal-tab - Insert a normal tab
$a


cEcESYNOPSIS cEcA


    cCncA cDnormal-tabcA


cEcEDESCRIPTION cEcA


    cDnormal-tabcA insert a tab into the current buffer by temporarily disabling
    any auto indentation schemes. The macro first disables any indentation
    rules by setting lslm$buffer-indent(5)le to 0 the command lslmtab(2)le is then called
    with the given argument cCncA. This means that the buffer's lslmtab(2m)le mode
    setting will be respected, i.e. whether a tab character or spaces are
    inserted. The initial indentation rules are restored on exit.


cEcENOTES cEcA


    cDnormal-tabcA is a macro implemented in cGformat.emfcA.


cEcESEE ALSO cEcA


    lslmtab(2)le, lslminsert-tab(2)le, lslmtab(2m)le.
! 3 perldb
cEcENAME cEcA


    perldb - Perl Debugger
$a


cEcESYNOPSIS cEcA


    cCncA cDperldbcA [ "cCscript-namecA" ] "cCscript-argscA"


cEcEDESCRIPTION cEcA


    cDperldbcA provides an editor interface to the Perl debugger, on running the
    command an interactive shell window is opened to the debugger command line
    interface. MicroEmacs then interprets the information from the debugger
    interface and opens files and hilights the current line as required. The
    current line is maintained while single stepping through the script.

    Buffers opened and referenced by the debugger have the key cGF9cA bound to
    setting a break point, this only works if the buffer contains the current
    execution point.

    If an argument cCncA of 2 is given to cDperldbcA the command assumes that the
    current buffer is the script file to debug, the "cGscript-namecA" argument is
    not prompted for.


cEcENOTES cEcA


    cDperldbcA is a macro defined in file cGhkipipe.emfcA.


cEcEBUGS cEcA


    The 'cDRcA' rerun command does not work correctly on Windows platforms, perldb
    is rerun in a newly created external dos command window instead of inside
    the MicroEmacs ipipe buffer.


cEcESEE ALSO cEcA


    lslmgdb(3)le, lslmipipe-shell-command(2)le.
! 3 generate-tags-file
cEcENAME cEcA


    generate-tags-file - Generate a tags file
$a


cEcESYNOPSIS cEcA


    cCncA cDgenerate-tags-filecA [ "cCtag-commandcA" ]


cEcEDESCRIPTION cEcA


    The cDgenerate-tags-filecA command provides an interface to tag file
    generation. Typically the "cCtag-commandcA" argument will not be required as
    the current buffer will automatically configure cDgenerate-tags-filecA on how
    tags are generated for the current buffer's file type. See the notes below
    for more information on configuration.

    cDgenerate-tags-filecA supports two different methods of tag generation,
    firstly via a MicroEmacs macro file and secondly by an external shell
    command (such as cDctags(1)cA). It is generally configured in the current
    buffer's lsfileHooks(2)lmsetup hookle.

    If a macro file is used a setup dialog is opened if an argument of 0 is
    given to cDgenerate-tagscA. This dialog can be used to configure which type of
    tags are required and the starting directory (useful when using recursive
    tags over a source tree). Note that not all tag types are available for
    all file types.

    The generated tags file can then be used by the lslmfind-tag(2)le command.


cEcENOTES cEcA


    cDgenerate-tags-filecA is a macro defined in file cGgentags.emfcA.

    cDgenerate-tags-filecA can be configured in one of 2 ways:

        When a MicroEmacs macro file (such as cGctags.emfcA) is to be used, simply
        give the name of the macro file to be run as the "cCtag-commandcA"
        argument. Alternatively set the variable cD.cAcC<$buffer-fhook>cAcD.tagscA to this
        name, e.g. for C files
sB
                set-variable .fhook-c.tags "ctags"

sA
        Note the "cG.emfcA" extension is assumed.

        When an external shell command is to be used, set the cCtag-commandcA to
        the shell command-line prefixed with a 'cG!cA' character, for example to
        use cDctags(1)cA try the following:
sB
                set-variable .fhook-c.tags "!ctags *.c *h"

sA
        Note that the generate-tags dialog is not available in this mode of
        execution.


cEcESEE ALSO cEcA


    lslmfind-tag(2)le.
! 3 cvs
! 3 cvs-setup
! 3 cvs-add
! 3 cvs-checkout
! 3 cvs-commit
! 3 cvs-diff
! 3 cvs-gdiff
! 3 cvs-log
! 3 cvs-remove
! 3 cvs-resolve-conflicts
! 3 cvs-state
! 3 cvs-status
! 3 cvs-tag
! 3 cvs-update
! 5 %cvs-com
cEcENAME cEcA


|cvs
    cvs - MicroEmacs CVS interface
|%cvs-com
    cvs-setup - MicroEmacs CVS interface setup
|cvs-add
    cvs-add - MicroEmacs CVS interface - add file
|cvs-checkout
    cvs-checkout - MicroEmacs CVS interface - checkout files and directories
|cvs-commit
    cvs-commit - MicroEmacs CVS interface - commit changes
|cvs-diff
    cvs-diff - MicroEmacs CVS interface - diff changes
|cvs-gdiff
    cvs-gdiff - MicroEmacs CVS interface - graphical diff changes
|cvs-log
    cvs-log - MicroEmacs CVS interface - log changes
|cvs-remove
    cvs-remove - MicroEmacs CVS interface - remove file
|cvs-resolve-conflicts
    cvs-resolve-conflicts - MicroEmacs CVS interface - resolve conflicts
|cvs-state
    cvs-state - MicroEmacs CVS interface - list state of directory files
|cvs-status
    cvs-status - MicroEmacs CVS interface - status of files
|cvs-tag
    cvs-tag - MicroEmacs CVS interface - tag files
|cvs-update
    cvs-update - MicroEmacs CVS interface - update directory files
$a


cEcESYNOPSIS cEcA


    cCncA cDcvscA
    cDcvs-setupcA

    cDcvs-addcA
    cDcvs-checkoutcA
    cDcvs-commitcA
    cDcvs-diffcA
    cDcvs-gdiffcA
    cDcvs-logcA
    cDcvs-removecA
    cDcvs-resolve-conflictscA
    cDcvs-statecA
    cDcvs-statuscA
    cDcvs-tagcA
    cDcvs-updatecA


cEcEDESCRIPTION cEcA


    The cvs and sub-commands provide MicroEmacs with an interface to cDcvs(1)cA.
    cDCVScA is a version control system; using it, you can record the history of
    your source file modifications. CVS is licensed under the GNU General
    Public License and is freely available on the Internet, see the
    documentation provided with CVS for more information on its features and
    use.

    The MicroEmacs cDcvscA command opens up a modified lslmfile-browser(3)le with an
    additional "cG*cvs-console*cA" window. The "cG*files*cA" window includes
    additional columns showing the CVS state, revision and repository date.
    The browser by default opens with 3 windows including a representation of
    the file tree. When cDcvscA is provided with a numeric argument cCncA of zero (0)
    then a single window displaying the directory is used only (i.e. cD0 cvscA)

    The functionality of the file-browser is the same as a non-CVS folder with
    the exception that additional CVS item controls are located in the mouse
    context menu (opened by clicking the right mouse button in the cG*files*cA
    buffer). This menu item opens another sub-menu providing access to the
    items below. When selecting commands than a pop-up check-box may be
    displayed which allows options to be selected for the command.

    cDCurrent StatecA
        Checks the state of selected file(s) or directory against the
        repository. Differences detected are shown in the cG*cvs-state*cA window.
        This provides a quick method of determining the working directory
        state.

        The cG*cvs-state*cA buffer supports some of the same features as a
        directory listing, the files can be loaded (using cGreturncA or left click
        on the file name), selected (using space or left mouse button on the
        left hand edge) and CVS commands executed from the window operate
        either on the selected files or the listed files if no files are
        selected. This runs the command "cGcvs -nq update <files>cA".

    cDCheckout filescA
        Checks out a file or directory from the repository into the current
        directory. The file or directory is specified by typing the name into
        a dialog which is opened when this option is selected. This runs the
        command "cGcvs checkout <file>cA".

    cDUpdate filescA
        Updates the currently selected files, files are selected by clicking
        the left button to the left of the required file name. Multiple files
        may be selected by 'dragging' a hilight region over the required
        files. This runs the command "cGcvs update <files>cA".

    cDCommit filescA
        Commits any changes made to the selected files back to the CVS
        repository. This runs the command "cGcvs commit <files>cA". The user is
        prompted for the message to add on the commit.

    cDDiff filescA
        Displays any differences between the selected files and the CVS
        repository version in the cC*cvs-console*cA window. This runs the command
        "cGcvs diff <files>cA".

    cDLog filescA
        Displays the CVS logs for the selected files in the cC*cvs-console*cA
        window. This runs the command "cGcvs log <files>cA".

    cDStatus filescA
        Displays the CVS status for each of the selected files in the
        cC*cvs-console*cA window. This runs the command "cGcvs status -v <files>cA".

    cDTag filescA
        Adds, removes or moves a CVS tag on the selected file(s) or
        directories. A pop-up window is displayed which allows entry of the
        tag name and define the operation. This runs the command "cGcvs tag
        <files>cA".

    cDAdd filescA
        Adds the selected files to the CVS repository. Note this command only
        performs the local add, a cDCVS commitcA is required to make the addition
        permanent. This runs the command "cGcvs add <files>cA". A pop-up is
        displayed to allow the user to change the mode of the add to binary or
        text.

    cDRemove filescA
        This command is deliberately not implemented as its far to dangerous!
        Instead it opens a dialog informing the user to use the cDcvs-removecA
        command instead.

    cDGraphical diffcA
        This command opens a lslmgdiff(3)le window showing the differences between
        the currently selected file and the CVS repository version. Note this
        command only works with a single file.

    cDResolve conflictscA
        This command may be used to resolve merge conflicts created by a cCCVScA
        cCupdatecA operation. The command opens a lslmgdiff(3)le window showing the
        areas of conflict allowing the user to select the correct version and
        saving the resultant version back to the local file. Note this command
        only works with a single file.

    cDClear cvs consolecA
        Clears the cC*cvs-console*cA buffer.

    The cDcvs-addcA command adds the current buffers file to the repository. Note
    that this command only performs the local addition, a cCCVScA cCcommitcA is
    required to make the addition permanent.

    The cDcvs-checkoutcA command checks out a file or directory from the
    repository into the current directory. The user specifies the file on the
    message line.

    The cDcvs-commitcA command commits any changes made to the currently buffer's
    file (including additions) to the repository. The user is prompted for a
    commit log message.

    The cDcvs-diffcA command opens a cC*cvs-diff*cA window displaying the differences
    between the current buffer's local file and repository version. If the
    current buffer is a directory list it will list all the differences found
    in all files within the directory.

    The cDcvs-gdiffcA command opens a lslmgdiff(3)le window displaying the differences
    between the current buffer's local file and repository version.

    The cDcvs-logcA command opens a cC*cvs-log*cA window displaying the CVS log of the
    current buffer's file.

    The cDcvs-removecA command removes the current buffer's file from the
    repository - PLEASE NOTE THIS CAN LEAD TO LOST DATA!!! This command only
    performs the local removal; as it deletes the buffer and file the
    cDcvs-commitcA command cannot be used to commit the removal to the CVS
    repository. Instead the main cDcvscA file-browser menu or cDcvs(1)cA itself must
    be used.

    The cDcvs-resolve-conflictscA command may be used to resolve any conflicts
    created by CVS when the current buffer's file is updated. The command
    opens a gdiff window displaying the areas of conflict, the user may then
    select the correct version in each case and save the resultant new version
    over the local file.

    The cDcvs-statecA command opens a cC*cvs-state*cA window listing the state of any
    file in the current directory which is not up-to-date. Note that unlike
    most cvs sub commands this command executes over all files in the current
    buffer's file directory.

    The cDcvs-statuscA command opens a cC*cvs-state*cA window and shows the state of
    the current buffer in the window including the modification state,
    repository etc.

    The cDcvs-tagcA command opens a dialog box and allows the user to add, remove
    or delete a CVS tag.

    The cDcvs-updatecA command updates all files in the current directory, the
    output being reported to a new cC*cvs-update*cA window. Note that unlike most
    cvs sub commands this command executes over all files in the current
    buffer's file directory.


cESetup cA


    cDcvs-setupcA provides a dialog interface to configure the MicroEmacs CVS
    interface if required. On a typical system installation then it is
    sufficient to have cD$CVSROOTcA defined in the environment and the CVS tools
    will operate from this environment variable without any further
    configuration of MicroEmacs. If MicroEmacs CVS configuration is provided
    then this will over-ride the environment variable.

    cDcvs-setupcA may also be accessed from lslmuser-setup(3)le from the cDMiscellaneouscA
    configuration. The the dialog provides the following configuration
    controls:

    cDCVS Command SetupcA

        cGCVSROOTcA
            If set, overrides the CVS cD$CVSROOTcA environment variable.

        cGCVS_RSHcA
            If set, overrides the CVS cD$CVS_RSHcA environment variable. rsh.

        cGCVS CommandcA
            Defines the cDcvs(1)cA system command. The default when not defined is
            cDcvscA.

        cGCompressioncA
            Sets the compression level to use with all CVS commands.

        cGQuieter CVS outputcA
            When enabled the cG-qcA CVS command-line option is used to suppress
            some of the more verbose print-out.


cECVS File Browser cA


    The cDCVS File BrowsercA is an extension to the lslmfile-browser(3)le and shows the
    state of CVS files in a directory listing.

    cGQuick browser modecA
        When enabled the CVS file browser does not launch a cvs command to
        determine the current state of all files in the directory, instead it
        extracts as much information as it can from the local file system,
        inserting 'cGQcA's for information it cannot determine. This is useful
        when the connection to the server is slow. The full CVS information
        can be obtained by executing the command cDcvs-full-rereadcA, typically
        bound to cGC-f5cA.

    cDTool DefaultscA
        The following define the default settings for options used in various
        CVS commands:

        cGRecurse into sub-directoriescA

        cGCheck-out missing directoriescA

        cGPrune empty directoriescA


cEcENOTES cEcA


    cDcvscA and sub-commands are macros defined in file cGcvs.emfcA.

    When filtering is enabled in the file browser the filter used by the CVS
    interface depends on the file browser mode, if cDQuick browser modecA is
    enabled the same filter is used, but when disabled all files ignored by
    cDcvs(1)cA are also removed by the filter. Use lslmbuffer-setup(3)le in the buffer
    to enable/disable the filter.


cEcESEE ALSO cEcA


    lslmClearCase(3)le, lslmfile-browser(3)le.
! 3 occur
cEcENAME cEcA

$a

cEcESYNOPSIS cEcA


    cDoccurcA


cEcEDESCRIPTION cEcA


    cDoccurcA performs a regular expression search for a string in the current
    buffer; generating a list of every occurrence of the regular expression in
    the buffer.

    On invocation the user is prompted for a lsRegularExpressions(2)lmRegular Expressionsle the buffer is
    searched for the expression and the results are presented in the
    cG*item-list*cA window appearing at the left-hand side of the window.

    The user may interact with the cG*item-list*cA buffer using the mouse or
    cG<RETURN>cA, on selecting a line then the user is moved to the corresponding
    line in the original buffer.


cEcENOTES cEcA


    The cG*item-list*cA window may be closed with the command lslmitem-list-close(3)le
    typically bound to cGesc-F7cA.

    cDoccurcA is a macro defined in cGitemlist.emfcA.


cEcESEE ALSO cEcA


    lslmitem-list(3)le, lslmitem-list-close(3)le, lslmsearch-forward(2)le, lsRegularExpressions(2)lmRegular Expressionsle
! 3 item-list
! 3 item-list-find
! 3 item-list-close
cEcENAME cEcA


|item-list
    item-list - Abbreviated search and list buffer contents.
|item-list-find
    item-list-find - Find the selected item in the item list
|item-list-close
    item-list-close - "Close the item list"
$a


cEcESYNOPSIS cEcA


    cDitem-listcA (cDF7cA)
    cDitem-list-findcA
    cDitem-list-closecA (cDesc F7cA)


cEcEDESCRIPTION cEcA


    cDitem-listcA performs a regular expression search of a buffer, presenting a
    list of the located text and associated types in a separate window which
    is presented to the left of the buffer window. cDitem-listcA is a generic
    function that interacts with the buffer environment variables to present
    abbreviated buffer information to the user.

    The regular expression search strings are predefined in the language
    templates. To add support for a new buffer type a list of search/replace
    strings must be created. The search strings must use regex (magic mode)
    and groups cG\(..\)cA to place the located object string into the replace
    string. Within the template buffer search strings (cDscA) and replace (cDrcA) are
    defined with the following syntax:-

        set-variable .cChooknamecA.item-list-scCxcA "cCregexpcA"
        set-variable .cChooknamecA.item-list-rcCxcA "cCreplacecA"

    Where:-

    cChooknamecA
        The name of the file hook i.e. cGfhook-ccA for ANSI 'C'.

    cCxcA
        The search number, this is valid in the range 1..9, commencing from 1.
        The search is processed in the order of the numeric identity.

    cCregexpcA
        The regular expression to search for. One of the arguments must
        include a groups cG\(..\)cA definition to allow the string to be moved to
        the replace.

    cCreplacecA
        The replace string, this typically includes a cCtypecA and part of the
        search string.

    On invocation of cDitem-listcA the buffer is searched and the results are
    presented in the cG*item-list*cA window appearing at the left-hand side of the
    window. If there is no item list set up for the file type then an error
    message is displayed.

    The user may interact with the cG*item-list*cA buffer using the mouse or
    cG<RETURN>cA, on selecting a line then the user is moved to the corresponding
    line in the original buffer.

    cDitem-list-findcA finds the current item list item and searches for the text
    in the original buffer. This is typically bound to a mouse or key stroke
    action.

    cDitem-list-closecA closes the item list buffer.


cEcEEXAMPLE cEcA


    The following example works through the cDitem-listcA definition for the ME
    macros e.g. given that the ME macro definition is:

        define-macro macro-name


    Searching for "cGdefine-macro \([a-z-]+\)cA" and replacing with "cGMacro \1cA"
    will work most of the time. The space between cGdefine-macrocA and the name
    does not have to be a single space and the cCnamecA does not have to contain
    just lower case letters, so these search strings should be a flexible as
    possible, try

        "define-macro\s +\(\w+\)"


    This however is not as optimal as it could be and if you have large files
    this could become slow. Performance can be greatly increased if it can be
    anchored to the start of the line, e.g.

        "^define-macro\s +\(\w+\)"


    but to allow for initial white spaces and the optional numeric argument,
    you really need

        "^\s *[0-9]*\s *define-macro\s +\(\w+\)"


    To hilight the function name you need the name encased the name in a magic
    hilighting string,

        "\ecBmacro-name\ecA"


    where cG\ecA is an escape char, so the replace string should be

        "Macro \ecB\1\ecA"


    Now all thats needed is to set these variables as fhook command variables,
    for macro files, the file hook command is cGfhook-emfcA, therefore the
    following is required:
sB
        set-variable .fhook-emf.item-list-s1 "^\\s *[0-9]*\\s *define-macro\\s +\\(\\w+\\)"
        set-variable .fhook-emf.item-list-r1 "Macro \ecB\\1\ecA"

sA
    Note that you can have as many of these search and replace variables as
    you require, i.e. cG.item-list-s1cA, cG.item-list-s2cA, cG.item-list-s3cA, ... ; but
    the more you have the slower it will be, often a good regex can do the job
    of 2 or 3.


cEcESEE ALSO cEcA


    lslmoccur(3)le, lslmsearch-forward(2)le, lsRegularExpressions(2)lmRegular Expressionsle
! 3 comment-line
! 3 uncomment-line
! 3 comment-to-end-of-line
! 3 comment-restyle
! 3 comment-start
! 3 comment-end
cEcENAME cEcA


|comment-line
    comment-line - Comment out the current line
|uncomment-line
    uncomment-line - Uncomment current line
|comment-to-end-of-line
    comment-to-end-of-line - Extend comment to end of line
|comment-restyle
    comment-restyle - Reformat the current comment
|comment-start
    comment-start - Start a new comment
|comment-end
    comment-end - End the current comment
$a


cEcESYNOPSIS cEcA


    cCncA cDcomment-linecA
    cCncA cDuncomment-linecA

    cDcomment-to-end-of-linecA
    cDcomment-restylecA

    cDcomment-startcA
    cDcomment-endcA


cEcEDESCRIPTION cEcA


    The action of the cDcommentcA commands are file type specific (comments in cDCcA
    are cG/* ... to ... */cA where as MicroEmacs macro file comments are cG; ... to
    the end of linecA) so the commands must be configured for each file type
    (see the NOTES section below). The configuration is automatically
    performed by almost all the standard file hooks released with MicroEmacs
    by the file hook so these commands should be fully functional.

    cDcomment-linecA comments out the current and next cCncA-1 lines (default when cCncA
    is omitted is to comment out just the current line). The cursor is then
    moved to the start of the next line. cDuncomment-linecA behaves differently
    depending on whether the file type terminates a comment with an end token
    or simply by the end of the line. If an end token is used then
    cDuncomment-linecA removes the current and next cCncA comments. If the end of line
    is used cDuncomment-linecA removes the first comment on the current and next
    cCn-1cA lines.

    cDcomment-to-end-of-linecA inserts cCcomment-padcAs (see NOTES) up-to the
    lslm$buffer-fill-col(5)le and then terminates the comment with the cCcomment-endcA
    string. cDcomment-restylecA reformats the text within the comment, filling
    text lines to the cD$buffer-fill-colcA and regenerating any boxing and divide
    lines.

    cDcomment-startcA opens a new "cD*comment*cA" buffer which is configured for
    writing a text comment, the user can then type in the comment with all the
    benefits of MicroEmacs in a plain text editor. Once the comment is
    complete use the cDcomment-endcA command to insert the comment into the source
    file, this comment is locally bounded to "cDC-c C-ccA". The styling of the
    comment is controlled by the cCcomment-flagcA setting (see NOTES).


cEcENOTES cEcA


    Consider the structure of a box comment to be as follows:

        <comment-start><comment-pad><comment-pad><comment-pad><comment-box-right>
        <comment-box-left> COMMENT TEXT ... COMMENT TEXT      <comment-box-right>
        <comment-box-left> COMMENT TEXT ... COMMENT TEXT      <comment-box-right>
        <comment-box-left><comment-pad><comment-pad><comment-pad><comment-end>


    The comment commands are configured by the single file hook command
    variable cD.fhook-cAcC<type>cAcD.commentcA where cC<type>cA is the file type label. The
    structure of the variable is a ls&ldel(4)lmlistle with the following format:

            |<comment-start>|<comment-end>|<comment-pad>|<comment-box-left>|...
                ...<comment-box-right>|<comment-flags>|


    Where cG|cA is the list divide character. The cC<comment-flags>cA are a list of
    character flags which are defined as follows:

    cGbcA
        Box format required, i.e. create right edge using cC<comment-box-right>cA.

    cGfcA
        Footer line required.

    cGFcA
        Fill footer line with cC<comment-pad>cA strings.

    cGhcA
        Header line required.

    cGHcA
        Fill header line with cC<comment-pad>cA strings.

    cGjcA
        Enable Justify mode in *comment* buffer.

    cGrcA
        A restyle key binding is added to the buffer "cGesc ocA" and "cGesc qcA"
        buffer key bindings are added and bound to lslmcomment-restyle(3)le.


cEcEEXAMPLE cEcA


    The following cDcommentcA is the standard cDCcA setting:
sB
        set-variable .fhook-c.comment "|/*| */|*| * | * |f|"

sA
    This can be used to create comments of the form:

        /* comment-line comments out the current and next n-1 lines (default
         * when n is omitted is to comment out just the current line). The
         * cursor is then moved to the start of the next line.
         *
         * uncomment-line behaves differently depending on whether the file
         * type terminates a comment with an end token or simply by the end
         * of the line.
         */


    A box style comment can be generated by changing the cC<comment-flags>cA form
    cGfcA to cGbfFhHcA, producing:

        /*********************************************************************
         * comment-line comments out the current and next n-1 lines (default *
         * when n is omitted is to comment out just the current line). The   *
         * cursor is then moved to the start of the next line.               *
         *                                                                   *
         * uncomment-line behaves differently depending on whether the file  *
         * type terminates a comment with an end token or simply by the end  *
         * of the line.                                                      *
         *********************************************************************/


cEcESEE ALSO cEcA


    lslmbuffer-init(3)le, lsfileHooks(2)lmFile Hooksle.
! 3 display-matching-fence
cEcENAME cEcA


    display-matching-fence - Display the matching bracket
$a


cEcESYNOPSIS cEcA


    cCncA cDdisplay-matching-fencecA


cEcEDESCRIPTION cEcA


    cDdisplay-matching-fencecA draws the fence (or bracket) pairing the one the
    cursor is currently over. A fence is considered to be one of the
    following:

        {...}   (...)   [...]


    If the matching fence is currently being drawn (i.e. it is visible) both
    fences are drawn in the 'cCNormalcA' Matching Fence scheme (see
    lslmscheme-editor(3)le). If the matching fence is not currently visible the
    cursor is temporarily moved to the matching fence for lslm$pause-time(5)le
    milliseconds before returning to the starting position, the fences are
    hilighted using the Matching Fence 'Current' scheme. The matching fence
    delay can be interrupted by pressing any key. If the fence cannot be
    matched the fence is hilighted using the 'Select' scheme which is usually
    a bold red color.

    The numeric argument cDncA passed to the command is a bitwise flag where each
    bit is defined as follows:

    cD0x01cA
        Display fence (if not set nothing is done).

    cD0x02cA
        Use set-position id 'cG\x85cA' instead of 'cG\x84cA' (for internal use).

    cD0x04cA
        Don't Jump when matching fence is off screen.

    cD0x08cA
        Jump when closing a fence and its pair is off screen (for internal
        use).

    cD0x10cA
        Always jump to matching fence when closing a fence (for internal use).

    cD0x20cA
        Give preference to closing fence to left of cursor rather than
        character under the cursor (for internal use).


cEcENOTES cEcA


    This macro is used by the cDFence DisplaycA setting of lslmuser-setup(3)le, the
    macro is bound to the cGidle-pickcA event using some of the more obscure
    numeric argument flags.


cEcESEE ALSO cEcA


    lslmgoto-matching-fence(2)le, lslmuser-setup(3)le, lslmscheme-editor(3)le, lslm$pause-time(5)le.
! 3 expand-look-back
cEcENAME cEcA


    expand-look-back - Complete a word by looking back for a similar word
$a


cEcESYNOPSIS cEcA


    cDexpand-look-backcA


cEcEDESCRIPTION cEcA


    cDexpand-look-backcA attempts to complete the word at the current position by
    looking backward for another word which starts the same. If such a word is
    found within 100 lines of the current cursor position the current partial
    word is replaced with the word found.

    cDexpand-look-backcA is automatically invoked from the lslmexpand-abbrev-handle(3)le
    macro in response to an expansion command, it is only invoked if enabled
    in the lslmuser-setup(3)le => General => Abbrev Expansion => Lookbk setting is
    enabled.


cEcENOTES cEcA


    cDexpand-look-backcA is a macro implemented in cGabbrev.emfcA.

    The cDuser-setupcA configuration simply sets the macro variable
    cG.expand-look-back.oncA to TRUE, i.e.:
sB
        set-variable .expand-look-back.on 1

sA
    It may be subsequently disabled by setting the variable back to 0.


cEcESEE ALSO cEcA


    lslmexpand-abbrev-handle(3)le, lslmuser-setup(3)le.
! 3 string-rectangle
! 3 space-rectangle
cEcENAME cEcA


|string-rectangle
    string-rectangle - Add a string vertically.
|space-rectangle
    space-rectangle - Adds space(s) vertically.
$a


cEcESYNOPSIS cEcA


    cDstring-rectanglecA "cCstringcA"
    cCncA cDspace-rectanglecA


cEcEDESCRIPTION cEcA


    cDstring-rectanglecA inserts the cCstringcA at the same column position on each
    line of the current region. The command prompts the user for a string and
    inserts it at the current cursor column on all the lines between the
    cursor and the mark inclusive. This is generally used to pre-pend lines
    with new text.

    cDspace-rectanglecA is the same as cDstring-rectanglecA except it inserts cCncA
    spaces, default being 1, rather than a given cCstringcA. This command is very
    useful when moving a column of text over to align with another column.


cEcESEE ALSO cEcA


    lslmexchange-point-and-mark(2)le, lslminsert-space(2)le, lslmkill-rectangle(2)le,
    lslmset-mark(2)le, lslmyank-rectangle(2)le.
! 3 buffer-init
! 3 buffer-init-hooks
! 3 buffer-init-fhook
cEcENAME cEcA


|buffer-init
    buffer-init - Initialize a buffer language template.
|buffer-init-hooks
    buffer-init-hooks - Initialize the buffer language template hooks.
|buffer-init-fhook
    buffer-init-fhook - Initialize the buffer file hooks.
$a


cEcESYNOPSIS cEcA


    cCncA cDbuffer-initcA cCnamecA [cCetfcA]
    cDbuffer-init-hookscA
    cDbuffer-init-fhookcA cCnamecA


cEcEDESCRIPTION cEcA


    The cDbuff-initcA commands prepare the operating modes of a buffer for a
    language template. These commands operate with variables defined in the
    template and automatically configure MicroEmacs to use the template.

    The commands are used in the hook files (hkXXX.emf - see lsfileHooks(2)lmFile Hooksle) and
    simply the setting up of lslanguageTemplates(2)lmFile Language Templatesle by automating common
    actions and integrating the configuration settings made via
    lslmbuffer-setup(3)le.

    The hook file is declared from cGme.emfcA or the user start up file binding a
    file extension or magic string association with the hook file. i.e.
sB
            -1 add-file-hook "-[*!]-[ \t]*XXX.*-[*!]-"    fhook-XXX
             1 add-file-hook "^#!/.*XXX"                  fhook-XXX

sA
    On loading a file which matches the lslmadd-file-hook(2)le definition then the
    cGhkXXX.emfcA file is executed and the template is applied to the file.

    A basic template framework to be used with the cDbuff-initcA commands may be
    defined as follows for a language template called cCXXXcA:-
sB
        ; File hook - initialize buffer on loading the file.
        define-macro fhook-XXX
            set-variable $buffer-mask "luh1"
            @# buffer-init "XXX"
            buffer-init-hooks
        !emacro

        ; buffer-init variables
        set-variable .fhook-XXX.name "XXX Macro"
        set-variable .fhook-XXX.setup &reg "/history/fhook/XXX" "bdfghnopx"
        set-variable .fhook-XXX.setup-mask "abdefghikmnoptux"
        ; Commenting configuration -- omit if not defined.
        set-variable .fhook-XXX.comment "|#||#|# | #||"
        ; Additional commands -- omit if not defined.
        set-variable .fhook-XXX.command-flag  "||"
        set-variable .fhook-XXX.command-name  "||"
        set-variable .fhook-XXX.command-nbind "||"
        set-variable .fhook-XXX.command-kbind "||"
        set-variable .fhook-XXX.command-desc  "||"
        ; OR define the commands one per line uniquely numbered from 0.
        set-variable .fhook-XXX.command-0  "|bo||xxx-para|esc o||"
        set-variable .fhook-XXX.command-1  "|bo||xxx-para|esc q||"
        ; Define additional buffer setup menu items -- omit if not defined
        set-variable .fhook-c.setup-flags   "|c|l|"
        set-variable .fhook-c.setup-labels  "|Option 1|Option 2|"
        ; Set up collapse or folding for XXX -- omit if not defined
        set-variable .fhook-XXX.collapse-open  "^{"
        set-variable .fhook-XXX.collapse-close "^}"
        set-variable .fhook-XXX.collapse-mopen  "-1"
        set-variable .fhook-XXX.collapse-mclose "1"
        set-variable .fhook-XXX.collapse-mnext "-1"
        ; setup XXX item-list -- omit if not defined
        set-variable .fhook-XXX.item-list-s1 "^[ \t]*func\\(\\w+\\)"
        set-variable .fhook-XXX.item-list-r1 "^[ \t]*end"
        ; Set up hilighting
        !if &and &sin "h" .fhook-XXX.setup &band .hilight.flags 0x02
            ; Hi-light XXX Mode
            !if &not &exi .hilight.XXX
                set-variable .hilight.XXX &pinc .hilight.next 1
            !endif

            0 hilight .hilight.XXX  2 50
            hilight .hilight.XXX 0 "#.*"          .scheme.comment
            hilight .hilight.XXX 1 "end"          .scheme.keyword
            hilight .hilight.XXX 1 "^[ \t]*func" .scheme.function
            ; ... more ...

            ; Hilight numbers.
            !if &band .hilight.flags 0x08
                ; hilight constants, e.g. numbers
                hilight .hilight.XXX 1 "[[:digit:]]+"       .scheme.constant
                hilight .hilight.XXX 1 "-[[:digit:]]+"      .scheme.constant
                hilight .hilight.XXX 1 "0[xX][[:xdigit:]]+" .scheme.constant
                hilight .hilight.XXX 1 "[[:digit:]]+\.[[:digit:]]+"  .scheme.constant
                hilight .hilight.XXX 1 "-[[:digit:]]+\.[[:digit:]]+" .scheme.constant
                hilight .hilight.XXX 1 "[[:digit:]]+\.[[:digit:]]+f"  .scheme.constant
                hilight .hilight.XXX 1 "-[[:digit:]]+\.[[:digit:]]+f" .scheme.constant
            !endif
        !endif

        ; End the initialisation - call user extensions i.e. myXXX.emf
        buffer-init-fhook "XXX"

sA
    cDbuffer-initcA is invoked from the buffer file hook lsfileHooks(2)lmfhookle and is invoked with
    the numerical argument passed to the cCfhookcA macro (specified as cG$#cA). The
    call takes two arguments, the first is the cCnamecA of the template or hook,
    in the example this is cCXXXcA. The second argument is the cCetfcA template name
    (see lslmetf(8)le). The command initializes the buffer, using the cC.fhook-XXXcA
    variable information defined in the file.

    cDbuffer-init-hookscA is invoked from the buffer file hook lsfileHooks(2)lmfhookle typically
    following the cDbuffer-initcA call this macro invokes any user defined file
    hooks of the form cDmy-fhook-XXXcA. User defined cDmy-bhook-XXXcA and cDmy-ehook-XXXcA
    are configured into the buffer space ready for execution.

    cDbuffer-init-hookscA must be placed in all cDfhook-XXXcA macros to correctly
    initialize the file hooks. If this is not added then the "cGmy-*hook-alwayscA"
    macros may not be called correctly for buffers where the cDfhook-XXXcA has not
    been configured correctly.

    cDbuffer-init-fhookcA is placed at the end of the hook file definition and
    retrieves additional configuration information from the registry and the
    user settings, it will also locate and load any user additions to the
    template by loading the file cGmyXXX.emfcA.

    A set of global default file hooks may be defined of the form
    cDmy-fhook-alwayscA, cDmy-bhook-alwayscA, cDmy-ehook-alwayscA and cDmy-dhook-alwayscA.
    These file hooks are global and invoked after the


cEExecution Sequence cA


    It is important to understand the execution sequence of the buffer hook
    files. On identifying a new file hook then the cGhkXXX.emfcA file is fetched
    from the file system and executed. Execution causes all of the variables
    to be defined and finally, when all definitions have been made,
    cDbuffer-init-fhookcA is executed to load in any user defined extensions. At
    this point then the macro cDfhook-XXXcA has ONLY been defined it has NOT been
    executed. This load operation is performed once only and is on demand.

    The cDfhook-XXXcA macro must be defined BEFORE any of the variables associated
    with the hook as all subsequent variables are command variables and are
    defined in the context of the macro definition. See lslmVariables(4)le for more
    information on macro variables.

    cDfhook-XXXcA is invoked to apply hilighting, buffer key bindings, indentation
    etc. to a new buffer which has just been created.

    cDehook-XXXcA is invoked when a buffer is swapped out. This may be used to
    save global variables that have been modified in the context of the
    buffer.

    cDbhook-XXXcA is invoked when a buffer is swapped in. This may be used to
    restore variables that are specific to a buffer to global variables.

    cDdhook-XXXcA is invoked before a buffer is deleted. This may be used to clean
    up a buffer before it is destroyed.

    cDExtended file hookscA
    The buffer hooks cG[fbed]hook-XXXcA may be extended by user specific
    configuration in the form cGmy-[fbed]hook-anycA, these are invoked after the
    primary hook as been invoked and operate on all buffers rather than a
    specific buffer type. The cCmy-*hook-alwayscA mechanism is provided by the
    cCbuffer-initcA macros of cGbuffinit.emfcA rather than from the base command set
    of MicroEmacs.


cEConfiguration Masks cA


    Buffer initialization is controlled by the settings of the variables
    cD.fhook-XXX.setupcA and cDfhook-XXX.setup-maskcA:-
sB
        set-variable .fhook-XXX.setup &reg "/history/fhook/XXX" "bdfghnopx"
        set-variable .fhook-XXX.setup-mask "abdefghikmnoptux"

sA
    The variables use an ASCII configuration string that identifies the modes
    of operation that are required. Upper and lower case alternatives are
    presented, an uppercase flag disables the mode, lower case enables. Where
    the flag is not specified then the mode is not changed.

    cGacA - Auto mode
        Configure lslmauto(2m)le mode for automatic source file line type detection.
        Typically enabled for text files.

    cGbcA - Abbreviation mode
        Configures the abbreviation mode using lslmbuffer-abbrev-file(2)le for the
        buffer.

    cGccA - View / Author mode
        Configure lslmview(2m)le mode for read only or authoring.

    cGdcA - Auto indentation operation.
        Automatic indent is enabled using lslmindent(2)le.

        Where lslmindent(2m)le mode is required then omit the cGdcA flag and use flag cGicA
        instead.

    cGecA - Exact or case sensitivity operation
        Configure lslmexact(2m)le case sensitive mode. cGecA enable exact, cGEcA disable
        exact.

    cGfcA - Folding/Collapsing operation
        Configures folding support, if enabled then the variables
        cC.fhook-XXX.collapse-OPERATIONcA, should be defined to declare the
        folding points.

    cGgcA - Fence matching operation
        Configure fence matching mode with lslmfence(2m)le. Note that fence matching
        is now typically performed in the macro environment using
        lslmdisplay-matching-fence(3)le rather than the in-built fence matching.
        This colorizes the fences that are matched. cGgcA enable fence matching, cGGcA
        disable fence matching.

    cGhcA - Hilighting
        Support syntax hilighting, when defined then the hilighting scheme
        defined by cC.hilight.XXXcA is attached to the buffer.

    cGicA - Automatic indentation
        Support indentation using lslmindent(2m)le. Automatic indentation (see
        lslmindent(2)le) is defined with the cGdcA flag. cGicA enables indent, cGIcA disables
        indent.

    cGjcA - Justify
        Configure paragraph justification using lslmjustify(2m)le. cGjcA enable justify,
        cGJcA disable justify.

    cGkcA - Backup mode
        Configure backups with lslmbackup(2m)le mode. cGkcA enable backup, cGKcA disable
        backup.

    cGmcA - Magic mode
        Configure regular expression lslmmagic(2m)le mode. cGmcA enable magic, cGMcA disable
        magic.

    cGncA - New buffer header
        Enable the insertion of a buffer header from the lslmetf(8)le template file.

    cGocA - Tool menu
        Enable the tool menu for the buffer.

    cGpcA - Help page
        Produce a help page for the buffer describing the bindings.

    cGscA - Auto spell
        Configure automatic spelling for the buffer using lslmauto-spell(3)le.

    cGtcA - Tab mode
        Configure insertion of literal tabs by enabling lslmtab(2m)le mode. cGtcA enable
        tab, cGTcA disable tab.

    cGucA - Undo
        Configure the undo/redo history using lslmundo(2m)le mode. cGucA enable undo, cGUcA
        disable undo.

    cGwcA - Wrap
        Configure wrapping using lslmwrap(2m)le mode. cGwcA enable wrap, cGWcA disable wrap.

    cGxcA - Time stamping
        Configure time stamping as defined by lslmtime(2m)le.

    cG1cA - Reformatting hilighting
        A special internal flag indicating that hilighting is used for
        reformatting purposes, i.e. to make readable and hide control text.

    cG#cA - Commenting
        Special flag used to indicate commenting is supported. The comment
        format should be defined with the cC.fhook-XXX.commentcA variable within
        the template.

    cD.fhook-XXX.setupcA is the current set-up, this is normally defined to take
    settings from the registry providing a default when not defined. This is
    the only mask that is allowed to include the uppercase flags. All values
    defined in cD.fhook-XXX.setupcA are explicitly enabled or disabled by default.
    The setup set should contain the configuration flags that are required to
    make the template operate correctly, but should not include modes that the
    user may set up i.e. cCexactcA or cCmagiccA etc.

    cD.fhook-XXX.setup-maskcA defines the set of flags that are allowed with the
    template. The configuration defined in lslmbuffer-setup(3)le is tested against
    the mask, if the mask allows it then the mode is enabled. cD.fhook-XXX.setupcA
    is generally a subset of cD.fhook-XXX.setup-maskcA.

    lslmbuffer-setup(3)le operates with the values defined by cD.fhook-XXX.setupcA and
    cD.fhook-XXX.setup-maskcA. The initialization of cD.fhook-XXX.setupcA is performed
    using the registry as follows:-
sB
        set-variable .fhook-XXX.setup &reg "/history/fhook/XXX" "bdfghnopx"

sA
    This allows the user to configure over-ridding modes via lslmbuffer-setup(3)le.
    The user configuration is saved to the lslmRegistryle and restored using
    lslm&reg(4)le, when the variable is defined. The flags that are defined by
    lslmbuffer-setup(3)le include cGacA, cGbcA, cGccA, cGdcA, cGecA, cGfcA, cGgcA, cGhcA, cGicA, cGjcA, cGkcA, cGmcA, cGncA, cGocA, cGpcA, cGscA, cGtcA,
    cGucA, cGwcA, and cGxcA.


cETags cA


    The buffer setup may be configured to add a tags generator to the language
    template, this is added to the menu. The tags generation is declared in
    the template by assigning the variable cD.fhook-XXX.tagscA with a command line
    to run tags utility. The command line string should commence with a cG!cA
    character to tell MicroEmacs to execute an external command, for example
    to use the GNU cDctags(2)cA utility is defined as:-
sB
        set-variable .fhook-c.tags "!ctags *.c *.h"

sA
    When the value starts with a 'cG!cA' then rest of the line is spawned as a
    process, no additional interface is provided to the command.

    Some language templates include a macro cCtagscA facility to generate a tags
    file (See lslmemftags(3f)le - cGemftags.emfcA, lslmctags(3f)le - cGctags.emfcA, lslmntags(3f)le -
    cGntags.emfcA). cD.fhook-XXX.tagscA may be defined to use an internal macro based
    tags generator rather than an external command. Without the 'cG!cA' character
    the command line is assumed to be an MicroEmacs macro based and runs the
    command

        me @<.tags-var-value> -v%tag-options=<options>


    A macros based command line for the 'C' Programming Language is defined
    as:-
sB
        set-variable .fhook-c.tags "ctags"

sA
    The presence of a tags generator is not flagged in the setup flags,
    declaration of the cD.fhook-XXX.tagscA variable is sufficient to declare that
    a tags generator exists.


cEPrivate Configuration Extensions cA


    The cD.fhook-XXX.setupcA may be extended to include local configuration items
    that are private to a specific buffer. The extensions are added to the
    lslmbuffer-setup(3)le menu and provide an on/off check-box control to enable and
    disable specific buffer features. Feature examples include: Enable or
    disable Doxygen highlighting in a buffer, control hidden file names in a
    directory listing etc.

    The configuration extensions are defined using two additional hook
    variables, these variables are normally omitted and only defined if the
    extensions are required.

    cD.fhook-XXX.setup-flagscA
        Defines the alphabetic [cGa-zcA] setup characters that are used to enable
        or disable a feature. These are defined as MicroEmacs list variables
        (see lslm&lfind(4)le, lslm&lget(4)le, etc. for the full syntax definition). The
        characters that may be used are those that are not used by buffer
        setup i.e. "cGclqrvyzcA"

    cD.fhook-XXX.setup-labelscA
        Defines the text labels that are added to the setup menu, the label is
        associated with the enable button.

    To add a new feature switch then the the character flags to hold the state
    are are defined with the cD.fhook-XXX.setup-flagscA and
    cD.fhook-XXX.setup-labelscA. The characters defined with the cDsetup-flagscA
    should be added to cD.fhook-XXX.setup-maskcA. If the option is to be enabled
    by default then the enabling character is added to cD.fhook-XXX.setupcA.

    To enable/disable the features then lslmbuffer-setup(3)le when invoked modifies
    the state of the variable cD.fhook-XXX.setupcA and then executes the buffer
    hook again causing the new state to be processed and applied. The modified
    cD.fhook-XXX.setupcA value is stored in the user registry and is applied
    thereafter when the specified buffer type is loaded.

    Within the template definition then the additional flags are checked by
    testing the state of the cD.fhook-XXX.setupcA variable. An example is shown
    below.
sB
        ; Add the extra variable to the buffer-init variables
        ; Option 1 is disabled and Option 2 is enabled by default here.
        set-variable .fhook-XXX.setup &reg "/history/fhook/XXX" "bdfghnopxl"
        set-variable .fhook-XXX.setup-mask "abdefghikmnoptuxcl"

        ; Define the additional options.
        set-variable .fhook-XXX.setup-flags   "|c|l|"
        set-variable .fhook-XXX.setup-labels  "|Option 1|Option 2|"

        ; Test for the Option 1 being enabled.
        !if &sin "c" .fhook-XXX.setup
            ; Do Option 1 configuration.
        !endif

        ; Test for the Option 2 being enabled.
        !if &sin "l" .fhook-XXX.setup
            ; Do Option 2 configuration.
        !endif

sA
    The templates cGhkc.emfcA, cGhkcpp.emfcA and cGhkjava.emfcA include private extensions
    which may be used as examples.


cEComments cA


    The format of comments may be defined in the template using the
    cD.fhook-XXX.commentcA variable. Definition of the comment form allows the
    comment formatting to be automatically set up. Where the comment format is
    defined then the following key bindings are automatically added to the
    template:-

        cGC-c C-scA cDcomment-startcA - start a new comment.
        cGC-c C-ccA cDcomment-linecA - comment out the current line.
        cGC-c C-dcA cDuncomment-linecA - remove commenting from current line.
        cGC-c C-ecA cDcomment-to-end-of-linecA - comment to end of line.
        cGC-c C-rcA cDcomment-restylecA - format/re-style comment.

    Help information is automatically added to the buffer to describe the key
    bindings if help information is enabled.

    The default comment format is defined with the variable cD.fhook-XXX.commentcA
    with an argument string in the form "cD|cA cC<comment-start>cA cD|cA cC<comment-end>cA cD|cA
    cC<comment-pad>cA cD|cA cC<mid-box-left>cA cD|cA cC<mid-box-right>cA cD|cA cC<comment-flags>cA cD|cA".
    Where a language supports multiple comment types, or styles, then
    additional comment styles may be specified with a comment definition of
    the form cD.fhook-XXX.comment-NcA where cDNcA is an integer from cG1cA to cGncA. Each
    definition defines an different comment style. Additional comment
    definitions should be ordered such that the longest or most definitive
    comment definition appears before other comment definitions which have
    less definitive features. The comment matching searches each of the
    comment definitions in the order cG1cA to cGncA to determine the comment style, as
    soon as a positive match is located then the comment is used without
    searching the remaining comments.

    The fields of the comment definition are defined as follows:-

    cC<comment-start>cA
        The format of the start of the comment or comment open syntax.

    cC<comment-end>cA
        The format of the closing comment, where the comment exists to the end
        of the line then the field is defined as empty. Leading white space
        should be included where this affects the horizontal positioning of
        the comment, white leading space is ignored in any match i.e. "cG */cA"
        for C type comments.

    cC<comment-pad>cA
        The character to use to pad a comment between the cC<comment-start>cA and
        cC<comment-end>cA characters when creating a line or a box formation.

    cC<mid-box-left>cA
        The start of a comment continuation line when creating a box comment.

    cC<mid-box-right>cA
        The end of a comment continuation line when creating a box comment and
        the comment is not closed and continues on the next line.

    cC<comment-flags>cA
        The comment flags define how the comment should be formatted when
        re-styled. The flags are defined as single characters that describe
        the attributes. Re-styling may include the following attributes:-

        cDb cA
            Box format required, create a left and right edge for the comment.

        cDf cA
            A footer line is required, a new line is created following the
            comment text to contain the with a closing comment cC<comment-end>cA
            string. The end of comment is not padded.

        cDF cA
            As cDfcA except the footer line is left padded with cC<comment-pad>cA
            strings.

        cDh cA
            A header line is required, a new line is created before the
            comment text to contain the opening comment cC<comment-start>cA
            string. The end of comment is not padded.

        cDH cA
            As cDhcA except the header line is right padded with cC<comment-pad>cA
            strings.

        cDj cA
            Enable justification mode in the *comment* buffer and re-style.

        cDr cA
            A restyle key binding is added to the buffer "cGesc ocA" and "cGesc qcA"
            buffer key bindings are added and bound to lslmcomment-restyle(3)le. The
            cDrcA flag is only processed from the

    Examples of the comments format are shown below.

    cD'C' Programming language cA
        Format: cG/* ... */cA
sB
            set-variable .fhook-c.comment "|/*| */|*| * | * |f|"

sA
        The comment output is defined as:-

            /***************************************************************
             * This is a box comment                                       *
             ***************************************************************/

            /* Comment to end of line **************************************/


    cDC++ Programming language cA
        Format: cG// ... <EOL>cA
sB
            set-variable .fhook-cpp.comment "|//||/|// | //||"

sA
        The comment output is defined as:-

            /////////////////////////////////////////////////////////////////
            // This is a box comment                                       //
            /////////////////////////////////////////////////////////////////

            // Comment to end of line ///////////////////////////////////////


        C++ supports both C and C++ comment styles, both styles may be defined
        in the language template. For C++ then cG//cA is assumed to be the default
        style.
sB
            set-variable .fhook-cpp.comment   "|//||/|// | //||"
            set-variable .fhook-cpp.comment-1 "|/*| */|*| * | * |f|"

sA
    cDMicroEmacs macro language cA
        Format: cG; ... <EOL>cA
sB
            set-variable .fhook-emf.comment "|;||;|; | ;||"

sA
        The comment output is defined as:-

            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
            ; Box Comment                                                   ;
            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

            ; Comment to end of line ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


    cDShell script cA
        Format: cG# ... <EOL>cA
sB
            set-variable .fhook-shell.comment "|#||#|# | #||"

sA
        The comment output is defined as:-

            #################################################################
            # Box Comment                                                   #
            #################################################################

            # Comment to end of line ########################################


    cDMS-DOS Batch file cA
        Format: cGrem ... <EOL>cA
sB
            set-variable .fhook-dos.comment "|rem |||rem |||"

sA
        The comment output is defined as:-

            rem
            rem Box Comment
            rem

            rem Comment to end of line


cECommands and Key Bindings cA


    Local buffer commands and key bindings for over-riding key definitions
    used within the buffer are defined with the cGfhook-XXX.command-*cA variables.
    These are defined as MicroEmacs list variables (see lslm&lfind(4)le, lslm&lget(4)le,
    etc. for the full syntax definition) and define a list of keys, commands
    and bindings. Each command is typically separated by the 'cG|cA' character.
    The field order in all of the cGfhook-XXX.command-*cA variables MUST be
    consistent, so if a command is defined in field 5, then all definitions
    associated with that command MUST be defined in field 5 for all variables.

    To make the command definitions easier then the syntax cGfhook-XXX.command-ncA
    may be used where cCncA is an integer from cC0..n-1cA. The cGfhook-XXX.command-ncA
    statements are used to construct the cGfhook-XXX.command-*cA lists, the
    advantage being that the command and key bindings etc. are defined
    together. Once the cGcommand-ncA variables are processed then they are deleted
    from the environment. The general syntax of the cGcommand-ncA variable is
    defined as a list:

        cG|command-flag|command-nbind|command-name|command-kbind|command-desc|cA

    The command variables are defined as follows:-

    cC.fhook-c.command-flagcA
        A configuration flag that defines the components to use for the
        command. The flags are set as individual characters and are defined as
        follows:-

        cGtcA - Toolbar
            Show the command in the toolbar. The cG.fhook-XXX.command-desccA
            variable should contain a readable name for the command to display
            in the menu. An optional hot key for selection in any lsosd(2)lmosdle is
            specified by prefixing the character in the string with cG\HcA.

        cGhcA - Help Screen
            Show the command in the help screen. The cG.fhook-XXX.command-desccA
            variable should contain a readable name for the command to display
            in the menu. An optional hot key for selection in any lsosd(2)lmosdle is
            specified by prefixing the character in the string with cG\HcA.

        cGbcA - Key binding
            Create a buffer key binding for the command, the key to bind is
            defined by the variable cGfhook-XXX.command-kbindcA, if the command
            requires a numerical argument then this is defined in the variable
            cGfhook-XXX.command-nbindcA. The binding is only created if the key
            buffer binding does not already exist, the binding may be forced
            by using the cGocA flag. Where a key binding is only to be created if
            hilighting is enabled then the cGbcA flag should be qualified with the
            cGHcA flag.

        cGocA - Forced key binding
            Optionally used with the cGbcA and forces the binding to over-write
            any existing binding.

        cGicA - Emulated key binding
            Used with the cGbcA flag, ignores key bindings that are emulation
            mappings.

        cGHcA - Hilighting key binding
            Used with the cGbcA flag, only performs the key binding if hilighting
            is enabled.

    cC.fhook-XXX.command-namecA
        Specifies the name of the command to execute, this may be a built in
        command of a macro. Typically the command is a local macro defined in
        the hook file.

    cC.fhook-XXX.command-nbindcA
        The value of the numeric argument to pass to the command defined in
        the cC.fhook-XXX.command-namecA field. This field may be empty if no
        numeric argument is required.

    cC.fhook-XXX.command-kbindcA
        The local key binding to bind to the command, this field is only
        interpreted if the cGbcA is specified, otherwise the field may be empty.
        Where multiple key bindings are required to the same command then a
        field definition is required for each binding.

    cC.fhook-c.command-desccA
        A short description of the command that is used for the help page (cGhcA)
        and toolbar (cGtcA). The field may be empty if the field is not specified
        for insertion into the toolbar or help page.

    As an example, two new commands or bindings may be defined for a template,
    the first field is bound to key cGA-qcA which executes macro cGXXX-compcA with a
    numerical argument of 2. The second field binds a new key to
    lslmcomment-restyle(3)le.
sB
        .....

        set-variable .fhook-XXX.command-flag  "|th|bo|"
        set-variable .fhook-XXX.command-name  "|XXX-comp|comment-restyle|"
        set-variable .fhook-XXX.command-nbind "|2||"
        set-variable .fhook-XXX.command-kbind "|A-q|esc o|"
        set-variable .fhook-XXX.command-desc  "|Complete command||"

        .....

        ; Local macro definition to perform command completion
        define-macro XXX-comp
            set-variable #l1 @#
            .....
        !emacro

sA
    The alternative form of definition using the cGcommand-ncA syntax is defined
    as:-
sB
        .....

        set-variable .fhook-XXX.command-0 "|th|2|XXX-comp|A-q|Complete command|"
        set-variable .fhook-XXX.command-1 "|bo||comment-restyle|esc o||"

        .....

        ; Local macro definition to perform command completion
        define-macro XXX-comp
            set-variable #l1 @#
            .....
        !emacro

sA
    The key bindings sometimes need to be protected where they have been
    redefined to perform some other operation for example when emulation modes
    are used (i.e. cDneditcA, cDme3.8cA). The buffer initialisation uses the command
    cDbuffer-bind-createcA and the variables cD.buffer-bind-create.map-fromcA and
    cD.buffer-bind-create.map-tocA which define replacement keys for bindings. As
    an example the cDneditcA emulation mode uses key binding cGC-c C-ccA and provides
    a buffer binding mapping to translate any key buffer binding to a
    different key. i.e.
sB
        ; reconfigure the buffer bindings
        set-variable .buffer-bind-key.map-from "|C-c C-c|C-c C-d|"
        set-variable .buffer-bind-key.map-to   "|C-b|C-u|"

sA

cEInformation Hiding with Collapse cA


    MicroEmacs 2009 provides a generic, albeit coarse, folding mechanism which
    is applied to some of the well known file modes. The folding mechanism
    allows parts of the buffer to be scrolled up and hidden, leaving a residue
    hilighting marker within the buffer indicating a folded region. A folded
    buffer typically allows a summary of the buffer contents to be viewed
    within several windows, hiding the detail of the buffer.

    Note: cDcollapsecA was called cDfoldcA in earlier releases but the name was
    changed when real fold editing support was added, see cGfold.emfcA for more
    information.

    The folding mechanism uses well defined cCstartcA and cCendcA markers which form
    part of the syntax of the well known file mode. i.e. in 'C' this is the
    open and closed braces that appear on the left-hand margin (cG{cA .. cG}cA). The
    intention is that the natural syntax of the text is used to determine the
    fold positions, requiring no additional text formating or special text
    tags to be inserted by the user.

    The language template defines the syntax of blocks of information that may
    be collapsed and hidden with lsnarrow-buffer(2)lmnarrowle. In order to utilize the
    lslmcollapse-current(3)le and lslmcollapse-all(3)le commands within a buffer, the
    cCstartcA and cCendcA markers have to be initialized for the syntactical contents
    of the buffer. The buffer specific variables are defined as follows, where
    cCXXXcA is the file hook base name. The cG.fhook-XXX.collapse-*cA variables define
    the regular expression search pattern and line positioning.

    cD.fhook-cAcCXXXcAcD-collapse-opencA
        A regular expression search string used to locate the start of the
        string. For speed the search string should include a regular
        expression start or end of line character whenever possible. i.e. in C
        the open is defined as "cG^{cA".

    cD.fhook-cAcCXXXcAcD-collapse-closecA
        A regular expression search string used to locate the end of the
        string. For speed the search string should include a regular
        expression start or end line character whenever possible. i.e. in C
        the close is defined as "cG^}cA".

    cD.fhook-cAcCXXXcAcD-collapse-mopencA
        An integer value that denotes the number of lines to move in a forward
        or (negative n) backward direction from the cCstartcA line located by the
        search string to the position in the buffer to be folded. If default
        value when cDmopencA is omitted is 0, starting the fold from the search
        string line.

    cD.fhook-cAcCXXXcAcD-collapse-mclosecA
        The relative displacement from the close fold line to the fold
        position, this is a positive or negative displacement depending on
        where the fold is to be positioned.

    cD.fhook-cAcCXXXcAcD-collapse-mnextcA
        Specifies the number of lines to advance before the next search is
        continued on the fold operation. This is only used by lscollapse-current(3)lmcollapse-allle.

    The following examples show how the collapse variables are set up in each
    of the buffer modes.

    cDC and C++cA
        cDCcA and cDC++cA collapse on the open and close brace appearing in the
        left-hand margin. The collapse variables are defined in cGhkccA/cGhkcpp.emfcA
        as follows:-
sB
            set-variable .fhook-c.collapse-open  "^{"
            set-variable .fhook-c.collapse-close "^}"
            set-variable .fhook-c.collapse-mopen  "-1"
            set-variable .fhook-c.collapse-mclose "1"
            set-variable .fhook-c.collapse-mnext "-1"

sA
        Given a 'C' function definition:-

            static void
            myfunc (int a, int b)
            {
                /* Function body */
            }


        the folded version appears as follows:-

            static void
            myfunc (int a, int b) ... }


    cDemfcA
        MicroEmacs macro files cDemfcA support folding of macro definitions, the
        collapse variables are defined in cGhkemf.emfcA as follows:-
sB
            set-variable .fhook-emf.collapse-open  "^0? ?define-macro[ \t]"
            set-variable .fhook-emf.collapse-close "^!emacro"
            set-variable .fhook-emf.collapse-mclose "1"
            set-variable .fhook-emf.collapse-mnext "-1"

sA
        Given a macro definition:-
sB
            0 define-macro mymacro
            ; This is the body of the macro
            ; ... and some more ...
            !emacro

sA
        the collapsed version of the macro is defined as:-
sB
            0 define-macro mymacro ... !emacro

sA
    cDnroffcA
        cDnroffcA is configured for manual pages only and folds between cG.SHcA and
        cG.SScA sections, the hook variables are defined as follows:-
sB
            set-variable .fhook-nroff.collapse-open  "^\.S[SH]"
            set-variable .fhook-nroff.collapse-close "^\.S[SH]\|\'"
            set-variable .fhook-nroff.collapse-mnext "-1"

sA
        Given an nroff block of text defined as:-

            .SH SYNOPSIS
            .\" Some text
            .\" Some more text
            .SH DESCRIPTION


        Then the collapsed version appears as:

            .SH SYNOPSIS
            .SH DESCRIPTION


    cDtcl/tkcA
        cDtcl/tkcA is configured to collapse procedures. The collapse variables
        are defined as:-
sB
            set-variable .fhook-tcl.collapse-open  "^proc "
            set-variable .fhook-tcl.collapse-close "^}"
            set-variable .fhook-tcl.collapse-mclose "1"
            set-variable .fhook-tcl.collapse-mnext "-1"

sA
        Given a tcl procedure definition:-

            proc tixControl:InitWidgetRec {w} {
                upvar #0 $w data

                tixChainMethod $w InitWidgetRec

                set data(varInited)   0
                set data(serial) 0
            }


        The collapsed version of the same section appears as:-

            proc tixControl:InitWidgetRec {w} { ... }


    Where folding is required using lslmfold-open(3)le then the collapse methods
    above are not enacted when folding is enabled. Folding may be enabled as
    defined by the lsfileHooks(2)lmFile Hooksle, alternatively the folding may be explicitly
    defined using the variable cC.fhook-XXX.foldcA. The cC.fhook-XXX.foldcA variable
    argument is defined as "cD|cA cC<literal-open>cA cD|cA cC<literal-close>cA cD|cA
    cC<comment-termination>cA cD|cA cC<regex-find-open>cA cD|cA cC<regex-find-close>cA cD|cA. Where
    the fields are defined as follows:-

    cC<literal-open>cA
        The literal fold open string.

    cC<literal-close>cA
        The literal fold close string.

    cC<comment-termination>cA
        The comment termination string.

    cC<regex-find-open>cA
        The regular expression to find an open fold.

    cC<regex-find-close>cA
        The regular expression to find a close string.

    As an example, a language may have the following syntax for defining
    folds:-

        /* {{{ This is an example fold. */
        This is
        the body
        of the fold
        /* }}} */


    The fold is defined as follows:-
sB
        set-variable fhook-XXX.fold "|/\\* {{{|/\\* }}}|\\*/|/\\*[ \t]*{{{|/\\*[ \t]*}}}|"

sA

cEItem Lists cA


    lsitem-list(3)lmItem Listsle perform a regular expression search of a buffer, presenting a
    list of the located text and associated types in a separate window which
    is presented to the left of the buffer window or more typically in the
    toolbar. The command lslmitem-list(3)le is a generic command that interacts with
    the buffer environment variables to present abbreviated buffer information
    to the user.

    The regular expression search strings are predefined in the language
    templates, using the variables cD.fhook-cAcCXXXcAcD-item-list-scAcCYcA and
    cD.fhook-cAcCXXXcAcD-item-list-rcAcCYcA and are described more fully in lslmitem-list(3)le.


cEHilighting cA


    Buffer hilighting is defined by the lslmhilight(2)le command. Within the context
    of cDbuffer-initcA then the standard definitions and name space conventions
    should be adhered to:-
sB
        !if &not &exist .hilight.XXX
            set-variable .hilight.XXX &pinc .hilight.next 1
        !endif
        !if &and &sin "h" .fhook-XXX.setup &band .hilight.flags 0x02
            ; High-light XXX Mode
            0 hilight    .hilight.XXX 0                    $global-scheme
            .....
            ; Variable hilighting
            !if &band .hilight.flags 0x08
                ; hilight constants, e.g. numbers
                hilight .hilight.XXX 1 "[[:digit:]]+"       .scheme.constant
                ......
            !endif
        !endif

sA

cEIndentation cA


    Buffer indentation is defined by the lslmindent(2)le command. Within the context
    of cDbuffer-initcA then the standard definitions and name space conventions
    should be adhered to. The buffer indentation scheme uses the hilighting
    variable, if hilighting is not defined then the variable allocation of
    cG.hilight.XXXcA should be performed as defined in the previous Hilighting
    section.
sB
        !if &sin "d" .fhook-XXX.setup
            0 indent  .hilight.XXX 0 10
            indent .hilight.XXX n "{"  4
            indent .hilight.XXX o "}" -4
            .....
        !endif

sA

cEcEHISTORY cEcA


    The January 2005 version of MicroEmacs introduced the following changes:

        * The cGmy-*hook-alwayscA introduced allowing global file hooks to
          manipulate operate on any buffer.
        * The Electric-C indentation previously flagged as cG>cA was removed, as
          was cDcmode(2m)cA. Indentation configuration for C mode is now performed
          by the lslmindent(2)le command.
        * Private template configuration using cD.fhook-XXX.setup-flagscA and
          cD.fhook-XXX.setup-labelscA.
        * The cGfhook-XXX.command-ncA syntax was introduced in June 2005 to
          simplify the command list definitions.


cEcESEE ALSO cEcA


    lslm$buffer-hilight(5)le, lslm$buffer-indent(5)le, lslmadd-file-hook(2)le,
    lslmbuffer-abbrev-file(2)le, lslmbuffer-setup(3)le, lslmcollapse-all(3)le,
    lslmcollapse-current(3)le, lslmctags(3f)le, lslmeaf(8)le, lslmemftags(3f)le, lslmetf(8)le, lslmetfinsrt(3)le,
    lslmexecute-buffer(2)le, lslmexpand-abbrev(2)le, lslmglobal-abbrev-file(2)le, lslmhilight(2)le,
    lslmindent(2)le, lslmindent(2m)le, lslmitem-list(3)le, lslmnarrow-buffer(2)le, lslmntags(3f)le,
    lslmrestyle-buffer(3)le, lslmrestyle-region(3)le, lslmscheme-editor(3)le, lslmtime(2m)le,
    lsfileHooks(2)lmFile Hooksle,
    lslanguageTemplates(2)lmFile Language Templatesle.
! 3 page-file
! 3 page-bfile
! 3 page-file-save-buffer
! 3 page-file-beginning-of-buffer
! 3 page-file-end-of-buffer
! 3 page-file-goto-byte
! 3 page-file-goto-page
! 3 page-file-scroll-down
! 3 page-file-scroll-up
! 3 page-file-forward-line
! 3 page-file-backward-line
! 3 page-file-search-buffer
! 3 page-file-search-forward
! 3 page-file-search-backward
! 3 page-file-isearch-forward
! 3 page-file-isearch-backward
cEcENAME cEcA


|page-file
    page-file - Load a large file in page mode.
|page-bfile
    page-bfile - Load a large binary file as binary data.
|page-file-save-buffer
    page-file-save-buffer - Save contents of a page mode buffer to file.
|page-file-beginning-of-buffer
    page-file-beginning-of-buffer - Move to the start of the paged file.
|page-file-save-buffer
    page-file-end-of-buffer - Move to the end of the paged file.
|page-file-goto-byte
    page-file-goto-byte - Page to the buffer byte offset.
|page-file-goto-page
    page-file-goto-page - Move to page.
|page-file-scroll-down
    page-file-scroll-down - Scroll paged buffer down.
|page-file-scroll-up
    page-file-scroll-up - Scroll paged buffer up.
|page-file-forward-line
    page-file-forward-line - Move forwards one line in paged buffer.
|page-file-backward-line
    page-file-backward-line - Move backwards one line in paged buffer.
|page-file-search-buffer
    page-file-search-buffer - Search the buffer for the pattern.
|page-file-search-forward
    page-file-search-forward - Search for a string in the forward direction.
|page-file-search-backward
    page-file-search-backward - Search for a string in the backward direction.
|page-file-isearch-forward
    page-file-isearch-forward - Search forward incrementally (interactive).
|page-file-isearch-backward
    page-file-isearch-backward - Search backwards incrementally (interactive)
$a


cEcESYNOPSIS cEcA


    cCncA cDpage-filecA "cCfile-namecA"
    cDpage-bfilecA cCfile-namecA

    cDpage-file-save-buffercA (cDC-x C-scA)

    cDpage-file-beginning-of-buffercA
    cDpage-file-end-of-buffercA
    cDpage-file-goto-bytecA cCbyte-offsetcA
    cDpage-file-goto-pagecA cCpage-offsetcA

    cCncA cDpage-file-scroll-downcA (cDC-ncA)
    cCncA cDpage-file-scroll-upcA (cDC-pcA)

    cCncA cDpage-file-forward-linecA (cDC-ncA)
    cCncA cDpage-file-backward-linecA (cDC-pcA)

    cDpage-file-search-buffercA cCoptioncA cCpatterncA
    cDpage-file-search-forwardcA (cDC-x scA)
    cDpage-file-search-backwardcA (cDC-x rcA)
    cDpage-file-isearch-forwardcA (cDC-scA)
    cDpage-file-isearch-backwardcA (cDC-rcA)


cEcEDESCRIPTION cEcA


    The cDpage-filecA commands allow large files, up to 2GB in size, to be viewed
    and edited. cDpage-filecA operates by loading a small part (or cCpagecA) of the
    file into a buffer for viewing and editing hence the whole file is not
    loaded into memory. The file may be viewed and edited while in a page
    mode, MicroEmacs automatically manages the page swapping and updates to
    the file.

    While a file is being paged then a replacement set of commands are used to
    navigate through the buffer. These replacement commands automatically load
    the next page into the buffer, discarding or saving any edits from
    existing pages.


cEFile Loading cA


    cDpage-filecA finds the named file cCfile-namecA. If it is already in a buffer,
    make that buffer active in the current window, otherwise attempt to create
    a new paged buffer and read the file into it. Syntax hilighting is
    available following any file loading. cDpage-filecA is the paged equivalent of
    lslmfind-file(2)le.

    The numeric argument cCncA is used to modify the default behavior of the
    command, where the bits are defined as follows:

    cD0x01cA
        If the file does not exist and this bit is not set the command fails
        at this point.

    cD0x02cA
        If this bit is set the file will be loaded with lslmbinary(2m)le mode
        enabled. See help on cDbinarycA mode for more information on editing
        binary data files.

    cDpage-bfilecA loads a file as binary data, providing binary editing
    capabilities. The command operate as command lslmpage-file(3)le except that it
    loads the given file with lslmbinary(2m)le mode set.


cESaving cA


    cDpage-file-save-buffercA saves the contents of the current buffer if the
    contents have been changed, writing the buffer back to the file it was
    read from. This command is the same as lslmsave-buffer(2)le for a paged file.


cENavigation cA


    cDpage-file-beginning-of-buffercA moves to the beginning of the buffer. If any
    edits have been performed at the current viewing position that need to be
    saved then the user is prompted to save the changes and the new pages are
    loaded from the file at the beginning of the buffer.

    cDpage-file-end-of-buffercA moves to the end of the buffer in a similar way to
    cDpage-file-beginning-of-buffercA.

    cDpage-file-goto-bytecA advances the buffer to the byte offset specified by
    cCbyte-offsetcA. If any edits have been performed at the current viewing
    position that need to be saved then the user is prompted to save the
    changes and the new pages are loaded from the file at the specified file
    byte offset.

    cDpage-file-goto-pagecA advances the buffer to the page offset specified by
    cCbyte-offsetcA. The behavior is the same as cDpage-file-goto-bytecA.

    cDpage-file-scroll-upcA and cDpage-file-scroll-downcA moves the window in the
    current buffer down by cCncA lines, the default when cCncA is omitted is 1 windows
    worth of lines i.e. a next page operation. The user is prompted to save
    changes if a file paging operation is performed.

    cDpage-file-forward-linecA moves the cursor down cCncA lines, default 1. If the
    line is not on the current screen then display the next page and move to
    the line. Similarly cDpage-file-backward-linecA moves the cursor up cCncA lines,
    if the line is not on the current screen then display the previous page
    and move to the line. The user is prompted to save changes if a file
    paging operation is performed.


cESearching cA


    cDpage-file-searching-buffercA is designed to be called from a macro and
    searches for a string in the buffer. The cCoptioncA specifies the search
    direction.

    cDpage-file-search-forwardcA and cDpage-file-search-backwardcA searches for a
    string from the current cursor position to the end/start of the file and
    is simular to lslmsearch-forward(2)le and lslmsearch-backward(2)le, respectively. If
    the search string is not found in the current buffer then the search
    continues by paging the file until the start/end of the file is reached.
    The user is prompted to save changes if a file paging operation is
    performed.

    cDpage-file-isearch-forwardcA and cDpage-file-isearch-backwardcA perform and
    incremental forward and backward search in the paged file and are similar
    to lslmisearch-forward(2)le and lslmisearch-backward(2)le, respectively. If the search
    string is not found in the current buffer then the search continues by
    paging the file until the start/end of the file is reached. The user is
    prompted to page and save changes if a file paging operation is performed.


cEcENOTES cEcA


    The cDpage-filecA macros are implemented in macro file cGpagefile.emfcA. The
    paging is managed in macro space and uses lslminsert-file(2)le to perform the
    read.


cEcESEE ALSO cEcA


    lslmbinary(2m)le, lslmfind-bfile(3)le, lslmfind-file(2)le, lslmisearch-backward(2)le,
    lslmisearch-forward(2)le, lslmsave-buffer(2)le, lslmsearch-backward(2)le, lslmsearch-forward(2)le.
! 3 toolbar
! 3 toolbar-open
! 3 toolbar-close
! 3 toolbar-refresh
cEcENAME cEcA


|toolbar
    toolbar - Toggle tool bar visibility.
|toolbar-open
    toolbar-open - Open the tool bar.
|toolbar-close
    toolbar-close - Close the tool bar
|toolbar-refresh
    toolbar-refresh - Update the tool bar
$a


cEcESYNOPSIS cEcA


    cCncA cDtoolbarcA
    cDtoolbar-opencA
    cDtoolbar-closecA
    cDtoolbar-refreshcA


cEcEDESCRIPTION cEcA


    The toolbar is one or more fixed buffers that typically appear at the
    left-hand edge of the window that contains different tools that assist in
    editing the buffer. The toolbar is really a container for tools and short
    cuts which are configured by the user depending on the tool that has been
    loaded. The tools themselves are buffer context sensitive, the
    lslmbuffer-init(3)le command automatically re-configures the toolbar for the
    buffer at run time.

    The configuration of the toolbar is stored in command variables cG.toolvar.*cA
    which are used to control the toolbar. The tools that are available in
    toolbar are determined from the file cGtoollist.emfcA which is loaded when the
    toolbar is started. User defined toolbars may be added by redefinging the
    toolbar variables at runtime.

    cDtoolbarcA toggles the visibility of the toolbar, i.e. if the toolbar is open
    it is closed and vica versa. If the numeric argument cCncA is specified then
    zero closes the toolbar and non-zero opens the toolbar. cDtoolbar-opencA
    initializes and starts the toolbar if it is not already running. The
    toolbar is loaded and instantiated in the system. The toolbar may be
    subsequently closed using cDtoolbar-closecA. Whilst the toolbar is running
    then the content of the tollbar may become out of date, the command
    lslmtoolbar-refresh(3)le forces the toolbar to be re-evaluated and the content
    is updated.


cEcECONFIGURATION cEcA


    The toolbar is configured with command variables cD.toolbar.*cA. The size
    information of the toolbar is defined with the following variables:-

    cC.toolbar.widthcA
        Defines the default width of the left-hand vertical toolbar.

    cC.toolbar.depthcA
        Defines the default depth of the top horizontal toolbar.

    The tools within the toolbar are configured with the following variables.
    Each variable is divided into fields, each field represents a single tool.
    The fields are separated with the cG\CHcA character. The order of the fields
    MUST be the same in each of the variables such that the field content
    matches the tool that is being defined.

    cC.tool-flagcA
        The cD.tool-flagcA variable describes the behaviour of the tool, this is
        defined as a bitmask as follows:-

        cG0x000001cA - Update on creation
            Call the tool update command when the tool is created, this is
            typically required when the content of the toolbar is generated.

        cG0x000002cA - Update on redraw
            Call the tool update command when a lsrecenter(2)lmredrawle operation has been
            performed.

        cG0x000004cA - Buffer type changed
            Call the tool update command when the buffer type has changed, a
            change of buffer type requires that a buffer specific tool is
            reconfigured.

        cG0x000008cA - Current buffer changed
            Call the tool update command when the current buffer is changed, a
            change of buffer buffer requires that a buffer content specific
            tool is reconfigured.

        cG0x000010cA - Current buffer modified or saved
            Call the tool update command when the current buffer is modified
            or saved.

        cG0x000080cA - Perform update checks
            On an update check the toolbar for changes in content.

        cG0x000100cA - Lock depth and width
            Lock the depth and width of the tool.

        cG0x000200cA - Tool uses a paged window
            The tool uses a paged window in the toolbar (i.e. only one tool
            has focus).

        cG0x000400cA - Tool is hidden
            The tool is currently hidden. When in this state the not active
            sub-page cG0x200cA will also be set.

        cG0x000800cA - Tool paged window, not first user.
            The tool is part of a paged window and is not the first tool.

        cG0x001000cA - position in the left toolbar
            The tool is present in the left toolbar, on toolbar creation the
            tool is automatically loaded into the toolbar.

        cG0x002000cA - position in the top toolbar
            The tool is present in the top toolbar, on toolbar creation the
            tool is automatically loaded into the toolbar.

        cG0x004000cA - position in the right toolbar
            The tool is present in the right toolbar, on toolbar creation the
            tool is automatically loaded into the toolbar.

        cG0x008000cA - position in the bottom toolbar
            The tool is present in the bottom toolbar, on toolbar creation the
            tool is automatically loaded into the toolbar.

        cG0x010000cA - Include buffer type in mode-line (Prefix)
            The buffer type is included in the toolbar mode line as a prefix.

        cG0x020000cA - Include buffer name in mode-line (suffix)
            The buffer name is included in the toolbar mode line as a suffix.

        cG0x040000cA - Include buffer filename in mode-line (suffix)
            The buffer file name is included in the toolbar mode line as a
            suffix.

        cG0x100000cA - Restore window location after an update
            The position of the hilighted line in the toolbar is restored
            after an update.

        cG0x200000cA - Move position to beginning of buffer after an update
            The position of the hilighted line is restored to the top of the
            buffer following an update.

    cC.toolbar.tool-namecA
        The name of the tool that is displayed to the user.

    cC.toolbar.tool-descscA
        A short description of the tool which is used in the tool selection
        dialog.

    cC.toolbar.tool-buffscA
        The name of the buffer which is used to store toolbar information. The
        names are usually cD*name*cA so that they are not saved.

    cC.toolbar.tool-filescA
        The macro file to load when the tool is loaded, if a tool is not used
        then the macros that define the tool are not loaded.

    cC.toolbar.tool-cmdscA
        The creation and update commands to run when the command is created.


cEcEFILES cEcA


    Notable toolbox macro files:-

        * cGtoolbar.emfcA - The main toolbar file.
        * cGtoolstp.emfcA - The toolbar setup menu i.e. the right click of the
          mouse on the toolbar mode line.
        * cGtoollist.emfcA - List off tools available in the toolbar.
        * cGbookmark.emfcA - The bookmark tool.
        * cGtoolstd.emfcA - Basic tools (Info, Buffer list)
        * cGabbrlist.emfcA - The buffer tools and buffer abbreviation tools.
        * cGitemlist.emfcA - Buffer item list tool.
        * cGkilllist.emfcA - The kill list tool.


cEcESEE ALSO cEcA


    lslmosd(2)le, lslmrecenter(2)le.
! 3 abbrev-list
cEcENAME cEcA


    abbrev-list - Create a list of abbreviations


cEcESYNOPSIS cEcA


    cDabbrev-listcA


cEcEDESCRIPTION cEcA


    cDabbrev-listcA operates opens a new pop-up window and displays a list of
    abbreviations that are available. Selecting an abbreviation within the
    window with the mouse inserts the abbreviation into the current buffer.

    The abbreviations are defined by the lseaf(8)lmXXX.eafle abbreviation file, where cGXXXcA
    is the buffer template. The abbreviation file is defined to the buffer
    using lslmbuffer-abbrev-file(2)le which is configured and loaded by
    lslmbuffer-init(3)le.

    When the lslmtoolbar(3)le is enabled then the command does not produce a pop-up
    window, the abbreviation list may be found (or added) to the toolbar.


cEcESEE ALSO cEcA


    lslmbuffer-abbrev-file(2)le, lslmbuffer-init(3)le, lslmeaf(8)le, lslmexpand-abbrev(2)le,
    lslmtoolbar(3)le.
! 3 c-to-cpp-convert
cEcENAME cEcA


    c-to-cpp-convert - Convert a C file to C++


cEcESYNOPSIS cEcA


    cDc-to-cpp-convertcA


cEcEDESCRIPTION cEcA


    cDc-to-cpp-convertcA changes the buffer type from C to C++ and loads the C++
    language template lslmcpp(9)le. The command is only available once a 'C' file is
    loaded as the command is defined within the C language template file
    cGhkc.emfcA.

    The command is normally used when a new C++ file is being created, if the
    default file type is C rather than C++ then the new file is converted to
    C++ by changing the magic string from cG-*- c -*-cA to cG-*- c++ -*-cA, whenever
    the file is subsequently loaded then it will be presented in the correct
    mode.


cEcESEE ALSO cEcA


    lslmc(9)le, lslmcpp(9)le.
! 3 c-slashify
! 3 c-deslashify
cEcENAME cEcA


|c-slashify
    c-slashify - C language, append backslash to end of lines of region
|c-deslashify
    c-deslashify - C language, remove backslash to end of lines of region
$a


cEcESYNOPSIS cEcA


    cDc-slashifycA
    cDc-deslashifycA


cEcEDESCRIPTION cEcA


    cDc-slashifycA and cDc-deslashifycA add and remove backslash characters to the
    ends of line(s) defined by a region, respectively.

    The commands are used with the C programming language for cG#definecA macro
    editing, allowing backslashes to be added and removed quickly. Backslashes
    are typically removed with cDc-deslashifycA and the macro edited before the
    backslashes are re-applied using cDc-slashifycA.


cEcESEE ALSO cEcA


    lslmc(9)le, lslmcpp(9)le.
! 3 delete-hilight-lines
cEcENAME cEcA


    delete-hilight-lines - Delete hilight lines


cEcESYNOPSIS cEcA


    cDdelete-hilight-linescA


cEcEDESCRIPTION cEcA


    cDdelete-hilight-linescA deletes all lines in the buffer that are hilighted
    with a line color scheme applied by lslmosd-search(3)le or lslmline-scheme(3)le.
    Deletion is only performed on the user hilight lines, lslmcollapse-current(3)le
    annotation lines that use a line based hilight scheme are not removed.

    The line hilighting may be used to mark up lines that are not required,
    typically in debugging logs, and then delete those lines using
    cDdelete-hilight-linescA.


cEcESEE ALSO cEcA


    lslmcollapse-all(3)le, lslmcollapse-current(3)le, lslmhilight(2)le, lslmosd-search(3)le,
    lslmline-scheme(3)le, lslm$line-scheme(5)le.
! 3 open-line
cEcENAME cEcA


    open-line - Open new line at cursor position


cEcESYNOPSIS cEcA


    cCncA cDopen-linecA (cDC-ocA)


cEcEDESCRIPTION cEcA


    cDopen-linecA inserts cCncA new lines after the current cursor position Any text
    following the cursor is moved to the newly created line(s). The cursor
    position is maintained by the command.


cEcESEE ALSO cEcA


    lslminsert-newline(2)le, lslmnewline(2)le.
! 3 copy-rectangle
! 3 yank-rectangle-overwrite
cEcENAME cEcA


|copy-rectangle
    copy-rectangle - Copy a rectangular region of text
|yank-rectangle-overwrite
    yank-rectangle-overwrite - Insert a column of text with overwrite
$a


cEcESYNOPSIS cEcA


    cDcopy-rectanglecA
    cDyank-rectangle-overwritecA


cEcEDESCRIPTION cEcA


    cDcopy-rectanglecA copies a rectangle (or column) of text defined between the
    cursor and the lsset-mark(2)lmset-markle position. The text between the mark column and the
    cursor column is copied from every line between the mark line and the
    cursor line inclusive and copied to the kill buffer. The copied text may
    then be extracted from the kill buffer using lslmyank(2)le, lslmyank-rectangle(2)le or
    cDyank-rectangle-overwritecA.

    The mark position may be ahead or behind the current cursor position. If
    the rectangle column boundary divides a tab character which spans multiple
    columns, the tab character is replaced with the equivalent number of
    spaces. Similarly if the boundary divides an unprintable character which
    is displayed using multiple characters (e.g. 'cG^AcA' for character 0x01) then
    spaces are inserted before the character to move it to the right of the
    boundary.

    cDyank-rectangle-overwritecA replaces a column of text with the current kill
    buffer, overwriting existing text with the contents of the kill buffer.
    The kill buffer should contain a rectangle region acquired with
    cDcopy-rectanglecA or lslmkill-rectangle(2)le. The current cursor position
    identifies the top left of the column to be written, the width of the
    column to be replaced is determined by the width of the kill buffer text
    being inserted.

    Where an overwrite is not required then use lslmyank-rectangle(2)le.


cEcESEE ALSO cEcA


    lslmcopy-region(2)le, lslmkill-rectangle(2)le, lslmkill-region(2)le, lslmreyank(2)le, lslmset-mark(2)le,
    lslmstring-rectangle(3)le, lslmundo(2)le, lslmyank(2)le, lslmyank-rectangle(2)le.
! 3 fold-create
! 3 fold-close
! 3 fold-enter
! 3 fold-exit
! 3 fold-exit-all
! 3 fold-kill
! 3 fold-open
! 3 fold-remove
cEcENAME cEcA


|fold-create
    fold-create - Create a new fold (cDC-f2cA)
|fold-close
    fold-close - Close an open fold (in-line) (cDC-f2cA)
|fold-enter
    fold-enter - Enter fold (cDf3cA)
|fold-exit
    fold-exit - Exit a fold (cDesc f3cA)
|fold-exit-all
    fold-exit-all - Exit all folds (cDesc C-f3cA)
|fold-kill
    fold-kill - Delete the fold and all its contents (cDC-x C-kcA)
|fold-open
    fold-open - Open fold (in-line) (cDf2cA)
|fold-remove
    fold-remove - Remove the fold, maintaining content (cDesc C-f3cA)
$a


cEcESYNOPSIS cEcA


    cDfold-createcA (cDC-f2cA)
    cDfold-closecA (cDC-f2cA)
    cDfold-entercA (cDf3cA)
    cDfold-exitcA (cDesc f3cA)
    cDfold-exit-allcA (cDesc C-f3cA)
    cDfold-killcA (cDC-x C-kcA)
    cDfold-opencA (cDf2cA)
    cDfold-removecA (cDesc C-f3cA)


cEcEINTRODUCTION cEcA


    MicroEmacs supports folding editor type features that allow folds to be
    created, deleted and traversed. Folded regions of the file may be entered
    and edited whilst hiding information in other folds. Folds may also be
    opened in-line such that more than one fold is visible at any time.

    The cDfoldcA operation has different semantics than lscollapse-current(3)lmcollapsele which simply
    hides information with a single narrow and does not provide features such
    as entering the fold.


cEcEDESCRIPTION cEcA


    cDfold-createcA creates a new fold from the text defined between the cursor
    and the lsset-mark(2)lmset-markle position. The text between the mark line and the cursor
    line inclusive are then folded and fold markers are inserted into the
    buffer. The folded line may be commented with a fold comment. The fold may
    be subsequently removed with cDfold-removecA which removes the fold under the
    cursor, deleting any fold annotations.

    cDfold-opencA opens the fold under the cursor, the fold is expanded in line
    such that the contents of the fold are visible. The fold may be
    subsequently closed using cDfold-closecA when the body of the text is hidden
    underneath a fold marker.

    cDfold-entercA enters a fold under the cursor and the contents of the fold are
    reveled the rest of the buffer is narrowed out. The previous fold level
    may be restored with cDfold-exitcA. Where the fold nesting is deep then
    cDfold-exit-allcA may be used to return to the top level.

    cDfold-killcA deletes the fold under the cursor and all of the information
    contained within the fold. lslmundo(2)le will restore the fold if this was not
    the required action.


cEcEDEFINITION cEcA


    Any file may be folded provided that the opening and closing fold strings
    are defined. Folding may be defined and initialized for a file type using
    lslmbuffer-init(3)le by defining the cDfhopok-XXX.foldcA variable to define the
    opening and closing fold markers. i.e.
sB
        set-variable .fhook-XXX.fold "<open> <close>"

sA
    Where cC<open>cA and cC<close>cA are the opening and closing fold strings.

    Folding may also be introduced on a file basis by defining the sold
    markers in the magic string by assignment of the open and close fold
    strings through the variables cDfold-open:cA and cDfold-close:cA. The macro file
    cGfold.emfcA does this to fold a MicroEmacs macro file as follows:-
sB
        ; -!- emf: fold-open: ";OPEN" ; fold-close: ";CLOSE" ; -!-

        ;OPEN fold-idle
        0 define-macro fold-idle
            !if &lfind "|yank|reyank|" @cl
                fold-region
                2 screen-update
            !endif
            !if &exi :fold-idle
                execute-line :fold-idle
            !endif
        !emacro
        ;CLOSE

sA

cEcESEE ALSO cEcA


    lslm$line-flags(5)le, lslmbuffer-init(3)le, lslmcollapse-all(3)le, lslmcollapse-current(3)le,
    lslmnarrow(2m)le, lslmnarrow-buffer(2)le, lslmset-mark(2)le.
! 3 narrow-search-forward
! 3 narrow-search-backward
cEcENAME cEcA


|narrow-search-forward
    narrow-search-forward - Search for a string in the forward direction
|narrow-search-backward
    narrow-search-backward - Search for a string in the backward direction
$a


cEcESYNOPSIS cEcA


    cCncA cDnarrow-search-forwardcA "cCstringcA" (cDC-c scA)
    cCncA cDnarrow-search-backwardcA "cCstringcA" (cDC-c rcA)


cEcEDESCRIPTION cEcA


    cDnarrow-search-forwardcA searches for a string from the current cursor
    position to the end of the file and will open up and search through
    lslmnarrow(2m)le regions to search for the string. This differs from the
    lslmsearch-forward(2)le command that does not search through narrow regions.

    The string is typed on the bottom line of the screen, and terminated with
    the cG<ESC>cA key. Special characters can be typed in by preceding them with a
    cG^QcA. A single cG^QcA indicates a null string. On successive searches, hitting
    cG<ESC>cA alone causes the last search string to be reused.

    Searching is affected by lslmmagic(2m)le mode, which allows regular expression
    pattern matching, and lslmexact(2m)le mode which makes the search case
    sensitive.

    The numeric argument cCncA is interpreted as follows:-

    cDn > 0cA
        The cCncAth occurrence of the cCstringcA is located.

    cDn < 0cA
        The first occurrence of the cCstringcA is located in the next cCncA lines.

    cDnarrow-search-backwardcA searches backwards in the file. In all other ways
    it is like cDnarrow-search-forwardcA.


cEcEDIAGNOSTICS cEcA


    The command returns a status of cGFALSEcA if the cCstringcA could not be located
    (or cCncAth cCstringcA where cCncA occurrences are requested). If the cCstringcA is found
    within the given search criteria the return status is cGTRUEcA.


cEcESEE ALSO cEcA


    lslmbuffer-mode(2)le, lslmexact(2m)le, lslmhunt-backward(2)le, lslmhunt-forward(2)le,
    lslmisearch-forward(2)le, lslmmagic(2m)le, lslmreplace-string(2)le. lslmsearch-forward(2)le,
    lsRegularExpressions(2)lmRegular Expressionsle
! 3 xfind
! 5 %xfind-com
cEcENAME cEcA


    xfind - Execute find command
    %xfind-com - Find command line
$a


cEcESYNOPSIS cEcA


|xfind
    cCncA cDxfindcA "cCbase-pathcA" "cCfile-searchcA"

    cD%xfind-comcA "cCstringcA"; Default is "cGfindcA"


cEcEDESCRIPTION cEcA


    cDxfindcA executes the cDfind(1)cA command with the command line set by the
    lslm%xfind-com(5)le variable and the user supplied cCbase-pathcA and cCfile-searchcA
    regular expression. The output of the command is piped into the cD*find*cA
    buffer.

    If an argument is given then a lslmpipe-shell-command(2)le is used instead of
    lslmipipe-shell-command(2)le, this is useful when used in macros as it ensures
    that cDfindcA has finished before the command returns.

    The find command is specified by the macro variable cD%xfind-comcA if not
    defined the default cGfindcA is used. The command line run by cDxfindcA is

        cC%xfind-comcA -name "cCbase-pathcA" -name "cCfile-searchcA" -print

    The resultant files found are displayed in the cD*find*cA buffer and may be
    selected by double-clicking with the mouse left button or selecting the
    line with a cG<RETURN>cA. The selected file under the cursor is loaded.


cEcEEXAMPLE cEcA


    The cDxfindcA command does not typically need to be set up in UNIX
    environments. In the Microsoft Windows environment then the UNIX cCtools for
    WindowscA are recommended, available from:

        http://unxutils.sourceforge.net/

    The cDxfindcA command may be set up in the startup files as follows:-
sB
        set-variable %xfind-com "c:/usr/local/wbin/find.exe"

sA

cEcESEE ALSO cEcA


    lslm%xgrep-com(5)le, cDfind(1)cA, lslmfind(3)le, lslmgrep(3)le, lslmget-next-line(2)le, cDgrep(1)cA,
    lslmxfind(3)le, lslmxgrep(3)le, lslmrgrep(3)le.
! 3 write-region
cEcENAME cEcA


    write-region - Write contents of region to named (new) file
$a


cEcESYNOPSIS cEcA


    cCncA cDwrite-regioncA "cCfile-namecA"


cEcEDESCRIPTION cEcA


    cDwrite-regioncA is used to write the contents of a selected region of a
    buffer to a NEW file i.e. where the region exists between cCpointcAcD and cAcCmarkcA.

    cDwrite-buffercA writes the contents of the current region to the named file
    cCfile-namecA. The action of the write also changes the file name associated
    with the current buffer to the new file name.

    On writing the region, if lslmtime(2m)le mode is enabled then the ls$timestamp(5)lmtime stampln
    lnstringle is searched for in the file and modified if located, to reflect the
    modification date and time.

    If the region contains a lslmnarrow(2m)le it will automatically be removed
    before saving so that the whole region is saved and restored when saving
    is complete.

    The argument cCncA may be used to change the default behavior of write-region
    described above, cCncA is a bit based flag where:-

    cD0x01cA
        Enables validity checks (default). These include a check that the
        proposed file does not already exist, if so confirmation of writing is
        requested from the user. Also MicroEmacs 2009 checks all other current
        buffers for one with the proposed file name, if found, again
        confirmation is requested. Without this flag the command will always
        succeed wherever possible.

    cD0x02cA
        Disables the expansion of any narrows (see lslmnarrow-buffer(2)le) before
        saving the buffer.


cEcENOTES cEcA


    lslmundo(2)le information may be discarded when the file is written.

    cDwrite-regioncA is a macro defined in cGmisc.emfcA, this macro was used as an
    example for lsmacroWriting(4)lmWriting MicroEmacs Macrosle.


cEcESEE ALSO cEcA


    lslmappend-buffer(2)le, lslmsave-buffer(2)le, lslmwrite-buffer(2)le.
    lsmacroWriting(4)lmWriting MicroEmacs Macrosle.
! 3 watch
! 3 watch-time
! 3 watch-reset
cEcENAME cEcA


    watch - Watch a file
$a


cEcESYNOPSIS cEcA


    cCncA cDwatchcA
    cCncA cDwatch-resetcA
    cDwatch-timecA


cEcEDESCRIPTION cEcA


    cDwatchcA monitors a file on the file system by periodically polling the file
    and reacquiring the contents into a buffer. The command is typically used
    to monitor build and logging files as their output changes under control
    of a background process. Any number of files may be watched
    simultaneously, however to minimize the number of file system transfers,
    only those buffers that are being viewed in a window are updated.

    cDwatchcA operates in three different modes:-

    cDMode 1 (Reload)cA
        On a re-fresh the existing buffer is emptied and the file contents are
        re-read in their entirety from the file system if the file has
        changed. This is the default mode of operation.

    cDMode 2 (Reload, Append)cA
        On enabling the watch then the complete file is re-read, changes are
        subsequently read as deltas from the end of the file. This mode
        ensures that the buffer contents are up to date before incrementally
        reading the file.

    cDMode 3 (Append)cA
        On enabling the watch then only the end of the file that has not been
        read before is appended to the end of the buffer. This method is ideal
        for large log files.

    The operational mode may be selected by passing a numeric value of cG1cA, cG2cA or
    cG3cA to the cDwatchcA command. If no numeric argument is provided then the user
    is prompted for the operational mode.

    Whilst running in an append mode (cG2cA or cG3cA) then byte offset of the end of
    the file is retained for the next read. On the next read then any new
    information from the last saved byte offset to the end of the file is
    read, irrespective of any edits made to the buffer. Therefore if the
    buffer contents have been deleted on the next cCappendcA read then the buffer
    will contain the appended information only and not reacquire the
    information that has been deleted. Where the complete buffer is to be
    re-acquired then use cDMode 1cA.

    The buffer mode line is modified to show the watch state. i.e.

        ==W <buffer-name> ==============


    Invocation of cDwatchcA in a buffer that is being watched disables the watch.
    All watches may be removed from all buffers using cG0 watch-resetcA.

    cDwatch-timecA modifies the poll time of a watch. The user is prompted for the
    time period which is entered in seconds.

    cDwatch-resetcA re-evaluates the watches that are on the buffers reporting the
    number of files that are bing watched. When invoked with a cG0cA argument then
    any outstanding watch commands are removed.


cEcENOTES cEcA


    cDwatchcA is a macro implemented in cGwatch.emfcA.

    The commands cDwatch-resetcA and cDwatch-timecA are not available until a cDwatchcA
    command has been executed.


cEcEHISTORY cEcA


    cDwatchcA was developed in 2000 and appeared in MicroEmacs releases after this
    date however the comand was not exported to the user. The cDwatchcA command
    was fully integrated in the 2005 release.


cEcESEE ALSO cEcA


    lslmosd-search(3)le.
! 3 notes
! 3 notes-file
! 3 notes-close
! 3 notes-import-skwyrul
! 3 notes-context
! 3 notes-instant
! 8 enf
cEcENAME cEcA


    notes - Tagged hierarchical database of notes.
$a


cEcESYNOPSIS cEcA


    cDnotescA
    cDnotes-filecA
    cDnotes-closecA
    cDnotes-contextcA
    cDnotes-instantcA


cEcEDESCRIPTION cEcA


    cDnotescA is a note database that allows miscellaneous text information to be
    organized and retained in a database. Each note is has a label associated
    with it which may be hierarchically organized into a tree of notes.

    Information that a programmer would typically put into a notes database
    may include:-

        * How to mount a CD-ROM on a remote UNIX system.
        * Boot strapping Linux.
        * Configuring the C compiler.
        * etc..

    This information would be hierarchically organized by system, function
    etc. The content typically represents a snippet of information from a
    diverse range of subjects that probably needs to be accessed infrequently
    but organized in such a way that it may be located quickly when required.

    On running cDnotescA then a new frame is created (retaining the existing
    window configuration) and the user is prompted to create a new notes file
    with their user name, accept this option and a new notes file is created
    in the JASSPA home directory. The user is presented with a split view
    window as follows:-

        +-------------+-----------------------------------+
        | + user Pad  |Text associated with the note.     |
        |*  +- info 1 |                                   |
        |   +- info 2 |Anything may be typed in here.     |
        |             |                                   |
        |             |                                   |
        |             |                                   |
        |             |                                   |
        +=User Pad====+=*User Pad: info 1* ===============+
        |                                                 |
        +-------------------------------------------------+


    The left pane comprises a tree of note titles, the right pane contains the
    text note body of the selected note title. Free form text may be entered
    into the text body pane.

    Notes are add and removed from the notes tree pane. A mouse right click
    presents a menu of options that operate on the current node as follows:-

    cDTidy TreecA - cGtcA/cGreturncA
        At the current node then close the note hierarchy. cGtcA will close the
        node a RETURN at the node will open or close it, depending on the
        current state.

    cDRename NotecA - cGrcA
        Edit the name of the note, a dialog is presented and a free form label
        of the note may be edited.

    cDDelete NotecA - cGdeletecA
        Delete the note from the tree. This deletes the label and the note. if
        the note has any children then all children are deleted.

    cDCut NotecA - cGxcA
        Delete a note, including any child notes from the tree, allowing the
        cut information to be pasted back to a different location in the tree.
        (See cDPastecA cDNotecA).

    cDPaste NotecA - cGvcA
        Inserts a cut note (or note tree) back into the list at the current
        position.

    cDMove Note UpcA - cGucA
        Move a note up the tree hierarchy, at the same level.

    cDMove Note DowncA - cGdcA
        Move a note down the tree hierarchy, at the same level.

    cDInsert New NotecA - cGinsertcA
        Insert a new note as a child of the current node. The user is prompted
        for the name of the note, the name may be entered and the cursor is
        left in the body pane for text entry.

    cDForward NotecA - cGncA
        Moves to the next note. Within the note window then cDC-page-downcA
        similarly advances to the next note.

    cDBackward NotecA - cGpcA
        Moves to the previous note. Within the note window then cDC-page-upcA
        similarly advances to the previous note.

    cDSearch ForwardcA - cGesc scA
        Search in a forwards direction from the current note.

    cDSearch BackwardcA - cGesc C-scA
        Search in a backwards direction from the current note.

    cDOpen Notes FilecA
        Opens a new notes file, the user is explicitly prompted for the name
        of the notes file to open.

    cDSave Notes FilecA
        Saves the notes file to the file system.

    cDHide NotescA
        Hides the notes window and restores the exiting buffer windows prior
        to the cDnotescA invocation.

    To quit cDnotescA then delete the buffer using cDC-x C-kcA or run the command
    cDnotes-closecA command.

    The notes file may be saved like any other buffer using lslmsave-buffer(2)le
    (cGC-x C-scA). This saves the tree and the notes. Auto-save is automatically
    enabled.

    cDnotes-closecA closes the notes frame and returns the user to the existing
    windows, retaining the same screen layout. The notes file is still
    resident in the editor and may be restored with a cDnotescA command.

    cDnotes-filecA opens a new notes file, the user is explicitly prompted for the
    name of the notes file. There are no restrictions on the number of notes
    files that may be created. cDnotes-import-skwyrulcA imports a Skwyrul index
    file (cGskwyrul_l.htmcA) into MicroEmacs notes format. This command is not
    available on line as it is likely to be used very infrequently. To load
    the command then load the file cGnotesutl.emfcA and execute the buffer
    lslmexecute-buffer(2)le (cGesc x execute-buffercA). The command may be explicitly
    run using cGesc xcA cGnotes-import-skwyrulcA.

    cDnotes-instantcA creates a new note under the cCInstant NotescA folder, it is
    designed to enable the user to jot something down quickly and in a safe
    place. The note is automatically named and is the fastest method of adding
    a note. This may be invoked outside of the notes window, on invocation
    then a new notes node is created and the content of the note added.

    cDnotes-contextcA is similar to cDnotes-instantcA but a bit more advanced and
    allows a note to be created that is associated with a buffer. When working
    on a file (source code, document etc.). It is sometimes useful to be able
    to associate some information with that file, typically this is done with
    something like a cGTODO:cA comment, however this is not always appropriate.
    cDnotes-contextcA attempts to address this, it works from the current buffers
    filename path and attempts to locate an existing note for it, if no note
    is found then a new one is created. When locating a note it looks down the
    path. The command may be invoked outside of the notes window, on
    invocation then a new notes node is created and the content of the note
    added.


cEText Hilighting cA


    Blocks of text within the notes body may be highlighted. The special
    constructs of cG>format>cA ... cG>end>cA located on the left margin introduce and
    close a highlighting style. i.e.

        >c>
        /* This is a C code insert */
        >end>

        >perl>
        # This is a perl insert
        >end>


    The keywords that are supported are:-

        cG>emf>cA - MicroEmacs macro files.
        cG>pseudo>cA - Pseudo code.
        cG>bnf>cA - BNF.
        cG>c>cA - C programming language
        cG>cpp>cA - C++ programming language
        cG>perl>cA - Perl programming language
        cG>tcl>cA - TCL programming language
        cG>shell>cA - UNIX shell scripts
        cG>make>cA - Makefile scripts
        cG>end>cA - Ends the highlighting block.


cEcENOTES cEcA


    cDnotescA is a macro implemented in cGnotes.emfcA. The database information is
    stored in a single file cCusercAcD.enfcA. The file comprises both the index and
    the text.

    The implementation of cDnotescA uses lslmnarrow-buffer(2)le to hide information for
    each note page. The lslmRegistryle is used to store and display the note tree
    labels.


cEcESEE ALSO cEcA


    lslmosd-search(3)le.
! 3 browse
cEcENAME cEcA


    browse - Browse a file or buffer in view mode
$a


cEcESYNOPSIS cEcA


    cDbrowsecA


cEcEDESCRIPTION cEcA


    cDbrowsecA is a simple utility that assists buffer viewing by mapping the
    basic keys to navigation functions. cDbrowsecA may be invoked on any buffer.

    On invoking cDbrowsecA then the buffer is placed into a simple viewing mode
    allowing the contents of the file to be viewed and the buffer cannot be
    edited. The key bindings that are recognized include:-

        cGSPACEcA, cGRETURNcA - Next page.
        cGBACKSPACEcA - Previous page.
        cGC-ncA - Scroll down .
        cGC-pcA - Scroll up.
        cGC-fcA - Scroll right.
        cGC-bcA - Scroll left.
        cGC-gcA - Quit browse mode.
        cG/cA - Search forward, initiates a forwards search.
        cGwcA - Toggle wrap mode, wraps long lines to screen width.

    To quit browse mode then issue a cDC-gcA cCabortcA command.


cEcENOTES cEcA


    cDbrowsecA is a macro implemented in cGosdmisc.emfcA.


cEcESEE ALSO cEcA


    lslmview-file(2)le.
! 3 save-session
cEcENAME cEcA


    save-session - Write session information to session file
$a


cEcESYNOPSIS cEcA


    cCncA cDsave-sessioncA "cCsession-filecA"


cEcEDESCRIPTION cEcA


    cDsave-sessioncA writes out MicroEmacs 2009's current session information into
    the given session file.

    The command lslmread-session(3)le can set a default session file in which case
    the session is automatically written out to this file if an argument of
    zero is given; the user is not prompted for a file. MicroEmacs 2009
    automatically tries to write the default session whenever it is exited.


cEcENOTES cEcA


    The session information is saved in a ascii format file (see lslmesf(8)le).
    Reference should be made to the notes included in lslmesf(8)le as to how the
    session file may be edited and effected in the same MicroEmacs 2009
    session.


cEcESEE ALSO cEcA


    lslmesf(8)le, lslm@h0(4)le, lslmread-session(3)le.
! 3 read-session
cEcENAME cEcA


    read-session - Read in session information
$a


cEcESYNOPSIS cEcA


    cCncA cDread-sessioncA [ "cCsession-filecA" ]


cEcEDESCRIPTION cEcA


    cDread-sessioncA reads in a MicroEmacs 2009 session file, setting the current
    session information. If argument cDncA is not given then the given
    "cCsession-filecA" is simply read in. If a non-zero argument is specified then
    default session is set to the given file-name and the file is read. If an
    argument of zero is given then the default session is re-read. Information
    read in (and saved) from the history file includes:-

        * Searching and replacing history.
        * Buffer name history.
        * Command name history.
        * File name history.
        * General (all the rest) history.
        * Buffer and file list with line numbers.

    MicroEmacs 2009's environment may be retained almost intact by the use of
    the default session and using the cD-ccA (continue) command-line option to
    re-load all files that were being edited in a previous session.

    On loading a new session then the user is prompted to save the current
    session. If the numeric argument is zero (bit 0 is 0) then the user is not
    prompted and the cCsession-filecA is effectively loaded and merged into the
    current session.


cEcENOTES cEcA


    When running multiple MicroEmacs 2009 sessions on the same work-station
    (or different workstations sharing the same home directory), the default
    history is saved when MicroEmacs 2009 exits. As a result the last
    MicroEmacs 2009 sessions that terminates writes the history information
    used next time.

    The session information is saved in a registry format file (see lslmesf(8)le).
    Reference should be made to the notes included in lslmerf(8)le as to how the
    history file may be edited and effected in the same MicroEmacs 2009
    session.

    The user may now have multiple sessions, this is useful when one is
    working on different projects, the sessions are created using
    lslmsave-session(3)le using a new session name. Starting the editor with a
    different session means that the hilighting scheme may be different
    between different sessions i.e. "cCBluecA cCHuecA" and "cCSherwoordcA cCForestcA". Note
    that the color scheme should be changed with lslmchange-scheme(3)le and not with
    lslmuser-setup(3)le if different sessions are to use different color schemes.


cECommand Line cA


    Reading a session is generally performed when a MicroEmacs session is
    started using the "cD-ccA" command line option rather than from the emacs mode
    line or main menu, see lslmme(1)le. Invoking

        cDme -ccAcC<mySessionName>cA

    where cC<mySessionName>cA is the name of the session (the lslm$MENAME(5)le or system
    login name) will restore all of of the buffers, windows layout, point and
    mark positions, main window size etc. at the point of the last shut down.
    e.g. given a system login name of cCjasspacA then

        cDme -ccAcCjasspacA

    restores the session to the state when cCjasspacA last exited MicroEmacs. When
    the session name is specified then no other files should be specified, so
    the command line

        cDme -ccAcCjasspacA cGmorefiles.txtcA

    restores the buffers but does not restore the window layout because this
    has been destroyed by the introduction of the new file "cGmorefiles.txtcA".
    This type of command with another file behaves as the old "cGme -ccA" command
    prior to the 2006 release that did not support sessions. If
    cC<mySessionName>cA is not specified then the buffers are restored but the
    window layout is not restored.


cEcESEE ALSO cEcA


    lslmchange-scheme(3)le, lslmerf(8)le, lslmesf(8)le, lslm@h0(4)le, lslmme(1)le, lslm$MENAME(5)le,
    lslmsave-session(3)le.
! 3 indent-increase
! 3 indent-decrease
cEcENAME cEcA


    indent-increase - Increase the line indentation
    indent-decrease - Decrease the line indentation
$a


cEcESYNOPSIS cEcA


|indent-increase
    cCindent-increasecA
|indent-decrease
    cCncA cDindent-decreasecA


cEcEDESCRIPTION cEcA


    cDindent-increasecA increases the indentation of a line or selection region by
    the numeric argument cCncA tab stops defined by lslm$buffer-indent-width(5)le. If
    the argument is negative then the indentation is reduced by the specified
    number of tab stops. The default when omitted is a single indentation
    level.

    cDindent-decreasecA operates in the same way as cDindent-increasecA except the
    indentation is decreased.


cEcENOTES cEcA


    cDindent-increasecA and cDindent-decreasecA are defined in cGformat.emfcA.


cEcESEE ALSO cEcA


    lslm$buffer-indent-width(5)le.
! 3 xdiff
! 5 %xdiff-com
cEcENAME cEcA


    xdiff - External graphical file difference
    %xdiff-com - Extenal graphical differnce xdiff(1) command line
$a


cEcESYNOPSIS cEcA


|xdiff
    cDxdiffcA "cCleftVersioncA" "cCrightVersioncA"
|%xdiff-com
    cG%xdiff-comcA "cCstringcA"

    X-Windows "cGxdiff -wb %lf %rfcA" when using cDxdiffcA from
    cChttp://reality.sgiweb.org/rudy/xdiff/cA

    MS-Windows "cGbc2.exe %lf %rf /title1=%lt /title2=%rtcA" when using cDBeyond
    ComparecA.


cEcEDESCRIPTION cEcA


    cDxdiffcA is a macro wrapper that invokes an external graphical file
    difference utility, named after the original X-Windows utility of the same
    name. The utility will usually display two files side by side and color
    code the differences, the differences may then be selected to merge the
    changes into a new output file which may (or may not) overwrite one of the
    original input files.

    cDxdiffcA executes the difference utility cDxdiff(1)cA command (or equivalent)
    with the command line set by the cD%xdiff-comcA variable and the user supplied
    files cCleftVersioncA and cCrightVersioncA. The command line variables are
    referenced from the cD%xdiff-comcA as follows:

    cD%lfcA
        The absolute file name of the left-hand file, cCleftVersioncA.

    cD%rfcA
        The absolute file name of the right-hand file, cCrightVersioncA.

    cD%lncA
        The base name of the left-hand file, cCleftVersioncA.

    cD%rncA
        The base name of the left-hand file, cCleftVersioncA.

    The cD%xdiff-comcA variable should include the appropriate command to invoke
    the difference utility and use cD%cA place holders for the arguments.
    MicroEmacs will fill in the cD%cA arguments with their correct values on
    invocation.

    cDUNIX cA
        UNIX environments may use cDxdiff(1)cA which is available from
        cDhttp://reality.sgiweb.org/rudy/xdiff/cA. The variable command line may
        be defined as:
sB
            set-variable %xdiff-com "xdiff -wb %lf %rf"

sA
    The cD-wbcA options will ignore while space and trailing blanks.

    cDMicrosoft Windows cA
        Microsoft Windows environments may use something like cDBeyond ComparecA.
        The variable command line may be defined as:
sB
            set-variable %xdiff-com "bc2.exe %lf %rf /title1=%lt /title2=%rt"

sA
    In this case the cD%ltcA values have been used for the title names for each of
    the windows in the utility.


cEcENOTES cEcA


    cDxdiffcA is a macro defined in cGtools.emfcA, inspired by the UNIX utility of the
    same name cDxdiff(1)cA


cEcESEE ALSO cEcA


    lslmcompare-windows(2)le, lslmcompile(3)le, cDdiff(1)cA, lslmgdiff(3)le, lslmgdiff(3f)le, lslmxgrep(3)le,
    lslm%xgrep-com(5)le.
! 3 change-scheme
cEcENAME cEcA


    change-scheme - Change the current highlight scheme
$a


cEcESYNOPSIS cEcA


    cDchange-schemecA cC"schemeName"cA


cEcEDESCRIPTION cEcA


    cDchange-schemecA changes the current highlight scheme used by the editor to
    the new scheme cCschemeNamecA which is the ASCII name of the scheme. The
    change is immediate and the change in scheme is retained in the session.
    Note that the cDtabcA key provides a completion list from the command line
    prompt.


cEcENOTES cEcA


    cDchange-schemecA is used by lslmread-session(3)le to restore the session scheme.


cEcESEE ALSO cEcA


    lslmadd-color-scheme(2)le, lslmprint-scheme(2)le, lslmread-session(3)le, lslmuser-setup(3)le.
! 3 ClearCase
! 3 cc-setup
! 3 cc-add
! 3 cc-checkout
! 3 cc-checkin
! 3 cc-delete
! 3 cc-diff
! 3 cc-state
! 3 cc-update
cEcENAME cEcA


|ClearCase
    ClearCase - MicroEmacs ClearCase interface
|cc-add
    cc-add - MicroEmacs ClearCase interface - add file
|cc-checkout
    cc-checkout - MicroEmacs ClearCase interface - checkout files and
    directories
|cc-checkin
    cc-checkin - MicroEmacs ClearCase interface - checkin changes
|cc-delete
    cc-delete - MicroEmacs ClearCase interface - delete file
|cc-diff
    cc-diff - MicroEmacs ClearCase interface - diff changes
|cc-state
    cc-state - MicroEmacs ClearCase interface - list state of directory files
|cc-update
    cc-update - MicroEmacs ClearCase interface - update directory files
$a


cEcESYNOPSIS cEcA


    cDClearCasecA
    cDcc-setupcA

    cDcc-addcA
    cDcc-checkoutcA
    cDcc-checkincA
    cDcc-deletecA
    cDcc-diffcA
    cDcc-statecA
    cDcc-updatecA


cEcEDESCRIPTION cEcA


    The ClearCase and sub-commands provide MicroEmacs with an interface to cDIBM
    Rational SoftwarecA cDClearCase(1)cA. cDClearCasecA is a version control system;
    using it, you can record the history of your source file modifications.
    ClearCase is licensed from IBM Rational and is widely used in a commercial
    environment, see the documentation provided with ClearCase for more
    information on its features and use.

    The cDClearCasecA directory should be defined to MicroEmacs using lslmcc-setup(3)le
    which enables extensions in the lslmfile-browser(3)le with an additional
    "cG*cc-console*cA" window. The "cG*files*cA" window includes additional columns
    showing the ClearCase state, revision and repository date. The
    functionality of the file-browser is the same as a non-ClearCase folder
    with the exception that additional ClearCase item controls are located in
    the mouse context menu (opened by clicking the right mouse button in the
    cG*files*cA buffer). This menu item opens another sub-menu providing access to
    the items below. When selecting commands than a pop-up check-box may be
    displayed which allows options to be selected for the command.

    cDCurrent StatecA
        Checks the state of selected file(s) or directory against the
        repository. Differences detected are shown in the cG*cc-state*cA window.
        This provides a quick method of determining the working directory
        state.

        The cG*cc-state*cA buffer supports some of the same features as a
        directory listing, the files can be loaded (using cGreturncA or left click
        on the file name), selected (using space or left mouse button on the
        left hand edge) and ClearCase commands executed from the window
        operate either on the selected files or the listed files if no files
        are selected.

    cDUpdate ElementscA
        Updates the currently selected files, files are selected by clicking
        the left button to the left of the required file name. Multiple files
        may be selected by 'dragging' a hilight region over the required
        files.

    cDClear CC consolecA
        Clears the cC*cc-console*cA buffer.

    The following sections describe some of the ClearCase commands that are
    available, a full list of commands may be found using lslmcommand-apropos(2)le
    searching for cDcccA which provides a full list of all of the ClearCase
    related commands.

    The cDcc-addcA command adds the current buffer file to the repository.

    The cDcc-checkoutcA command checks out a file or directory from the repository
    into the current directory, the read-only status of the file is changed to
    read-write, the user is prompted for a comment which will be used on a
    subsequent check-in operation. The user specifies the file on the message
    line.

    The cDcc-checkincA command commits any changes made to the currently buffer's
    file (including additions) to the repository. The user is prompted for a
    commit log message, the file state will change to read-only.

    The cDcc-diffcA command opens a cC*cc-diff*cA window displaying the differences
    between the current buffer's local file and repository version. If the
    current buffer is a directory list it will list all the differences found
    in all files within the directory.

    The cDcc-deletecA command removes the current buffer's file from the
    repository.

    The cDcc-statecA command opens a cC*cc-state*cA window listing the state of any
    file in the current directory which is not up-to-date. Note that unlike
    most ClearCase sub commands this command executes over all files in the
    current buffer's file directory.

    The cDcc-updatecA command updates all files in the current directory, the
    output being reported to a new cC*cc-update*cA window. Note that unlike most
    ClearCase sub commands this command executes over all files in the current
    buffer's file directory.


cESetup cA


    cDcc-setupcA provides a dialog interface to configure the MicroEmacs ClearCase
    interface if required. The VOB view location in the file system should be
    added for each view that is to be access by MicroEmacs.

    A cDToolscA tab exists to configure each of the cDcleartool(1)cA options, these
    may be configured to suite the users preferences.

    cDcc-setupcA may also be accessed from lslmuser-setup(3)le from the cDMiscellaneouscA
    configuration.


cEClearCase File Browser cA


    The cDClearCase File BrowsercA is an extension to the lslmfile-browser(3)le and
    shows the state of ClearCase files in a directory listing.


cEcENOTES cEcA


    cDClearCasecA and sub-commands are macros defined in file cGclearcs.emfcA.


cEcESEE ALSO cEcA


    lslmcvs(3)le, lslmfile-browser(3)le.
! 3 insert-password
! 3 password-to-phonic
cEcENAME cEcA


|insert-password
    insert-password - Create and insert a new password string
|password-to-phonic
    password-to-phonic - Convert a password to phonic string
$a


cEcESYNOPSIS cEcA


    cCncA cDinsert-passwordcA
    cDpassword-to-phoniccA "cCpasswordcA"


cEcEDESCRIPTION cEcA


    The password commands are typically used by a system administrator to
    generate new random passwords or to phonically unambiguously describe a
    password.

    cDinsert-passwordcA generates a new random password string and inserts the
    generated password with phonic description into the current buffer. The
    generated password minimally includes include at least one each of
    lowercase, uppercase and numeric characters. The default length of the
    password is 8 characters, the numeric argument cCncA changes the length of the
    generated password and must be at least 3 characters long. Running cD4
    insert-passwordcA to generate a 4 character password generates:

        y5Ck (yankee - Five - CHARLIE - kilo)


    cDpassword-to-phoniccA converts a string of characters to the phonic alphabet,
    the command requires a single argument cCpasswordcA which is converted to a
    phonic string. The command cDpassword-to-phoniccA "cCy5CkcA" inserts the phonic
    string into the buffer:

        yankee - Five - CHARLIE - kilo


cEcENOTES cEcA


    The password commands are macros defined in cGpassword.emfcA.


cEcESEE ALSO cEcA


    lslm$random(5)le, lslminsert-string(2)le.
! 3 buffer-major-mode
cEcENAME cEcA


    buffer-major-mode - Change the operating mode of a buffer


cEcESYNOPSIS cEcA


    cDbuffer-major-modecA "cCmodenamecA"


cEcEDESCRIPTION cEcA


    cDbuffer-major-modecA changes the major mode of a buffer affecting the
    highlighting, indentation, key bindings and mode specific commands to the
    specified cCmodenamecA. This allows the buffer to be configured correctly for
    the type of file.

    On invocation then the user is prompted for the cCmodenamecA, TAB performs
    completion.

    Running cDbuffer-major-modecA causes the lsfileHooks(2)lmFile Hookle to be executed for the
    buffer for the new cCmodenamecA.


cEcENOTES cEcA


    lslmbuffer-setup(3)le may be used to make local changes to the major mode for
    the current buffer only. lslmmajor-mode-setup(3)le may be used to change the
    major mode settings across all buffers.


cEcESEE ALSO cEcA


    lslmbuffer-setup(3)le, lslmmajor-mode-setup(3)le, lsfileHooks(2)lmFile Hooksle
! 3 find
! 3 find-setup
cEcENAME cEcA


    find - Execute find command
$a


cEcESYNOPSIS cEcA


|find
    cDfindcA ["cCfind-optionscA"] "cCfile-maskcA" ["cCfile-maskcA"...] ["cCstarting-pathcA"]
|find-setup
    cDfind-setupcA


cEcEDESCRIPTION cEcA


    cDfindcA performs a search for files in the current directory (or from
    cCstarting-pathcA) using built in MicroEmacs 2009 constructs rather than
    relying on any external executables such as cDfind(1)cA. cDfindcA operates in
    exactly the same way as a traditional cCfindcA command line utility and uses a
    command line option sequence from the MicroEmacs 2009 command line. The
    cCfile-optionscA allow recursive and regular expression searches, searching
    against the file modification time etc. The command line takes the user
    supplied cCfile-optionscA, cCfile-maskcA and cCstarting-pathcA. The output of the
    command is piped into the cD*find*cA buffer.

    cCfind-optionscA
        Defines the cCoptionscA that are specified on the command line, the
        default options may also be defined with the cDfile-setup(3)cA command
        invoked from the command line or from the the cDToolscA menu. The
        cCfind-optionscA are defined as follows:

        cD-2cA
            List the file and directory attributes in the output (directory
            list sort key)

        cD-3cA
            List file and directory size in the output.

        cD-4cA
            List file and directory modified time in the output.

        cD-a cA
            Re-read all out of date buffers, prevents a manual prompt,
            equivalent of Yes to all. This is the inverse of cD-ocA

        cD-b cA
            Ignore binary files.

        cD-B cA
            Do not ignore binary files.

        cD-d cA
            List directories or grep in directory listings.

        cD-D cA
            Do not list directories or grep in directory listings.

        cD-f cA
            List/search files.

        cD-F cA
            Do not list/search files.

        cD-g cA
            File masks are regex (i.e. .*.emf)

        cD-G cA
            File masks are not regex (i.e. *.emf)

        cD-i cA
            Ignore search pattern case (case insensitive).

        cD-I cA
            Do not ignore search pattern case (case sensitive).

        cD-l cA
            Use existing buffer of loaded files.

        cD-L cA
            Do not use existing buffer of loaded files.

        cD-m cA
            Search pattern is a regular expression.

        cD-M cA
            Search pattern is not a regular expression.

        cD-o cA
            Do not re-read all out of date buffers, prevents a manual prompt,
            equivalent of No to all. This is the inverse of cD-acA.

        cD-p cA
            Starting path specified

        cD-P cA
            Starting path not specified

        cD-r cA
            Recurse into sub-directories

        cD-R cA
            Do not recurse into sub-directories

        cD-ScA cC<size>cA
            File size - less than or equal, the following size formats are
            supported:

            cD-ScA cC<number>cA File size specified bytes.

            cD-ScA cC<number>cAcDkcA File size specified in Kilobytes.

            cD-scA cC<size>cA File size greater than; supported size formats are the
            same as cD-ScA.

        cD-TcA cC<time>cA
            Modification time - older than, the following time formats are
            supported:

            cD-TcA cCyy-mm-ddcA

            cD-TcA cCyyyy-mm-ddcA

            cD-TcA cCyyyy-mm-dd hh:mm:sscA

            cD-TcA cCdayscA Offset time in days from midnight this morning, e.g. cD-T 0cA
            would match all files not modified today.

            cD-T cAcCdays.hours[.minutes[.seconds]]cA Offset time in , e.g. cD-T 1.1.30cA
            matches all files 25 hours and 30 minutes old.

            Note that cD-T 1cA is not the same as cD-T 1.0cA, except at midnight.

        cD-tcA cC<time>cA
            Modification time - newer than or equal, supported time formats
            are the same as cD-TcA.

        cD-u cA
            When used with cD-wcA, allows the file size limit of 100Mb to be
            disabled and strings are searched in files of any size.

        cD-U cA
            When used with cD-UcA, files are limited in size 100Mb otherwise they
            will not be searched.

        cD-wcA cC<search-pattern>cA
            File must contain a string matching the given cCsearch-patterncA.

        cD-x cA
            Use MicroEmacs 2009 lslm$file-ignore(5)le to exclude unimportant files

        cD-X cA
            Do not use MicroEmacs 2009 lslm$file-ignore(5)le.

    cCfile-maskcA
        The files to search for e.g. cD*.txtcA

    cCstarting-pathcA
        The directory location where the search should commence. The default
        is the location of the current buffer.

    cDfile-setupcA invokes a dialogue and allows the default cCfile-optionscA to be
    specified when the cDfindcA command is invoked.


cEcENOTES cEcA


        * Directories are not considered binary files, so cD-bcA will not exclude
          them.
        * The default when no options are given will be cD-XGPrdfMIBLcA, default
          options can be set via the find-setup command (sets the
          cD/history/find-comcA registry entry).
        * Use of cD-wcA on directories searches for cC<search-pattern>cA within the
          MicroEmacs 2009 directory listing, the command is then the same as
          lslmgrep(3)le except for the output buffer format.
        * String searches of cD-wcA are not performed on files that exceed 100Mb
          unless the cD-ucA option is specified on the command line. This prevents
          MicroEmacs 2009 from loading exceptionally large files unless
          explicitly required.


cEcESEE ALSO cEcA


    lslm%xgrep-com(5)le, cDfind(1)cA, lslmgrep(3)le, lslmget-next-line(2)le, cDgrep(1)cA, lslmxfind(3)le,
    lslmxgrep(3)le, lslmrgrep(3)le.
! 3 grep
cEcENAME cEcA


    grep - Search a file for a pattern
$a


cEcESYNOPSIS cEcA


|grep
    cDgrepcA ["cCgrep-optionscA"] cCsearch-patterncA "cCfile-maskcA" ["cCfile-maskcA"...]
    ["cCstarting-pathcA"]


cEcEDESCRIPTION cEcA


    cDgrepcA performs a search for a pattern and displays all lines that contain
    that pattern within files in the current directory (or from cCstarting-pathcA)
    using built in MicroEmacs 2009 constructs rather than relying on any
    external executables such as cDgrep(1)cA. cDgrepcA operates in exactly the same
    way as a traditional cCgrepcA command line utility and uses a command line
    option sequence from the MicroEmacs 2009 command line. The cCgrep-optionscA
    allow recursive and regular expression searches, searching against the
    file modification time etc. The command line takes the user supplied
    cCgrep-optionscA, cCsearch-patterncA, cCfile-maskcA and cCstarting-pathcA. The output of
    the command is piped into the cD*grep*cA buffer.

    cCgrep-optionscA
        Defines the cCoptionscA that are specified on the command line, the
        default options may also be defined with the lslmfind-setup(3)le command
        invoked from the command line or from the the cDToolscA menu. The
        cCgrep-optionscA are defined as follows:

        cD-a cA
            Re-read all out of date buffers, prevents a manual prompt,
            equivalent of Yes to all. This is the inverse of cD-ocA

        cD-b cA
            Ignore binary files.

        cD-B cA
            Do not ignore binary files.

        cD-d cA
            List directories or grep in directory listings.

        cD-D cA
            Do not list directories or grep in directory listings.

        cD-f cA
            List/search files.

        cD-F cA
            Do not list/search files.

        cD-g cA
            File masks are regex (i.e. .*.emf)

        cD-G cA
            File masks are not regex (i.e. *.emf)

        cD-i cA
            Ignore search pattern case (case insensitive).

        cD-I cA
            Do not ignore search pattern case (case sensitive).

        cD-l cA
            Use existing buffer of loaded files.

        cD-L cA
            Do not use existing buffer of loaded files.

        cD-m cA
            Search pattern is a regular expression.

        cD-M cA
            Search pattern is not a regular expression.

        cD-o cA
            Do not re-read all out of date buffers, prevents a manual prompt,
            equivalent of No to all. This is the inverse of cD-acA.

        cD-p cA
            Starting path specified

        cD-P cA
            Starting path not specified

        cD-r cA
            Recurse into sub-directories

        cD-R cA
            Do not recurse into sub-directories

        cD-ScA cC<size>cA
            File size - less than or equal, the following size formats are
            supported:

            cD-ScA cC<number>cA File size specified bytes.

            cD-ScA cC<number>cAcDkcA File size specified in Kilobytes.

            cD-scA cC<size>cA File size greater than; supported size formats are the
            same as cD-ScA.

        cD-TcA cC<time>cA
            Modification time - older than, the following time formats are
            supported:

            cD-TcA cCyy-mm-ddcA

            cD-TcA cCyyyy-mm-ddcA

            cD-TcA cCyyyy-mm-dd hh:mm:sscA

            cD-TcA cCdayscA Offset time in days from midnight this morning, e.g. cD-T 0cA
            would match all files not modified today.

            cD-T cAcCdays.hours[.minutes[.seconds]]cA Offset time in , e.g. cD-T 1.1.30cA
            matches all files 25 hours and 30 minutes old.

            Note that cD-T 1cA is not the same as cD-T 1.0cA, except at midnight.

        cD-tcA cC<time>cA
            Modification time - newer than or equal, supported time formats
            are the same as cD-TcA.

        cD-u cA
            When used with cD-wcA, allows the file size limit of 100Mb to be
            disabled and strings are searched in files of any size.

        cD-U cA
            When used with cD-UcA, files are limited in size 100Mb otherwise they
            will not be searched.

        cD-x cA
            Use MicroEmacs 2009 lslm$file-ignore(5)le to exclude unimportant files

        cD-X cA
            Do not use MicroEmacs 2009 lslm$file-ignore(5)le.

    cCfile-maskcA
        The files to search for e.g. cD*.txtcA

    cCstarting-pathcA
        The directory location where the search should commence. The default
        is the location of the current buffer.

    cDfind-setupcA invokes a dialogue and allows the default cCfile-optionscA to be
    specified when the cDfindcA command is invoked.


cEcENOTES cEcA


        * Trying to make the command-line look like the standard UNIX cDgrep(1)cA
          command may be more of a hindrance than a help because its not grep.
          No support is provided for options like cD-wcA, cD-lcA etc.
        * The default when no options are given is cD-XGPRDfMIBLcA, default
          options may be set via the lslmfind-setup(3)le command (sets the
          cC/history/grep-comcA registry entry).
        * Use of cD-dcA searches for cC<search-pattern>cA within the MicroEmacs 2009
          directory listing.
        * It may be advantageous to enable the cD-lcA option default using
          lslmfind-setup(3)le.


cEcESEE ALSO cEcA


    lslm%xgrep-com(5)le, cDfind(1)cA, lslmfind(3)le, lslmfind-setup(3)le, lslmget-next-line(2)le, cDgrep(1)cA,
    lslmreplace-string-in-files(3)le, lslmxfind(3)le, lslmxgrep(3)le, lslmrgrep(3)le.
! 3 replace-string-in-files
! 3 query-replace-string-in-files
cEcENAME cEcA


    replace-string-in-files - Search and replace strings across files
$a


cEcESYNOPSIS cEcA


|replace-string-in-files
    cDreplace-string-in-filescA "cCfrom-patterncA" "cCto-patterncA" cCfind-optionscA
    "cCfile-maskcA" ["cCfile-maskcA"...] ["cCstarting-pathcA"]
|query-replace-string-in-files
    cDquery-replace-string-in-filescA "cCfrom-patterncA" "cCto-patterncA" cCfind-optionscA
    "cCfile-maskcA" ["cCfile-maskcA"...] ["cCstarting-pathcA"]


cEcEDESCRIPTION cEcA


    cDreplace-string-in-filescA performs a search for a cCfrom-patterncA and and
    replaces the string with cCto-patterncA in all files that match cCfile-maskcA in
    the current directory (or from cCstarting-pathcA) using built in MicroEmacs
    2009 constructs rather than relying on any external executables such as
    cDgrep(1)cA.

    cDquery-replace-string-in-filescA is identical to cDreplace-string-in-filescA
    except the user is prompted to accept each potential replacement.

    cCfind-optionscA
        Defines the cCoptionscA that are specified on the command line, the
        default options may also be defined with the lslmfind-setup(3)le command
        invoked from the command line or from the the cDToolscA menu. The
        cCfind-optionscA are defined as follows:

        cD-2cA
            List the file and directory attributes in the output (directory
            list sort key)

        cD-3cA
            List file and directory size in the output.

        cD-4cA
            List file and directory modified time in the output.

        cD-a cA
            Re-read all out of date buffers, prevents a manual prompt,
            equivalent of Yes to all. This is the inverse of cD-ocA

        cD-b cA
            Ignore binary files.

        cD-B cA
            Do not ignore binary files.

        cD-f cA
            List/search files.

        cD-F cA
            Do not list/search files.

        cD-g cA
            File masks are regex (i.e. .*.emf)

        cD-G cA
            File masks are not regex (i.e. *.emf)

        cD-i cA
            Ignore search pattern case (case insensitive).

        cD-I cA
            Do not ignore search pattern case (case sensitive).

        cD-l cA
            Use existing buffer of loaded files.

        cD-L cA
            Do not use existing buffer of loaded files.

        cD-m cA
            Search pattern is a regular expression.

        cD-M cA
            Search pattern is not a regular expression.

        cD-o cA
            Do not re-read all out of date buffers, prevents a manual prompt,
            equivalent of No to all. This is the inverse of cD-acA.

        cD-p cA
            Starting path specified

        cD-P cA
            Starting path not specified

        cD-r cA
            Recurse into sub-directories

        cD-R cA
            Do not recurse into sub-directories

        cD-ScA cC<size>cA
            File size - less than or equal, the following size formats are
            supported:

            cD-ScA cC<number>cA File size specified bytes.

            cD-ScA cC<number>cAcDkcA File size specified in Kilobytes.

            cD-scA cC<size>cA File size greater than; supported size formats are the
            same as cD-ScA.

        cD-TcA cC<time>cA
            Modification time - older than, the following time formats are
            supported:

            cD-TcA cCyy-mm-ddcA

            cD-TcA cCyyyy-mm-ddcA

            cD-TcA cCyyyy-mm-dd hh:mm:sscA

            cD-TcA cCdayscA Offset time in days from midnight this morning, e.g. cD-T 0cA
            would match all files not modified today.

            cD-T cAcCdays.hours[.minutes[.seconds]]cA Offset time in , e.g. cD-T 1.1.30cA
            matches all files 25 hours and 30 minutes old.

            Note that cD-T 1cA is not the same as cD-T 1.0cA, except at midnight.

        cD-tcA cC<time>cA
            Modification time - newer than or equal, supported time formats
            are the same as cD-TcA.

        cD-u cA
            When used with cD-wcA, allows the file size limit of 100Mb to be
            disabled and strings are searched in files of any size.

        cD-U cA
            When used with cD-UcA, files are limited in size 100Mb otherwise they
            will not be searched.

        cD-wcA cC<search-pattern>cA
            File must contain a string matching the given cCsearch-patterncA.

        cD-x cA
            Use MicroEmacs 2009 lslm$file-ignore(5)le to exclude unimportant files

        cD-X cA
            Do not use MicroEmacs 2009 lslm$file-ignore(5)le.

    cCfile-maskcA
        The files to search for e.g. cD*.txtcA

    cCstarting-pathcA
        The directory location where the search should commence. The default
        is the location of the current buffer.


cEcENOTES cEcA


        * The location of the find options in the 3rd argument may seem odd,
          but the command is not required to have a single cC<options>cA cC<from>cA
          cC<to>cA cC<mask>cA interface as this becomes unwieldy.
        * The default when no options are given is cD-XGPRDfMIbLcA, default
          options may be set via the lslmfind-setup(3)le command (sets
          cD/history/rsif-comcA registry entry).
        * The cD-dcA option is not supported as lslmfind(3)le and error is reported if
          supplied.
        * It may be advantageous to enable the cD-lcA option default using
          lslmfind-setup(3)le.
        * Use of cD-wcA is supported and is separate from the cC<from-pattern>cA, i.e.
          this option can still be used to filter the files to operate on.
        * cD-wcA shares the cD-mcA and cD-icA options, i.e if cD-mcA is used both the
          cC<from-pattern>cA and the cC<search-pattern>cA must be a regular expression
          pattern.


cEcESEE ALSO cEcA


    cDfind(1)cA, cDgrep(1)cA, lslmfind(3)le, lslmgrep(3)le, lslmfind-setup(3)le, lslmget-next-line(2)le,
    cDgrep(1)cA, lslmxfind(3)le, lslmxgrep(3)le, lslmrgrep(3)le.
! 3 encase
cEcENAME cEcA


    encase - Encase a text region with start/end string
$a


cEcESYNOPSIS cEcA


|encase
    cDencasecA "cCstart-stringcA" "cCend-stringcA"


cEcEDESCRIPTION cEcA


    cDencasecA provides a short cut to encapsulate a selected region of text with
    a cCstart-stringcA and cCend-stringcA pattern. The command is modal and operates
    in two different operating modes as follows.

    First run cDencasecA without a current region section (i.e. no selected
    highlighted text) and the user is prompted for the cCstart-stringcA and
    cCend-stringcA. The user is also prompted if the command has not been run
    before and the cCstart-stringcA and cCend-stringcA are undefined.

    With the strings defined then select a region with the mouse or keyboard
    (cDesc spacecA and cDmovecA or cDS-movecA) to define the start and end point of the
    region. With a selected region then execute the cDencasecA command using cDesc xcA
    cDencasecA. This is most effective when bound to a simple key, see
    lslmglobal-bind-key(2)le.


cEcENOTES cEcA


    cDencasecA is a macro defined in cGmisc.emfcA.


cEcESEE ALSO cEcA


    lslmglobal-bind-key(2)le.
! 3 number-items
cEcENAME cEcA


    number-items - Renumber a vertical list of items
$a


cEcESYNOPSIS cEcA


|number-items
    cDnumber-itemscA cCstart-numbercA cCchar-widthcA cCnum-linescA


cEcEDESCRIPTION cEcA


    cDnumber-itemscA provides a short cut method of re-numbering a list of
    vertically aligned numbered items. The command assumes a fixed width
    number per line. The command operates from the current cursor position in
    a downward direction. The parameters are defined as follows:

    cCstart-numbercA
        The value of the first item to renumber.

    cCchar-widthcA
        The width of the number space i.e. 1-10 is a width of 2, 89-101 is a
        width of 3.

    cCnum-linescA
        The number of lines to re-number, including the current line.


cEcEEXAMPLE cEcA


    The following code fragment shows how a list is renumbered.

        MY_COMMAND (myCMD_UP,   # 9, "Move Up")
        MY_COMMAND (myCMD_DOWN,  10, "Move down")
        MY_COMMAND (myCMD_LEFT,  15, "Move down")
        MY_COMMAND (myCMD_RIGHT, 10, "Move down")


    To to use the command to renumber the list from 100 to 103 then the cursor
    is placed at the left hand side where the number should start. In the
    example this is cG#cA, then issue the command cDesc xcA cDnumber-itemscA cD100cA cD3cA cD4cA. This
    renumbers the list resulting in the following:

        MY_COMMAND (myCMD_UP,   100, "Move Up")
        MY_COMMAND (myCMD_DOWN, 101, "Move down")
        MY_COMMAND (myCMD_LEFT, 102, "Move down")
        MY_COMMAND (myCMD_RIGHT,103, "Move down")


cEcENOTES cEcA


    cDnumber-itemscA is a macro defined in cGmisc.emfcA.


cEcESEE ALSO cEcA
! 3 user-setup
cEcENAME cEcA


    user-setup - Configure MicroEmacs for a specific user
$a


cEcESYNOPSIS cEcA


    cDuser-setupcA


cEcEDESCRIPTION cEcA


    cDuser-setupcA provides a dialog interface to enable the user to configure the
    editor. cDuser-setupcA may be invoked from the main cCHelpcA menu or directly from
    the command line using lslmexecute-named-command(2)le. cDuser-setupcA configures the
    user's setup registry file, "cC<logname>cAcG.erfcA" which is used by MicroEmacs to
    initialize the environment to a user's preference.

    Note, if your screen is too small to display the whole dialog, it may be
    moved using any key bound to the scroll commands such as cDscroll-upcA, e.g.
    cGA-upcA, cGC-zcA, cGA-downcA, cGC-vcA, cGA-leftcA etc. For systems without mouse support, the
    cGtabcA key may be used to move between fields.

    On all pages the following buttons are available at the bottom of the
    dialog and have the following effect:

    cGSavecA
        Saves the changes made to the users registry file, i.e.
        "cC<Log-Name>cAcG.erfcA" but does not re-initialize MicroEmacs. Some changes,
        such as color scheme changes, only take effect when the cDCurrentcA button
        is used or when MicroEmacs is restarted.

    cGCurrentcA
        Makes the current user and the changes made Current to this MicroEmacs
        session, dismissing the cDuser-setupcA dialog and reinitializing
        MicroEmacs. This also saves the registry file out!

    cGCancelcA
        Quits cDuser-setupcA, if changes where not cDSavecAd or made cDCurrentcA they will
        be lost.

    The following pages, which appear in the dialog, are defined as follows:-


cEStart-up cA


    cGUser NamecA
        Documents the user name currently being configured, this entry cannot
        be changed in user-setup, see lslm$user-name(5)le for help on changing the
        MicroEmacs user name.

    cGUser PathcA
        Documents the location of the current user's MicroEmacs setup files,
        this entry cannot be changed in user-setup, see lslm$user-path(5)le for help
        on changing the user path.

    cGSetup FilecA
        Sets the personal user setup macro file name which is executed at
        start-up. A user macro file should contain all personal settings such
        as preferred key bindings etc. See lsUserProfiles(2)lmSetting Up A User Profilele for more
        information. The cDEditcA check box can be used to enable/disable the
        automatic loading of the setup file ready for editing when the cDCurrentcA
        button is used.

    cGCompany FilecA
        Sets the company setup macro file name which is executed at start-up.
        A company macro file should contain all company wide standard settings
        such as cG%company-namecA, No cG.emfcA extension is supplied. See lsCompanyProfiles(2)lmSetting Up aln
        lnCompany Profilele for more information.

    cGEmulationcA
        Sets an emulation mode which changes the behaviour on MicroEmacs to
        emulate another editor/program; this is done by executing a macro file
        at start-up. An emulation macro file should contain the macro code
        required to simulate the environment of the other editor. MicroEmacs
        2009 is released with four emulation modes, GNU Emacs (see macro file
        cGmeemacs.emfcA), CUA (Windows style key bindings and interface, see
        cGmecua.emfcA), MicroEmacs v3.8 (cGmeme3_8.emfcA) and NEdit v5 which is at
        best a demonstration of what can be achieved via the emulation support
        (defined in cGmenedit.emfcA). See lsCompatibility(2)lmCompatibilityle for more information on
        emulation.

    cGRebind Home KeyscA
        When enabled the following key bindings are created to ease
        frustration, particularly for MS users:

        cGhomecA
            Bound to beginning-of-line instead of beginning-of-buffer.

        cGendcA
            Bound to end-of-line instead of end-of-buffer.

        cGC-homecA
            Bound to beginning-of-buffer.

        cGC-endcA
            Bound to end-of-buffer.

    cGMS Shift RegioncA
        Enables/disables cursor key manipulation with the shift key similar to
        the conventional Microsoft region selection. When enabled, pressing
        the shift key in conjunction with the cursor movement keys selects a
        region which is hilighted. Once the region is selected then the
        cG<DELETE>cA or cG<BACKSPACE>cA key erases the selected region. This also
        enables a similar behaviour with the Mouse cDDrag regioncA driver, see
        below.


cELocale Setup cA


    cGKeyboardcA
        Configures MicroEmacs to the user's keyboard. Accent character
        generation keys present on foreign keyboards cannot be automatically
        supported on Windows platforms. MicroEmacs must be informed of the
        keyboard being used to correctly interpret the keys. If a required
        keyboard is not supported please see lsfaq38(0f)lmFAQ38le on how to setup the
        keyboard, also see lslocaleSupport(2)lmLocale Supportle.

    cGLanguagecA
        Sets the user language, this sets the word (or letter) characters and
        if available sets up lslmspell(2)le with appropriate spelling rules and
        dictionaries. For more information on adding support for a language
        see lslocaleSupport(2)lmLocale Supportle.

    cDNOTEScA
        Earlier versions MicroEmacs had "cG(Ext)cA" languages which use extended
        language dictionaries, vastly increasing the word list. New versions
        automatically test for and use these dictionaries if available.

        In earlier versions a personal dictionary name could be set in the
        next field, this option was removed on Oct 2001. Instead a personal
        dictionary for each language is automatically created for you, any
        words or auto-corrected words will be added to the current languages
        personal dictionary. The name of dictionary is "cGlsdpcAcC<lang-id>cAcG.edfcA"
        where "cC<lang-id>cA" is the 4 letter MicroEmacs language name (e.g.
        "cGenuscA" for American), simply rename any existing personal dictionary
        to this new name.

    cGAuto Save DictionariescA
        Enables auto-saving of any changed dictionaries on exit. If this is
        disabled the user is prompted to save for each changed dictionary.

    cGEnable Auto-SpellcA
        Enables Auto Spell Checking in file types which support this feature
        (usually text based files such as lslmtxt(9)le or lslmnroff(9)le files etc). Auto
        spell detects word breaks as you type and checks the spelling of every
        completed word hilighting any erroneous words in the error color
        scheme (usually red). When auto-spell is enable, right clicking on an
        erroneous word will add an extra cDAuto SpellcA sub-menu to the opened
        context menu, the sub-menu lists suggested corrections and other
        useful options; this menu can also be opened by executing the
        lslmauto-spell-menu(3)le command (usually bound to "cGC-f7cA"). The feature can
        be manually enabled and disabled by invoking the lslmauto-spell(3)le
        command.


cEGeneral cA


    cGFull NamecA
        This should be set to the user's name and is used in a variety of
        places, e.g. by lslmetfinsrt(3)le to set the "Created By" field in a
        template.

    cGOrganizer FilecA
        Sets the organizer file base name, defaults to the cDLog NamecA. When
        notes and addresses are stored using lslmorganizer(3)le the file
        "cC<Organizer>cAcG.eofcA" is used.

    cGGlobal ModescA
        Sets the initial state of the global ls$quiet(5)lmquiet(5)le global variable.

    cGSearch ModescA
        Sets the initial state of the global search modes lslmexact(2m)le and
        lslmmagic(2m)le. This indirectly executes lslmglobal-mode(2)le to set the required
        modes.

    cGBuffer ModescA
        Sets the initial state of the global modes lslmauto(2m)le, lslmbackup(2m)le,
        lslmtab(2m)le and lslmundo(2m)le, any buffers created will inherit the state of
        these modes. However, as changing these modes directly effects only
        the global modes, any existing buffers (including ones re-created
        using the cG-ccA command-line option, see lslmme(1)le) will not be effect by the
        setting of these modes. For them to take effect, the buffers should be
        reloaded. These modes can be changed on a per file type basis using
        the command lslmbuffer-setup(3)le, also some file hooks override these
        global settings, such as the lslmmakefile(9)le hook which overrides the cDtabcA
        mode. This indirectly executes lslmglobal-mode(2)le to set the required
        modes.

    cGAuto-Save TimecA
        Sets the length of time in seconds between buffer auto-saves, a
        setting of cG0cA or an empty string disables auto-saving. The default
        setting is 300 seconds or 5 minutes. This indirectly sets the
        ls$auto-time(5)lmauto-time(5)le variable and the lslmautosv(2m)le global mode.

    cGKeep UndocA
        If this is enabled the lsundo(2)lmundole history is kept after a save allowing the
        lslmundo(2)le command to back-up changes beyond the last save. When clear
        the undo history is discarded after the buffer is saved. This
        indirectly sets bit 0x8000 of the lslm$system(5)le variable.

    cGHide BackupscA
        Enables hiding MicroEmacs generated backup files. On Windows and Dos
        platforms the Hidden file attribute is used to hide the file, whereas
        on UNIX the backup file name is prepended with a 'cG.cA'. This indirectly
        sets bit 0x100000 of the lslm$system(5)le variable.

    cGMain Menu - EnablecA
        Enables the top main menu bar.

    cGF-Type Buffer SelcA
        When enabled the main cDFilecA menu's cDBuffercA selection sub-menu changes
        from being a simple complete list of buffers to being a list of cDFile
        TypescA (as defined by the cDFile TypescA section below). Selecting one of
        these file types opens a further sub-menu listing all buffers of this
        type; this option is useful when the current session of MicroEmacs has
        a large number of buffers.

    cGAlt Action - Esc PrfxcA
        If enabled the Alt key acts as a lsprefix(2)lmprefix 1le modifier key when no direct
        binding exists. By default 'cGA-ncA' is not bound, with this bit set the
        key is inferred to 'cGesc ncA' which is bound to cDforward-paragraphcA. Note
        that global, local and menu hot-key bindings override these. This
        indirectly sets bit 0x4000 of the lslm$system(5)le variable.

    cGAlt Action - Main Menu Hot-keyscA
        If enabled the main menu Alt hot-key bindings are enabled. These are
        dynamic bindings automatically generated from the main menu. Typically
        the first item in the main menu is "cGFilecA" with a hot key of 'cDFcA', with
        this enabled 'cGA-fcA' will open this menu item. Note that global and
        local key bindings override these. This indirectly sets bit 0x2000 of
        the lslm$system(5)le variable.

    cGAbbrev SetupcA
        Configures which abbreviation expansion methods are enabled by default
        when the lslmexpand-abbrev-handle(3)le is executed. cDAccentcA enables
        lslmexpand-iso-accents(3)le, cDLookbackcA enables lslmexpand-look-back(3)le and cDDict'ncA
        enables lslmexpand-word(3)le.

    cGTab To IndentcA
        Sets the lslmtab(2)le behavior in a buffer which has an lsindent(2)lmindentationle method.
        This indirectly sets bits cG0x1000cA and cG0x200000cA of the lslm$system(5)le
        variable.

    cGShow ModescA
        Selects which modes are to be displayed on the mode-line whenever a
        "cG%ecA" token is used in the lslm$mode-line(5)le variable. This indirectly sets
        the lslm$show-modes(5)le variable.


cEPlatform - UNIX Setup cA


    Only present on UNIX platforms using the X interface, see below for the
    Console setup.

    cGFontcA
        Sets the X font name to be used. This indirectly executes
        lslmchange-font(2)le with the given font name. e.g.

        cG"-*-fixed-medium-r-normal--15-*-*-*-c-90-*"cA

    cGDisplay Char SetcA
        Selects the display character set being used by the system to render
        the MicroEmacs window, dependent on the cDFontcA being used. The setting
        of this option effects the configuration of MicroEmacs's internal
        character maps (using command lslmset-char-mask(2)le) enabling the character
        sets of foreign languages to be correctly supported. It also changes
        the definition of variables lslm$box-chars(5)le and lslm$window-chars(5)le to
        their best values for the given font.

    cGExtend Char SetcA
        When enabled MicroEmacs replaces the display of characters cG0x00cA to
        cG0x1fcA with forms which are useful for variables lslm$box-chars(5)le and
        lslm$window-chars(5)le greatly improving the look of lslmosd(2)le dialogs, the
        scroll bars etc.

    cGUse FontscA
        When enabled the bold, italic, light and underline characteristics of
        the font will be used depending on their availability and the Color
        Scheme being used. This indirectly sets bit cG0x10cA of the lslm$system(5)le
        variable.

    cGDraw White SpacescA
        Enables the drawing of visible white spaces, i.e. space, tab and
        new-line characters. This indirectly sets bit cG0x80000cA of the
        lslm$system(5)le variable.

    cGEnable ToolbarcA
        Enables the Toolbar - configurable, managed windows giving easy access
        to many features and tools. When enabled the toolbar is opened and
        displayed at start-up, when disabled the toolbar is not displayed but
        it can be opened (or closed) by simply executing the lslmtoolbar(3)le
        command.

    cGClient ServercA
        The client/server enables the file based external macro command driver
        to be enabled - see lsClient-Server(2)lmClient-Serverle. This by default is disabled, when
        enabled it is used by lsme(1)lmcommand-linele options cD-mcA and cD-ocA.

    cGDOS File NamescA
        DOS has a restricted 8.3 file naming system (i.e. "cGBBBBBBBB.XXXcA"), if
        this option is enabled the MicroEmacs 2009 will adhere to this system
        for auto-save and backup file names whenever possible. See
        lslm$auto-time(5)le for more information on the naming convention used. This
        indirectly sets bit 0x400 of the lslm$system(5)le variable.

    cG# BackupscA
        This option only has an effect when cDDOS File NamescA is disabled.
        Setting this to a number greater than zero enables multiple backup
        files to be created, the number determined by this value. If set to
        zero (or less) then only a single backup file is created. This
        indirectly sets the lslm$kept-versions(5)le variable.

    cGIgnore FilescA
        Sets a list extensions of files to be ignored in file completion, e.g.
        MicroEmacs backup files (cG~cA). This indirectly sets the lslm$file-ignore(5)le
        variable.

    cGCursor Blink RatecA
        Sets the cursor blink period in millisecond. The first entry box sets
        the cursor visible time, a setting of zero disables blinking. The
        second box sets the hidden time. A visible time of 600 and hidden time
        of 200 gives a reasonable blink cycle. This indirectly sets the
        lslm$cursor-blink(5)le variable.

    cGFence DisplaycA
        Sets the preferred method of displaying a matching fence, a fence is
        one of the following brackets:

        {...}   (...)   [...]


        Jumping to the opening fence only occurs when the closing brace is
        typed, whereas the drawing of matching fences occurs whenever the
        cursor is on an open fence or one character past the close fence. When
        this option is set to "cGNever DisplaycA" the lslmbuffer-setup(3)le setting is
        ignored.

    cGScroll BarscA
        Selects the scroll bar support required. When Splitter is enabled, the
        first character of the scroll bar and mode-line is a split character
        used for splitting the window into two using the mouse. This
        indirectly sets the lslm$scroll-bar(5)le variable.

    cGHorizontal ScrollcA
        Selects the horizontal scrolling method used with the lslmscroll-left(2)le
        and lslmscroll-right(2)le commands. This indirectly sets the lslm$scroll(5)le
        variable.

    cGVertical ScrollcA
        Selects the vertical scrolling method used with the lslmforward-line(2)le
        and lslmbackward-line(2)le commands. This indirectly sets the lslm$scroll(5)le
        variable.

    cGColor SchemecA
        Sets the color scheme setup macro file name which is executed at
        start-up. MicroEmacs by default comes with 4 color schemes. Color
        schemes can be created and altered using the lslmscheme-editor(3)le dialog.


cEPlatform - UNIX Console Setup cA


    Only present on UNIX platforms when using the termcap interface, all the
    Console platform settings are kept independent of the X interface
    settings.

    cGDisplay Char SetcA
        See cDPlatform UNIX SetupcA above.

    cGTermcap ColorcA
        This option determines whether Termcap based colors should be used.
        These are typically the standard eight colors and may not be supported
        on all terminals. If this option is disabled Termcap fonts (such as
        bold) are used instead to create a primitive hi-lighting. This
        indirectly sets bit 0x004 of the lslm$system(5)le variable.

    cGUse FontscA
        See cDPlatform UNIX SetupcA above.

    cGDraw White SpacescA
        See cDPlatform UNIX SetupcA above.

    cGEnable ToolbarcA
        See cDPlatform UNIX SetupcA above.

    cGClient ServercA
        See cDPlatform UNIX SetupcA above.

    cGDOS File NamescA
        See cDPlatform UNIX SetupcA above.

    cG# BackupscA
        See cDPlatform UNIX SetupcA above.

    cGIgnore FilescA
        See cDPlatform UNIX SetupcA above.

    cGCursor Blink RatecA
        See cDPlatform UNIX SetupcA above.

    cGFence DisplaycA
        See cDPlatform UNIX SetupcA above.

    cGScroll BarscA
        See cDPlatform UNIX SetupcA above.

    cGHorizontal ScrollcA
        See cDPlatform UNIX SetupcA above.

    cGVertical ScrollcA
        See cDPlatform UNIX SetupcA above.

    cGColor SchemecA
        See cDPlatform UNIX SetupcA above.


cEPlatform - Win32 Setup cA


    Only present on Microsoft Windows based machines.

    cGFont NamecA
        Sets the windows font name and size. This indirectly executes
        lslmchange-font(2)le with the given font name. MicroEmacs may only use a
        Fixed Mono Font, either an OEM font as used by the MS-DOS command
        line, or the more conventional ANSI fonts. The fonts are selected
        using the cDChangecA cDFontcA button which invokes a dialog to allow the
        available fonts to be selected. True-Type mono fonts such as cGCourier
        NewcA or cGLucida ConsolecA are typically used.

    cGWeight & SizecA
        Allows the size and weight of the font to be selected, specified as
        cCweightcA, cCwidthcA and cCheightcA. The cCweightcA is typically 4, this corresponds
        to a regular weighting, 7 is bold. cCwidthcA is the width of the font in
        pixels, this may be 0 when the height is specified as negative. cCheightcA
        is the height of the font, typically a negative value (where the cCwidthcA
        is 0), which produces a proportionally sized font, values of in the
        range -11 .. -14 generally produce reasonably sized fonts. The cChightcA
        and cCwidthcA may be specified as positive values and allow explicit font
        dimensions to be specified, generally used to achieve a precise font
        size requirement.

    cGFontscA
        See cGUse FontscA in cDPlatform UNIX SetupcA above.

    cGDisplay Char SetcA
        See cDPlatform UNIX SetupcA above.

    cGExtend Char SetcA
        See cDPlatform UNIX SetupcA above.

    cGChoose FontcA
        Opens a windows dialog allowing the user to select a font, the
        selection is used to configure the above font fields.

    cGDraw White SpacescA
        See cDPlatform UNIX SetupcA above.

    cGCapture Alt SpacecA
        Used to enable/disable the capture and interpretation of the 'cGA-spacecA'
        key sequence. If this key sequence is not captured by MicroEmacs it is
        passed back to Windows which opens the top left window menu, allow
        keyboard access to Window commands like Maximize.

    cGEnable ToolbarcA
        See cDPlatform UNIX SetupcA above.

    cGClient ServercA
        See cDPlatform UNIX SetupcA above. Note that on windows based systems the
        client/server is also used by lslmmemsdev(1)le to drive the editor from the
        Microsoft Developer environment.

    cGDOS File NamescA
        See cDPlatform UNIX SetupcA above. Note that some early version of Windows
        '95 have problems with cG~cA extensions. Service release 2 fixed these
        problems - if you experience problems then return to 8.3 filename mode
        - note that MicroEmacs will still store longer file names, only the
        backup naming convention changes.

    cG# BackupscA
        See cDPlatform UNIX SetupcA above.

    cGIgnore FilescA
        See cDPlatform UNIX SetupcA above.

    cGCursor Blink RatecA
        See cDPlatform UNIX SetupcA above.

    cGFence DisplaycA
        See cDPlatform UNIX SetupcA above.

    cGScroll BarscA
        See cDPlatform UNIX SetupcA above.

    cGHorizontal ScrollcA
        See cDPlatform UNIX SetupcA above.

    cGVertical ScrollcA
        See cDPlatform UNIX SetupcA above.

    cGColor SchemecA
        See cDPlatform UNIX SetupcA above.


cEPlatform - Win32 Console Setup cA


    Only present on Windows NT and Win95+ platforms when using the console
    interface, all the Console platform settings are kept independent of the
    Window interface settings.

    cGDisplay Char SetcA
        See cDPlatform UNIX SetupcA above.

    cGDraw White SpacescA
        See cDPlatform UNIX SetupcA above.

    cGEnable ToolbarcA
        See cDPlatform UNIX SetupcA above.

    cGClient ServercA
        See cDPlatform Win32 SetupcA above.

    cGDOS File NamescA
        See cDPlatform Win32 SetupcA above.

    cG# BackupscA
        See cDPlatform UNIX SetupcA above.

    cGIgnore FilescA
        See cDPlatform UNIX SetupcA above.

    cGCursor Blink RatecA
        See cDPlatform UNIX SetupcA above.

    cGFence DisplaycA
        See cDPlatform UNIX SetupcA above.

    cGScroll BarscA
        See cDPlatform UNIX SetupcA above.

    cGHorizontal ScrollcA
        See cDPlatform UNIX SetupcA above.

    cGVertical ScrollcA
        See cDPlatform UNIX SetupcA above.

    cGColor SchemecA
        See cDPlatform UNIX SetupcA above.


cEPlatform - DOS Setup cA


    Only present on DOS machines.

    cGGraphic Mode #cA and cGDouble LinescA
        Sets the DOS graphics mode number and whether the number of text lines
        can be doubled. This indirectly executes lslmchange-font(2)le with the given
        font name.

    cGDisplay Char SetcA
        See cDPlatform UNIX SetupcA above.

    cGDouble LinescA
        In some graphic modes the number of text lines can be doubled via a
        dos terminal call, this option is worth trying if more visible text
        lines are required.

    cGDraw White SpacescA
        See cDPlatform UNIX SetupcA above.

    cGEnable ToolbarcA
        See cDPlatform UNIX SetupcA above.

    cGIgnore FilescA
        See cDPlatform UNIX SetupcA above.

    cGCursor Blink RatecA
        See cDPlatform UNIX SetupcA above.

    cGFence DisplaycA
        See cDPlatform UNIX SetupcA above.

    cGScroll BarscA
        See cDPlatform UNIX SetupcA above.

    cGHorizontal ScrollcA
        See cDPlatform UNIX SetupcA above.

    cGVertical ScrollcA
        See cDPlatform UNIX SetupcA above.

    cGColor SchemecA
        See cDPlatform UNIX SetupcA above.


cEMouse cA


    The mouse device creates keys in a similar way to regular keyboard keys
    and, like keyboard keysm they must be bound before they are used.
    MicroEmacs 2009 does not have the mouse functionality hard coded into the
    editor, it provides a macro interface to the mouse for ultimate
    flexibility and a set of default functionality which can be bound to the
    mouse in a variety of ways.

    All the mouse controlling macros are stored in cGmouse.emfcA and cGmouseosd.emfcA
    although some buffers have local functionality over-rides, such as
    lslmfile-browser(3)le. The user can expand the range of mouse functionality but
    how this is achieved is beyond the scope of this documentation.

    The cDuser-setupcA dialog allows the user to configure the mouse to use the
    default functionality, as follows:-

    cGEnable MousecA
        Enables or disables the mouse, when disabled the mouse can not be used
        and will not generate any key events. This does not apply to UNIX
        Termcap systems as the mouse cut and paste operation is performed by
        the Xterm. This indirectly sets bit 0x010 of the lslm$mouse(5)le variable.

    cGNumber ButtonscA
        Sets the number of buttons on the mouse, may be 1, 2 or 3. MicroEmacs
        usually obtains the correct number for the system, but sometimes this
        can be wrong. This entry can be used to correct this problem. For one
        button mice, the button is considered to be the cGleftcA mouse button, two
        button mice have an cGleftcA and cGrightcA button. This indirectly sets the
        lslm$mouse(5)le variable.

    cGSwap ButtonscA
        If enabled then the cGleftcA and cGrightcA buttons are swapped, i.e. when the
        left button is pressed it executes the right button bindings. This
        indirectly sets bit 0x020 of the lslm$mouse(5)le variable.

    cGSimulate 3 ButtonscA
        If enabled then pressing the cGleftcA and cGrightcA buttons together with
        generate a middle button press event, this feature is for people with
        a 2 button mouse who want more. The two buttons must be pressed or
        release within 10 millisecond of each other.

    The following four fields determine which mouse button binding the user
    wishes to view and change:-

    cGButtoncA
        The mouse button, cGLeftcA, cGRightcA or cGMiddlecA for the normal buttons and
        cGWhell UpcA or cGWhell DowncA for the pilot wheel events.

    cGModifier - ShiftcA
        The action of the mouse can be different for every modifier key
        setting, if this is enabled then the binding being modified is for the
        cDButtoncA being pressed with the cDShiftcA key held down.

    cGModifier - ControlcA
        If enabled then modifying the action when the cDButtoncA is pressed with
        the cDControlcA key held down.

    cGModifier - AltcA
        If enabled then modifying the action when the cDButtoncA is pressed with
        the cDAltcA key held down.

    The following two fields determine the functionality of the button defined
    by the previous four fields:-

    cGBound TocA
        The function to be performed. The functions available depend on the
        type of button being bound, the following is a list of functions
        available for normal buttons:-

        cG<not bound>cA
            The Button is not bound.

        cGDrag regioncA
            lslmset-mark(2)le is called at the pick location, until the button is
            dropped, the area of text between this point and the current mouse
            position is hi-lighted. When the mouse button is dropped, if the
            drop position is the same as the pick then the double click is
            tested for, if a double click is entered then the cDSelect WordcA
            function is executed, otherwise the cursor is simply moved to the
            drop position. If the pick and drop position are different then
            the enclosed text is copied to the kill buffer using
            lslmcopy-region(2)le. Note this behaviour is altered by the setting of
            cDMS Shift RegioncA on the cDStart-UpcA page.

        cGCopy RectanglecA
            One corner of a rectangle is defined on the pick and the
            diagonally opposite corner is defined when the button is dropped,
            the text enclosed within the rectangle is copied to the kill
            buffer using lslmcopy-rectangle(3)le.

        cGKill RectanglecA
            The same as cGCopy RectanglecA except the text is killed using
            lslmkill-rectangle(2)le.

        cGSelect WordcA
            Also executed from a double click bound to cDDrag RegioncA, cDSelect
            WordcA copies the word under the mouse into the kill buffer using
            lslmcopy-region(2)le, unless a double click is entered in which case the
            whole line is copied.

        cGDefault PancA
            While the mouse button is pressed the current buffer pans with any
            mouse movement.

        cGMS PancA
            MicroSoft style Pan; while the mouse button is pressed the current
            buffer pans vertically according to the mouse position relative to
            the point where the button was pressed.

        cGFind BuffercA
            Opens a buffer selection dialog, the buffer selected is displayed
            in the window.

        cGFind TagcA
            Executes lslmfind-tag(2)le with the word currently under the mouse.

        cGFind ME HelpcA
            Executes lslmhelp-item(2)le with the word currently under the mouse.

        cGUndocA
            Simply executes lslmundo(2)le without moving the cursor to the position
            of the mouse. Subsequent calls to this binding will undo multiple
            edits.

        cGNo Move YankcA
            Simply executes lslmyank(2)le without moving the cursor to the position
            of the mouse.

        cGReplace YankcA
            Simplar to "cGNo move yankcA" except when the is a current region
            (typically defined by "cGDrag regioncA" above), in which case the
            region is first deleted.

        cGMove to YankcA
            Moves the cursor to the current position of the mouse and executes
            lslmyank(2)le.

        cGReyankcA
            Executes lslmreyank(2)le without moving the cursor. Note, to enable this
            functionality some sanity checks have had to be removed, as a
            result it should not be misused as seeming bizarre things can
            occur.

        cGRectangle YankcA
            Moves the cursor to the current position of the mouse and executes
            lslmyank-rectangle(2)le.

        cGCollapse CurrentcA
            Toggles the collapse status of the current block, only applicable
            in buffers supporting lslmcollapse-current(3)le, such as c and emf
            files.

        cGCollapse AllcA
            Toggles the collapse status of the whole buffer, opening or
            closing all found blocks. Only applicable in buffers supporting
            lslmcollapse-all(3)le, such as c and emf files.

        cGMain MenucA
            Simply opens the main menu from any where on the screen.

        cGContext MenucA
            Opens a context sensitive menu dependent on the position of the
            mouse, i.e. opens the main menu if over it, opens a different menu
            when executed on the mode-line etc.

        The following is a list of functions available for pilot wheel
        events:-

        cGNot boundcA
            The Button is not bound.

        cGScroll Up 1 LinecA ....
            Scrolls the current buffer by the specified amount.

    cGHandle Scroll BarscA
        When enabled, if the button is pressed with the mouse on the main
        menu, a scroll bar or mode-line the standard action is performed, such
        as opening the main menu or scrolling up or down the window etc. The
        cDbound TocA command is only called if the mouse is in a main window. If
        disabled, the cDBound TocA command is always called.

    cGDefaultscA
        Rests the mouse configuration to the default settings.


cEFile Types cA


    The file type list is used in two places, the main menu's cGFile => Quick
    OpencA sub-menu list and the cGFile => Open => File TypecA list. In each case
    the file type "cGAll FilescA" is automatically added. The user can add, remove
    and change the list of file types by using this dialog. An entry can be
    selected for editing or deletion by simply selecting it with the left
    mouse button. A new entry may be added by simply filling in the 3 entry
    boxes and selecting Add. Items in the Dialog are as follows.

    cGNo.cA
        The file type entry number. A new entry is always added to the end of
        the list, ignoring this value. The position of an existing entry can
        be changed by altering this field to the desired position and
        selecting the cGChangecA button to move it to its new position.

    cGNamecA
        The file type name, the string printed in the sub-menus.

    cGFile Mask ListcA
        A comma ('cG,cA') separated list of file masks which match the file type,
        e.g. for C and C++ source files use "cG*.c,*.cc,*.cppcA".

    cGAddcA
        Adds a new entry to the list, only the cDNamecA and cDFileMask ListcA fields
        are used, the cDNo.cA field is ignored as the new entry is always added to
        the end of the list. The position can be altered by using the cDChangecA
        button.

    cGChangecA
        Alters an existing file type entry, all 3 fields must be set.

    cGDeletecA
        Deletes the current entry number, only the cDNo.cA entry is used.


cETools cA


    The Tools dialog allows the user to configure up to 10 system commands, or
    tools, which can be executed via MicroEmacs Main Tools Menu. The dialog
    configures the user's registry for the command lslmexecute-tool(3)le to be used.
    The execution of a tool can also be bound to a key, see cDexecute-toolcA for
    more information.

    The top half of the dialog consists of the 10 Tools (cG0cA-cG9cA) configuration
    buttons. Selecting one of these selects the current tool to be configured,
    the current tool is shown by the title in the middle of the dialog.

    The lower half of the dialog configures the currently selected tool, as
    follows:-

    cGTool NamecA
        Sets the displayed name of the tool. The tool name is used in the
        buttons in the top half of this dialog and in the MicroEmacs Main
        Tools Menu.

    cGCommand LinecA
        Sets the system command-line to be launched whenever the tool is
        executed, the following special tokens may be used in the command-line
        which are substituted at execution:-

        cD%ffcA
            The current buffer's full file name, including the path.

        cD%fpcA
            The current buffer's file path.

        cD%fncA
            The current buffer's file name without the path.

        cD%fbcA
            The current buffer's file base name, i.e. the file name without
            the path or the extension.

        cD%fecA
            The current buffer's file extension with the 'cC.cA' (e.g. "cC.emfcA"),
            set to the empty string if the file name does not have an
            extension.

        Note that "cD%ffcA" is always the same as "cD%fp%fncA" and "cD%fp%fb%fecA". If any
        of these tokens are used, the tool will fail to execute if the current
        buffer does not have a file name.

    cGRun ConcurrentlycA
        If enabled, when the tool is executed the command is launched and run
        concurrently, allowing the user to continue working in MicroEmacs
        during the tools execution. This option is not available for all
        versions on MicroEmacs and forces the output to be captured. Enabling
        this option will force the use of command lslmipipe-shell-command(2)le to
        launch the tool.

    cGCapture OutputcA
        If enabled any output produced from the execution of the tool will be
        captured and inserted into a new buffer. When enabled the following
        two items, cGBuffercA and cGHidecA, may be specified. When disabled the
        command used to execute the tool is lslmshell-command(2)le, otherwise the
        command used is either lslmpipe-shell-command(2)le or lslmipipe-shell-command(2)le
        depending on the setting of cGRun ConcurrentlycA.

    cGBuffercA
        Specifies the buffer name the captured output should be dumped to,
        this option is only visible when cGCapture OutputcA is enabled. The
        following special tokens may be used in the buffer name which are
        substituted at execution:-

        cD%fncA
            The current buffer's file name without the path, set to the buffer
            name if the current buffer does not have a file name.

        cD%fbcA
            The current buffer's file base name, i.e. the file name without
            the path or the extension. Set to the buffer name if the current
            buffer does not have a file name.

        cD%fecA
            The current buffer's file extension with the 'cC.cA' (e.g. "cC.emfcA"),
            set to the empty string if the current buffer does not have a file
            name or it does not have an extension.
        Note that "cD%fncA" is always the same as "cD%fb%fecA". Default buffer name
        when this field is left empty is "cC*command*cA", or "cC*icommand*cA" if cGRun
        ConcurrentlycA is enabled.

    cGHidecA
        When enabled the tool output capture buffer is hidden, this option is
        only visible when cGCapture OutputcA is enabled.

    Current Buffer - cGSavecA and cGPrompt Before SavingcA
        If the current buffer has been edited, enabling cGSave Current BuffercA
        will automatically save the current buffer before executing the tool.
        This is particularly useful when the tool operates on the current
        buffer's file (e.g. compiles the file). If cGPromptcA is also enabled the
        user will be prompted before the file is saved.

    All Buffers - cGSavecA and cGPrompt Before SavingcA
        If cGSave All BufferscA is enabled, all edited buffers will be
        automatically saved before executing the tool. This is particularly
        useful when the tool may operate on multiple files (e.g. compilation
        of a project). If cGPromptcA is also enabled the user will be prompted
        before each file is saved.


cEE-Mail cA


    MicroEmacs 2009 provides a simple E-Mail manager, see lslmvm(3)le for more
    information and example entries. It must be stressed that cDvmcA has only been
    tested in one environment, caution should be used as system differences
    may cause problems, such as loss of data, which the author does not except
    any responsibility for.

    The cDE-Mail SetupcA dialog configures a user to use part or all of the cDvmcA
    E-Mail manager, as follows:-


cEPlatform ALL Mail Setup cA


    The following field is used for both sending and receiving mail:

    cGUser Mail DircA
        Sets the user mail-box directory where all files are to be found and
        stored (except usually the cDIncoming Mail boxcA). The value of this field
        is platform independent and must be setup for each one.

    The following fields are used for sending mail:

    cGSend Mail SignaturecA
        Sets the signature file name which is inserted at the bottom of every
        out-going email message, if empty the no signature is inserted. The
        value of this field is platform independent, is value use by all. The
        file must be located in the cDUser Mail DircA and no path entered for it
        to work across platforms.

    cGCarbon-Copy FilecA
        Sets the sent-mail carbon-copy file, creating the "cGFcc:cA" line of the
        mail buffer. All out-going emails are appended to the end of this file
        if the "cGFcc:cA" line is not altered. If this field is left empty then no
        "cGFcc:cA" line is created. The value of this field is platform
        independent, the file must be located in the cDUser Mail DircA.

    cGInsert Data (^C^I)cA
        Sets the first embedded data command line, bound to "cGC-c C-IcA". The
        value of this field is platform dependent.

    cGInsert Data (^C^Z)cA
        Sets the second embedded data command line, bound to "cGC-c C-zcA". The
        value of this field is platform dependent.

    cGSend Mail CommandcA
        Sets the command-line used for sending email messages. The value of
        this field is platform dependent.

    The following fields are used for receiving mail:

    cGCheck for mailcA
        Sets the time interval between the automatic checking for incoming
        mail in seconds, when set to 0 the automatic checking is disabled.
        When enabled, the check is performed by lslmmail-check(3)le which also sends
        any queued mail and gets any new mail if the cDGet Mail CommandcA is used.
        The value of this field is platform dependent.

    cGGet Mail CommandcA
        The command used to get new mail from the server, if empty it is
        assumed the cDIncoming Mail BoxcA is automatically updated by the system.
        If used the command must append new mail to the end of the cDIncoming
        Mail BoxcA specified below. The value of this field is platform
        dependent.

    cGIncoming Mail BoxcA
        Sets the incoming mail box file which new incoming mail is appended
        to, either automatically by the system or by the cDGet Mail CommandcA. The
        value of this field is platform dependent.

    cGVM Main In BoxcA
        Sets the main current mail box, or inbox. The value of this field is
        platform independent, the file must be located in the cDUser Mail DircA.

    cGVM Gets MailcA
        When enabled, executing the command vm will not only create the mail
        box windows, it will also get and process any new mail. When disabled
        only the vm 'cGgcA' command can be used to get and process new mail.

    cGMime Data ExtractcA
        Sets the command-line used for extracting Mime encoded embedded data.
        The value of this field is platform dependent.

    cGUuencode ExtractcA
        Sets the command-line used for extracting Uuencoded embedded data. The
        value of this field is platform dependent.

    cGAuto-Archive SetupcA
        Sets up the auto-archive of messages in the current inbox to other
        mail boxes.


cEcENOTES cEcA


    cDuser-setupcA is a macro using lslmosd(2)le, defined in cGuserstp.emfcA.


cEcESEE ALSO cEcA


    lsUserProfiles(2)lmUser Profilesle, lsCompanyProfiles(2)lmCompany Profilesle, lsInstallation(1)lmInstallationle, lslmbuffer-setup(3)le,
    lslmchange-scheme(3)le, lslmscheme-editor(3)le, lslm$user-name(5)le, lslm$user-path(5)le.
! 3 organizer
cEcENAME cEcA


    organizer - Calendar and address organizer
$a


cEcESYNOPSIS cEcA


    cDorganizercA


cEcEDESCRIPTION cEcA


    cDorganizercA is a calendar and address organizer, enabling notes to be stored
    against the calendar days; addresses may be archived into an address book.

    cDorganizercA uses the MicroEmacs 2009 in-built registry to store information
    within a registry file called cC<username>cAcG.eofcA. cDorganizercA may be entered
    directly from the command line, or via the menu (via cDToolscA).

    cDorganizercA is displayed within a single osd dialog box, tab selections at
    the top of the window enable the different forms of information to be
    displayed. Navigation is typically performed using the mouse, where the
    mouse is absent then the cGTABcA key may be used to move between the fields.
    The information presented is defined as follows:-


cEMonth cA


    Shows the calendar month, starting with the current month, the current day
    is hi-lighted and any notes that have been entered are displayed in the
    cDNotescA entry box at the bottom of the page.

    The default mode of operation is note entries for the current month,
    however specifying the cC<year>cA as the wild card 'cD*cA' (star) enables annual
    events to be entered into the organizer. Annual events are automatically
    inserted into the calendar each year, typically used for birthdays etc.

    The entry controls to the dialog are defined as follows:-

    cD<-cA
        Advances to the previous month.

    cD->cA
        Advances to the next month.

    cC<Month>cA
        A pull down dialog enabling month selection.

    cC<year>cA
        A text entry field specifying the current year as a 4 digit number. A
        value of cD*cA is the wild card year for specifying annual events.

    cDNotescA
        A free form text entry box allowing a note to be attached to the
        currently selected day.

    cDSavecA
        Saves the entry back to file.

    cDMonth To BuffercA
        Dumps a view of the month to the currently active buffer, any notes
        are also dumped to the buffer.

    cDClosecA
        Exits the cDorganizercA.


cEWeek cA


    Shows the calendar week in the current buffer, the days of the week are
    shown in a column ordering. Note that selection of the week is typically
    performed from the cDMonthcA view, moving to the cDWeekcA view (via the tab)
    selects the week appropriate to the previously selected day within the
    month view.

    The entry controls on the dialog are defined as follows:-

    cD<-cA
        Advances to the previous week.

    cD->cA
        Advances to the next week.

    cC<year>cA
        A text entry field specifying the current year as a 4 digit number.
        The value of cD*cA for viewing and setting annual events is not valid in
        this view.

    cDNotescA
        A free form text entry box allowing a note to be attached to the
        currently selected day.

    cC<day>cA
        Selecting a date in the cCdaycA column changes the view to the cDDaycA view.

    cDSavecA
        Saves the entry back to file.

    cDWeek To BuffercA
        Dumps a view of the week to the currently active buffer, any notes are
        also dumped to the buffer.

    cDClosecA
        Exits the cDorganizercA.

    cDNote:cA The start day in the week view may be configured to commence on a
    day other than Sunday from the cDSetupcA tab.


cEDay cA


    Shows an extended view of the notes attached to the current day, day
    selection is typically performed from the cDMonthcA or cDWeekcA views. The entry
    controls on the dialog are defined as follows:-

    cD<-cA
        Advances to the previous day.

    cD->cA
        Advances to the next day.

    cC<year>cA
        A text entry field specifying the current year as a 4 digit number. A
        value of cD*cA is the wild card year for specifying annual events.

    cC<month>cA
        A pull down dialog enabling month selection.

    cC<day>cA
        A text entry enabling the current day to be entered.

    cDNotescA
        A free form text entry box allowing a note to be attached to the
        currently selected day.

    cDSavecA
        Saves the entry back to file.

    cDDay To BuffercA
        Dumps a view of the day to the currently active buffer, any notes are
        printed in the buffer.

    cDClosecA
        Exits the cDorganizercA.


cELists cA


    The lists pane provides support for multiple list generation and
    manipulation. Each list consists of zero or more ordered items each of
    which has a text field in which the user can enter information.

    Entry to the dialog is defined as follows:-

    cDListcA
        Selects a list.

    cDNewcA
        Creates a new list.

    cDLines Per ItemcA
        Sets the number of lines to use when displaying a list item.

    cDNewcA
        Creates a new list item at the end of the current list.

    cDUpcA
        Moves the currently selected item (left click on the item number) up
        the list.

    cDDowncA
        Moves the currently selected item down the list.

    cDInsertcA
        Inserts a new list item before the currently selected item.

    cDDeletecA
        Deletes the currently selected item.

    cDSavecA
        Saves the entry back to file.

    cDList To BuffercA
        Dumps a view of the list to the currently active buffer.

    cDClosecA
        Exits the cDorganizercA.


cEAddress cA


    The address pane provides entry to the address book, enabling personal and
    business details to be retained against a single name, tabbed selection of
    cDWorkcA or cDHomecA selects the information that is displayed. A search engine is
    provide to locate names within the database, and provision is made to save
    some text against a name. Entries in the database are, by default,
    organized by record number, sorting may be explicitly performed from the
    cDSortcA button.

    Entry to the dialog is defined as follows:-

    cC<Record No>cA
        The identity number of the record, a value of cD*cA denotes that this is a
        new record that is being inserted.

    cD<<cA
        Moves to the start of the database.

    cD>>cA
        Moves to the end of the database, showing record cD*cA, a new entry may be
        entered.

    cD<cA
        Moves to the previous record.

    cD>cA
        Moves to the next record.

    cDNamecA
        The name of the individual, entered as cCfore-namecA and cCsurnamecA.

    cDNicknamecA
        A pseudo name assigned to an individual.

    cDPartnercA
        Shown in the cDHomecA view only. The cCforenamecA and cCsurnamecA of any partner.

    cDChldcA
        Shown in the cDHomecA view only in the cDExtended Address Book ModecA. The
        names of any children (up to 3).

    cDDOBcA
        Date of Birth, shown in the cDHomecA view only in the cDExtended AddresscA
        cDBook ModecA. The dates of birth of the parents, any children in addition
        to an anniversary date.

    cDCompanycA
        Shown in the cDWorkcA view only. The name of the company.

    cDAddresscA
        The address of the individual/company.

    cDTelcA/cDFaxcA/cDMobilecA
        Telecommunication information.

    cDEmailcA/cDWWWcA/cDFTPcA
        Electronic communication information.

    cDNotescA
        Notes associated with the individual.

    cDSavecA
        Saves the address information to file.

    cDDupcA
        Duplicates the currently selected address entry, creating a new record
        card. Typically used to construct a similar entry for a different
        individual.

    cDDeletecA
        Deletes the currently selected entry.

    cDAddr to BuffercA
        Dumps the currently selected address to the current buffer.

    cDClosecA
        Exits the organizer.

    cDFindcA
        cDfindcA provides access to a search engine, enabling addresses to be
        located in the address book.

        cDSearch ForcA
            The string to search for.

        cDIn FieldcA
            Pull-down menu allowing the selection of the field to be searched
            in.

        cDMatchcA
            Selects how strict the search should be; typically cDAny PartcA is
            used as this is the least in-exact search. The default mode is
            configured in the cDSetupcA tab.

        cDCasecA/cDmagiccA
            Selects the search criteria. The default mode is configured in the
            cDSetupcA tab.

        cDFirstcA
            Finds the first record that matches the search criteria

        cDNextcA
            Finds the next record that matches the search criteria, from the
            currently displayed record.

        cDReversecA
            Searches in reverse order.

        cDClosecA
            Exits the search

    cDSortcA
        cDsortcA provides a mechanism to re-sort the data base into a different
        order. The sort is performed on up to 3 different keys enabling
        conflicting primary sort fields to be resolved by the secondary sort
        criteria. The default sort order is cC<Record No>cA, cC<None>cA, cC<None>cA.

        cDSort KeyscA
            The cCPrimarycA, cCSecondarycA and cCTertiarycA sort fields are selected by a
            pull down menu. The fields to be used for sorting are selected
            from the list.

        cDSortcA
            Performs the sort, based on the settings of the cCSort KeyscA.

        cDClosecA
            Exits the sort dialog.


cESetup cA


    The cDsetupcA pane configures a number of general settings of the organizer.

    cDCurrent Organizer FilecA
        The full pathname of the organizer file. By default this is set to
        cC<userpath><userName>cAcD.eofcA and can be altered using lslmuser-setup(3)le.

    cDChange NamecA
        Allows the displayed name of the month and the day to be modified.

    cDFirst Day of the weekcA
        Selects the first day of the week, this sets the first day to be
        displayed in the cDWeekcA view and the first column in the cDMonthcA view.

    cDMin New Year DayscA
        The number of days that must appear in the first week of the New Year
        for the week to be considered week 1. Modifying the value of this
        field modifies the week number.

    The cDCalendarcA section allows the wordy representation of the calendar date
    to be modified. Typically used to modify the names to the native language.

    cDChange Month NamecA
        Select the existing month representation from the left-hand box and
        type in a new selection into the right-hand box.

    cDChange Week Day NamecA
        As cCChange Month NamecA, enables the day of the week representation to be
        modified.

    cDFirst Day Of The WeekcA
        Selects the first day that appears in the cDWeekcA view.

    cDMinimum Days of New Year in first weekcA
        Specifies the number of days that must appear in the first week of the
        New Year for the week to be designated as week 1. This value allows
        the week number to be aligned with the calender weeks of standard
        diaries. The default value is 7 days; but may be reduced to 5 or 6 for
        typical alignment.

    The cDAddress BookcA section allows the operation of the address book to be
    modified.

    cDUse Extended Address BookcA
        The extended address book allows additional information to be added to
        the personal address book. The extended information is limited to the
        amount of personal information attributed to an individual, including
        cCDate of BirthcA and cCChildcA information.

    cDImport From FilecA
        The cDImportcA from file allows the address book to be imported from a
        file. The import data format is a single line per entry, comma cG,cA
        separated. The field order is defined as follows, the cD*cA entries
        indicate the cDExtendedcA cDAddresscA cDBookcA fields:-

            cCRecord NocA, cCFirst NamecA, cCSurnamecA, cCNick NamecA, cCSelectedcA, cCNotescA,
            cCPartner First NamecA, cCPartner SurnamecA, cCHome AddresscA, cCHome TelephonecA,
            cCHome FaxcA, cCHome MobilecA, cCHome E-MailcA, cCHome WWW PagecA, cCHome FTP SitecA,
            cCWork CompanycA, cCWork AddresscA, cCWork TelephonecA, cCWork FaxcA, cCWork MobilecA,
            cCWork E-MailcA, cCWork WWW PagecA, cCWork FTP SitecA, cCDate-Of-Birth*cA, cCPartner
            DOB*cA, cCDate-Of-Marriage*cA, cCChild1 Name*cA, cCChild1 DOB*cA, cCChild2 Name*cA,
            cCChild2 DOB*cA, cCChild3 Name*cA, cCChild3 DOB*cA.

    cDExport To FilecA
        Exports the address book to a file, the address book is exported in
        the current sort order, with the fields defined as above. The exported
        address book may then be imported into a 3rd party package i.e.
        Microsoft Access, etc.

    The cDDefault Address Find SettingscA section defines the default search
    criteria used in the address book search function.

    cDWholecA/cDStartcA/cDAny PartcA
        Radio buttons determine how the search is performed on the string.

                * cDWholecA matches the whole string exactly.
                * cDStartcA matches the first part of the string only (i.e. cGAb*cA).
                * cDAny PartcA finds entries that include the search string at any
                  position within the data base search field.

    cDCase InsensitivecA
        Checked, matches the strings regardless of case. (default).

    cDMagic ModecA
        Allows magic strings to be included in the search string.


cEcENOTES cEcA


    cDorganizercA is a macro that is implemented in cGorganiz*.emfcA files. Organizer
    uses lslmosd(2)le to create and manage the dialogs.

    The maximum size of a text note is 1024 characters.

    With an new address is created it is added to the end of the address list
    regardless of the current sort criteria.

    cDOrganizercA replaces the original cDCalendarcA utility.


cEcESEE ALSO cEcA


    lslmnotes(3)le, lslmuser-setup(3)le, lslmosd(2)le.
! 3 spell-buffer
! 3 spell-word
! 3 spell-edit-word
! 3 find-word
cEcENAME cEcA


|spell-buffer
    spell-buffer - Spell check the current buffer
|spell-word
    spell-word - Spell check a single word
|spell-edit-word
    spell-edit-word - Edits a spell word entry
|find-word
    find-word - Find a using spelling dictionaries
$a


cEcESYNOPSIS cEcA


    cDspell-buffercA
    cCncA cDspell-wordcA ["cCwordcA"] (cDesc $cA)
    cDspell-edit-wordcA ["cCwordcA"]
    cDfind-wordcA ["cCwordcA"]


cEcEDESCRIPTION cEcA


    MicroEmacs 2009 provides an integrated spell checker with the following
    features:-

        * Different languages.
        * Dialog control of the speller.
        * Best guess capability.
        * cCReplacecA and cCReplace allcA, cCIgnorecA and cCIgnore AllcA
        * Undo capability.
        * Adding new words and endings to speller.
        * Auto correct of commonly occurring mistakes.
        * Word finder, allows words to be searched with wild cards.

    cDspell-buffercA spell checks the current buffer, from the current position,
    to the end of the buffer. On invocation, an lslmosd(2)le dialog is opened and
    any corrections are made through this interface. If an error dialog opens
    instead the current language is not setup, please see the Language setting
    in lslmuser-setup(3)le and lslocaleSupport(2)lmLocale Supportle.

    The dialog provides the user with an interface from which a new spelling
    may be selected, in addition new words may be added to the spelling
    dictionary. The dialog entries are defined as follows:-

    cDWordcA
        The cDwordcA entry contains the erroneous word, this is presented in a
        text dialog box which may be manually edited to correct. If the word
        is manually corrected, then it is spell checked prior to insertion,
        and a new guess list is created. The user may elect to replace the
        word, take one of the suggestions or re-edit the misspelled word.

    cDMeaningcA
        The meaning button provides a convenient interface to lslmdescribe-word(3)le
        for looking up the meaning of the current word. The cDInsertcA button
        within the describe-word dialog will replace the current word in the
        spell-buffer.

    cDSuggestionscA
        The suggestions entry contains a list of suggestions as to the correct
        spelling of the word. The list is ranked in order of the best match,
        typically the misspelled word appears at (or near) the top of the
        list, unless the word is unknown or there are gross errors in the
        spelling. Selecting the word in the list with a single click of the
        mouse selects the word as the replacement, the actual replacement is
        performed by the cDReplacecA or cDReplace AllcA buttons. Alternatively, double
        selecting a guess word replaces the word.

    cDLanguagecA
        The cDlanguagecA entry allows the user to select the current spelling
        language. The new language is chosen from the dialog box. The language
        may be changed at any time during the spell operation and is effective
        immediately. The cDExtcA languages are extended dictionaries that contain
        additional words, it is recommended that all spelling is performed
        with the extended dictionaries (where available).

    cDReplacecA
        The cDreplacecA button is activated when a new word has been edited or
        selected as a candidate for replacement. Selecting cDreplacecA modifies
        the erroneous word in the buffer with the newly selected word.

    cDReplace AllcA
        The cDReplace AllcA button is similar to the cDReplacecA button, except that
        it automatically replaces any subsequent occurrences of the erroneous
        word with the newly selected word. The replacement words are retained
        for the MicroEmacs edit session and are lost when the editor is
        closed.

    cDIgnorecA
        The cDignorecA button requests that the speller ignore the erroneous word
        and continue to spell the buffer.

    cDIgnore AllcA
        The cDIgnore AllcA button is similar to the cDIngorecA button, except that it
        automatically ignores the erroneous word thereafter. The ignore words
        are retained for the MicroEmacs edit session and are lost when the
        editor is closed.

    cDAddcA
        cDAddcA adds the current erroneous word to the dictionary, thereafter the
        word is recognized as a valid word. cDAddcA should only be used for words
        which have no derivatives, it is generally better to add a new word
        through the cDEditcA interface where a new cCbasecA word may be specified with
        it's derivatives.

    cDEditcA
        The cDEditcA button executes cDspell-edit-wordcA giving the current erroneous
        word. This allows new words and auto-corrections to be defined as well
        as existing words to be altered, see full description below.

    cDFindcA
        The cDFindcA button executes cDfind-wordcA giving the current word as a
        starting seed. This allows the user to search for the word using a
        simple search criteria, see full description below.

    cDUndo LastcA
        The cDundo LastcA button restores the user to the previous spelling so
        that it may be re-entered, any replacement text that was made is
        restored to it's original spelling.

    cDClosecA
        Exits the speller and returns the user to the buffer.

    cDspell-wordcA checks a single word which is either supplied by the user, or
    if an argument is given, the word under (or to the left of) the cursor
    position. If the word is correct, a simple message-line print-out is
    given, otherwise the main spell cDosdcA dialog is opened and the user may
    check the spelling within the context of the spell dialog as described
    above.

    The default key binding of "cGesc $cA" supplies an argument forcing cDspell-wordcA
    to check the current buffer word. cDspell-wordcA is often used to check the
    spelling of a word outside of the context of the editor (i.e. when working
    on paper, or when doing at that prize crossword !!).

    cDspell-edit-wordcA allows words in dictionaries to be altered as well as new
    words and auto-corrections to be defined. On invocation, an cDosdcA dialog is
    opened and changes are made through this interface, defined as follows:-

    cDWordcA
        The cDwordcA entry to be changed or added. If cDspell-edit-wordcA was executed
        via spell-buffer cDEditcA button, this will be set to the current word.

    cDNo word setcA
        The word entry is empty, most of the functionallity will not be
        available until a word is entered.

    cDNew WordcA
        To add a new word, the derivatives of the new word should be selected
        using the prefix and suffix options. Note that not all derivatives are
        listed, only one example derivative of each lsadd-spell-rule(2)lmspell rulele is given.

        cDBE CAREFUL WITH THE CASE OF THE BASE WORD:cA new words that are entered
        are case sensitive, as a general rule the cCwordcA in the cDWordcA text box
        should be edited to it's base form and should be presented in lower
        case characters (unless it is a proper name, in which case it should
        be capitalized, or is an abbreviation or acronym when it might be
        upper case).

        When the appropriate derivatives of the new word have been selected,
        it may be added to the dictionary using the cDAddcA button. This adds the
        word to the users personal dictionary. Please note that if there are
        numerous standard words missing then check that an cCextendedcA dictionary
        (designated by cDExtcA in the language) is being used, the extended
        dictionaries more than double the repertoire of words available.

        Words added to the dictionary may be subsequently removed using the
        cDDeletecA button, typing the existing word in the cDWordcA entry and
        selecting cDDeletecA button removes the existing word.

    cDAuto-CorrectcA
        Selection of the cDAuto-CorrectcA button allows a replacement word to be
        entered in the cDTocA text entry. Selecting cDAddcA adds the automatic
        correction to the speller. Thereafter, whenever the erroneous word is
        encountered the replacement word is always used to replace it, without
        user intervention.

        Entering an exiting cCauto-correctcA word into the dialog and selecting
        cDDeletecA removes an existing auto-correct entry.

    cDClosecA
        Exits the cDEditcA dialog.

    cDfind-wordcA opens the word finder dialog. This allows the user to search for
    a word using a simple search criteria. (This is ideal for cheating at
    crosswords !!). The word to be searched for is entered into the cDWordcA cDMaskcA
    and may use wild cards cD*cA to represent any number of characters, cD?cA to
    represent an unknown character and cD[cA..cD]cA for a range of characters.

    For example, searching for cGt?e?ecA presents the list cCthemecA, cCtherecA and cCthesecA.
    Searching for cGt*ncA lists all of the words beginning with cGtcA and ending in cGncA.
    See lslm$find-words(5)le for a full discription of the format used by search
    engine.

    The words that match are returned in the scrolling dialog, and may be
    selected with the mouse (or cursor keys). The cDInsertcA button inserts the
    selected word into the current buffer or into the cDWordcA entry if executed
    from the cDspell-buffercA dialog. Note that the list presented is limited to
    200 words, selecting cDnextcA gets the next 200 words, and so on. The cDClosecA
    button exits the dialog.


cEcENOTES cEcA


    The words added to the speller during a MicroEmacs session are saved when
    the editor is closed. The user is prompted to save the dictionary, if the
    dictionary is not saved then any words added are lost.

    All cCignorecA words accumulated during a spell session are lost when the
    editor is closed. In order to retain cCignorecA words, it is suggested that
    they are added to the personal dictionary rather than be ignored.

    The personal spelling dictionary is typically called cC<user>cAcC<type>cA.edf, and
    is stored in the default user location. The dictionary names are specified
    in the lslmuser-setup(3)le dialog.

    cDfind-wordcA may claim to have found more words than are actually listed. The
    use of derivatives in the spell algorithm allows a single word to be
    present several times. cDfind-wordcA counts each occurrence but it is only
    listed once.


cEcESEE ALSO cEcA


    lslmuser-setup(3)le, lslocaleSupport(2)lmLocale Supportle, lslmosd(2)le, lslmspell(2)le, lslmdescribe-word(3)le,
    lslm$find-words(5)le.
! 3 insert-symbol
cEcENAME cEcA


    insert-symbol - Insert an ASCII character
$a


cEcESYNOPSIS cEcA


    cDinsert-symbolcA


cEcEDESCRIPTION cEcA


    cDinsert-symbolcA draws the ASCII character table to the screen, displaying
    decimal, hexadecimal and character notations in a tabular form. A
    character is selected using the mouse or cursor characters inserting the
    selected character into the current buffer at the current position.


cEcENOTES cEcA


    cDinsert-symbolcA is a macro defined in cGosdmisc.emfcA.

    The dialog is created using lslmosd(2)le.


cEcESEE ALSO cEcA


    lslminsert-string(2)le, lslm&atoi(4)le, lslmosd(2)le.
! 3 osd-search
cEcENAME cEcA


    osd-search - Search and annotate the current buffer
$a


cEcESYNOPSIS cEcA


    cDosd-searchcA


cEcEDESCRIPTION cEcA


    cDosd-searchcA is a hidden macro which provides a method of searching for text
    patterns within the current buffer and annotating any matches through
    colored line hilighting. A selection of line colors are provided to allow
    different search patterns to be assigned their own color.

    cDosd-searchcA is generally used for annotating log files and alike, where
    indevidual lines are of interest in addition to the context about that
    line. The hilighting draws attention to the line, by providing a visual
    cue, allowing the contents of the file to be breifly scanned.

    On invocation of cDosd-searchcA from the menu cDSearchcA -> cDHilightcA cDSearchcA a
    lslmosd(2)le dialog is presented to the user, search patterns and their
    associated hilighting assignment are selected through this interface. The
    dialog entries are defined as follows:-

    cDSearch forcA
        The text dialog entry box allows the search pattern to be entered.
        This may be a regular expression or plain text.

    cDColorcA
        The cDColorcA allows the line hilighting color scheme to be selected from
        a pop-up menu. The color cDRemovecA is special and allows previously
        applied line hilighting to be removed.

    cDCase SensitivecA
        A check box that allows the search to be case sensitive or
        insensitive. This modifies the lslmexact(2m)le mode.

    cDMagic ModecA
        A check box that enables/disables regular expression pattern matching.
        This modifies the lslmmagic(2m)le mode.

    cDBelowcA
        Searches and hilights lines matching the search pattern from the
        current cursor position to the end of the buffer.

    cDAbovecA
        Searches and hilights lines matching the search pattern from the
        current cursor position to the top of the buffer.

    cDAllcA
        Searches and hilights lines matching the search pattern for the whole
        buffer.

    cDClear AllcA
        Removes all line hilighting from the current buffer.

    cDFirstcA
        Moves to the top of the buffer and hilights the first line that
        matches the search pattern.

    cDNextcA
        Hilights the next line that matches the search pattern.

    cDReversecA
        Hilights the previous line that matches the search pattern.

    cDExitcA
        Exits the hilighting search dialog.


cEcENOTES cEcA


    cDosd-searchcA is a macro implemented in cGosdmisc.emfcA.


cEcESEE ALSO cEcA


    lslmdelete-hilight-lines(3)le, lslmline-scheme(3)le, lslmosd(2)le, lslm$line-scheme(5)le.
! 3 scheme-editor
cEcENAME cEcA


    scheme-editor - Color Scheme Editor
$a


cEcESYNOPSIS cEcA


    cDscheme-editorcA


cEcEDESCRIPTION cEcA


    cDscheme-editorcA is a color and font scheme editor that provides a dialog
    interface to configure the display schemes used by the editor. The schemes
    may be created or modified within the scheme editor and then committed to
    the configuration files for general use.

    The editor can be used to create both screen and printer color/font
    schemes, they are typically stored in the cGmacroscA directory and are
    executed as macro files at start up or when printing. The standard screen
    schemes are called cGschemecAcCXcAcG.emfcA and printer ones cGprintcAcCXcAcG.emfcA.

    The cDscheme-editorcA is displayed within a single dialog box, tab selections
    at the top of the dialog box enable cDcolorcA and cDschemecA creation and/or
    modification. Navigation is typically performed using the mouse, where the
    mouse is absent then the cGTABcA key may be used to move between the fields.
    The information presented is defined as follows:-

    cDFile NamecA
        The name of the color scheme to be modified. This is the name of the
        cDschemecAcCXcAcD.emfcA file, omitting the file extension. See the cDFILEScA section
        below for a list of standard screen and printer scheme supplied with
        MicroEmacs 2009.

    cDTypecA
        Defines whether the scheme is a screen or printer type.

    cDDescriptioncA
        An ASCII description of the color scheme, used to identify the color
        scheme.

    cDBuffer HilightcA
        Available when scheme is a screen type. Defines whether buffer
        hilighting should be enabled, when cCCompletely DisablecA all buffers are
        displayed character for character in the standard text scheme, this
        will ensure maximum update performance but some file formats such as
        the on-line help will become unreadable so this option is really
        selected. Similarly cCReformat OnlycA disables the majority of buffers,
        hilighting is only enabled when the file would be unreadable without
        it, such as the on-line help or man page files. The default cCFully
        EnabledcA setting enables all buffer hilighting.

    cDPrint OptioncA
        Available when scheme is a printer type. Defines what components of a
        scheme is to be used when printing.


cEColors cA


    The cDcolorscA tab allows the basic palette colors of the editor to be created
    and modified. The left-hand side of the dialog contains a scrolling window
    containing the existing color entries. The right-hand side of the dialog
    provides the controls to add and change the color assignment. The controls
    operate on the currently selected palette entry.

    cDCursorcA
        Defines the colour of the text cursor.

    cDShow in DialogscA
        Defines whether the cursor should be displayed in the main OSD
        dialogs, this improves usability of the dialogs when limited colors
        are available. Indirectly sets bit cG0x20cA of lslm$system(5)le.

    cDRedcA/cDGreencA/cDBluecA
        The color entries allow the currently selected palette color entry to
        be modified. The color values may be changed by direct numeric entry
        (0..255) or via the ^/v controls; the color is committed to the
        palette using the cDAddcA or cDChangecA button.

    cDChangecA
        Commits changes to the currently selected color in the palette.

    cDAddcA
        Creates and adds a new color entry into the palette. The new palette
        entry is created with a default color that may be subsequently
        modified.


cESchemes cA


    The cDschemescA tab allows the schemes to be edited. The left-hand side of the
    dialog contains a scrolling window of the available color palette (created
    from the cDColorscA tab). The right-hand side of the window shows the variants
    of the scheme.

    cDSelectioncA
        The cDselectioncA item provides a pull-down menu containing gross scheme
        categories used by the editor.

    cDSchemecA
        A pull-down menu containing the schemes of the selection, modifying
        this entry shows the variants of the scheme in the cDNormalcA, cDCurrentcA,
        cDSelectcA and cDSel-CurcA dialogs.

    cDResetcA
        Resets the current scheme back to the default cCStandard TextcA scheme.

    There are 4 variants, or styles, for a single scheme; each style is
    comprised of a foreground and background color, and a row of toggle button
    to enable/disable fonts, defined as follows.

        cGBcA - Bold.
        cGIcA - Italic.
        cGLcA - Light (typically not supported).
        cGRcA - Reverse video (fore/back-ground swapped).
        cGUcA - Underline.
        cGVcA - Toggle reverse video when inverted.

    The last mode cDVcA needs a little more explanation; commands such as
    lslmscreen-poke(2)le are able to invert the color scheme, i.e. use the fore
    color for the background etc. Enabling this mode will toggle the reverse
    video mode (cDRcA) when this feature is used.

    The style displayed by a particular scheme depends upon the
    selection/current status of the text:

    cDNormalcA
        The normal style, when the text object is not selected or current
        (i.e. out of focus).

    cDCurrentcA
        The style used when the text object is current (i.e. in focus)

    cDSelectcA
        The style used when the text object is selected (i.e. by the mouse)
        and is not current.

    cDSel-CurcA
        The style used when the text object is selected and is current.

    Note that a printer scheme only uses the Normal style.

    Setting of the cDselectioncA and cDschemecA shows the current scheme in the
    cDNormalcA, cDCurrentcA, cDSelectcA and cDSel-CurcA dialogs. New colors are assigned by
    selecting a color in the palette area and making it current. The current
    color is applied by selecting the cDForecA / cDBackcA boxes of the scheme dialog.
    The assigned color is displayed in the text box cCThe big brown fox...cA.


cEControls cA


    The controls at the bottom of the dialog apply the edits to the
    configuration files.

    cDCurrentcA
        Makes the changes to the palette and schemes current, they are applied
        to the current editing session but are not committed to file. This
        allows the palette changes to be used prior to commitment. Note that
        all modifications are lost if they are not saved and the editing
        session is terminated.

    cDSavecA
        Saves the scheme modifications to file, effectively making the changes
        permanent. Note however that the scheme macro file will be saved in
        the first directory in the lslm$search-path(5)le, regardless of the location
        of the original. For network systems this typically means that the
        changes will only effect the current user.

    cDInstallcA
        Installs the current color scheme into the configuration files, making
        the color scheme accessible to the lslmuser-setup(3)le dialog.

    cDExitcA
        Quits the scheme editor without modifying the settings.


cEcEFILES cEcA


    cGscheme.emfcA - Defines the standard scheme variables, including the
    available scheme list, and associated text.
    cGschemed.emfcA - Default white on black color scheme.
    cGschemej.emfcA - Black on cream color scheme.
    cGschemevicA - Sandy shores.
    cGschemesfcA - Sherwood Forest.
    cGschemebhcA - Blue Hue.
    cGschemepdcA - Plain Black on Cream.
    cGschemeplcA - Plain White on Black.
    cGschemelcA - Black on grey.
    cGschememdcA - Microsoft Developer Studio Colors.
    cGprinters.emfcA - Defines the list of available printer schemes and drivers.
    cGprintdcA - Default plain print-out.
    cGprintfcA - Print using fonts.
    cGprintepccA - Print using Epson base colors and fonts.


cEcENOTES cEcA


    cDscheme-editorcA is a macro that is implemented in file cGschemosd.emfcA. The
    scheme editor uses lslmosd(2)le to create and manage the dialogs.

    Only the Normal scheme style is used by printer schemes.

    The setting of cDBuffer HilightcA can effect the way buffer hooks are load so
    changing from one scheme to another with differing Buffer Hilight settings
    may not fully work. This can be rectified by restart MicroEmacs with the
    new scheme as default.

    The current screen scheme can effect the printing due to the cDBuffercA
    cDHilightcA setting, e.g. if the screen scheme is set to completely disable
    hilighting then any print-out will also have no hilighting.


cEcESEE ALSO cEcA


    lslmuser-setup(3)le, lslmadd-color-scheme(2)le, lslmprint-scheme(2)le, lslmosd(2)le.
! 3 MainMenu
cEcENAME cEcA


    Main Menu - The top main menu
$a


cEcESYNOPSIS cEcA


    cCncA osd
    cDtoolbarcA


cEcEFRAME COMPOSIOTION cEcA


    The frame composition presented by MicroEmacs is defined as follows:-

                  +--------------------------------------------+
                  | File  Edit .. .                   Help     | Menu Line
                  +-----+-+----------------------------------+-+
                  |     |=|                                  |=|Split Vertically
                  |  T  |^|                                  |^|
                  |  O  |||         CURRENT WINDOW           |#|Scroll Bar
                  |  O  |#|                                  |#|
                  |  L  |#|                                  |V|
                  |  B  |#||=* file = 17:30 04/1/11 (Aeb) == |*| Mode Line
                  |  A  |#|^  Split Horizontally             |^|
                  |  R  | |  ^ Buffer edit(*) Read Only(%)   |#|
                  |     | |                                  |#|
                  |     | |          OTHER WINDOW            | |
                  |     |v|                                  |v|
                  +<--->+*+|-- file - 17:30 04/1/11 (AeB) ---+*| Mode Line
                  |f-isearch..: forw                           | Message Line
                  +--------------------------------------------+


    cDMenu LinecA
        The cCMenu LinecA appears at the top of the buffer. A left click of the
        mouse on the menu line shows a menu dialog for user selection.

    cDWindowcA
        The windows appear at the center of the frame, typically with a scroll
        bar to the right of the window and a cDMode LinecA at the bottom of the
        window. The mouse interactions with the window are defined as
        follows:-

        Left mouse in window - Selecting a region
            Regions may be selected with the mouse. Select a position with the
            left mouse, keep the left button pressed move the mouse to the
            desired region end and release the left button. Theregion is
            hilighted, the text is copied the user does not need to perform
            any other selection operation to copy the text.

        Right mouse in window - Pop up Dialog
            A right mouse click in the window brings up a context sensitive
            pop-up menu. A right click on a spelling error, with lslmauto-spell(3)le
            enabled shows a list of possible corrections.

        Right mouse on mode line - Pop up Dialog
            A right mouse click on the cDMode LinecA brings up a pop-up menu to
            control the buffer.

        Left mouse on mode line - split and resize window
            If the cG|cA character is selected on the cDMode LinecA then the window is
            split into two horizontally. If the mode line is dragged with the
            mouse then the buffer is re-sized. If the window is dragged into
            another window then the other window is deleted.

        Left mouse on scroll bar - Up/down action
            A left click on the scroll bar moves the window up/down. If the cG=cA
            component of the scroll bar is selected then the window is split
            into two vertically. Dragging the scroll-bar with the mouse
            horizontally causes the window to be re-sized. Selecting the cG*cA in
            the corner of the window allows the window to be resized both
            horizontally and vertically.

        Right mouse on scroll bar - Scroll bar size
            A right click of the mouse on the scroll bar allows the scroll bar
            width to be altered.

    Message Line
        The message line is used from command entry and messages. On entering
        a command such as lslmisearch-forward(2)le then the user enters text into
        the cDMessage LinecA until the command completes. Messages are also
        displayed in the message line using lslmml-write(2)le.

    Toolbar
        The toolbar window is displayed if lstoolbar(3)lmtoolbarle mode is enabled in
        lslmuser-setup(3)le. The mouse interaction is a little different from a
        conventional mode line, a mouse right click on the toolbar cDMode LinecA
        allows the tollbar to be configured. A Right click on the cG<cA and cG>cA
        characters of the toolbar mode line moves to the next or previous
        tool.


cEcEMAIN MENU cEcA


    The main menu is provided to give an easier access to parts of MicroEmacs
    functionality, the menu is not burnt into MicroEmacs but defined on
    start-up in cGme.emfcA and cGosd.emfcA. The lslmuser-setup(3)le command can be used to
    set whether the menu is always visible and if the Alt-Hotkeys are enabled
    (i.e. 'cGA-fcA' to open the cDFilecA menu).

    The main menu is lslmosd(2)le dialog number cG0cA so key bindings can be made which
    will open the main menu, an argument of cG0cA will simply open the main menu,
    an argument of cG0x0n0000cA will not only open the main menu but also the cGncAth
    sub menu, e.g. to open the edit menu use:

            0x020000 osd


    Following is a brief description of the main menu items:


cEFile Menu cA


    cGNewcA
        Changes the current buffer to a new buffer.

    cGOpencA
        Opens a dialog enabling the user to select files for opening into
        MicroEmacs. By default the dialog opens the selected file using
        command lslmfind-file(2)le, but if the view option is selected the
        lslmview-file(2)le command is used. The binary or encrypt options configure
        whether the files are to be loaded with lslmbinary(2m)le or lslmcrypt(2m)le modes
        enabled.

    cGQuick OpencA
        Opens a sub-menu list all user file types (defined in lslmuser-setup(3)le).
        Selecting one will open another sub-dialog list all files of that type
        in the current directory, selecting a file will open it using command
        lslmfind-file(2)le.

    cGFavoritescA
        Opens a sub-menu enabling the user to add new favorite files, edit the
        existing list of favorite files, or select an existing favorite file
        in which case the file is opened using command lslmfind-file(2)le. The
        favorite file using to store the list is "cD$MENAMEcAcG.effcA" and is saved in
        the first path given in the lslm$search-path(5)le. Each favorite file takes
        2 lines in the file, the first is the text displayed in the dialog
        (note that characters 'cG\cA' and 'cG&cA' must be protected with a 'cG\cA' and the
        'cG&cA' can be used to set the Hot key) and the second line is the file
        name. A line with a single 'cG-cA' character creates a separater line in
        the dialog.

    cGClosecA
        Closes the current buffer, executes a dialog form of the command
        lslmdelete-buffer(2)le.

    cGAttributescA
        Opens a dialog enabling the user to set the current buffers file
        attributes, i.e. read and write permissions. See command
        lslmfile-attrib(3)le for more information.

    cGSavecA
        Saves the current buffer, executes a dialog form of the command
        lslmsave-buffer(2)le.

    cGSave AscA
        Saves the contents of the current buffer as a new file, executes a
        dialog form of the command lslmwrite-buffer(2)le.

    cGSave AllcA
        Saves all changes buffers and session history, executes a dialog form
        of the command lslmsave-all(3)le.

    cGReread FilecA
        Reloads the contents of the current buffer from the file system,
        discarding any changes, executes lslmreread-file(3)le.

    cGPrint SetupcA
        Opens a dialog which enables the user to configure the printer driver,
        output location and page layout (executes command lslmprint-setup(3)le).

    cGPrintcA
        Prints the contents of the current buffer to the printer, executes
        command lslmprint-buffer(2)le.

    cGFile BrowsercA
        Launches the file browser which enables the file system to be
        manipulated and traversed, executes command lslmfile-browser(3)le.

    cGFTP BrowsercA
        Launches the FTP browser, an FTP client, executes command lslmftp(3)le.

    cGLoad SessioncA
        Loads a new session into MicroEmacs, the current session is saved and
        closed and the new session is loaded. The user is prompted from the
        command line to provide the name of the new session to load. See
        lslmread-session(3)le.

    cGExitcA
        Exits the editor, prompting the user to save any unsaved buffers,
        executes command lslmsave-buffers-exit-emacs(2)le.


cEEdit Menu cA


    cGUndocA
        Undoes the last edit in the current buffer (executes command lslmundo(2)le).

    cGRedocA
        Redo the last undo, only available immediately after an undo. This is
        also done via the lslmundo(2)le command.

    cGUndo AllcA
        Undo all edits in the current buffer until the last save or no more
        undo history is available. Executes the command lslmundo(2)le with a 0
        numerical argument.

    cGSet MarkcA
        Sets the position of start of a selected region, executes command
        lslmset-mark(2)le.

    cGCopy RegioncA
        Copies a marked up region, executes command lslmcopy-region(2)le.

    cGKill RegioncA
        Deletes a marked up region and places the deleted text in the kill
        buffer which may be retrieved using cDPastecA, executes command
        lslmkill-region(2)le.

    cGDelete RegioncA
        Deletes a marked up region but the deleted text is not saved in the
        the kill buffer and cannot be retrieved using cDPastecA.

    cGPastecA
        Inserts text from the clipboard into the buffer at the current cursor
        position, executes command lslmyank(2)le.

    cGCut RectanglecA
        Deletes a selected rectangular region from the buffer, the vertical
        extents of the cut are determined by the column position of the start
        and end of the selected region, executes command lslmkill-rectangle(2)le.

    cGCopy RectanglecA
        Copies a selected rectangular region from the buffer, the vertical
        extents of the copy are determined by the column position of the start
        and end of the selected region, executes command lslmcopy-rectangle(3)le.

    cGPaste RectanglecA
        Inserts a rectangle region into the buffer at the current cursor
        position (and for the subsequent lines at the given column position),
        executes the command lslmyank-rectangle(2)le.

    cGInsert SymbolcA
        Dialog presented to select a character symbol for insertion, executes
        the command lslminsert-symbol(3)le.

    cGInsert Date/TimecA
        Inserts the current date and time at the cursor position, a sub-menu
        is used to determine the format of the insertion string.

    cGInsert File NamecA
        Inserts the name of the file at the current cursor position, executes
        the command lslminsert-file-name(2)le.

    cGInsert FilecA
        Inserts the contents of a file into the buffer at the cursor position,
        the user is prompted for the name of the file to insert. Executes the
        command lslminsert-file(2)le.

    cGDraw LinescA
        Moves into line drawing mode, the cursor keys are used to control the
        line drawing, use cDesc-hcA for help, cDreturncA to exit draw mode and cDC-gcA to
        quit draw mode without making changes. Executes the command lslmdraw(3)le.

    cGToggle Insert ModecA
        Modifies character entry behavior, moves between overwrite and
        insertion mode, changes the buffer mode lslmover(2m)le.

    cGToggle View ModecA
        Toggles the buffer between view mode and edit mode, in view mode the
        contents of the buffer may not be altered. Change the buffer mode
        lslmview(2m)le.


cESearch Menu cA


    cGIncremental SearchcA
        Initiates an incremental search, the user is prompted to enter the
        string to search for, execute the command lslmisearch-forward(2)le.

    cGHilight SearchcA
        Opens a dialog which allows lines of the buffer to be searched and
        highlighted by changing the line color. Setting a line highlight is a
        temporary change, it does not effect any files and is lost when the
        buffer is deleted, see lslmosd-search(3)le.

    cGFindcA
        Opens a dialogue for searching the buffer for a given string, see
        lslmosd-search(3)le.

    cGFind NextcA
        Finds the next string in the buffer using the last search string, uses
        lslmhunt-forward(2)le.

    cGFind PrevcA
        Finds the previous string in the buffer using the last search string,
        uses lslmhunt-backward(2)le.

    cGReplacecA
        Opens a dialogue for searching and replacing the buffer for a given
        string, see lslmosd-search(3)le.

    cGFind in FilescA
        Initiates a string search of the file system, in the directory of the
        current buffer using lslmgrep(3)le.

    cGReplace in FilescA
        Initiates a string search and replace of the file system, in the
        directory of the current buffer using lslmquery-replace-all-string(3)le.

    cGSet BookmarkcA
        Places a bookmark in the buffer which provides a quick method of
        returning to the buffer position, the user is prompted for a single
        character to identify the position the buffer. Executes command
        lslmset-alpha-mark(2)le.

    cGGoto BookmarkcA
        Moves the cursor to a book mark position defined with cDSet BookmarkcA,
        the user is prompted for a single character that identifies the
        bookmark. Executes command lslmgoto-alpha-mark(2)le.

    cGGoto FencecA
        When the cursor is on a fence character (i.e. cG{cA, cG}cA, cG(cA, cG)cA, cG[cA, cG]cA, ...)
        then the other matching fence is located and the buffer position is
        changed to the other fence character. Executes command
        lslmgoto-matching-fence(2)le.

    cGGoto LinecA
        Moves cursor to the specified line number or relative line position,
        executes a dialog form of the command lslmgoto-line(2)le.

    cGGoto TagcA
        Only active when a cGtagscA file is found in the current directory, a
        dialog is presented with the tags, on selection of a tag then the file
        is opened and the cursor position is moved to the definition of the
        tag. See command lslmfind-tag(2)le for more information.


cEView Menu cA


    cGNarrow OutcA
        Hides the selected region of the buffer, executes command
        lslmnarrow-buffer(2)le with a numeric argument of cG4cA.

    cGNarrow TocA
        Hides all of the buffer with the exception of the selected region,
        executes command lslmnarrow-buffer(2)le with a numeric argument of cG3cA.

    cGRemove Single NarrowcA
        Removes a single narrowed region of the buffer under the cursor.
        Executes command lslmnarrow-buffer(2)le with a numeric argument of cG2cA.

    cGRemove All NarrowscA
        Removes all of the narrowed regions in the buffer, executes command
        lslmnarrow-buffer(2)le with a numeric argument of cG1cA.

    cGBuffer InfocA
        Provides information on the buffer current cursor position on the mode
        line including line number, character under the cursor etc. See
        lslmbuffer-info(2)le.

    cGWord CountcA
        Counts the number of words in the selected region (between point and
        mark), executes lslmcount-words(2)le.

    cGOccurrencescA
        Finds all occurrences of a given string in the buffer. The user is
        prompted for the string to find. A second window opens and all
        occurrences of the string in the buffer are presented, selecting an
        item from this list, using the mouse, moves the cursor to the
        specified occurrence. See lslmoccur(3)le.

    cGBuffercA
        Lists the current buffers in the editor, selecting one changes the
        current buffer to the selection.

    cGMain MenucA
        Hides or shows the Main Menu. If the main menu has been hidden then cDF1cA
        brings up the menu, the main menu may be re-activated then if
        necessary.

    cGScroll BarscA
        Hides or shows scroll bars within the buffer.

    cGTool BarcA
        Hides or shows the tool bar window, see lslmtoolbar(3)le.

    cGWhite CharacterscA
        Hides or shows the white space characters in the buffer.


cEFormat Menu cA


    cGRestyle BuffercA
        Re-styles the layout of the buffer based on the major-mode setting.
        Executes the command lslmrestyle-buffer(3)le.

    cGRestyle RegioncA
        Re-styles the layout of a selected region of the buffer based on the
        major-mode setting. Executes the command lslmrestyle-region(3)le.

    cGIncrease IndentcA
        Increases the indentation of a line or region by a single single Tab
        stop position. Executes the command lslmindent-increase(3)le.

    cGDecrease IndentcA
        Decreases the indentation of a line or region by a single single Tab
        stop position. Executes the command lslmindent-decrease(3)le.

    cGIQ Fill ParagraphcA
        Reformat a paragraph using the current fill mode, handling embedded
        bullets with no line separation. Executes the command
        lslmifill-paragraph(3)le.

    cGFill ParagraphcA
        Reformat a paragraph using the current fill mode using the standard
        paragraph fill mode. Executes the command lslmfill-paragraph(2)le.

    cGFill All ParagraphscA
        Reformats all paragraphs in the buffer using the standard paragraph
        filling mode. Executes command lslmfill-paragraph(2)le with a very large
        positive numerical argument. Note that this only effects paragraphs
        from the current position onwards.

    cGAll Paragraphs to LinescA
        Converts all paragraphs to a single line, one line per original
        paragraph. Paragraphs are typically converted to a single line before
        copying into a Word Processor (i.e. Word, StarOffice etc.). The Word
        Processor performs its own text wrapping therefore it is important
        that MicroEmacs paragraphs with new lines in them are not copied.

    cGChange Character Set ...cA
        Converts the ASCII text from one character set to another, this allows
        diacritical marks to be maintained.

    cGTabs to SpacescA
        Converts cGTABcA characters to spaces whilst retaining the correct tab
        stop positions within the file. Note that if the tab stops appear to
        be incorrect then the tab width should be temporarily changed using
        lslmbuffer-setup(3)le before converting to spaces.

    cGClean BuffercA
        Cleans up the buffer by removing white space from the ends of all
        lines, see lslmclean(3)le.

    cGCapitalize WordcA
        Capitalizes the characters from the cursor position, or next word, to
        the end of the word using lslmcapitalize-word(2)le.

    cGLower Case WordcA
        Changes characters to lowercase from the cursor position, or next
        word, to the end of the word using lslmlower-case-word(2)le.

    cGUpper Case WordcA
        Changes characters to uppercase from the cursor position, or next
        word, to the end of the word using lslmupper-case-word(2)le.

    cGLower Case RegioncA
        Lowercase all characters in the current region using
        lslmlower-case-region(2)le.

    cGUpper Case RegioncA
        Uppercase all characters in the current region using
        lslmupper-case-region(2)le.


cETools Menu cA


    cGCurrent Buffer ToolscA
        For some file formats MicroEmacs provides a file format specific set
        of tools, see the lsMicroEmacs - Supported File Typeslmfile typele help page for more specific information.

    cGSpell WordcA
        Spell checks a word entered on the command line, executes the command
        lslmspell-word(3)le.

    cGSpell BuffercA
        Spell checks the buffer from the current cursor position onwards,
        executes command lslmspell-buffer(3)le.

    cGWord CompletecA
        Takes the incomplete word to the left of the cursor and attempts to
        complete the word by using the users current language dictionary, use
        cGTABcA for a list of possible completions. Executes the command
        lslmexpand-word(3)le.

    cGCompare WindowscA
        Compares the contents of two buffers, the comparison starts from the
        current cursor position in each buffer and the cursor position should
        be aligned before starting the comparison, executes the command
        lslmcompare-windows(2)le.

    cGDiff ChangescA
        Compares the current buffer with the last backup version of the
        buffer, the buffer has to be saved before the comparison may be
        performed, executes the command lslmdiff-changes(3)le.

    cGDiffcA
        Runs a lslmdiff(3)le command to difference two files, the user is prompted
        each of the files before running the command. The results of the
        difference are presented in a new buffer window.

    cGGraphical DiffcA
        Runs a graphics difference between two files where the files are
        presented side by side. The user is prompted for the two files to
        compare. See also lslmgdiff(3)le which uses a command line prompt for the
        files rather than a dialog.

    cGCompilecA
        Starts a compilation or build process, executes the command
        lslmcompile(3)le.

    cGSort LinescA
        Performs an alphabetical case sensitive sort of the lines in a
        selected region, the lines are re-ordered in ascending alphabetic
        order. Executes the command lslmsort-lines(2)le.

    cGSort Lines (Ignore Case)cA
        Performs an alphabetical case insensitive sort of the lines in a
        selected region, the lines are re-ordered in ascending alphabetic
        order. Executes the command lslmsort-lines(2)le.

    cGUnique LinescA
        Removes duplicated adjacent lines in a region. The region should be
        sorted before lslmuniq(3)le.

    cGUser SetupcA
        Runs a dialog interface to configure MicroEmacs, executes the command
        lslmuser-setup(3)le.

    cGBuffer SetupcA
        Runs a dialog interface to change the session configuration of a
        buffer i.e. assignment of the major-mode etc. This command changes the
        current buffer only and does not affect other buffers. Executes the
        command lslmbuffer-setup(3)le.

    cGMajor Mode SetupcA
        Runs a dialog interface which allows the major mode to be changed.
        Executes the command lslmmajor-mode-setup(3)le.

    cGScheme EditorcA
        Runs a dialog which allows the current highlighting scheme to be
        edited, modification of the scheme affects all buffers. Executes the
        command lslmscheme-editor(3)le.


cEAdvanced Menu cA


    cGRecord MacrocA
        Starts recording the key strokes to create a keyboard macro, see
        lslmstart-kbd-macro(2)le.

    cGExecute MacrocA
        Executes a previously recorded keyboard macro, see
        lslmexecute-kbd-macro(2)le.

    cGName MacrocA
        Allows a keyboard macro to be named, see lslmname-kbd-macro(2)le.

    cGExecute CommandcA
        Executes a named MicroEmacs command, the user is prompted to enter the
        command to be executed, see lslmexecute-named-command(2)le.

    cGExecute FilecA
        Executes a MicroEmacs macro file, typically used to load and install
        Macros into the editor, see lslmexecute-file(2)le.

    cGCalculatecA
        Invokes a simple command line calculator, see lslmcalc(3)le.

    cGNotescA
        Invokes the lslmnotes(3)le tool which may be used to organize and store
        miscellaneous information (i.e. short notes).

    cGOrganizercA
        Invokes the lslmorganizer(3)le tool which provides a calendar and address
        book.

    cGSend MailcA
        Create and send a electronic mail message, this requires that the mail
        tool has been configured, see lslmmail(3)le.

    cGView MailcA
        Start the mail reading tool lslmvm(3)le.

    cGIpipe commandcA
        Start a incremental shell command, the command runs in the background
        and the results are collected in a new buffer window, using
        lslmipipe-shell-command(2)le.

    cGShellcA
        Creates a new shell command window outside of the editor using
        lslmshell(2)le.


cEWindow Menu cA


    cGSplit Window VcA
        Splits the current buffer window into two vertically (stacked),
        executes the command lslmsplit-window-vertically(2)le.

    cGGrow Window VcA
        Increases the height of the current buffer window by a single line,
        executes the command lslmchange-window-depth(2)le with an argument of 1.

    cGShrink Window VcA
        Reduces the height of the current buffer window by a single line,
        executes command lslmchange-window-depth(2)le with an argument of -1.

    cGSplit Window HcA
        Splits the current buffer window into two horizontally (side by side),
        executes command lslmsplit-window-horizontally(2)le.

    cGGrow Window HcA
        Increases the width of the current buffer window by a single
        character, executes the command lslmchange-window-width(2)le with an
        argument of 1.

    cGShrink Window HcA
        Reduces the width of the current buffer window by a single character,
        executes the command lslmchange-window-width(2)le with an argument of -1.

    cGOne WindowcA
        Makes the current buffer the only window on the screen, the other
        buffers are removed from the screen, executes the command
        lslmdelete-other-windows(2)le.

    cGDelete WindowcA
        Removes the current buffer window from the screen, other windows are
        re-organized to occupy the space created by deleting the window,
        executes the command lslmdelete-window(2)le.

    cGPrevious WindowcA
        Moves focus to the previous window using lslmprevious-window(2)le.

    cGNext WindowcA
        Moves focus to the next window using lslmnext-window(2)le.

    cGCreate New FramecA
        Create an new external frame, only available on version which support
        multiple-window frames. Executes command lslmcreate-frame(2)le.

    cGClose This FramecA
        Closes the current frame, only available on version which support
        multiple-window frames. The command will fail if this is the only
        frame, use File -> Exit to exit MicroEmacs, executes command
        lslmdelete-frame(2)le.

    cGNext FramecA
        Shows the next internal frame, see lslmnext-frame(2)le.


cEHelp Menu cA


    cGMajor Mode HelpcA
        Display the help information associated with the current buffer. For
        some major mode (file format) MicroEmacs provides a major mode
        specific help page providing details of key-bindings and tools
        specific to the current buffers file type.

    cGGeneral HelpcA
        Starts the lslmosd-help(3)le dialog which allows the help pages to the
        searched.

    cGList BindingscA
        Lists the key bindings associated with the current buffer, the
        bindings are displayed in a separate window and include the buffer and
        global key bindings. Executes the command lslmdescribe-bindings(2)le.

    cGList BufferscA
        Lists the buffers currently active within MicroEmacs, the list is
        presented in a new buffer window and shows the buffer name, size,
        associated files and current mode. Executes the command
        lslmlist-buffers(2)le.

    cGList CommandscA
        Lists all of the available commands and key bindings in a new buffer
        window, executes the command lslmlist-commands(2)le.

    cGList RegistrycA
        Presents the registry hierarchy in a separate buffer window, executes
        the command lslmlist-registry(2)le.

    cGList VariablescA
        Presents a list of all of the global variables and their assigned
        values in a new window, executes the command lslmlist-variables(2)le.

    cGCommand AproposcA
        Produces a list of commands that contain a given string as part of
        their name, the user is prompted to enter the string to search for.
        Executes the command lslmcommand-apropos(2)le.

    cGDescribe keycA
        Determines the command that is bound to a specific key, user is
        prompted for the key sequence, the command bound to that key is
        displayed. executes the command lslmdescribe-key(2)le.

    cGDescribe VariablecA
        Determine the value of a MicroEmacs variable, user is prompted for the
        variable name. Executes the command lslmdescribe-variable(2)le.

    cGDescribe WordcA
        A dictionary function that looks up the meaning of a word specified on
        the command line, executes the command lslmdescribe-word(3)le.

    cGHelp on CommandcA
        Provides help on a specific MicroEmacs command, user prompted for the
        command name. Executes the command lslmhelp-command(2)le.

    cGHelp on VariablecA
        Provides help on a specific MicroEmacs variable, user prompted for the
        variable name. Executes the command lslmhelp-variable(2)le.

    cGGamescA
        Opens a sub-menu listing all available games, see lsMicroEmacs - GameslmGamesle for more
        information.

    cGProduct SupportcA
        Opens on-line lslmContactle information.

    cGAbout MicroEmacscA
        Version and status information on the editor, executes the command
        lslmabout(2)le.


cEcENOTES cEcA


    The main menu is defined using lslmosd(2)le in macro files me.emf and osd.emf.

    General user extensions to the main menu can be added to the user file
    cGmyosd.emfcA which is executed once when the main menu is first opened. The
    macro file can add new items to any of the main sub menus and can delete
    most existing items (some are dynamically added when appropriate, these
    should not be deleted). See cGosd.emfcA for examples of how to add items to
    the menu.

    New sub-menus should be added in the company or user setup files as this
    must be done at start-up. The content on the menu is not required until
    the main menu is used so populating the new sub-menu can be done in
    cGmyosd.emfcA.


cEcESEE ALSO cEcA


    lslmuser-setup(3)le.
! 3 osd-help
cEcENAME cEcA


    osd-help - GUI based on-line help
$a


cEcESYNOPSIS cEcA


    cDosd-helpcA


cEcEDESCRIPTION cEcA


    cDosd-helpcA provides a GUI front end to the on-line help manual, the dialog
    consists of 3 pages which are defined as follows:-


cEContents cA


    The contents page displays a list on contents similar to the lslmhelp(2)le high
    level help page. Selecting an item will display the help page in a buffer,
    selecting cDExitcA will exit the dialog.


cEIndex cA


    The index page gives a list of help items, the cDScopecA menu can be used to
    narrow the index list to the required item type.


cESearch cA


    The search page provides a way of searching the on-line help for a given
    topic. Similarly to the Index page, the cDScopecA menu is provided to narrow
    the search to the required area.

    The search strings is considered to be made up of items separated by
    spaces, an item can be enclosed in quotes ('cG"cA') so that the item can
    include a space. If the first letter of an item is a 'cG+cA' the given item
    must be found in a page for it to match, if the character is a 'cG-cA' the
    item must NOT be found on a page for it to match, or other items are
    considered optional. At least one item must be found on a page for it to
    be a match, the numbers to the right of each found page is the number of
    items found.


cEcENOTES cEcA


    See lslmHelp!le for help on the on-line help pages.

    cDosd-helpcA is a macro using lslmosd(2)le, defined in osdhelp.emf.


cEcESEE ALSO cEcA


    lslmhelp(2)le.
! 3 file-attrib
cEcENAME cEcA


    file-attrib - Set the current buffers system file attributes
$a


cEcESYNOPSIS cEcA


    cDfile-attribcA


cEcEDESCRIPTION cEcA


    cDfile-attribcA opens a dialog enabling the user to change the system
    properties of the current buffer's file. Top of the dialog give the
    current buffer name and its file name. The cGSave ChangescA button writes the
    current buffer out with any current edits and changes to its file
    attributes. The cGOkcA button closes the file-attrib dialog, any changes made
    to the file attributes will be applied next time the buffer is written.

    The type allow the changing between UNIX, MS Windows and DOS text file
    formats. UNIX has a single new line character ('cG\ncA') where as Windows and
    Dos have a double new line character ('cG\r\ncA'). Also a Dos text file is
    terminated with a cGC-zcA (0x1A) character which the other two do not. These
    attribute are set in MicroEmacs by using buffer modes lslmcr(2m)le, lslmlf(2m)le and
    lslmctrlz(2m)le.

    The central part of the dialog contains system dependent attributes which
    are defined as follows:

    cDUNIX PlatformscA
        Allow the setting of user, group and global, read, write and execute
        permissions, see man pages on cDchmod(1)cA for more information. This is a
        front end to setting the variable lslm$buffer-fmod(5)le.

    cDWin32 PlatformscA
        Allow the setting of MS Windows file attributes, i.e. read-only,
        hidden, archive etc. Note that the directory attribute is displayed
        but cannot be altered. This is a front end to setting the variable
        lslm$buffer-fmod(5)le.

    cDDOS PlatformcA
        Allow the setting of MS Dos file attributes, i.e. read-only, hidden,
        archive etc. Note that the directory attribute is displayed but cannot
        be altered.


cEcENOTES cEcA


    cDfile-attribcA is a macro implemented in cGfattrib.emfcA.


cEcESEE ALSO cEcA


    lslmfind-file(2)le, lslmwrite-buffer(2)le, lslmcr(2m)le, lslmlf(2m)le, lslmctrlz(2m)le, lslm$buffer-fmod(5)le.
! 3 describe-word
cEcENAME cEcA


    describe-word - Display a dictionary definition of a word
$a


cEcESYNOPSIS cEcA


    cDdescribe-wordcA "cCwordcA"


cEcEDESCRIPTION cEcA


    cDdescribe-wordcA can be used to interface to an external dictionary to get a
    definition of a given word. The interface has two modes of interface, the
    first simply launches an external program which provides the definition in
    its own user interface, e.g. MS Bookshelf. The second interface launches
    an external program which prints out the definition to cGstdoutcA, MicroEmacs
    can then pull out the definition and display it in cDdescribe-wordcA's own
    GUI.

    When executed cDdescribe-wordcA will use the current word under the cursor as
    the initial cCwordcA or will prompt the user if the cursor is not in a word.

    When cDdescribe-wordcA's dialog is used the information presented is defined
    as follows:

    cDWordcA
        The word being defined, the entry can be edited and the new word will
        be automatically looked-up when the edit is completed.

    cDInsertcA
        The effect of this button is dependent on where describe-word was
        executed. If executed from the cDMeaningcA button within the lsspell-buffer(3)lmspell checkerle
        the Word entry is changed to the current word. When executed outside
        the spell checker the definition of the current word is inserted into
        the current buffer.

    cDExitcA
        Closes the dialog.

    Main definition box
        Displays the definition of the current word. The user can select a new
        word to describe by clicking the left mouse button on any word within
        the current definition.


cEcENOTES cEcA


    cDdescribe-wordcA is a macro implemented in cGword.emfcA.

    Due to the size and availability of dictionaries etc. MicroEmacs is
    released without describe-word set up, the user must setup it up.

    cDdescribe-wordcA must be setup for each required language as follows:

    cD1)cA
        A command-line interface to a dictionary of the required language must
        be found. This could simply be a text file containing one word
        definition per line and using cDgrep(1)cA as the command-line interface.
        In this example the text file could take the following form:

            A () The first letter of the English...
            Aam (n.) A Dutch and German measure of liquids...
            Aardvark (n.) An edentate mammal...
            .
            .


        The cDgrepcA command-line interface required to look-up the word
        "cGaardvarkcA" would be:

            grep -i "^aardvark (" words.txt


        The output produced from this will be the single line giving the
        required definition. A second common interface would be executing an
        external dictionary program typically using a command-line option to
        specify the word to define, e.g.:

            mydict -d "aardvark"


    cD2)cA
        The MicroEmacs language name must be found, this can be done by first
        using lslmuser-setup(3)le or lslmspell-buffer(3)le to ensure that the current
        language is set the the require one and then running cDdescribe-wordcA.
        The command will probably fail, but before it does it will set the
        variable cG.describe-word.langcA, use the command lslmdescribe-variable(2)le to
        get the value of this variable, this value is the internal language
        name. For example, when the current language is cDAmericancA or cDAmerican
        (Ext)cA the language name is cGamericancA.

    cD3)cA
        To execute the command-line interface the variable
        cG.describe-word.cAcC<language>cAcG-commandcA must be set to the command-line
        required to obtain a word definition with the string "cG%scA" used in
        place of the word and "cG%%cA" using in place of a single "cG%cA". For the
        first example in cD(1)cA above the following would be required:
sB
            set-variable .describe-word.american-command ...
                    ... "grep -i \"^%s (\" /tmp/words.txt"

sA
        For the second example:
sB
            set-variable .describe-word.american-command "mydict -d \"%s (\""

sA
    cD4)cA
        Only required for the second mode, for use with cDdescribe-wordcA's own
        GUI, the setting of another variable is required, the presence of this
        variable determines which mode is to be used.

        The variable cG.describe-word.cAcC<language>cAcG-searchcA must be set to a lsRegularExpressions(2)lmregexln
        lnsearch patternle which will match the required definition(s) in the
        command out put, the first group ("cG\(...\)cA") must enclose the required
        definition, again "cG%scA" can be used in place of the word and "cG%%cA" for a
        single "cG%cA". cDdescribe-wordcA simply uses lslmsearch-buffer(2)le repeatedly to
        find all definitions of the current word, it then uses the value of
        the variable lslm@s1(4)le to get the individual definitions. For example for
        the first example the following is required:
sB
            set-variable .describe-word.american-search  "^\(%s (.*\)\n"

sA
        Note that the word being defined should be kept in the definition if
        possible as the lsadd-spell-rule(2)lmspell rulesle are used to look-up base words when a
        derivitive of a word is not found, therefore the word being defined
        may not be clear (e.g. cCdeactivatecA can be derived from cCactivatecA but
        their meanings are very different). Also long text lines are
        automatically wrapped by the GUI.

    The required variables should be added to the user setup file.


cEcESEE ALSO cEcA


    lslmspell-buffer(3)le.
! 3 major-mode-setup
cEcENAME cEcA


    major-mode-setup - Configures the current buffer settings
$a


cEcESYNOPSIS cEcA


    cDmajor-mode-setupcA


cEcEDESCRIPTION cEcA


    The cDMajor ModecA defines the operational mode of the buffer, controlling
    highlighting and additional commands that are available. The cCMajor ModecA is
    determined by the file type content and is determined from the file
    extension or cCMagic StringcA in the first few lines of the file.

    cDmajor-mode-setupcA provides a dialog interface to configuring the setup of
    the current buffer's file type within MicroEmacs. cDmajor-mode-setupcA may be
    invoked from the main cCToolscA menu or directly from the command line using
    lslmexecute-named-command(2)le.

    The changes made to a configuration in cDmajor-mode-setupcA are maintained in
    future MicroEmacs sessions by storing them within the user's setup
    registry file, "cC<logname>cAcG.erfcA". Note that not all file types may be
    supported by cDmajor-mode-setupcA, if not the help menu item will not be
    available.

    The contents of the dialog change, depending on the features the current
    buffer's file type supports. These features are implemented and installed
    within the lsfileHooks(2)lmbuffer's file hookle. The following buttons are always present at
    the bottom of the dialog:

    cGSavecA
        Saves the changes made to the configuration back to the users registry
        file, i.e. "cC<Log-Name>cAcG.erfcA" but does not re-initialize the current
        buffer. No changes made will effect the current buffer unless the
        cDCurrentcA button is pressed. Buffers of the same type created after the
        save may inherrit some of the changes.

    cGCurrentcA
        Makes the current buffer reflect the changes made, dismissing the
        cDmajor-mode-setupcA dialog. This also performs the above 'cDSavecA'
        operation. Some changes such as dialog creation changes, will only
        take effect when MicroEmacs is restarted.

    cGCancelcA
        Quits major-mode-setup, if changes where not cDSavecAd or made cDCurrentcA
        they will be lost.

    Following is a list of configurable features which may be available:

    Create Help Page
        Enables/disables the creation of a help page dialog for the tools
        available for the current file type.

    Create Tools Menu
        Enables/disables the creation of a file type specific sub menu located
        within the main menu's cDToolscA sub-menu.

    Use Author Mode
        For file types which have an automatic formatter/viewer (currently
        only html) enabling this will simply load the file enabling the source
        code to be viewed and edited. When disabled files of this type will be
        automatically processed giving a more readable 'formatted'
        representation.

    Insert New Template
        When creating a new buffer/file of this type, a default template will
        be inserted if this is enabled. When disabled the buffer will remain
        empty.

    Fence Display
        Enables or disables the displaying of matching fences for this file
        type. Note that the way in which the matching fence is display is
        determined by the cDFence DisplaycA option on the Platform page of
        lslmuser-setup(3)le; the cDmajor-mode-setupcA option is ignored if this option
        is set to "cGNever DisplaycA".

    Setup Hilighting
        Creates and enables the token lshilight(2)lmhilightingle for the current file type.

    Setup Auto Indent
        Enables automatic formating (indenting) for the current file type. The
        indentation rules are either the built in lsindent(2)lm'C' indentationle or created
        explicitly using the lslmindent(2)le command. When enabled the lslmtab(2m)le is
        still adhered to, but the lslmindent(2m)le mode is ignored; when disabled
        the indent mode can be used.

    Setup Auto Spell
        Enables the setting up of lslmauto-spell(3)le. When enabled the auto-spell
        key bindings are created and auto-spell is enabled if enabled within
        the user-setup dialog.

    Setup Folding
        Enables the setting up of section lscollapse-current(3)lmfoldingle, when enabled the folding
        key bindings are created.

    Add Abbreviations
        Adds the file type's abbreviation file to the buffer using
        lslmbuffer-abbrev-file(2)le

    Search Modes: Exact
        Enables/disables the lslmexact(2m)le mode over-riding the setting within the
        lslmuser-setup(3)le dialog. If this setting is changed the setting within
        user-setup will be ignored for the current file type.

    Search Modes: Magic
        Enables/disables the lslmmagic(2m)le mode over-riding the setting within the
        lslmuser-setup(3)le dialog. If this setting is changed the setting within
        user-setup will be ignored for the current file type.

    Buffer Modes: Auto
        Enables/disables the lslmauto(2m)le mode.

    Buffer Modes: Backup
        Enables/disables the lslmbackup(2m)le mode.

    Buffer Modes: Indent
        Enables/disables the lslmindent(2m)le mode.

    Buffer Modes: Justify
        Enables/disables the lslmjustify(2m)le mode.

    Buffer Modes: Tab
        Enables/disables the lslmtab(2m)le mode over-riding the setting within the
        lslmuser-setup(3)le dialog. If this setting is changed the setting within
        user-setup will be ignored for the current file type.

    Buffer Modes: Time
        Enables/disables the lslmtime(2m)le mode.

    Buffer Modes: Undo
        Enables/disables the lslmundo(2m)le mode over-riding the setting within the
        lslmuser-setup(3)le dialog. If this setting is changed the setting within
        user-setup will be ignored for the current file type.

    Buffer Modes: Wrap
        Enables/disables the lslmwrap(2m)le mode.


cEcENOTES cEcA


    cDmajor-mode-setupcA is a macro using lslmosd(2)le, defined in cGmajormod.emfcA. This
    macro configures the user settings of the cGhkXXX.emfcA files via
    lslmbuffer-init(3)le.


cEcESEE ALSO cEcA


    lslmbuffer-init(3)le, lslmmajor-mode-help(3)le, lslmuser-setup(3)le. lsfileHooks(2)lmFile Hooksle.
! 3 major-mode-help
cEcENAME cEcA


    major-mode-help - Displays help page for current buffer
$a


cEcESYNOPSIS cEcA


    cDmajor-mode-helpcA


cEcEDESCRIPTION cEcA


    cDmajor-mode-helpcA opens a dialog giving the user a brief help page on tools
    available for the current buffer. The help page changes depending on the
    type of the current buffer.


cEcEHISTORY cEcA


    cDmajor-mode-helpcA was introduced in the 2006 release, prior to this the
    command was known as cDbuffer-helpcA.


cEcESEE ALSO cEcA


    lslmmajor-mode-setup(3)le.
! 3 print-setup
cEcENAME cEcA


    print-setup - Configure MicroEmacs's printer interface
$a


cEcESYNOPSIS cEcA


    cDprint-setupcA


cEcEDESCRIPTION cEcA


    cDprint-setupcA provides a dialog interface for configuring MicroEmacs's
    printing interface. cDprint-setupcA may be invoked from the main cCFilecA menu or
    directly from the command line using lslmexecute-named-command(2)le.

    The cDprint-setupcA dialog is broken down into three pages of configuration
    options, the following buttons are available at the bottom of each
    dialog:-

    cGPrintcA
        Prints the current buffer using the current configuration.

    cGExitcA
        Quits cDprint-setupcA, changes made to the configuration are saved.

    The following pages appear in the dialog:-


cEPrinter cA


    The cDPrintercA page is used to configure the cCtypecA, cCstylecA and cClocationcA of the
    printer, the items on this page are defined as follows:-

    cGDrivercA
        Sets the printer type to be used, selecting this item creates a drop
        down list of available printer drivers. The drivers inform MicroEmacs
        which fonts and colors are available and how to enable/disable them,
        these are usually special character sequences. The following special
        drivers are defined:-

        Default Plain Text
            This driver does not use any special character sequences so the
            output it produces is plain text. This should work with most
            printers, but it does not support any colors or fonts.

        HTML
            This is a virtual printer driver as no printer uses HTML directly.
            However the files produced by this driver can be loaded by a
            web-browser and rendered with full color and font support so
            provides an efficient way of testing printer schemes. In addition
            may be used to convert the text rendered in MicroEmacs into HTML
            content.

        Windows
            This utilizes MicroEmacs's built-in Windows printer interface
            (Windows platforms only). When selected MicroEmacs communicates
            directly to the MS Printer Manager.

    cGPrint SchemecA
        Defines the color and font scheme to be used, selecting this item
        creates a drop down list of available printer schemes - choose the
        most appropriate one for your printer. The cCDefault Plain TextcA scheme
        does not use any color or fonts and should work for all drivers. See
        the next item for scheme creation and editing.

    cGEditcA
        Opens the lslmscheme-editor(3)le dialog box to edit the currently selected
        printer scheme. The editor may be used to create and install new
        printer schemes.

    cGDestinationcA
        Specifies the destination print output, when selected a drop down menu
        appears with the following items:

        To buffer only
            Creates a "cG*printer*cA" buffer and prints to that buffer.

        To file only
            Creates a new temporary file and prints to it.

        To file & print
            Prints to a temporary file and then executes the cGcommand-linecA (see
            next item) to print the resultant file. This option is not
            available when using the Windows printer driver.

        Direct to printer
            Output is sent directly to the printer. The option is only
            available when using the Windows driver.

    cGCommand-linecA
        Sets the command-line required to print a generated print file (option
        not available when the Windows driver is selected as printing is
        performed directly by the MS Print Manager). The command-line should
        be a single shell command using "cG%fcA" to reference the name of the file
        to be printed, e.g. on UNIX systems cDlp(1)cA or cDlpr(1)cA may be used as
        follows:-

            lp -s %f


        On MS-DOS machines this may be performed by copying the file to the
        cGPRNcA device, as follows:

            copy %f PRN


    cGPage LayoutcA
        Displays the current page configuration in the form:

            cCColumnscAcDxcAcCRowscA cCChars-WidecAcDxcAcCChars-HighcA

        the fields cannot be edited directly, the settings in cDPage SetupcA
        affect these values.


cEPage Setup cA


    cGPaper SizecA
        Defines the size of the printer paper, selecting this item produces a
        pop down menu listing of all available paper sizes. If the the Windows
        printer driver is being used this field cannot be selected and the
        cDEditcA button is used instead.

    cGPage SizecA
        Defines the printable size of the page in terms of the number of
        characters which will fit on the paper (cCwidthcAcDxcAcCheightcA). When selected a
        drop down menu lists all available sizes for the current paper size.
        This option is not available with the Windows driver and the cDEditcA
        button should be used.

    cGEditcA (Windows only)
        Opens a Windows printer dialog box allowing the user to specify the
        windows printer, paper size and character size, etc.

    cGNo. of ColumnscA and cGRowscA
        Defines the page subdivision in terms of sub-columns and rows, thereby
        creating sub-pages within a page.

    cGPrint Line NumberscA
        When enabled, prints the line number at the left hand edge of each
        line.

    cGPrint Split Line IDscA
        When enabled the last right hand text column is reserved for a split
        line identifier. Whenever a line is too long to fit on a single line
        it is split over two or more lines, if this option is enabled the
        right edge will be set to the split character (usually a 'cG\cA' char) to
        clearly indicate that the line is split.

    cGPage LayoutcA
        As with the cDPrintercA cDPage LayoutcA, displays the current page
        configuration, the field cannot be edited.


cELayout cA


    cGMarginscA
        Configures the top, bottom, left and right margins of the page in
        terms of characters.

    cGPrint HeadercA
        Defines whether a header should be printed and its format. The
        following escape sequence is interpreted:

        cG%%cA
            Print a 'cG%cA' character.

        cG%bcA
            Print the current buffer's name.

        cG%DcA
            Print the current day of the month.

        cG%fcA
            Print the current buffer's file name.

        cG%hcA
            Print the current hour.

        cG%McA
            Print the current month of the year.

        cG%mcA
            Print the current minute of the hour.

        cG%pcA
            Print the current page number.

        cG%scA
            Print the current seconds.

        cG%YcA
            Print the current year as a 2 digit number.

        cG%ycA
            Print the current year as a 4 digit number.

    cGPrint FootercA
        Defines whether a footer should be printed at the end of the page and
        the format. The header escape sequence characters are used.


cEcENOTES cEcA


    cDprint-setupcA is a macro using lslmosd(2)le, defined in cGprintstp.emfcA.

    The list of available printer drivers and print schemes is stored in the
    macro file cGprinters.emfcA. To create a new printer driver a new
    configuration registry file (cGerfcA file - see cGprint*.erfcA for examples) must
    be created and added to the printer driver lists within cGprinter.emfcA.

    The cGprinters.emfcA file also contains a list of printing schemes, using the
    cDInstallcA option of the lslmscheme-editor(3)le. lslmscheme-editor(3)le automatically
    adds the new scheme to the print schemes list.


cEcESEE ALSO cEcA


    lslmprint-buffer(2)le, lslmscheme-editor(3)le, lslmosd(2)le.
! 3 line-scheme
cEcENAME cEcA


    line-scheme - Apply line annotation in current buffer
$a


cEcESYNOPSIS cEcA


    cCncA cDline-schemecA


cEcEDESCRIPTION cEcA


    cDline-schemecA applies or removes line hilighting by assignment of the buffer
    line variable lslm$line-scheme(5)le. The numerical argument cCncA is the line scheme
    number to apply to the line or region when omitted (or specified as 1)
    then any line hilighting is removed.

    If a region is defined then the command operates as follows:-

    Region contained on a single line
        When the region is contained on a single line then this is assumed to
        be a search string and all lines in the buffer that match the region
        text are hilighted with the color scheme cCncA.

    Region spans multiple lines
        When the region spans multiple lines then all of the lines of the
        region are hilighted with the color scheme cCncA.

    cDline-schemecA is typically invoked from the pop-up menu (mouse right) to
    apply line hilighting annotation to a line or region. The user may select
    to apply a region hilight, remove the region hilight, remove all
    hilighting or perform a search using lslmosd-search(3)le.


cEcENOTES cEcA


    cDline-schemecA is a macro implemented in cGsearch.emfcA.


cEcESEE ALSO cEcA


    lslmdelete-hilight-lines(3)le, lslmosd-search(3)le, lslmosd(2)le, lslm$line-scheme(5)le.
! 3 buffer-setup
cEcENAME cEcA


    buffer-setup - Configure the current buffer settings
$a


cEcESYNOPSIS cEcA


    cDbuffer-setupcA


cEcEDESCRIPTION cEcA


    cDbuffer-setupcA provides a dialog interface for configuring the buffer major
    mode, indentation and buffer modes. cDbuffer-setupcA may be invoked from the
    main cCToolscA menu or directly from the command line using
    lslmexecute-named-command(2)le.

    The cDbuffer-setupcA dialog may be used to quickly reconfigure the attributes
    of a given buffer. The settings are only temporary and expire once the
    buffer has been closed or re-loaded. lslmbuffer-setup(3)le should be used to
    associate user specific settings with different buffer types.

    The following controls are available:-

    cDMajor ModecA
        Associates a file type with the content of the file and is used to
        modify the buffer highlighting and content assisted controls if the
        file type has not been recognized correctly. Changing the major mode
        will cause the new file type template to be loaded and may cause the
        buffer key bindings to change. The default major mode settings are set
        with lslmmajor-mode-setup(3)le.

    cDIndent WidthcA
        Defines the indent width to use when the TAB key is pressed, or
        following a nested construct in a auto-indent buffer. This entry
        modifies the lslm$buffer-indent-width(5)le setting. The default indentation
        width is defined by the variable lslm$indent-width(5)le.

    cDTab WidthcA
        The width of a rendered TAB character in spaces, modification of this
        value immediately changes the layout. This modifies the buffer width
        tab variable lslm$buffer-tab-width(5)le the default is 8 (defined by
        lslm$tab-width(5)le). Where files have been edited with a non-standard tab
        width then modification of this value (to typically 2 or 4) may
        correct the problem. To correct the styling of the buffer to be editor
        independent then the command lslmtabs-to-spaces(3)le may be used to change
        all of the tab characters to spaces once the tab width has been
        correctly set.

    cDFill ColumncA
        A text layout variable, defines the maximum length of the line before
        wrapping occurs when a text paragraph is filled. This modifies the
        buffer fill column variable lslm$buffer-fill-col(5)le the default is 78
        (defined by lslm$fill-col(5)le).

    cDFill ModecA
        A text layout variable, defines how paragraphs should be filled across
        multiple lines. This modifies the buffer fill mode variable
        lslm$buffer-fill-mode(5)le the default is cDBcA which causes automatic detection
        of paragraph layout, defaulting to full justification against the left
        and right margins (defined by lslm$fill-mode(5)le).

    cDUse Auto IndentationcA
        Toggles automatic indentation on an off, this setting is only present
        if the buffer type supports a lslmindent(2)le scheme. Typically used for
        files such as lsc(9)lmlexle and lsc(9)lmyaccle which use a special syntax combination with
        C.

    cDUse HilightingcA
        Toggles hilighting on and off, this setting is only present if the
        buffer type supports a lslmhilight(2)le scheme.

    cDBuffer ModescA
        The modes of the buffer, refer to lslmOperating Modesle for more
        information.

        A notable mode switch here is lslmtab(2m)le which changes the behavior of
        the cGTABcA key, when set tabs are simulated with the insertion of spaces,
        when disabled literal tab characters are used.


cEcEHISTORY cEcA


    Prior to the 2006 release cDbuffer-setupcA was previously called cDindent-setupcA
    and dealt with the indentation settings only. The 2006 release introduced
    the concept of cDMajor ModecA.


cEcESEE ALSO cEcA


    lslmbuffer-setup(3)le, lslmexecute-named-command(2)le, lslmhilight(2)le, lslmindent(2)le,
    lslmmajor-mode-setup(3)le, lslmosd(2)le, lslmtabs-to-spaces(3)le lslm$buffer-fill-col(5)le,
    lslm$buffer-fill-mode(5)le, lslm$buffer-indent-width(5)le, lslm$buffer-tab-width(5)le,
    lslm$fill-col(5)le, lslm$fill-mode(5)le, lslm$indent-width(5)le, lslm$tab-width(5)le.

    lslmOperating Modesle.
! 3 file-type-setup
cEcENAME cEcA


    file-type-setup - Define file type set
$a


cEcESYNOPSIS cEcA


    cDfile-type-setupcA


cEcEDESCRIPTION cEcA


    cDfile-type-setupcA provides a dialog interface for declaring a set of common
    files type categories and their associated file extensions. The file
    categories are used to determine the common file types in the File main
    menu cDQuick OpencA.

    cDfile-type-setupcA may be invoked directly from the command line or more
    usually from the miscellaneous configuration item cDFile TypescA in
    lslmuser-setup(3)le.

    On invocation a generic name for the file class is assigned to a set of
    file names or extensions as a comma separated list i.e. cG*.a,*.b,*.ccA.


cEcESEE ALSO cEcA


    lslmbuffer-setup(3)le, lslmuser-setup(3)le, lsMainMenu(3)lmTop Main Menule.
! 3 alias-path-setup
cEcENAME cEcA


    alias-path-setup - Define alternative path alias
$a


cEcESYNOPSIS cEcA


    cDalias-path-setupcA


cEcEDESCRIPTION cEcA


    cDalias-path-setupcA provides a dialog interface for declaring alternative
    alias paths. Alias path is a short name, conventionally then cG~cA is the home
    directory. The alias path setup allows other directory paths to be bound
    to a name i.e. "cDmecA" may be associated with "cD/home/jon/merep/me/cA". Given
    the alias definition then cD~mecA expands to cD/home/jon/merep/me/cA.

    cDalias-path-setupcA is accessible from the lslmuser-setup(3)le cDMiscellaneouscA tab.

    Multiple aliases may be defined and they are automatically accessible from
    the mode line when a file or directory name is entered.


cEcESEE ALSO cEcA


    lslmuser-setup(3)le.
! 3 file-tool-setup
cEcENAME cEcA


    file-tool-setup - Define file-browser tools
$a


cEcESYNOPSIS cEcA


    cDfile-tool-setupcA


cEcEDESCRIPTION cEcA


    cDfile-tool-setupcA provides a dialog interface for declaring a set of actions
    to act on files shown in the lslmfile-browser(3)le directory listing. Actions
    may be defined to interact with cGZIPcA files for both creation and
    extraction, opening of cGPDFcA files with Adobe Acrobat, opening of Microsoft
    Word cGDOCcA files with Word or StarOffice etc. These options are shown in the
    cDfile-browsercA pop-up menu under cDToolscA.

    The file tools may be configured from lslmuser-setup(3)le in the cDMiscellaneouscA
    tab or invoked directly from the command line using cDfile-tool-setupcA, when
    invoked then the File Tool Setup dialog is displayed. The dialog allows
    commands to be be matched against certain file types that are determined
    using a regular expression, if a filename matches the pattern then a
    command line or MicroEmacs command may be invoked to process the file(s).
    The command line includes cCvariablescA which are filled in by MicroEmacs. The
    information is stored in the registry cCuser.erfcA and is retained across
    sessions.

    The cDfile-tool-setupcA presents a list of tools, there is no limit to the
    number of tools which can be defined or to the number of tools that may
    map to a specific file type. The dialog has the following fields:

    cDName cA
        Declares the name of the tool as it appears in the cDToolscA section of
        the lslmfile-browser(3)le pop-up menu. A single menu short-cut key may be
        defined by prefixing the hot key with a cG\HcA.

    cDFile Mask cA
        A regular expression that is used to search for files of a given type,
        this follows the standard MicroEmacs lsRegularExpressions(2)lmRegular Expressionle syntax. As an
        example 'all files' is defined as "cG.*cA", PDF files are defined as
        cG.*\.pdfcA, image files might be defined as a set of different extensions
        cG.*\.\(png\|jpg\|jpeg\|bmp\|gif\)cA, etc.

    cDCommand cA
        Defines the command line or MicroEmacs command that is executed to
        process the action. The command line comprises escape characters using
        the percentage (cG%cA) character, these fields are filled in automatically
        by MicroEmacs and are defined as follows:

        cD%fcA - Filename
            A replacement for the filename, typically passed in quotes to the
            command being executed as an argument. The filename is defined as
            a relative pathname from the current directory location. If
            multiple files are selected in the cDfile-browsercA then the command
            line is executed multiple times, once for each file, unless the cD%*cA
            construct is used in conjunction with cD%fcA when multiple files may
            be specified with a single command invocation.

        cD%bcA - Base Filename
            The basename of the file, i.e. no pathname and no file extension.

        cD%ecA - File Extension
            The file extension of the filename.

        cD%pcA, cD%PcA - File pathname
            The pathname of the file without the filename. cD%pcA is the file path
            with '/' forward slash directory separators. cD%PcA is the same as cD%pcA
            but with '\' backslashes directory separators on Microsoft Windows
            and DOS.

        cD%i[cAcChcAcD|cAcCpromptcAcD|cAcCdefaultcAcD]cA .. cD%ncA - User Input
            Specifies that the user is to be prompted for input from the
            command line. Square brackets follow the cD%icA which defines the
            command line prompt. The cD%i[..]cA is replaced with the user input
            and may be replicated in the command line using cD%ncA where cDncA is a
            digit cG1..9cA where cD%1cA reproduces the first cD%icA, cD%2cA reproduces the
            second, ... etc.

            cChcA specifies the type of data to be entered including the history
            and semantics allowed. cChcA may have the following values:

            cG0cA For a general string input using the general history.
            cG1cA For an absolute file name, with completion and history.
            cG2cA For a MicroEmacs buffer name, with completion and history.
            cG3cA For a MicroEmacs command name, with completion and history.
            cG4cA For a file name, with completion and history.
            cG5cA For a search string, with history.
            cG6cA For a MicroEmacs mode name, with completion and history.
            cG7cA For a MicroEmacs variable name, with completion and history.
            cG8cA For a general string using no history.
            cG9cA For a user supplied completion list (cGcom-listcA).
            cGacA For a user supplied completion list (cGbuffer-namecA).

            cCpromptcA is the prompt string presented on the command line.

            cCdefaultcA is the default value that should be used. The cD%cA characters
            may be used and will be replaced with information from the
            filename e.g. cD%bcA would be replaced with the base file name.

            As an example of the user input, consider the following command
            line which is used to unzip a cD.zipcA file:

            cGunzip "%f" -d %i[4|Unzip sub-dir|%b]cA

            Given an input file of cG/home/user/foo.zipcA then the command line
            cGunzipcA cG"/home/user/foo.zip"cA cG-dcA cGfoocA is generated, given that the
            user accepted the defualt command line prompt of "cGfoocA" for the
            prompt "cGUnzipcA cGsub-dircA"

            Where the user input is required in multiple parts of the command
            line then the cD%1cA syntax may be used. The following example may be
            used to create a cD.zipcA archive from one or more selections in the
            file list.

            cGrm -f "%i[4|Zip file name|%b].zip"; zip -r %1.zip%*[ "%f"]cA

            In this instance the user is prompted for the cGZip file namecA and it
            is used twice in the command line, the default name is the base
            file name of the first file. Consider two files have been selected
            cGfoo.txtcA and cGbar.txtcA where cGfoo.txtcA is first. The generated command
            line is:

            cGrm -f "foo.zip"; zip -r foo.zip "foo.txt" "bar.txt"cA

            Note how the cCbasenamecA has been used as the default for the zip
            file name to create and this has been used in two places in the
            command line, once to delete the old archive if it already exists
            and once to form the new archive.

        cD%*[cAcCargumentcAcD]cA - Multiple file command line
            Utilities that accept multiple arguments on the command line use a
            special construct cD%*cA. By default a single command line invocation
            is made for each file, the cD%*cA construct makes a single command
            line invocation for multiple files.

            The square bracket construct contains the expansion for each file
            specified in the cDfile-browsercA, this will typically include the cD%fcA
            construct. For each argument then the brackets are expanded and
            concatenated together to form a command line, as such the bracket
            construct usually starts with a space character as this separates
            the files.

            As an example then zip file construction will take multiple files
            on the command line to add to the archive:

            cGrm -f "%i[4|Zip file name|%b].zip"; zip -r %1.zip%*[ "%f"]cA

        cD%"cAcC...cAcD%"cA - Quote text
            Using quote tags ensures the quoted part of the command-line is
            treated as a single argument. For example, if the tool:

            cGunzip %fcA

            is used for the file "Test Files.zip" the command-line becomes
            'cGunzipcA cGTestcA cGFiles.zipcA' which will not work correctly, conversely
            using cG"%f"cA will not work for files with quotes (e.g.
            '2"bolt.def'). However, if

            cGunzip %"%f%"cA

            is used MicroEmacs works out the best way to quote the file name
            for it to be properly processed.

        cD*cAcCMicroEmacs-CommandcA - Internal command
            Where the command commences with a star character (cG*cA) then the
            command is treated as a MicroEmacs command and is executed within
            the editor. As an example consider handling a zip file using the
            lslmfind-zfile(3)le command:

            cG*find-zfile "%f"cA

            For each file then cDfind-zfilecA is invoked to read the zip archive.

    cDDefault Open cA
        A flag that defines whether this is the default open action. When set
        then the command is automatically launched if the file is opened in
        the cDfile-browsercA (usually by left clicking on the file name or
        pressing "cGreturncA") . When clear then the tool has to be explicitly
        invoked.

    cDHide Window cA
        Defines the visibility of the window associated with the command, for
        example, if the command-line uses a cGcmdcA shell to launch another
        process the cmd window should be hidden. This has no effect on
        internal MicroEmacs commands.

    cDUp/Down cA
        Changes the item order in the list/menu by moving it up or down.

    cDAdd cA
        Adds a new tool line to the list.

    cDModify cA
        Modifies the existing tool setting.

    cDDelete cA
        Deletes the tool from the list.

    cDClose cA
        Closes the tool menu.


cEcEEXAMPLE cEcA


    Example tool definitions:

    Word processor
        Name: StarOffice/OpenOffice/Microsoft Word
        File Mask: cG.*\.\(doc\|ppt\|xls\|odt\|rtf\)cA
        Command: cGsoffice %"%f%"cA
        Hide Window: yes
        Default Open: no

    Image Viewer
        Name: XnView/Gimp/Photoshop/PaintShop
        File Mask: cG.*\.\(png\|jpg\|jpeg\|bmp\|gif\)cA
        Command: cGxnview %"%f%"cA
        Hide Window: yes
        Default Open: yes

    Postscript Viewer
        Name: Gnome Ghostview/Ghostview
        File Mask: cG.*\.pscA
        Command: cGggv %"%f%"cA
        Hide Window: yes
        Default Open: yes

    Acrobat Viewer
        Name: Adobe Acrobat
        File Mask: cG.*\.pdfcA
        Command: cGacroread %"%f%"cA
        Hide Window: yes
        Default Open: yes

    Unzip a zip Archive in current directory
        Name: Unzip in .
        File Mask: cG.*\.zipcA
        Command: cGunzip %"%f%"cA
        Hide Window: no
        Default Open: no

    Unzip a zip Archive in a sub-directory
        Name: Unzip in sub-dir
        File Mask: cG.*\.zipcA
        Command: cGunzip %"%f%" -d %"%i[4|Unzip sub-dir|%b]%"cA
        Hide Window: no
        Default Open: no

    Create a zip archive
        Name: Create Zip
        File Mask: cG.*cA
        Command: cGrm -f %"%i[4|Zip file name|%b].zip%"; zip -r %"%1.zip%"%*[
        %"%f%"]cA
        Hide Window: no
        Default Open: no

    Add to a zip archive
        Name: Add to Zip
        File Mask: cG.*cA
        Command: cGzip -r %"%i[4|Zip file name|%b]%"%*[ %"%f%"]cA
        Hide Window: no
        Default Open: no

    View archive file
        Name: View Archive
        File Mask: cG.*\.\(zip\|tgz\|tar\.gz\|tar\|gz\|bz2\)cA
        Command: cG*find-zfile %"%f%"cA
        Hide Window: no
        Default Open: yes

    Convert files to UNIX
        Name: 2Unix
        File Mask: cG.*cA
        Command: cGme @2unix %*[ %"%f%"]cA
        Hide Window: no
        Default Open: no

    Microsoft Windows - default action
        Name: Windows Default
        File Mask: cG.*cA
        Command: cGcmd /c %"%f%"cA
        Hide Window: yes
        Default Open: no
        Notes: This action runs the default action for the file type.

    Microsoft Windows - Explorer
        Name: Explorer
        File Mask: cG.*cA
        Command: cGexplorer .%*[]cA
        Hide Window: yes
        Default Open: no


cEcESEE ALSO cEcA


    lslmfile-browser(3)le, lslmfind-zfile(3)le, lslmuser-setup(3)le.
    lsRegularExpressions(2)lmRegular Expressionsle
! 4 &rep
!44 &irep
!44 &xrep
!44 &xirep
cEcENAME cEcA


    &rep, &irep, &xrep, &xirep - Replace string in string functions


cEcESYNOPSIS cEcA


    cD&repcA cCstr1cA cCstr2cA cCstr3cA
    cD&irepcA cCstr1cA cCstr2cA cCstr3cA
    cD&xrepcA cCstr1cA cCstr2cA cCstr3cA
    cD&xirepcA cCstr1cA cCstr2cA cCstr3cA


cEcEDESCRIPTION cEcA


    These functions search for cCstr2cA in cCstr1cA, replacing it with cCstr3cA, returning
    the resultant string.

    The functions may all be abbreviated to their three letter abbreviation
    (i.e. cD&xirepcA may be expressed as cD&xircA). In all cases the first argument is
    completely evaluated before the second and third arguments.

    cD&repcA cCstringcA cCsearchcA cCreplacecA
        Searches for the cCsearchcA string in the given cCstringcA using a simple case
        sensitive exact match algorithm. Any occurrences are removed from
        cCstringcA and cCreplacecA is inserted in its place. Either of the 3 input
        strings can be the empty string (cG""cA).

    cD&irepcA cCstringcA cCsearchcA cCreplacecA
        cD&irepcA is identical to cD&repcA except a case insensitive search algorithm
        is used.

    cD&xrepcA cCstringcA cCregex-searchcA cCregex-replacecA
        cD&xrepcA can be used to access the more powerful regular expression
        searching capabilities. The function is similar to cD&repcA except it
        takes a regex search string and the replacement string may also refer
        to all or part of the matched string. See lsRegularExpressions(2)lmRegular Expressionsle for
        information on the cCregexcA format.

    cD&xirepcA cCstringcA cCregex-searchcA cCregex-replacecA
        cD&xirepcA is identical to cD&xrepcA except a case insensitive regex search is
        used.


cEcEEXAMPLE cEcA


    The following example turns a UNIX format file name (using a 'cG/cA' to divide
    directories - like MicroEmacs) into an windows format name (using a 'cG\cA'):
sB
        set-variable #l0 &rep #l0 "/" "\\"

sA
    The following example replaces one or more white spaces in the variable
    with a single space, this is an easy way to remove unnecessary spaces:
sB
        set-variable #l0 "This   is   not   so    spacey    after   xrep"
        set-variable #l0 &xrep #l0 "\\s +" " "
        ml-write #l0

sA

cEcESEE ALSO cEcA


    lslmOperating Modesle, lsIntroduction to Variable FunctionslmVariable Functionsle, lslm&sequal(4)le, lslm&sin(4)le.
! 4 &abs
! 4 &add
! 4 &sub
!44 &multiply
!44 &divide
! 4 &mod
!44 &negate
! 4 &inc
! 4 &dec
!44 &pinc
!44 &pdec
cEcENAME cEcA


    &abs, &add, &sub, &mul, &div, &mod, &neg, &inc, &dec, &pinc, &pdec -
    Numeric macro operators


cEcESYNOPSIS cEcA


    cD&abscA cCnum1cA
    cD&addcA cCnum1cA cCnum2cA
    cD&subcA cCnum1cA cCnum2cA
    cD&multiplycA cCnum1cA cCnum2cA
    cD&dividecA cCnum1cA cCnum2cA
    cD&modcA cCnum1cA cCnum2cA
    cD&negatecA cCnumcA

    cD&inccA cCvariablecA cCincrementcA
    cD&deccA cCvariablecA cCdecrementcA
    cD&pinccA cCvariablecA cCincrementcA
    cD&pdeccA cCvariablecA cCdecrementcA


cEcEDESCRIPTION cEcA


    The numeric operators operate on variables or integers to perform integer
    computations, returning the integer result of the operation. The contents
    of the variables are interpreted as signed integers typically with a
    dynamic range of 2^31 <= cCnumcA <= 2^31-1.

    The operators may all be abbreviated to their three letter abbreviation
    (i.e. cD&multiplycA may be expressed as cD&mulcA). In all cases the first argument
    is completely evaluated before the second argument.

    cD&abscA cCnum1cA
        Returns the absolute value of cCnum1cA i.e. if cCnum1cA is positive it returns
        cCnum1cA, else -cCnum1cA

    cD&addcA cCnum1cA cCnum2cA
        Addition of two numbers cCnum1cA and cCnum2cA. i.e. cCnum1cA + cCnum2cA

    cD&subcA cCnum1cA cCnum2cA
        Subtract the second number cCnum2cA from the first cCnum1cA i.e. cCnum1cA - cCnum2cA.

    cD&multiplycA cCnum1cA cCnum2cA
        (Signed) Multiply cCnum1cA by cCnum2cA. i.e. cCnum1cA * cCnum2cA. cD&mulcA is the three
        letter abbreviation.

    cD&divcA cCnum1cA cCnum2cA
        Divide the first number cCnum1cA by the second cCnum2cA, returning the integer
        result. i.e. cCnum1cA / cCnum2cA. cD&divcA is the three letter abbreviation.

    cD&modcA cCnum1cA cCnum2cA
        Divide the first number cCnum1cA by the second cCnum2cA, returning the integer
        remainder. i.e. cCnum1cA % cCnum2cA.

    cD&negatecA cCnumcA
        Negate the integer (multiply by -1) i.e. -cCnumcA. cD&negcA is the three
        letter abbreviation.

    Expression evaluation is prefix. Operators may be nested using a pre-fix
    ordering, there is no concept of brackets (in-fix notation). The
    expression cG(2 * 3) + 4cA is expressed as:-
sB
        &add &mul 2 3 4

sA
    conversely cG2 * (3 + 4)cA is expressed as:-
sB
        &mul 2 &add 3 4

sA
    The pre/post incrementing and decrementing operators provide a mechanism
    for stepping through indexed information without incurring the overhead of
    providing multiple statements to perform assignment operations. The
    cCvariablecA argument MUST be the name of a variable, it cannot be an
    expression or an indirection. The cCincrementcA may be any integer expression
    (including another auto (dec)increment). Note that cCvariablecA is re-assigned
    with it's new value within the operator, therefore use with care when
    performing multiple (dec)increments within the same statement line. The
    four operators are defined as follows:

    cD&inccA cCvariablecA cCincrementcA
        Pre-increment the cCvariablecA by cCincrementcA, returning the incremented
        value i.e. cCvariablecA += cCincrementcA.

    cD&deccA cCvariablecA cCdecrementcA
        Pre-decrement the cCvariablecA by cCdecrementcA, returning the decrement value
        i.e. cCvariablecA -= cCdecrementcA.

    cD&pinccA cCvariablecA cCincrementcA
        Post-increment the cCvariablecA by cCincrementcA, returning the pre-increment
        value i.e. cCvariablecA++., where the ++ value is determined by cCincrementcA.
        The return value is the value of cCvariablecA as passed by the caller, the
        next reference to cCvariablecA uses the cCvariablecA+cCincrementcA value.

    cD&pdeccA cCvariablecA cCdecrementcA
        Post-decrement the cCvariablecA by cCdecrementcA, returning the pre-decrement
        value i.e. cCvariablecA--, where the -- value is determined by cCdecrementcA.


cEcEEXAMPLE cEcA


    Add two numbers together and assign to a variable:-
sB
        set-variable %result &add %num1 %num2

sA
    Increment cG%resultcA by 1 and add to cG%result2cA
sB
        set-variable %result  &add %result 1
        set-variable %result2 &add %result2 %result

sA
    The previous example could have used the increment operators to achieve
    the same result in a single operation e.g.
sB
        set-variable %result2 &add %result2 &inc %result 1

sA

cEcESEE ALSO cEcA


    lsIntroduction to Variable FunctionslmVariable Functionsle, lslm&great(4)le.
! 4 &cat
!44 &left
!44 &right
! 4 &mid
! 4 &len
!44 &slower
!44 &supper
!44 &trboth
!44 &trleft
!44 &trright
cEcENAME cEcA


    &cat, &lef, &rig, &mid, &len, &slo, &trb - String macro operators


cEcESYNOPSIS cEcA


    cD&catcA cCstr1cA cCstr2cA
    cD&lefcA cCstrcA cClencA
    cD&rightcA cCstrcA cCindexcA
    cD&midcA cCstrcA cCindexcA cClencA

    cD&lencA cCstrcA

    cD&slowercA cCstrcA
    cD&suppercA cCstrcA

    cD&trbothcA cCstrcA
    cD&trleftcA cCstrcA
    cD&trrightcA cCstrcA


cEcEDESCRIPTION cEcA


    The string operators operate on character strings (cD%cA or cD$cA variables),
    performing general string manipulation, returning a string result.

    The operators may all be abbreviated to their three letter abbreviation
    (i.e. cD&rightcA may be expressed as cD&rigcA). In all cases the first argument is
    completely evaluated before the second argument.

    cD&catcA cCstr1cA cCstr2cA
        Concatenate two string cCstr1cA with cCstr2cA to form a new string. i.e.
        cCstr1str2cA

    cD&lefcA cCstrcA cClencA
        Return cClencA leftmost characters from cCstrcA. If cCstrcA length is shorter than
        cClencA then the string itself is returned. A cClencA of zero returns the
        empty string. A negative cClencA returns all but the 0-cClencA rightmost
        characters from cCstrcA.

    cD&rigcA cCstrcA cCindexcA
        Returns the rightmost characters of string cCstrcA from index cCindexcA. This
        function causes some confusion, consider cD&lefcA and cD&rigcA to be the
        string equivalents of their integer counterparts ls&abs(4)lm&divle and ls&abs(4)lm&modle; cD&rigcA
        returns the remainder of the equivalent cD&lefcA function. Invocation with
        cCindexcA set to zero returns cCstrcA. A negative cCindexcA returns the 0-cCindexcA
        rightmost characters from cCstrcA.

    cD&midcA cCstrcA cCindexcA cClencA
        Extracts a sub-string from string cCstrcA, starting at position cCindexcA of
        length cClencA. A negative cCindexcA extracts the string starting from 0-cCindexcA
        from the end of cCstrcA with a length of cClencA.

    cD&lencA cCstrcA
        Returns the integer length of the string (number of characters).

    cD&slowercA cCstrcA
        Returns the given string with all upper case characters converted to
        lower case.

    cD&suppercA cCstrcA
        Returns the given string with all lower case characters converted to
        upper case.

    cD&trbothcA cCstrcA
        Returns the given string trimmed of white spaces (i.e. 'cG cA', 'cG\tcA',
        'cG\rcA', 'cG\ncA', 'cG\ClcA' and 'cG\CkcA') from both sides of the string.

    cD&trleftcA cCstrcA
        Returns the given string trimmed of white spaces from the left side of
        the string only.

    cD&trrightcA cCstrcA
        Returns the given string trimmed of white spaces from the right side,
        or end, of the string only.

    Evaluation of the strings is left to right, the leftmost argument is fully
    evaluated before the next argument. The operator ordering is prefix
    notation (see lslm&add(4)le for an example of prefix ordering).


cEcEEXAMPLE cEcA


    Concatenate two strings cGabccA and cGdefcA together:-
sB
        set-variable %result &cat "abc" "def"

sA
    To concatenate three strings cGabccA, cGdefcA cGghicA together:
sB
        set-variable %result &cat "abc" &cat "def" "ghi"

sA
    or, a slightly different ordering:
sB
        set-variable %result &cat &cat "abc" "def" "ghi"

sA
    Retrieve the leftmost character of a string variable, modify the variable
    to contain the remainder.
sB
        set-variable %foo "abcdef"
        set-variable %c   &lef %foo 1
        set-variable %foo &rig %foo 1

sA
    Where cG%ccA = "cGacA"; cG%foocA = "cGbcdefcA" following evaluation.

    To retrieve the characters cGcdecA into variable cG%resultcA from the string
    "cGabcdefcA" use:
sB
        set-variable %result &mid "abcdef" 2 3

sA
    To retrieve the rightmost character from the string:
sB
        set-variable %foo "abcdef"
        ; using negative argument
        set-variable %result &rig %foo -1
        ; using &len
        set-variable %result &rig %foo &sub &len %foo 1
        ; using &mid to do the same thing
        set-variable %result &mid %foo -1 1
        set-variable %result &mid %foo &sub &len %foo 1 1

sA
    To get an input string from the user which is free of spaces at the start
    and end:
sB
        set-variable %result &trb @ml "Enter string"

sA

cEcENOTES cEcA


    The original cDMicroEMACScA "cD&rigcA cCstrcA cCncA" function returns the last cCncA
    characters from the string cCstrcA this differs from the definition of cD&rigcA in
    this implementation. As most string decomposition is performed left to
    right, and to make cD&lefcA and cD&rigcA complement each other, the indexing of
    the function has been modified.


cEcESEE ALSO cEcA


    lsIntroduction to Variable FunctionslmVariable Functionsle, lslm&sin(4)le, lslm&sequal(4)le, lslm&lget(4)le, lslm&sprintf(4)le.
! 4 &and
! 4 &or
! 4 &not
!44 &equal
!44 &great
!44 &less
cEcENAME cEcA


    &and, &or, &not, &equal, &sequal - Logical macro operators


cEcESYNOPSIS cEcA


    cD&andcA cClog1cA cClog2cA
    cD&orcA cClog1cA cClog2cA
    cD&notcA cClogcA

    cD&equalcA cCnum1cA cCnum2cA
    cD&greatcA cCnum1cA cCnum2cA
    cD&lesscA cCnum1cA cCnum2cA


cEcEDESCRIPTION cEcA


    The logical testing operators perform comparison tests, returning a
    boolean value of cGTRUEcA (1) or cGFALSEcA (0).

    The functions may all be abbreviated to their three letter abbreviation
    (i.e. cD&greatcA may be expressed as cD&grecA). In all cases the first argument is
    completely evaluated before the second argument. Logical operators
    include:-

    cD&and cAcClog1cA cClog2cA
        cGTRUEcA if the logical arguments cClog1cA and cClog2cA are both cGTRUEcA.

    cD&orcA cClog1cA cClog2cA
        cGTRUEcA if either one of the logical arguments cClog1cA and cClog2cA are cGTRUEcA.

    cD&notcA cClogcA
        Logical NOT. Returns the opposite logical value to cClogcA.

    The numerical logical functions operate with integer arguments:

    cD&equalcA cCnum1cA cCnum2cA
        cGTRUEcA. If numerical arguments cCnum1cA and cCnum2cA numerically equal.
        Abbreviated form of the function is cD&equcA.

    cD&greatcA cCnum1cA cCnum2cA
        cGTRUEcA. If numerical argument cCnum1cA is greater than cCnum2cA. Abbreviated
        form of the function is cD&grecA.

    cD&lesscA cCnum1cA cCnum2cA
        cGTRUEcA. If numerical argument cCnum1cA is less than cCnum2cA Abbreviated form of
        the function is cD&lescA.

    Evaluation of the logical operators are left to right, the leftmost
    argument is fully evaluated before the next argument. The operator
    ordering is prefix notation (see lslm&add(4)le for an example of prefix
    ordering).


cEcEEXAMPLE cEcA


    Test for integers in the range greater than 12:
sB
        !if &great %i 12
            ...

sA
    Test for integers in the range 8-12, inclusive
sB
        !if &and &great 7 &less 13
            ...

sA

cEcENOTES cEcA


    MicroEmacs always evaluates all arguments operators BEFORE the result is
    obtained, this differs from most programming languages. Consider the
    following example:
sB
        !if &and &bmod "edit" &iseq @mc1 "Save buffer first [y/n]? " "nNyY" "y"
            save-buffer
        !endif

sA
    This would not not work as the user may expect, the user would be prompted
    to save every time regardless of whether the buffer has been changed.
    Instead the following should be used:
sB
        !if &bmod "edit"
            !if &iseq @mc1 "Save buffer first [y/n]? " "nNyY" "y"
                save-buffer
            !endif
        !endif

sA

cEcESEE ALSO cEcA


    lsIntroduction to Variable FunctionslmVariable Functionsle, lslm&add(4)le, lslm&sequal(4)le, lslm&sin(4)le, lslm&cond(4)le.
!44 &sprintf
cEcENAME cEcA


    &sprintf - Formatted string construction


cEcESYNOPSIS cEcA


    cD&sprintfcA cCformatcA cCargscA


cEcEDESCRIPTION cEcA


    The cD&sprintfcA function (or cD&sprcA in it's abbreviated form) provides a
    mechanism to generated a formatted string, similar to the 'C' programming
    language cDsprintf(2)cA function.

    The cD&sprintfcA function is generally used where a number of different
    sources of information have to be converted and joined together to form a
    new string. It is possible to do this using lslm&cat(4)le, but it does become
    complicated if the number of strings to be spliced together is greater
    than about 4, cDsprintfcA alleviates these problems and results in faster
    execution. Where only two, or three strings are to be concatenated cD&catcA
    provides better execution times.

    The cD&sprintfcA function produces a string construct for the cCformatcA and a
    caller determined number of arguments cCargscA (variable arguments). The
    cCformatcA string may contain special 'cD%cA' formatting commands to insert
    strings and numbers into the base cCformatcA string. The format for the 'cD%cA'
    commands is "cD%nccA" where:-

    cDncA
        An optional numerical argument, the interpretation of the numeric
        value is determined by the following command (cDccA).

    cDccA
        The command determines the interpretation of the next argument cCargcA
        which are specified as follows:

        cDdcA (Decimal integer)
            Expects a single numeric argument cCargcA which is inserted into the
            cCformatcA string as decimal text string. If cCncA is specified then the
            inserted text string is fixed to cCncA character in length.

        cDncA (Repeat String)
            Expects two arguments cCargcA, the first is a numeric argument giving
            the number of times to insert the given string (the second
            argument). If cCncA is specified then the string is inserted cCncA *
            cCnumeric-argumentcA times.

        cDscA (String)
            Expects a single argument cCargcA which is a string to be inserted
            into the key. If cCncA is given then it is insertedcCncA times.

        cDxcA (Hexadecimal integer)
            Expects a single numeric argument cCargcA which is inserted into the
            format string as hexadecimal text string. If cCncA is given then the
            inserted text string will be fixed to cCncA character in length.

        cD%cA
            Inserts a single '%', cCncA has no effect.

        The cD&sprintfcA function may be nested (i.e. a string argument to
        cD&sprintfcA may be the result of another cD&sprintfcA invocation). Although
        this type of construct is not generally required !!


cEcEEXAMPLE cEcA


    The following examples show how the command may be used:-
sB
        set-variable %result &sprintf "Foo [%s%s]" "a" "b"

sA
    generates "cGFoo [ab]cA"
sB
        set-variable %result &sprintf "Foo [%n%s]" 10 "a" "b"

sA
    generates "cGFoo [aaaaaaaaaab]cA".
sB
        set-variable %result &sprintf "[%d] [%3d] [%x] [%3x]" 10 11 12 13

sA
    generates "cG[10] [ 11] [c] [  d]cA"


cEcENOTES cEcA


    It is the callers responsibility to ensure that the correct number of
    arguments is supplied to match the requested formatting string. The
    results are undefined if an incorrect number of arguments are supplied.


cEcESEE ALSO cEcA


    lsIntroduction to Variable FunctionslmVariable Functionsle, lslm&cat(4)le.
!44 &atoi
!44 &itoa
!44 &gmode
!44 &bmode
!44 &nbmode
!44 &inword
!44 &indirect
!44 &exist
cEcENAME cEcA


    &ato, &gmod, &bmo, &ind, &inw, &exi - Miscellaneous functions


cEcESYNOPSIS cEcA


    cD&atoicA cCcharcA
    cD&itoacA cCnumcA

    cD&gmodecA cCmodecA
    cD&bmodecA cCmodecA
    cD&nbmodecA cCbuffercA cCmodecA
    cD&inwordcA cCcharcA

    cD&indirectcA cCstrcA

    cD&existcA cCstrcA


cEcEDESCRIPTION cEcA


    These are a selection of miscellaneous functions providing tests and
    exchanging of information.

    The functions may all be abbreviated to their three letter abbreviation
    (i.e. cD&indirectcA may be expressed as cD&indcA). In all cases the first argument
    is completely evaluated before the second argument.

    cD&atoicA cCcharcA
        Converts the given character cCcharcA to it's ASCII number which is
        returned. (see cD&itoacA). Abbreviated command is cD&atocA.

    cD&itoacA cCnumcA
        Converts an integer cCnumcA to it's ASCII character representation which
        is returned to the caller. Abbreviated command is cD&itocA.

    cD&gmodecA cCmodecA
        Returns cG1cA if the given mode cCmodecA is globally enabled. Allows macros to
        test the global mode state (see lslmOperating Modesle). Abbreviated command
        is cD&gmocA.

    cD&bmodecA cCmodecA
        Returns cG1cA if the mode cCmodecA is enabled in the current buffer. Allows
        macros to test the state of the buffer mode. Abbreviated command is
        cD&bmocA.

    cD&nbmodecA cCbuffercA cCmodecA
        Returns cG1cA if the mode cCmodecA is enabled in buffer cCbuffercA . Allows macros
        to test the state of a buffer mode other than the current. Abbreviated
        command is cD&nbmcA.

    cD&inwordcA cCcharcA
        cGTRUEcA. If the given character cCcharcA is a 'word' character, see
        lslmforward-word(2)le for a description of a 'word' character. Abbreviated
        command is cD&inwcA.

    cD&indirectcA cCstrcA
        Evaluate cCstrcA as a variable. The cCstrcA argument is evaluated and takes
        the resulting string, and then uses it as a variable name. i.e. a
        variable may reference another variable which contains the data to be
        referenced. Abbreviated command is cD&indcA.

    cD&existcA cCstrcA
        Tests for the existance of cCstrcA which may be a variable or a
        command/macro name, returning cGTRUEcA if the variable or command does
        currently exist. Abbreviated command is cD&exicA.


cEcEEXAMPLE cEcA


    The cD&exicA function is etremely useful in initializing, for example:
sB
        !if &not &exi %my-init
            ; %my-init is not yet defined so this is the first call
            set-variable %my-init 1
            .
            .

sA
    Or in all the lsfileHooks(2)lmfile hooksle a user defined extension is checked for and
    executed if defined:
sB
        define-macro fhook-c
            .
            .
            ; execute user extensions if macro is defined
            !if &exi my-fhook-c
                my-fhook-c
            !endif
        !emacro

sA
    The cD&indcA function deserves more explanation. cD&indcA evaluates its string
    argument cCstrcA, takes the resulting string and then uses it as a variable
    name. For example, given the following code sequence:
sB
        ; set up reference table

        set-variable  %one "elephant"
        set-variable  %two "giraffe"
        set-variable  %three "donkey"

        set-variable  %index "%two"
        insert-string &ind %index

sA
    the string "cGgiraffecA" would have been inserted at the point in the current
    buffer.

    The cD&bmodecA invocation allows a calling macro to determine the buffer mode
    state (see lslmOperating Modesle). Consider the following example which is a
    macro to perform a case insensitive alphabetic sort using the
    lslmsort-lines(2)le function. cDsort-listcA sorts according to the state of the
    lslmexact(2m)le mode, hence the macro has to determine the buffer state in order
    to be able to do the sort.
sB
        define-macro sort-lines-ignore-case
            set-variable #l0 &bmod exact
            -1 buffer-mode "exact"
            !if @?
                @# sort-lines
            !else
                sort-lines
            !endif
            &cond #l0 1 -1 buffer-mode "exact"
        !emacro

sA
    The cD&inwordcA function is shown in the following example. In this case the
    mouse is positioned over a word. The cD&inwordcA function is used to determine
    if the cursor is on a valid word character, if so the cursor is placed at
    the start of the word.
sB
        define-macro mouse-control-drop-left
            set-cursor-to-mouse
            !if &inword @wc
                backward-word
                set-mark
                forward-word
            !else
                ...
            !endif
            copy-region
            set-cursor-to-mouse
        !emacro

sA

cEcESEE ALSO cEcA


    lslmOperating Modesle, lsIntroduction to Variable FunctionslmVariable Functionsle, lslm&sprintf(4)le, lslm&equal(4)le.
!44 !emacro
!44 !ehelp
cEcENAME cEcA


|!emacro
    !emacro - Terminate a macro definition
|!ehelp
    !ehelp - Terminate a help definition


cEcESYNOPSIS cEcA


    lsdefine-macro(2)lmdefine-macrole cCmacro-namecA

        cC... macro body ...cA

    cD!emacrocA
    lsdefine-help(2)lmdefine-helple cCitem-namecA

        cC... help body ...cA

    cD!ehelpcA


cEcEDESCRIPTION cEcA


    cD!emacrocA terminates the storage of an open macro, (opened with
    lslmdefine-macro(2)le). Only the lines between cDdefine-macrocA and the cD!emacrocA
    directive comprise the new macro cCmacro-namecA.

    Similarly cD!ehelpcA terminates the storage of an open help definition,
    (opened with lslmdefine-help(2)le). Only the lines between cDdefine-helpcA and the
    cD!ehelpcA directive comprise the new help text for item cCitem-namecA.

    cD!emacrocA and cD!ehelpcA may not be used in any other context.


cEcEEXAMPLE cEcA


    For example if a file is being executed contains the text:
sB
        ;
        ; Read in a file in view mode, and make the window red
        ;
        define-macro view-a-file
            find-file @ml"File to view: "
            1 buffer-mode "view"
            set-variable $buffer-bcol %red
        !emacro

        define-help view-a-file
            This is the help text for the macro view-a-file.
        !ehelp

        ml-write "[view-a-file macro has been loaded]"

sA
    then only the lines between the cDdefine-macrocA command and the cD!emacrocA
    directive are stored in macro cCview-a-filecA and the lines between the
    cDdefine-helpcA command and the cD!ehelpcA directive are stored as help for
    cCview-a-filecA. The lsml-write(2)lmml-writele line is executed when the file is loaded, and
    the message will appear on the message line, this does not however form
    part of the macro or help.


cEcESEE ALSO cEcA


    lslmOperating Modesle, lslmdefine-macro(2)le, lslmdefine-help(2)le.

    lsmacroWriting(4)lmWriting MicroEmacs Macrosle
    lsMicroEmacs - Macro Language GlossarylmMacro Glossaryle
    lsmacroDebugging(4)lmMacro Debugging - A Crash Coursele
    lsmacroOverview(4)lmMicroEmacs Macro Language at a Glancele
!44 !force
cEcENAME cEcA


    !force - Ignore command or macro status


cEcESYNOPSIS cEcA


    cD!forcecA [cCncA] cCcommandcA


cEcEDESCRIPTION cEcA


    cD!forcecA ignores the return status of a cCcommandcA while executing a macro.
    When MicroEmacs 2009 executes a macro, if any command fails, the macro is
    terminated at that point. If a line is preceded by a cD!forcecA directive,
    execution continues whether the command succeeds or not. lslm$status(5)le may be
    used following cD!forcecA to determine if the command failed or not.

    A double cD!forcecA can be used to catch a user termination (via the
    lslmabort-command(2)le bound to cGC-gcA). A macro command aborted by the user will
    be terminated even with a single cD!forcecA directive, but not with two. See
    the example below.

    When specifying a numerical argument with a cCcommandcA, it is placed after
    the cD!forcecA directive and before the cCcommandcA i.e.
sB
        !force 1 forward-char

sA

cEcEEXAMPLE cEcA


    The following example shows how cD!forcecA is used in conjunction with
    cD$statuscA.
sB
        ; Merge the top two windows

        push-position           ;remember where we are
        1 next-window           ;go to the top window
        delete-window           ;merge it with the second window
        !force pop-position     ;This will continue regardless
        !if $status
            ml-write "Call PASSED"
        !else
            ml-write "Call FAILED"
        !endif


    The following example creates an infinite loop that can only be broken out
    of by a user abort. The calling macro catches this by using a double
    cD!forcecA and continues. This concept is used by commands which take a
    considerable amount of time yet cannot be simply aborted by the user such
    as the spell-checker's best guess list generator.

        define-macro infinite-loop
            set-variable #l0 1
            !while 1
                ml-write &cat "In loop, C-g to exit: " &pinc #l0 1
            !done
        !emacro

        define-macro catch-abort
            !force !force infinite-loop
            ml-write "You will see this"
        !emacro

sA

cEcESEE ALSO cEcA


    lslm$status(5)le.
! 4 !if
!44 !else
!44 !elif
!44 !endif
cEcENAME cEcA


    !if, !elif, !else, !endif - Conditional statements


cEcESYNOPSIS cEcA


    cD!ifcA cCconditioncA
        cC... condition body ...cA
    [cD!elifcA cCconditioncA
        cC... condition body ...cA
    ]
    [cD!elsecA
        cC... condition body ...cA
    ]
    cD!endifcA


cEcEDESCRIPTION cEcA


    The conditional directives allow statements to be executed only if a
    condition specified in the directive is met, as follows:-

        * Every line following the cD!ifcA directive, until the first cD!elifcA, cD!elsecA
          or cD!endifcA directive, is only executed if the expression following
          the cD!ifcA directive evaluates to a cGTRUEcA value (non-zero).

        * If the cD!ifcA evaluates to cGFALSEcA and a cD!elifcA directive is next then the
          expression following the cD!ifcA is evaluated and following statements
          are executed if cGTRUEcA.

        * If no cD!ifcA or cD!elifcA is found to be cGTRUEcA and a cD!elsecA is found then the
          statements following it are executed.

    The cCconditioncA may be any logical condition as evaluated by the lsIntroduction to Variable Functionslmvariableln
    lnfunctionsle (e.g. lslm&equal(4)le) returning cGTRUEcA or cGFALSEcA. An integer value,
    non-zero evaluates cGTRUEcA, zero evaluates to cGFALSEcA. A non-numerical
    argument, such as a string is always cGFALSEcA.

    The cCconditional bodycA may be any cDMicroEmacs 2009cA function, macro or
    directive with the exception of cDdefine-macrocA and cD!emacrocA. All directives
    that alter the execution of the macro are handled correctly within the cD!ifcA
    statement (e.g. ls!goto(4)lm!gotole, ls!return(4)lm!returnle etc.


cEcEEXAMPLE cEcA


    The following macro segment creates the portion of a text file
    automatically. (yes believe me, this will be easier to understand then
    that last explanation....)
sB
        !if &sequal %curplace "timespace vortex"
            insert-string "First, rematerialize\n"
        !endif
        !if &sequal %planet "earth" ;If we have landed on earth...
            !if &sequal %time "late 20th century"  ;and we are then
                ml-write "Contact U.N.I.T."
            !elif &sequal %time "pre 20th century"
                ml-write "start praying for a miracle"
            !else
                insert-string "Investigate the situation....\n"
                insert-string "(SAY 'stay here Sara')\n"
            !endif
        !else
            set-variable %conditions @ml"Atmosphere conditions outside? "
            !if &sequal %conditions "safe"
                insert-string &cat "Go outside......" "\n"
                insert-string "lock the door\n"
            !else
                insert-string "Dematerialize..try somewhere else"
                newline
            !endif
        !endif

sA

cEcESEE ALSO cEcA


    lsIntroduction to Variable FunctionslmVariable Fuctionsle, lslm!goto(4)le, lslm&equal(4)le, lslm!return(4)le, lslm$status(5)le.
!44 !goto
!44 !tgoto
cEcENAME cEcA


|!goto
    !goto - Unconditional labeled jump
|!tgoto
    !tgoto - Conditional labeled jump


cEcESYNOPSIS cEcA


    cD!gotocA cClabelcA
        ...
    cD*cAcClabelcA

    cD!tgotocA cCconditioncA cClabelcA
        ...
    cD*cAcClabelcA


cEcEDESCRIPTION cEcA


    Flow can be controlled within a MicroEmacs 2009 macro using the cD!gotocA
    directive. It takes as an argument a cClabelcA. A cClabelcA consists of a line
    starting with an asterisk (cD*cA) and then an alphanumeric label. Only labels
    in the currently executing macro can be jumped to, trying to jump to a
    non-existing label terminates execution of a macro. cClabelscA may be located
    at any position within the macro (forwards or backwards from the cD!gotocA).

    A conditional jump may be implemented with a cD!tgotocA, this takes an
    additional argument cCconditioncA, which may be a literal numeric value, a
    variable or an evaluated expression (see lsIntroduction to Variable FunctionslmVariable Functionsle). If the
    cCconditioncA evaluates to TRUE (or non-zero) then the branch is taken and
    control continues from the cClabelcA.

    cD!tgotocA is an ideal replacement for lslm!while(4)le and lslm!repeat(4)le where nested
    loops are required.


cEcEEXAMPLE cEcA


    For example, create a block of DATA statements for a BASIC program:
sB
                insert-string "1000 DATA "
                set-variable %linenum 1000
        *nxtin
                screen-update           ;make sure we see the changes
                set-variable %data @ml"Next number: "
                !if &equal %data 0
                    !goto finish
                !endif
                !if &greater $curcol 60
                    2 backward-delete-char
                    newline
                    set-variable %linenum &add %linenum 10
                    insert-string &cat %linenum " DATA "
                !endif
                insert-string &cat %data ", "
                !goto nxtin
        *finish
                2 backward-delete-char
                newline

sA
    Not that any of us are writing basic programs these days !!


cEcENOTES cEcA


    cD!gotocA and cD!tgotocA are expensive operations because a symbolic name lookup
    is performed in the macro file. For time critical macros then the lslm!jump(4)le
    and lslm!tjump(4)le directives should be used as these do not perform a symbolic
    name search. The cCjumpcA equivalents are source sensitive since a line
    displacement rather than a cClabelcA is used - this makes them a little
    dangerous to use.


cEcESEE ALSO cEcA


    lsIntroduction to Variable FunctionslmVariable Functionsle, lslm!if(4)le, lslm!jump(4)le, lslm!repeat(4)le, lslm!return(4)le, lslm!tjump(4)le,
    lslm!while(4)le.
!44 !return
!44 !abort
cEcENAME cEcA


    !return, !abort - Exit macro


cEcESYNOPSIS cEcA


    cD!returncA [cCncA]
    cD!abortcA [cCncA]


cEcEDESCRIPTION cEcA


    The cD!returncA directive causes the current macro to exit with a cGTRUEcA status,
    either returning to the caller (if any) or to interactive mode. If an
    argument cCncA is specified then the return status is determined by the value
    of cCncA.

    cD!abortcA has the same effect as cD!returncA only always returning a cGFALSEcA status
    to halt the execution of any calling macro. If an argument cCncA is given to
    cD!abortcA the bell is also rung, the valid values of cGncA are the same as for
    the lslm!bell(4)le directive.


cEcEEXAMPLE cEcA


    The following example checks the current language and warns if it has not
    be set, i.e. cGDefaultcA.
sB
        ; Check the current language

        !if &not &seq %language "Default"
            !return
        !endif
        ml-write "Warning - you have not setup the Language - use user-setup"

sA
    The following example is shows the logic of the cD!returncA directive:-

sB        ; !return example
        define-macro i-will-return
            ml-write "you will see me"
            !return
            ml-write "you wont see me"
        !emacro

        define-macro test-return
            ml-write "you will see me"
            i-will-return
            ml-write "you will see me"
        !emacro

sA
    Similarly, for the cD!abortcA directive
sB
        ; !abort example
        define-macro i-will-abort
            ml-write "you will see me"
            !abort
            ml-write "you wont see me"
        !emacro

        define-macro test-abort
            ml-write "you will see me"
            i-will-abort
            ml-write "you wont see me"
        !emacro

sA
    For the last two examples above, all the "cDwillcA"s are displayed and none of
    the "cDwontcA"s are.


cEcESEE ALSO cEcA


    lslmdefine-macro(2)le, lslm!bell(4)le, lslm!if(4)le, lslm!goto(4)le.
!44 !while
!44 !continue
!44 !done
cEcENAME cEcA


    !while, !continue, !done - Conditional loop


cEcESYNOPSIS cEcA


    cD!whilecA cCconditioncA
        ... loop body ...
        [cD!continuecA]
    cD!donecA


cEcEDESCRIPTION cEcA


    The cD!whilecA directive allows statements only to be executed if a cCconditioncA
    specified in the directive is met. Every line following the cD!whilecA
    directive, until the first cD!donecA directive, is only executed if the
    expression following the cD!whilecA directive evaluates to a cGTRUEcA value.

    A cD!continuecA may be used in the loop, this immediately returns control to
    the cD!whilecA statement and skips the rest of the section.

    cD!while statement may not be nested.cA That is, only one cD!whilecA statement may
    be outstanding at a time, a lslm!repeat(4)le statement may be used within the
    cD!whilecA to create an inner loop if required. Alternatively the lslm!goto(4)le
    used in conjunction with the lslm!if(4)le statement may be used to construct
    loops.


cEcEEXAMPLE cEcA


    For example, the following macro segment fills to the fill column with
    spaces.
sB
        !while &less $curcol $buffer-fill-col
            insert-string " "
            !if &equal %example "1"     ; Silly to show continue
                !continue               ; Goto !while
            !endif
            ml-write "You wont see me if %example = 1"
        !done

sA

cEcESEE ALSO cEcA


    lslm!if(4)le, lslm!goto(4)le, lslm!repeat(4)le.
!44 !repeat
!44 !until
cEcENAME cEcA


    !repeat, !until - Conditional loop (post testing)


cEcESYNOPSIS cEcA


    cD!repeatcA
        ... loop body ...
    cD!untilcA cCconditioncA


cEcEDESCRIPTION cEcA


    Th cD!repeatcA command operates in a similar fashion to ls!while(4)lm!while/!donele except
    the condition is tested at the end. Control finishes if the condition is
    met. As with the lslm!while(4)le there is no nesting of multiple cD!repeatcA
    statements.


cEcEEXAMPLE cEcA


    For example, the following macro segment fills to the fill column with
    spaces.
sB
        !repeat
            insert-string " "
        !until &equal $curcol $buffer-fill-col

sA

cEcESEE ALSO cEcA


    lslm!if(4)le, lslm!goto(4)le, lslm!repeat(4)le.
!44 !bell
cEcENAME cEcA


    !bell - Sound audio alarm


cEcESYNOPSIS cEcA


    cD!bellcA [cCncA]


cEcEDESCRIPTION cEcA


    cD!bellcA provides a warning (audible or visual) to alert the user of a
    problem. cD!bellcA honors the ls$quiet(5)lmquiet(5)le setting, as such if cDquietcA mode is
    disabled an audible warning is given, otherwise a visual warning is given
    to the user (usually the message "cC[BELL]cA" in the bottom left hand corner
    of the message line).

    The optional numerical argument cCncA over-rides the current setting of cDquitecA,
    a value of cG0cA specifies a quite bell, cG2cA an audible one, when omitted the
    default is cG1cA honoring the setting of cDquitecA mode.

    cD!bellcA is generally used in conjunction with ls!return(4)lm!abortle, the !bell function
    warning the user and the !abort function to quit the macro.


cEcEEXAMPLE cEcA


    The following macro example checks for incoming mail and is taken from
    cGmail.emfcA. If any mail has arrived an audible warning is assured by
    toggling the cDquietcA mode.
sB
        ;
        ; Mail checker
        define-macro mail-check
            !if &seq &set %vm-mail-src &reg &spr "/history/%s/mail-src"  $platform ""
                ml-write "[Incoming mail file not setup! Execute mail-setup to configure]"
                !abort
            !endif
            600000 create-callback mail-check
            ml-write &spr "Checking for mail in %s..." %vm-mail-src
            set-variable #l0 &cond &gre &stat "s" %vm-mail-src 0 "M" "-"
            !if &not &seq &mid $mode-line 2 1 #l0
                set-variable #l1 &rig $mode-line &cond &seq &mid $mode-line 2 1 "%" 4 3
                set-variable $mode-line &cat &cat &lef $mode-line 2 #l0 #l1
                screen-update
                !if &seq #l0 "M"
                    ; use an argument to !bell so it toggles it back to its original state
                    !bell 0
                    !bell 2
                !endif
            !endif
            0 ml-write
        !emacro

sA

cEcESEE ALSO cEcA


    lslm!abort(4)le, lslmabort-command(2)le, lslm!bell(4)le.
! 4 MacroArguments
! 4 @?
! 4 @#
! 4 @0
! 4 @1
! 4 @2
! 4 @p
cEcENAME cEcA


    @?, @#, @0, @1, @2, @3, ... @p - Macro arguments


cEcESYNOPSIS cEcA


    cD@?cA - Boolean flagging if a numeric argument was supplied
    cD@#cA - The value of the numeric argument

    cD@0cA - The name of the macro
    cD@1cA - The first argument of macro
    cD@2cA - The second argument of macro
    cD@3cA ... cD@cAcCncA

    cD@pcA - The name of the calling (or parent) macro.


cEcEDESCRIPTION cEcA


    Macros may be passed arguments, allowing a macro to be used by other
    macros. The cD@?cA and cD@#cA are used to determine the numeric argument given to
    the command. The cD@cAcCncA variable (where cCncA is an integer) used in the context
    of a macro allows the macro body to determine it's arguments.

    From a macro all commands are called in the following form

        [num] <macro-name> "arg1" "arg2" ....


    When executed macros do not have to be given an argument, in this case cD@?cA
    will be cC0cA and cD@#cA will be cC1cA (the default argument). If an argument is given
    then cD@?cA will be cC1cA and cD@#cA will be set to the numeric argument given.

    The current macro command name cC<macro-name>cA can be obtain by using the cD@0cA
    variable, e.g.
sB
        define-macro Test-it
            ml-write @0
        !emacro

sA
    When executed, writes the message "cGTest-itcA" which is the name of the
    macro.

    Arguments may be passed into macro commands in the same way as standard
    commands are given arguments. The macro being called can access these by
    the cD@1cA to cD@ncA variables, where cCncA is a positive integer. Any variables given
    as arguments are evaluated so if the variable name is required then
    enclose it in quotes, e.g.
sB
        set-variable %test-var "Hello World"

        define-macro Test-it
            ml-write &cat &cat &cat &cat @0 " " @1 " = " &ind @1
            set-variable  @1 @2
        !emacro

        Test-it "%test-var" "Goodbye World"

sA
    On execution the macro writes the message

        "cGTest-it %test-var = Hello WorldcA"

    and will set variable cG%test-varcA to "cGGoodbye WorldcA". Note that the cD@1cA has
    been used by reference on the cDset-variablecA rather than by value as it is
    used in an assignment.

    The cD@pcA variable can be used to obtain the name of the macro which is
    executing the current macro, i.e. the value of the parent's cD@0cA variable.
    If the macro was executed directly by the user then there is no parent
    macro and the value of cD@pcA is an empty string ("").

    The variables cD@#cA and cD@?cA are automatically set on entry to a macro, the
    values may be over-written by the calling macro if required, but their
    assignment values are restricted to being integer values, assignment of a
    character string causes an error.


cEcEDIAGNOSTICS cEcA


    If an attempt is made to access an argument which has not been given then
    a error occurs. This error can be trapped using the lslm!force(4)le directive,
    enabling the macro to take appropriate action, see example.


cEcEEXAMPLE cEcA


    Consider the implementation of lslmreplace-all-string(3)le macro defined in
    search.emf:
sB
        define-macro replace-all-string
            !force set-variable #l0 @3
            !if &not $status
                set-variable #l1 @ml05 "Replace all"
                set-variable #l2 @ml05 &spr "Replace [%s] with" #l1
                set-variable #l0 @ml00 "In files"
            !else
                set-variable #l1 @1
                set-variable #l2 @2
            !endif
            .
            .
            .
        !emacro

sA
    In this example if the 3rd argument is not given then the macro gets all
    arguments from the user.

    The cD@pcA variable having a value of "" when a macro is called directly by
    the user can be useful when determining the amount of information to
    feed-back to the user. For example, executing the lsclean(3)lmcleanle macro is an easy
    way to remove surplus white characters, so it is often used by other
    macros as well as by the user. When called directly cDcleancA refreshes the
    display and prints a message of completion, but when called by other
    macros this would cause an unwanted screen-update and message, so clean
    only does this when executed by the user. This is done as follows:
sB
        define-macro clean
            ;
            ; Prepare to clean up file.
            .
            .
            .
            !if &seq @p ""
                screen-update
                ml-write "[Cleaned up buffer]"
            !endif
        !emacro

sA

cEcENOTES cEcA


    The parsing of arguments can be inefficient because of the way the
    arguments have to be parsed; to get the 4th argument the 1st, 2nd and 3rd
    arguments must be evaluated. This is because each argument is not
    guaranteed to be only one element, it could be an expression which needs
    to be evaluated. Consider the following invocation of our Test-it macro
sB
        Test-it &cat "%test" "-var" "Goodbye World"

sA
    The 2nd argument is not cC"%test"cA as this is part of the first argument, the
    2nd argument is in fact the 4th element and the invocation will have the
    same effect except slower.


cEcESEE ALSO cEcA


    lsMacroNumericArguments(4)lmMacroNumericArgumentsle, lslmdefine-macro(2)le, lslmreplace-all-string(3)le, lslm!force(4)le.
! 4 MessageLineVaraibles
! 4 @mn
! 4 @mna
! 4 @ml
! 4 @mc
! 4 @mx
! 4 @mxa
cEcENAME cEcA


    @mn, @mna, @ml, @mc, @mx, @mxa - Message line input


cEcESYNOPSIS cEcA


    cD@mncA
    cD@mnacA
    cD@mlcA[cCfcA][cChcA] "cCpromptcA" ["cCdefaultcA"] ["cCinitialcA"] ["cCcom-listcA"] ["cCbuffer-namecA"]
    cD@mccA[cCfcA] cCpromptcA [cCvalid-listcA] [cChelp-stringcA]
    cD@mxcA "cCcommand-linecA"
    cD@mxacA "cCcommand-linecA"


cEcEDESCRIPTION cEcA


    The cDMessage Line VariablescA provide a method to prompt the user for an
    input returning the data to the caller. The cD@mncA variable cause MicroEmacs
    to input data from the user in the default way for that command's
    argument, i.e. the normal prompt with the normal history and completion
    etc. Similarly cD@mnacA causes MicroEmacs to input the current argument and
    any subsequent arguments in the default way.

    The cD@mlcA variable can be used to get a string (or Line) of text from the
    user using the message-line in a very flexible way. The first optional
    flag cDfcA is a bitwise flag where each bit has the following meaning

    cG0x01cA
        The cCdefaultcA value will be specified and this will be returned by
        default.

    cG0x02cA
        The cCinitialcA value will be specified and this will be initial value
        given on the input line.

    cG0x04cA
        Auto-complete using the initial value, usually used with bit cG0x02cA.

    cG0x08cA
        Hide the input string, the characters in the current input string are
        all displayed as cG'*'cAs.

    If no value is specified then default value is 0 and cDhcA can not be
    specified. The cCdefaultcA value is returned when the user enters an empty
    string. If the cCinitialcA string is specified the the input buffer will be
    initialized to the given string instead of and empty one.

    The flag cDhcA specifies what type of data is to be entered, this specifies
    the history to be used and the semantics allowed, cDhcA can have the following
    values

        cG0cA For a general string input using the general history.
        cG1cA For an absolute file name, with completion and history.
        cG2cA For a MicroEmacs 2009 buffer name, with completion and history.
        cG3cA For a MicroEmacs 2009 command name, with completion and history.
        cG4cA For a file name, with completion and history.
        cG5cA For a search string, with history.
        cG6cA For a MicroEmacs 2009 mode name, with completion and history.
        cG7cA For a MicroEmacs 2009 variable name, with completion and history.
        cG8cA For a general string using no history.
        cG9cA For a user supplied completion list (cGcom-listcA).
        cGacA For a user supplied completion list (cGbuffer-namecA).

    A default value of 0 is used if no value is specified. At first glance
    type 1 and 4 appear to be the same. They differ only when a non absolute
    file name is entered, such as "foobar". Type 1 will turn this into an
    absolute path, i.e. if the current directory is "cG/tmpcA" then it will return
    "cG/tmp/foobarcA". Type 4 however will return just "foobar", this is
    particularly useful with the lslm&find(4)le function to then find the file
    "foobar".

    When a value of cG9cA is used the argument cCcom-listcA must be given which
    specifies a list of completion values in the form of a MicroEmacs list
    (see help on lslm&lget(4)le for further information on lists). The user may
    enter another value which is not in the list, which will be returned.

    Alternatively a completion list may be given in the form of a buffer using
    a value of cGacA. The argument cCbuffer-namecA must be given to specify the buffer
    name from which to extract the completion list; each line of the buffer is
    taken as a completion value. This option is particularly useful for large
    completion lists as there is no size restrictions.

    The cD@mccA variable can be used to get a single character from the user using
    the message-line. The optional flag cDfcA is a bitwise flag where each bit has
    the following meaning

    cG0x01cA
        The cCvalid-listcA specifies all valid letters.

    cG0x02cA
        Quote the typed character, this allows keys such as 'cGC-gcA' which is
        bound to the abort command to be entered.

    cG0x04cA
        A cChelp-stringcA is given which will be displayed if the user presses
        'cG?cA'.

    The default value for cDfcA is 0. When cD@mccA is used, the user is prompted, with
    the given prompt, for a single character. If a cCvalid-listcA is specified
    then only a specified valid character or an error can be returned. For
    example, a yes/no prompt can be implemented by the following
sB
        !if &iseq @mc1 "Are you bored (yn) ? " "yYnN" "y"
            save-buffers-exit-emacs
        !endif

sA
    By using the lslm&isequal(4)le operator a return of "Y" or "y" will match with
    "y". However, there are two problems with this, firstly if the user aborts
    by pressing 'cGC-gcA' a macro error will be generated because the cD&iseqcA
    operator failed to get 2 arguments. The second problem is that the meaning
    of "cG(yn)cA" may not be obvious to all users so a help string should be
    supplied. To address these 2 issues the following should be used in
    preference:
sB
        set-variable #l0 @mc5 "Are you bored (?yn) ? " "yYnN" "(Y)es, (N)no, (C-g)Abort ? "
        !if &iseq #l0 "y"
            save-buffers-exit-emacs
        !endif

sA
    When the cD@mxcA variable is used MicroEmacs sets the system variable
    lslm$result(5)le to the input prompt, it will then execute the given
    cGcommand-linecA. If this command aborts then so does the calling command, if
    it succeeds then the input value is taken from the cD$resultcA variable.
    Similarly cD@mxacA causes MicroEmacs to get the current and any subsequent
    arguments in this way.

    These variables are useful when trying to use existing commands in a
    different way, such as trying to provide a GUI to an existing command. See
    the cDdelete-buffercA example below.


cEcEEXAMPLE cEcA


    The following example can be used to prompt the user to save any buffer
    changes, the use of cD@mnacA ensures the user will be prompted as usual
    regardless of the number of buffers changed:
sB
        save-some-buffers @mna

sA
    The following example sets cG%languagecA to a language supplied by the user
    from a given list, giving the current setting as a default
sB
        set-variable %languages "|American|British|French|Spanish|"
        set-variable %language "American"

        set-variable %language @ml19 "Language" %language %languages

sA
    The following example is taken from cGdiff-changescA in tools.emf, it uses cD@mccA
    to prompt the user to save the buffer before continuing:-
sB
        define-macro diff-changes
            !if &seq $buffer-fname ""
                ml-write "[Current buffer has no file name]"
                !abort
            !endif
            !if &bmod "edit"
                set-variable #l0 @mc5 "Save buffer first (?yn) ? " "nNyY" "(Y)es, (N)o, (C-g)Abort ? "
                !if &iseq #l0 "y"
                    save-buffer
                !endif
            !endif
                .
                .

sA
    Note that the input is case insensitive. The following version would not
    work as the user may expect when the buffer has not been edited:
sB
                .
                .
            !if &and &bmod "edit" &iseq @mc1 "Save buffer first (?yn) ? " "nNyY" "y"
                save-buffer
                .
                .

sA
    Unlike cDCcA and other similar languages MicroEmacs macro language always
    evaluates both cD&andcA arguments. This means that the user will be prompted
    to save the buffer regardless of whether the buffer has been edited.

    The cD@mxcA variables are useful when using existing commands in a new
    environment. For example, consider providing a GUI for the
    lslmdelete-buffer(2)le command, when executed the calling GUI may not be aware
    that changes could be lost or a process may still be active. These
    variables can be used as a call back mechanism to handle this problem:
sB
        define-macro osd-delete-buffer-callback
            !if &sin "Discard changes" $result
                2 osd-xdialog "Delete Buffer" "  Dicard changes?  " 2 10 6 "&Yes" "&No"
                set-variable $result &cond &equ $result 1 "y" "n"
            !elif &sin "Kill active process" $result
                2 osd-xdialog "Delete Buffer" "  Kill active process?  " 2 10 6 "&Yes" "&No"
                set-variable $result &cond &equ $result 1 "y" "n"
            !else
                1000 ml-write &spr "[Unknown prompt %s]" $result
                !abort
            !endif
        !emacro

        define-macro osd-delete-buffer
            .
            . set #l0 to buffer name to be deleted
            .
            delete-buffer #l0 @mxa osd-delete-buffer-callback
        !emacro

sA

cEcESEE ALSO cEcA


    lslmdefine-macro(2)le.
! 4 CurrentBufferVariables
! 4 @wc
! 4 @wl
cEcENAME cEcA


    @wc, @wl - Extract characters from the current buffer


cEcESYNOPSIS cEcA


    cD@wlcA
    cD@wccA


cEcEDESCRIPTION cEcA


    Buffer variables allow text to be taken from the current buffer and placed
    into a variable. Two types of extraction are provided cD@wlcA provides a line
    extraction method, cD@wccA provides a character extraction method.

    For example, if the current buffer contains the following text:

        Richmond
        Lafayette
        <*>Bloomington                (where <*> is the current point)
        Indianapolis
        Gary
        =* me (BE..) == rigel2 == (c:/data/rigel2.txt) ===================


    The cD@wlcA variable allows text from the current buffer to be accessed, a
    command such as:-
sB
        set-variable %line @wl

sA
    would start at the current point in the current buffer and grab all the
    text up to the end of that line and pass that back. Then it would advance
    the point to the beginning of the next line. Thus, after the lsset-variable(2)lmset-variablele
    command executes, the string "cGBloomingtoncA" is placed in the variable cD%linecA
    and the buffer rigel2 now looks like this:

        Richmond
        Lafayette
        Bloomington
        <*>Indianapolis               (where <*> is the current point)
        Gary
        =* me (BE..) == rigel2 == (c:/data/rigel2.txt) ===================


    The buffer command cD@wccA gets the current character in the buffer, it does
    not change the buffer position. It is important to stress that the cursor
    position is not modified, in general a macro will interrogate the
    character under the cursor and then affect the buffer (i.e. by moving the
    cursor, deleting the character etc.) dependent upon the value of the
    character returned.

    Assignment of the variables causes the buffer contents to be modified,
    deleting the pervious contents and setting the new value. This can be
    useful in certain situations but should be performed with care.


cEcEEXAMPLE cEcA


    The cD@wccA variable provides the most useful mechanism to modify the current
    buffer. The following example is a macro called cDsuper-deletecA which is
    bound to cG<CTRL-del>cA. The macro deletes characters under the cursor in
    blocks. If a white space character is under the cursor then all characters
    up until the next non-white space character are deleted. If a non-white
    space character is under the cursor then all non-white space characters up
    until the next white space character are deleted, then the white space is
    deleted. White space in this context is a cGSPACEcA, cGtabcA or cGCRcA character.
sB
        ;
        ;---    Macro to delete the white space, or if an a word all of the
        ;       word until the next word is reached.
        ;
        define-macro super-delete
            !while &not &sin @wc " \t\n"
                forward-delete-char
            !done
            !repeat
                forward-delete-char
            !until &or &seq @wc "" &not &sin @wc " \t\n"
            !return
        !emacro

        global-bind-key super-delete "C-delete"

sA

cEcESEE ALSO cEcA


    lslmdefine-macro(2)le.
! 4 CommandVariables
! 4 @clk
! 4 @cl
! 4 @cck
! 4 @cc
! 4 @cgk
! 4 @cg
! 4 @cqk
! 4 @cq
cEcENAME cEcA


    @clk, @cl - Last key or command name
    @cck, @cc - Current key or command name
    @cgk, @cg - Get a key or command name from the user
    @cqk, @cq - Get a quoted key or command name from the user


cEcESYNOPSIS cEcA


    cD@clkcA
    cD@clcA
    cD@cckcA
    cD@cccA
    cD@cgkcA
    cD@cgcA
    cD@cqkcA
    cD@cqcA


cEcEDESCRIPTION cEcA


    The Command Variables allow macros to obtain MicroEmacs 2009 input
    commands and keystrokes from the user. The general format of the command
    is:-

        cD@ccAcCicA[cDkcA]

    Where,

    cCicA
        Determines the source of the input as follows:-

        cDlcA
            The last input entered.

        cDccA
            The current input entered.

        cDqcA
            Provides a low level character input mechanism, obtaining a single
            raw character input from the user. The input fetch does not
            interact with the message line and the user is NOT prompted for
            input (use lslmml-write(2)le to create your own message). cD@cqcA is very
            low level, it is generally preferable to use cD@cgcA which provides a
            more intelligent binding.

        cDgcA
            Like cD@cqcA, cD@cgcA[cDkcA] gets a single character input, however if the
            input is bound to a function then the function name is returned
            instead of the character e.g. if cG^FcA or cG<left-arrow>cA is depressed
            then cDforward-charcA is returned. This has distinct advantages over
            cD@cqcA as the binding becomes device independent and executes on all
            platforms. In addition, it honors the users bindings, however
            bizarre.

    cDkcA
        When, omitted command input is returned to the caller (i.e. the name
        of the command, such as "cGforward-charcA"). When present, the raw
        keystroke is returned to the caller, i.e. "cG^FcA (control-F).

    The cD@clcA, cD@clkcA, cD@cccA and cD@cckcA variables can also be set, this feature can be
    used by macros to change the command history. While setting the current
    command is limited in use, setting the last command can be immensely
    useful, consider the following macro code:-
sB
        kill-line
        forward-line
        set-variable @cl kill-line
        kill-line

sA
    Without the setting of the cD@clcA variable, the current kill buffer will
    contain only the last line. But the setting of cD@clcA to kill-line fools
    MicroEmacs into thinking the last command was a kill command so the last
    kill line as appended to the current yank buffer, i.e. the kill buffer
    will have both lines in it.

    This feature can be used for any command whose effect depends on the
    previous command. Such commands include lslmforward-line(2)le, lslmkill-region(2)le,
    lslmreyank(2)le and lslmundo(2)le. This feature should not be abused as unexpected
    things may happen.


cESummary cA


    cD@clcA
        Get or set the last command.

    cD@clkcA
        Get or set the last key stroke.

    cD@cccA
        Get or set the current command.

    cD@cckcA
        Get or set the current keystroke.

    cD@cgcA
        Get a command name from the user.

    cD@cgkcA
        Get a keystroke from the user.

    cD@cqcA
        Get a quoted command name from the user.

    cD@cqkcA
        Get a quoted keystroke from the user.


cEcEEXAMPLE cEcA


    The following example shows how the cD@cccA and cD@clcA commands are used:-
sB
        define-macro current-last-command
            insert-string &spr "Last key [%s] name [%s]\n" @clk @cl
            insert-string &spr "Current key [%s] name [%s]\n" @cck @cc
        !emacro

sA
    Pressing the up key and then executing this macro using
    execute-named-command (esc x) will insert the lines:-

        Last key [up] name [backward-line]
        Current key [esc x] name [execute-named-command]


    cD@cgcA like cD@cqcA gets a single character input, however if the keyboard input
    is bound to a function then the function name is returned instead of the
    character e.g. if cG^FcA or cG<left-arrow>cA is depressed then cDforward-charcA is
    returned. This has distinct advantages over cD@cqcA as the binding becomes
    device independent and executes on all platforms, additionally it honors
    the users bindings, however bizarre.

    cD@cqcA provides a low level character input mechanism, obtaining a single raw
    character input from the user. This does not interact with the message
    line and the user is not prompted for input (use lslmml-write(2)le to create
    your own message). cD@cqcA is very low level, it is generally preferable to
    use cD@cgcA which provides a more intelligent binding.


cEcEEXAMPLE cEcA


    The following example is taken from cGdraw.emfcA which uses cD@cgcA to obtain
    cursor movements from the user. Note how the input from cD@cgcA (stored in
    variable cD%dw-commcA) is compared with the binding name rather than any
    keyboard characters.
sB
            !repeat
                0 screen-update
                !force set-variable #l0 @cg
                !if &seq #l0 "abort-command"
                    !if &iseq @mc1 "Really quit [y/n]? " "nNyY" "y"
                        find-buffer :dw-buf
                        0 delete-buffer "*draw*"
                        -1 buffer-mode "view"
                        !abort
                    !endif
                !elif &seq #l0 "newline"
                    .
                    .
                !elif &seq #l0 "forward-line"
                    1 draw-vert
                !elif &seq #l0 "backward-line"
                    -1 draw-vert
                !elif &seq #l0 "forward-char"
                    1 draw-horz
                !elif &seq #l0 "backward-char"
                    -1 draw-horz
                !elif &seq #l0 "osd"
                    .osd.draw-help osd
                !elif &set #l1 &sin #l0 "mdeu-="
                    !if &les #l1 5
                        set-variable :dw-mode &sub #l1 1
                        set-variable :dw-modes #l0
                        draw-setmode-line
                    !elif &sin #l0 "-="
                        set-variable :dw-char #l0
                        draw-setmode-line
                    !endif
                !else
                    ml-write "[Invalid command]"
                !endif
            !until 0

sA

cEcESEE ALSO cEcA


    lslm@wc(4)le, lslm&kbind(4)le, lslmdefine-macro(2)le.
! 4 Variables
! 4 RegisterVariables
! 4 CmdVariables
! 4 BufferVariables
!24 #g0..#g9 - Global register variables
!24 #p0..#p9 - Parent register variables
!24 #l0..#l9 - Local register variables
cEcENAME cEcA


    Variables - Macro variables


cEcESYNOPSIS cEcA


    cD#cAcCtncA
    cD$cAcCvariableNamecA
    cD%cAcCvariableNamecA
    cD.cAcCvariableNamecA
    cD.cAcCcommandNamecAcD.cAcCvariableNamecA
    cD:cAcCvariableNamecA
    cD:cAcCbufferNamecAcD:cAcCvariableNamecA


cEcEDESCRIPTION cEcA


    Variables are part of MicroEmacs macro language and may be used wherever
    an argument is required. The variable space comprises:-

        cD#cA - Register Variable
        cD$cA - System Variable
        cD%cA - Global Variable
        cD.cA - Command Variable
        cD:cA - Buffer Variable

    All variables hold string information, the interpretation of the string
    (numeric, string or boolean) is determined when the variable is used
    within the context of the command. There are five types of variable,
    cDRegistercA cDVariablescA (prefixed with a hash cD#cA), cDSystem VariablescA (prefixed
    with a dollar cD$cA), cDGlobal VariablescA (prefixed with a percentage cD%cA), cDBuffer
    VariablescA (prefixed with a colon cD:cA) and cDCommand VariablescA (prefixed with a
    period cD.cA).


cERegister Variables cA


    Register Variables provide a set of 10 prefixed global (cD#g0cA .. cD#g9cA),
    parent (cD#p0cA .. cD#p9cA) and local (cD#l0cA .. cD#l9cA) register variables. The
    interpreted decode time of the register variables is significantly smaller
    than other variable types as no name space search is performed.

    Register variables are assigned using lslmset-variable(2)le, their value may be
    queried with lslmdescribe-variable(2)le, unlike Global Buffer or Command
    variables they cannot be deleted.

    Register variables are implemented like a stack, where the global
    registers are the top of the stack and every executing macro gets its own
    set of resister variables (cD#l?cA). The macro also has access to the global
    registers (cD#g?cA) and its calling, or parent macro (cD#p?cA). If the macro has
    no parent macro then the global registers are also the parent registers.
    Outside macros, i.e. using cDset-variablecA manually, the global parent and
    local registers are the same.

    Register variables are typically used for retaining short term state,
    computation steps etc. As with the User Variables, the global register
    variables are global and care must be taken with nested macro invocations
    to ensure that the register usage does not conflict.


cESystem Variables cA


    MicroEmacs defines many System variables which are used to configure many
    aspects of the editors environment. The functionality of each system
    variable has been documented, they can be set and described but cannot be
    unset. If the user attempts to set or describe a non-existent MicroEmacs
    system variable (e.g. cD$PATHcA) the system environment is used instead,
    allowing the user to query and alter the system environment.


cEGlobal, Command and Buffer Variables cA


    The Global variables are denoted by an initial cD%cA character followed by the
    name of the variable cCvariableNamecA. The cCvariableNamecA may be any ASCII
    character string up to 127 characters in length, all characters of the
    name are significant. Shorter names are preferred as this speeds up
    execution. Global Variables exist in a global context which all macros
    have access to.

    Command variables exist within the scope of a command, they are denoted by
    the period (cD.cA) character. They can be accessed by one of two forms, either
    cD.cAcCvariableNamecA or cD.cAcCcommandNamecAcD.cAcCvariableNamecA. The first form, without the
    command name, assumes the scope to be the current command, as such may
    only be used to access internal variables. The second form qualifies the
    scope by specifying the command, this form is much more versatile and may
    be used to access any command variable from any other command, e.g.
sB
        define-macro foo
            set-variable .foo "Hello world"
            1000 ml-write &cat "foo1: " .foo
            1000 ml-write &cat "foo2: " .foo.foo
        !emacro
        define-macro bar
            foo
            1000 ml-write &cat "bar1: " .foo
            1000 ml-write &cat "bar2: " .foo.foo
        !emacro

        bar

sA
    When cDbarcA is executed the following messages may be observed:-

        foo1: Hello World
        foo2: Hello World
        bar1: ERROR
        bar2: Hello World


    When a macro file or buffer is executed, they are executed within their
    own scope so local scope command variables (form 1) may be created and
    used in that scope. Any such variables created are automatically deleted
    at the end of execution. For example, the default color scheme generator
    macro file, cGschemed.emfcA, creates command variables for the created colors
    to aid readability:-
sB
        add-color &set .green     3 0   200 0
        a0dd-color &set .lgreen   11 0   255 0

        ...

        add-color-scheme .scheme.cardback   .lgreen   .green   .lgreen ...

sA
    The variables only exist as a file or buffer is being executed, they are
    not accessible by another command once the command or buffer execution has
    finished.

    Buffer variables are similar to Command variable in function and behaviour
    except that their scope is of a buffer and are denoted by the colon (cD:cA)
    character. Access can be in one of two forms, either cD:cAcCvariableNamecA where
    the scope is assumed to be the current buffer or cD:cAcCbufferNamecAcD:cAcCvariableNamecA,
    where the scope is explicitly given allowing access to any buffer
    variable, e.g.
sB
        find-buffer "foo"
        set-variable :foo "Hello world"
        find-buffer "bar"
        set-variable :bar "Hello world"
        1000 ml-write &cat ":foo     " :foo
        1000 ml-write &cat ":foo:foo " :foo:foo
        1000 ml-write &cat ":bar     " :bar
        1000 ml-write &cat ":bar:bar " :bar:bar

sA
    When the above is executed the following messages may be observed:-

        :foo     ERROR
        :foo:foo Hello World
        :bar     Hello World
        :bar:bar Hello World


    Global, Buffer and Command variables are automatically defined when they
    are used. A variable is assigned with lslmset-variable(2)le and may be
    subsequently deleted with lslmunset-variable(2)le. The current assignment of a
    variable may be queried from the command line using lslmdescribe-variable(2)le.
    e.g.
sB
        define-macro foo
        !emacro
        set-variable %foo "Some string"
        set-variable :bar "Some string"
        set-variable .foo.bar "Some string"

        ...

        ml-write &spr "%s %s %s" %foo :bar .foo.bar

        ...

        unset-variable :bar
        unset-variable %foo
        unset-variable .foo.bar

sA
    An undefined variable returns the string cGERRORcA, this known state is used
    to advantage with the lshilight(2)lmhilightingle initialization, e.g.
sB
        !if &sequal .hilight.c "ERROR"
            set-variable .hilight.c &pinc .hilight.next 1
        !endif
        ;
        ; Hi-light C Mode
        ;
        0 hilight .hilight.c  2 50             $global-scheme

sA
    In this case the variable cD.hilight.ccA is explicitly tested for definition,
    if it is undefined then it is assigned a new value.

    Conventionally, names are separated with a minus sign character (cD-cA) e.g.
    cGfoo-barcA. It is strongly advised that the name space is kept reasonably
    clean, since there are no restrictions on the number of macros that may be
    defined, problems will arise if different macros use the same variables in
    different contexts. Where possible, Command or Buffer Variables are
    preferable to Global Variables since they have no side effects on other
    macros or buffers. It is advised that all variable names associated with a
    particular macro set are prefixed with short identifier to make the
    variable name space unique. e.g. the cDMetriscA macro prefixes all variables
    with cD:met-cA; the cDdrawcA macro uses cD:dw-cA, the cDpatiencecA macro cD:pat-cA etc.

    Macro writers should endeavor to use the minimal number of variables,
    obviously the more variables that exist in the system, the greater the
    lookup time to find a variable. Use Register Variables in preference to
    Command, Global or Buffer variables for intimidate computation steps,
    temporary state etc.

    Note that Buffer Variables are automatically deleted when the buffer is
    deleted.


cEcEEXAMPLE cEcA


    The following example is the macro to convert tabs to spaces, it is shown
    in two forms, with User Variables and with Register Variables, the
    register variable implementation is obviously preferable since no new
    variables have been defined.


cEUser Variable Implementation cA

sB

        ;
        ; tabs-to-spaces.
        ; Convert all of the tabs to spaces.
        define-macro tabs-to-spaces
            set-variable %curline $window-line        ; Remember line
            beginning-of-buffer
            !force search-forward "\t"
            !while $status
                3 drop-history
                set-variable %curcol $window-acol
                backward-delete-char
                &sub %curcol $window-acol insert-space
                !force search-forward "\t"
            !done
            3 drop-history
            goto-line %curline
            update-screen
            ml-write "Converted tabs!"
        !emacro

sA

cERegister Variable Implementation cA

sB

        ;
        ; tabs-to-spaces.
        ; Convert all of the tabs to spaces.
        define-macro tabs-to-spaces
            ; Remember line
            set-variable #l0 $window-line
            beginning-of-buffer
            !force search-forward "\t"
            !while $status
                set-variable #l1 $window-acol
                backward-delete-char
                &sub #l1 $window-acol insert-space
                !force search-forward "\t"
            !done
            goto-line #l0
            screen-update
            ml-write "[Converted tabs]"
        !emacro

sA

cEcESEE ALSO cEcA


    lslm@wc(4)le, lslmdefine-macro(2)le, lslmdescribe-variable(2)le, lslmset-variable(2)le,
    lslmunset-variable(2)le.
! 4 MacroNumericArguments
cEcENAME cEcA


    @#, @? - Macro numeric arguments


cEcESYNOPSIS cEcA


    cD@#cA - The numerical argument to a macro
    cD@?cA - The truth of the numerical argument to a macro


cEcEDESCRIPTION cEcA


    All built-in commands and macros are invoked with a numerical argument.
    The argument is obtained from either the command line when the user
    invokes a command line such as:

        cDesc 5 esc x forward-charcA

    where the argument is entered after lsprefix(2)lmprefix 1le (cDesccA). In this case, causing
    the cursor to be moved forward 5 characters. Within a macro file the same
    operation is defined as:-

        cD5 forward-charcA

    In both cases the numerical argument 5 is passed to the command requesting
    that the resultant operation is performed 5 times in succession before
    returning. The command itself is invoked once, it is the responsibility of
    the command to iterate if requested.

    The command determines how the numerical argument is interpreted, in the
    case of lsspell-buffer(3)lmspell-wordle the argument identifies the type of word that is being
    spelled and NOT the number of words to spell.

    The invocation of named macros operate in the same way, the macro may use
    the variables cD@?cA and cD@#cA to determine the status of the numerical argument
    passed to it. The variables are interpreted as follows:

    cD@?cA
        A logical value defined as cGTRUEcA (1) if a numerical argument has been
        specified, otherwise cGFALSEcA (0).

    cD@#cA
        A signed integer value of the supplied numeric argument. If no
        argument is supplied (i.e. cD@?cA==cGFALSEcA) then cD@#cA is set to 1.

    The cD@?cA and cD@#cA are only valid for the current macro invocation. Other
    macros or commands that are invoked have their own values of cD@?cA and cD@#cA.


cEcEEXAMPLE cEcA


    Consider the following example, which sorts lines into alphabetical order
    using the lslmsort-lines(2)le function. A new command cDsort-lines-ignore-casecA is
    created using a macro to sort lines case insensitively regardless of the
    current buffer mode. The command cDsort-linescA takes an optional argument
    which determines which column should be used to perform the sort.
sB
        ;
        ; sort-lines-ignore-case
        ; Sort lines case insensitively regardless of the current 'exact' mode
        ; setting.
        define-macro sort-lines-ignore-case
            set-variable #l0 &bmod exact
            -1 buffer-mode "exact"
            !if @?
                @# sort-lines
            !else
                sort-lines
            !endif
            &cond #l0 1 -1 buffer-mode "exact"
        !emacro

sA
    cD@?cA is used to test the presence of the argument, if it is false cDsort-linescA
    is invoked without an argument. When true the numeric argument is
    propagated e.g. cD@# sort-linescA.

    This particular macro highlights an important consideration when passing
    the numerical argument to other functions, had the macro been implemented
    as:
sB
        ; INCORRECT IMPLEMENTATION
        define-macro sort-lines-ignore-case
            set-variable #l0 &bmod exact
            -1 buffer-mode "exact"
            @# sort-lines
            &cond #l0 1 -1 buffer-mode "exact"
        !emacro

sA
    then when cDsort-lines-ignore-casecA is invoked with no arguments cD@#cA is
    defined as 1, this is would be incorrectly propagated to cDsort-linescA
    causing it to sort on column 1 rather than column 0 as expected.


cEcESEE ALSO cEcA


    lsMacroArguments(4)lmMacroArgumentsle, lslmdefine-macro(2)le.
! 4 @y
cEcENAME cEcA


    @y - Yank buffer variable


cEcESYNOPSIS cEcA


    cD@ycA - Yank buffer variable


cEcEDESCRIPTION cEcA


    The cCYank Buffer VariablecA cD@ycA retrieves the current lslmyank(2)le string from the
    kill buffer and returns it to the caller.

    The cD@ycA variable may be set to change the kill ring buffer.

    The cCYank Buffer VariablecA may be specified with a numeric qualifier to
    access one of the historical yank buffers cD@y0cA to cD@y15cA to directly extract
    text from the kill-ring.


cEcEEXAMPLE cEcA


    The current contents of the yank buffer can be obtained using cD@ycA, so to
    set variable cG#l1cA to the current or last word if the cursor is not in a
    word, simply use:
sB
            forward-char
            backward-word
            set-mark
            forward-word
            copy-region
            set-variable #l1 @y

sA

cEcESEE ALSO cEcA


    lslmyank(2)le, lsMacroArguments(4)lmMacroArgumentsle, lsMacroNumericArguments(4)lmMacroNumericArgumentsle, lslmdefine-macro(2)le.
!44 &band
! 4 &bor
!44 &bxor
!44 &bnot
cEcENAME cEcA


    &band, &bor, &bnot, &bxor - Bitwise macro operators


cEcESYNOPSIS cEcA


    cD&bandcA cCnum1cA cCnum2cA
    cD&borcA cCnum1cA cCnum2cA
    cD&bxorcA cCnum1cA cCnum2cA
    cD&bnotcA cCnumcA


cEcEDESCRIPTION cEcA


    The bitwise operators perform bit operations on numeric values returning a
    numerical result of the operation.

    The functions may all be abbreviated to their three letter abbreviation
    (i.e. cD&bandcA may be expressed as cD&bancA). In all cases the first argument is
    completely evaluated before the second argument.

    cD&band cAcCnum1cA cCnum2cA
        Bitwise AND of cCnum1cA and cCnum2cA i.e. cCnum1cA & cCnum2cA.

    cD&borcA cCnum1cA cCnum2cA
        Bitwise (inclusive) OR of cCnum1cA and cCnum2cA i.e. cCnum1cA | cCnum2cA.

    cD&bxorcA cCnum1cA cCnum2cA
        Bitwise (exclusive OR) XOR of cCnum1cA and cCnum2cA i.e. cCnum1cA ^ cCnum2cA.

    cD&notcA cCnumcA
        Bitwise NOT operator of cCnumcA, inverts the state of all bits i.e. ~cCnumcA.

    Evaluation of the bitwise operators are left to right, the leftmost
    argument is fully evaluated before the next argument. The operator
    ordering is prefix notation (see lslm&add(4)le for an example of prefix
    ordering).


cEcESEE ALSO cEcA


    lsIntroduction to Variable FunctionslmVariable Functionsle, lslm&add(4)le, lslm&and(4)le, lslm&negate(4)le, lslm&or(4)le.
!44 &cond
cEcENAME cEcA


    &cond - Conditional expression operator


cEcESYNOPSIS cEcA


    cD&condcA cClogcA cCexpr1cA cCexpr2cA


cEcEDESCRIPTION cEcA


    The conditional expression cD&condcA provides an alternative way to write
    ls!if(4)lm!if-!else-!endifle constructs, e.g.:-
sB
        !if &gre %a %b
            set-variable %z %a
        !else
            set-variable %z %b
        !endif

sA
    may be replaced with a conditional expression, breaking down the
    components then

        cClogcA is cD&gre %a %bcA
        cCexpr1cA is cD%acA
        cCexpr2cA is cD%bcA

    rewriting the expression we get:
sB
        set-variable %z &cond &gre %a %b %a %b

sA
    This is far more concise, albeit a little less readable, but does improve
    the performance of macros as there is less information to interpret.

    The cD&condcA operator accepts three fields, ALL fields are evaluated although
    only one of the results cCexpr1cA or cCexpr2cA is used. The cClogcA field is a logical
    value, if it is non-zero (cGTRUEcA) then the result of the cCexpr1cA evaluation is
    used, otherwise the result of cCexpr2cA is used.

    It should be noted that the conditional expression may be used in any
    construct i.e. lslm&add(4)le, lslm&cat(4)le, etc. the cCexprcA arguments may be strings,
    numbers or booleans the resultant value of the cCexprcA arguments is simply
    returned to the calling expression.


cEcESEE ALSO cEcA


    lsIntroduction to Variable FunctionslmVariable Functionsle, lslm&add(4)le, lslm&great(4)le.
! 4 &set
cEcENAME cEcA


    &set - In-line macro variable assignment


cEcESYNOPSIS cEcA


    cD&setcA cC<var>cA cC<expr>cA


cEcEDESCRIPTION cEcA


    cD&setcA performs an in-line macro variable assignment assigning a variable
    cC<var>cA the value of the expression cC<expr>cA, returning the evaluated result
    to the caller. cC<expr>cA may be numeric, boolean or a string expression.

    cD&setcA is typically used for defining (and simultaneously using) indices
    e.g. as with lslmadd-color(2)le or lslmadd-color-scheme(2)le. This is a short-hand of
    lslmset-variable(2)le.


cEcEEXAMPLE cEcA


    The following example usescD&setcA to define new colors (see cGcolor.emfcA):
sB
        ; Standard colors
        add-color &set %white     0 200 200 200
        add-color &set %black     1 0   0   0
        add-color &set %red       2 200 0   0
        add-color &set %green     3 0   200 0
        add-color &set %yellow    4 200 200 0
        add-color &set %blue      5 0   0   200
        add-color &set %magenta   6 200 0   200
        add-color &set %cyan      7 0   200 200

sA

cEcESEE ALSO cEcA


    lsIntroduction to Variable FunctionslmVariable Functionsle, lslm&inc(4)le, lslmset-variable(2)le.
!44 &find
!44 &which
cEcENAME cEcA


|&find
    &find - Find a file on the search path
&which

    &which - Find a program on the path
$a


cEcESYNOPSIS cEcA


    cD&findcA cC<basename>cA cC<extension>cA
    cD&whichcA cC<progname>cA


cEcEDESCRIPTION cEcA


    cD&findcA searches for a named file cC<basename><extension>cA on the MicroEmacs
    2009 search path defined by the variable lslm$search-path(5)le, initialized by
    the system of from the the environment variables lslm$MEINSTALLPATH(5)le etc.

    Each path component defined in cD$search-pathcA is prepended to the
    constructed file name and it's existence is tested. If the file exists,
    then the FULL path name of the file is returned to the caller, otherwise
    cGERRORcA.

    cC<basename>cA
        The base name of the file, excluding any extension.

    cC<extension>cA
        The extension of the file name, this must be specified with the
        extension delimiter, typically dot ('cG.cA'). A cGNULLcA string (e.g. 'cG""cA')
        may be specified if no extension is required.

    cD&whichcA searches for the given executable program cC<progname>cA on the system
    program search path defined the the environment variable cD$PATHcA.


cEcEUSAGE cEcA


    cD&findcA is typically used with lslminsert-file(2)le and lslmfind-file(2)le within macro
    scripts, and is used to locate user specific files.


cEcEEXAMPLE cEcA


    The following example uses cD&findcA to locate the uses 'C' template file.
    Given a cD$search-pathcA setting of cG/usr/bob/emacs:/usr/local/microemacscA:-
sB
        insert-file &find "c" ".etf"

sA
    Would insert the file cG/usr/bob/emacs/c.etfcA if it existed, else the file
    cG/usr/local/microemacs/c.etfcA if it exists.


cEcESEE ALSO cEcA


    lsIntroduction to Variable FunctionslmVariable Functionsle, lslmfind-file(2)le, lslminsert-file(2)le, lslm$search-path(5)le,
    lslm$MEINSTALLPATH(5)le, lslm$MEUSERPATH(5)le.
!44 !nmacro
cEcENAME cEcA


    !nmacro - Execute line as if not in a macro


cEcESYNOPSIS cEcA


    cD!nmacrocA cCcommandcA


cEcEDESCRIPTION cEcA


    cD!nmacrocA causes cCcommandcA to be executed as if it were initiated from the
    command line by the user, rather than from the macro context. When
    MicroEmacs 2009 executes a macro, by default any input the command
    requires is expected on the same line immediately following the command.
    If a line is preceded by a cD!nmacrocA (or cD!nmacA) directive, the command is
    executed as if it was invoked from the command line by the user, as such,
    the rest of the line is ignored and all input is obtained directly from
    the user, as per normal command interaction.


cEcEEXAMPLE cEcA


    The following example is taken from macro file cGmeme3_8.emfcA and shows how
    to add a buffer mode.
sB
        ; Add a buffer mode
        define-macro add-mode
            ; Has the require mode been given as an argument, if so add it
            !force 1 buffer-mode @1
            !if &not $status
                ; No - use 1 buffer-mode to add a mode
                !nma 1 buffer-mode
            !endif
        !emacro

sA
    The first line checks that the mode to add has not already been given as a
    macro argument, e.g. by executing the following line
sB
        buffer-add-mode "view"

sA
    If this line fails then the argument was not specified and must be
    obtained from the user as normal.


cEcENOTES cEcA


    Individual arguments may be obtained from the user using the lslm@mn(4)le
    interactive macro variables.


cEcESEE ALSO cEcA


    lslm@mn(4)le.
!44 &cbind
!44 &kbind
!44 &nbind
cEcENAME cEcA


    &cbind, &kbind, &nkind - Command/key binding operators


cEcESYNOPSIS cEcA


    cD&cbindcA cCkeycA
    cD&kbindcA cCncA cCcommandcA
    cD&nbindcA cCkeycA


cEcEDESCRIPTION cEcA


    cD&cbindcA returns the command bound to the given key sequence, cD&kbindcA can be
    abbreviated to cD&kbicA. If the key is not bound then cD&kbindcA returns the
    string "cCERRORcA".

    cD&nbindcA returns the numerical argument associated with the given key
    binding, cD&nbindcA can be abbreviated to cD&nbicA. If the key is not bound then
    cD&nbindcA returns the string "cCERRORcA", if the binding has no argument then an
    empty string (cG""cA) is returned.

    cD&kbindcA returns a key sequence bound to the given cCcommandcA with the given
    numerical argument cCncA. If no binding can be found then cD&kbindcA returns an
    empty string (cG""cA).


cEcEEXAMPLE cEcA


    The following example waits for the user to press a key, then prints what
    command the key is bound to.
sB
        ml-write "Enter key: "
        set-variable #l0 @cgk
        ml-write &spr "%s is bound to %s" #l0 &cbin #l0

sA

cEcENOTES cEcA


    In March 2001 cD&kbindcA was renamed cD&ckindcA and a new cD&nkindcA and cD&kbindcA added.


cEcESEE ALSO cEcA


    lsIntroduction to Variable FunctionslmVariable Functionsle, lslmglobal-bind-key(2)le.
!44 &stat
cEcENAME cEcA


    &stat - Retrieve a file statistic


cEcESYNOPSIS cEcA


    cD&statcA cC<stat>cA cC<filename>cA


cEcEDESCRIPTION cEcA


    cD&statcA returns the specified cC<stat>cA on the given cC<filename>cA. Valid cC<stat>cA
    values are:-

    cDacA
        Returns the absolute file name, corrects relative paths and symbolic
        links, i.e. on UNIX if the filename is a symbolic link it returns the
        file name the link points to (recursive), otherwise returns the file
        name.

    cDdcA
        Returns the file's modification time stamp as an integer, larger
        values indicate a later time.

    cDicA
        Returns information on the file in a ls&ldel(4)lmMicroEmacs listle formatted string.
        The fields within the list are defined as follows:

        1
            File location, which will be one of the following:

                F   File is an ftp URL file (see note).
                H   File is a http URL link (see note).
                L   File is a local file.


        2
            File type, which will be one of the following:

                D   File is a directory.
                H   File is a http URL link (no further information is known).
                L   File is a symbolic link (UNIX).
                N   File is an untouchable system file.
                R   File is a regular file.
                X   File does not exist.


            Note the information returned here is different to the 'cGtcA' flag
            below as the type of an ftp file is evaluated, i.e. cGDcA, cGRcA or cGXcA will
            be returned.

        3
            Symbolic file type, which will be the empty string unless the file
            type above is 'cGLcA' in which case it will be one of the following:

                D   File is a directory.
                L   File is a symbolic link (UNIX).
                N   File is an untouchable system file.
                R   File is a regular file.
                X   File does not exist.


        4
            File permissions or attributes which are returned as an integer
            value specific to the Operating System.

        5 and 6
            File size given as an upper and lower 32 bit integers for large
            file support, these values will be the empty string if the file
            size could not be determined.

        7
            File modification time given as "cGYYYYMMDDhhmmsscA", this field has
            not yet been implemented.

    cDmcA
        Returns the file's modification time stamp as a string, the format of
        the string is the same as lslm$time(5)le.

    cDrcA
        Returns a non-zero value if the user has permission to read the given
        file.

    cDscA
        Returns the size of the file in bytes.

    cDtcA
        Returns the type of the file, where values returned are

            X   File does not exist.
            R   File is a regular file.
            D   File is a directory.
            H   File is a http URL link (see note).
            F   File is an ftp URL file (see note).
            N   File is an untouchable system file.


        Note that a URL type is determined from the file name, e.g.
        http://..., and its existence is not verified.

    cDwcA
        Returns a non-zero value if the user has permission to write to the
        given file.

    cDxcA
        Returns a non-zero value if the user has permission to execute the
        given file.


cEcEEXAMPLE cEcA


    The following example is a macro which, given a file name, uses cD&statcA to
    check that file file is regular:
sB
        define-macro test-file
            !force set-variable #l0 @1
            !if &not $status
                set-variable #l0 @ml04 "File name"
            !endif
            !if &not &equ &stat "t" #l4 1
                ml-write &spr "[%s is not a regular file]" #l0
                !abort
            !endif
        !emacro

        test-file "foobar"

sA
    The macro can be passed a file name and aborts if the file is not regular,
    there by returning the state.

    The follow example checks that a file is not empty, this is used by
    cDmail-checkcA to test for any incoming mail.
sB
            !if &gre &stat "s" %incoming-mail-box
                ml-write "[You have new mail]"
            !endif

sA

cEcESEE ALSO cEcA


    lsIntroduction to Variable FunctionslmVariable Functionsle, lslmfind-file(2)le, lslm&bstat(4)le.
! 4 &reg
cEcENAME cEcA


    &reg - Retrieve a registry value (with default)


cEcESYNOPSIS cEcA


    cD&regcA cCrootcA cCdefaultcA


cEcEDESCRIPTION cEcA


    cD&regcA retrieves the value of a node defined by cCrootcA from the registry, this
    is an absolute path.

    The cCdefaultcA value is the value of the node to return if the registry node
    does not exist.


cEcEEXAMPLE cEcA


    The following example is taken from cGme.emfcA and uses the registry to
    retrieve some of the default configuration files:
sB
        ; Load in the color setup
        !force execute-file &reg &spr "/history/%s/color" $platform "color"
        ; execute company setup
        !if &not &seq &set #l0 &reg "/history/company" ""
            !force execute-file #l0
        !endif

sA

cEcESEE ALSO cEcA


    lslmcopy-registry(3)le, lslmdelete-registry(2)le, lslmfind-registry(2)le, lslmlist-registry(2)le,
    lslmmark-registry(2)le, lslmread-registry(2)le, lslmset-registry(2)le. lslmerf(8)le.
!44 &ldel
!44 &lfind
!44 &lget
!44 &linsert
!44 &lset
cEcENAME cEcA


    &ldel, &lfind, &lget, &linsert, &lset - List manipulation functions


cEcESYNOPSIS cEcA


    cD&ldelcA cClistcA cCindexcA
    cD&lfindcA cClistcA cCvaluecA
    cD&lgetcA cClistcA cCindexcA
    cD&linsertcA cClistcA cCindexcA cCvaluecA
    cD&lsetcA cClistcA cCindexcA cCvaluecA


cEcEDESCRIPTION cEcA


    The list manipulation functions perform operations on specially formatted
    strings called lists. A list is defined as:

        "|value1|value2|.....|valueN|"


    Where 'cG|cA' is the dividing character, this is not fixed to a 'cG|cA', but is
    defined by the first character of the string. Following are all valid
    lists.

        "cG|1|2|3|4|5|cA"
        "cGX1X2X3X4X5XcA"
        "cG\CAHello\CAWorld\CAcA"
        "cG??cA"

    The functions may all be abbreviated to their three letter abbreviation
    (i.e. cD&linsertcA may be expressed as cD&lincA). In all cases the first argument
    is completely evaluated before the second or third argument.

    cD&ldelcA cClistcA cCindexcA
        Creates a new list from deleting item cCindexcA from cClistcA. If cCindexcA is out
        of cClistcA's range (0 < index <= # items in list) then cClistcA is returned
        unchanged.

    cD&lfindcA cClistcA cCvaluecA
        Returns the index whose item is the same as cCvaluecA in cClistcA. If cCvaluecA is
        not found in cClistcA then "cG0cA" is returned.

    cD&lgetcA cClistcA cCindexcA
        Returns the value of item cCindexcA in cClistcA. If cCindexcA is out of cClistcA's
        range (0 < index <= # items in list) then an empty string is returned.

    cD&linsertcA cClistcA cCindexcA cCvaluecA
        Creates a new list from inserting cCvaluecA into cClistcA at point cCindexcA,
        thereby pushing item cCindexcA to cCindexcA+1 etc.

        If cCindexcA is cG0cA, cCvaluecA is inserted at the beginning of the list.

        If cCindexcA is cG-2cA, cCvaluecA is inserted alphabetically (case sensitively)
        into the list.

        If cCindexcA is cG-3cA, cCvaluecA is inserted alphabetically (case insensitively)
        into the list.

        Otherwise, if cCindexcA is cG-1cA or greater that the number of items in cClistcA
        then cCvaluecA is inserted at the end of the list.

    cD&lsetcA cClistcA cCindexcA cCvaluecA
        Creates a new list from setting cCindexcA of cClistcA to cCvaluecA. If cCindexcA is
        out of cClistcA's range (0 < index <= # items in list) then cD&lsetcA behaves
        like cD&linsertcA and inserts alphabetically or at the end of the list.


cEcEEXAMPLE cEcA


    The following example moves item 4 in a list to position 2:
sB
        set-variable #l0 &lget %list 4
        set-variable #l1 &ldel %list 4
        set-variable %list &lins #l1 2 #l0

sA
    The following example is taken from vm.emf, it firstly checks where the
    user has entered a vm command, if not then the key is execute as normal,
    otherwise the appropriate vm command is executed.
sB
        define-macro vm-input
            set-variable #l2 @cck
            set-variable #l3 @cc
            !if &not &set #l0 &lfi "|esc h|delete|space|return|A|a|C|c|....|z|" #l2
                !if &not &seq #l3 "ERROR"
                    execute-line &spr "!nma %s %s" &cond @? @# "" #l3
                    !return
                !endif
                ml-write &spr "[Key \"%s\" not bound - \"esc h\" to view help]" #l2
                !abort
            !endif
            set-variable #l1 &lget "|%osd-vm-help osd|vm-del-windows|scroll-down|....
                               ....vm-goto-list|vm-Archive-box|vm-archive-box|....
                               vm-cut-all-data|0 vm-extract-data|...|vm-forward|" #l0
            execute-line #l1
        !emacro

sA

cEcESEE ALSO cEcA


    lsIntroduction to Variable FunctionslmVariable Functionsle, lslm&mid(4)le, lslm&cat(4)le.
!44 &sequal
!44 &isequal
!44 &sless
!44 &sgreat
!44 &xsequal
!44 &xisequal
cEcENAME cEcA


    &seq, &iseq, &sle, &sgre, &xseq, &xiseq - String logical macro operators


cEcESYNOPSIS cEcA


    cD&sequalcA cCstr1cA cCstr2cA
    cD&isequalcA cCstr1cA cCstr2cA
    cD&slesscA cCstr1cA cCstr2cA
    cD&sgreatcA cCstr1cA cCstr2cA

    cD&xsequalcA cCstr1cA cCregexcA
    cD&xisequalcA cCstr1cA cCregexcA


cEcEDESCRIPTION cEcA


    The string logical testing operators perform string comparison tests,
    returning a boolean value of cGTRUEcA (1) or cGFALSEcA (0).

    The functions may all be shortened to their three letter abbreviation
    (i.e. cD&sequalcA may be expressed as cD&seqcA). In all cases the first argument
    is completely evaluated before the second argument. String logical
    operators include:-

    cD&sequalcA cCstr1cA cCstr2cA
        cGTRUEcA if the two strings cCstr1cA and cCstr2cA are the same. Abbreviated form
        of the function is cD&seqcA.

    cD&slesscA cCstr1cA cCstr2cA
        cGTRUEcA if string cCstr1cA alphabetically less than cCstr2cA. Abbreviated form of
        the function is cD&slecA.

    cD&sgreatcA cCstr1cA cCstr2cA
        cGTRUEcA if string cCstr1cA alphabetically larger than cCstr2cA. Abbreviated form
        of the function is cD&sgrcA.

    cD&isequalcA cCstr1cA cCstr2cA
        cGTRUEcA if the two strings cCstr1cA and cCstr2cA are the same ignoring letter
        case. Abbreviated form of the function is cD&isecA.

    cD&xsequalcA cCstr1cA cCregexcA
        cGTRUEcA if the string cCstr1cA matches the cCregexcA (case sensitive).
        Abbreviated form of the function is cD&xsecA. See lsRegularExpressions(2)lmRegular Expressionsle for
        information on the cCregexcA format.

    cD&xisequalcA cCstr1cA cCregexcA
        cGTRUEcA if the string cCstr1cA matches the cCregexcA (case insensitive).
        Abbreviated form of the function is cD&xiscA. See lsRegularExpressions(2)lmRegular Expressionsle for
        information on the cCregexcA format.

    Evaluation of the string logical operators are left to right, the leftmost
    argument is fully evaluated before the next argument. The operator
    ordering is prefix notation (see lslm&add(4)le for an example of prefix
    ordering).


cEcEEXAMPLE cEcA


    Test for variable lslm$buffer-bname(5)le is equal to cG*scratch*cA:
sB
        !if &seq $buffer-bname "*scratch*"
            ...

sA
    The following example tests a character is in the range cGacA-cGzcA:
sB
        !if &not &and &sle %c "a" &sgr %c "z"
            ...

sA
    The following example inserts the string "cGccA" into the alphabetically order
    string list cD%test-listcA:
sB
        set-variable %test-list "|a|b|d|e|"
        set-variable %test-insert "c"

        set-variable #l0 1
        !while &and &not &seq &lget %test-list #l0 "" ...
                ... &sle &lget %test-list #l0 %test-insert
            set-variable #l0 &add #l0 1
        !done
        set-variable %test-list &lins %test-list #l0 %test-insert

sA
    The first test on the cD!while &andcA conditional checks that the current item
    in the list is not an empty string (""). If it is the end of the list has
    been reached.

    The following example tests the current buffers file name for a ".c"
    extension:
sB
        !if &xse $buffer-fname ".*\\.c"
            ...

sA
    Note the 'cG\cA' character is needed to protect the second 'cG.cA', i.e. so that
    it does not match any character and the second 'cG\cA' is required as the
    string is first parsed by the macro interpreter which changes it to
    "cG.*\.ccA" which is then interpreted as a regex.


cEcESEE ALSO cEcA


    lsIntroduction to Variable FunctionslmVariable Functionsle, lslm&sin(4)le, lslm&slower(4)le, lslm&rep(4)le, lslm&add(4)le, lslm&equal(4)le,
    lslm&cond(4)le, lsRegularExpressions(2)lmRegular Expressionsle.
! 4 &sin
!44 &isin
!44 &rsin
!44 &risin
cEcENAME cEcA


    &sin, &isin, &rsin, &risin - String in string test functions


cEcESYNOPSIS cEcA


    cD&sincA cCstr1cA cCstr2cA
    cD&isincA cCstr1cA cCstr2cA
    cD&rsincA cCstr1cA cCstr2cA
    cD&risincA cCstr1cA cCstr2cA


cEcEDESCRIPTION cEcA


    These functions test for the existence of cCstr1cA in cCstr2cA, returning the
    position of the string in cCstr2cA or 0 if not found.

    The functions may all be abbreviated to their three letter abbreviation
    (i.e. cD&risincA may be expressed as cD&riscA). In all cases the first argument is
    completely evaluated before the second argument.

    cD&sincA cCstr1cA cCstr2cA
        Returns cG0cA if string cCstr1cA does not exists in string cCstr2cA. Otherwise the
        function returns the character position + 1 of the location of the
        first character of the first occurrence of cCstr1cA.

    cD&isincA cCstr1cA cCstr2cA
        Returns cG0cA if case insensitive string cCstr1cA does not exists in string
        cCstr2cA. Otherwise the function returns the character position + 1 of the
        location of the first character of the first occurrence of cCstr1cA.

    cD&rsincA cCstr1cA cCstr2cA
        Returns cG0cA if string cCstr1cA does not exists in string cCstr2cA. Otherwise the
        function returns the character position + 1 of the location of the
        first character of the last occurrence of cCstr1cA.

    cD&risincA cCstr1cA cCstr2cA
        Returns cG0cA if case insensitive string cCstr1cA does not exists in string
        cCstr2cA. Otherwise the function returns the character position + 1 of the
        location of the first character of the last occurrence of cCstr1cA.


cEcEEXAMPLE cEcA


    The cD&sincA and similar functions are useful for two different purposes.
    Consider the following example, this utilizes cD&sincA in two different
    contexts. cG!while &not &sin @wc " \t\n"cA is a test for the end of the
    number, i.e. a white space character (cG<tab>cA, cG<SPACE>cA or cG<NL>cA).

    The invocation cGset-variable #l1 &isin @wc "0123456789abcdef"cA is subtly
    different. In this case the return value is used to convert the character
    to it's integer hex value by using the value returned by cD&isincA.
sB
        ;
        ; calc-hexnum
        ; Convert the sting from the current position in the buffer
        ; to a hexadecimal number.
        define-macro calc-hexnum
            forward-delete-char
            forward-delete-char
            set-variable #l0 0
            !while &not &sin @wc " \t\n"
                set-variable #l1 &isin @wc "0123456789abcdef"
                !if &not #l1
                    ml-write "Bad Hex number found"
                    !abort
                !endif
                set-variable #l0 &mul #l0 16
                set-variable #l0 &add #l0 &sub #l1 1
                forward-delete-char
            !done
            insert-string #l0
        !emacro

sA
    The cD&rsincA function is very similar to sin except the value return is the
    position of the last occurrence of the string in the given string instead
    of the first. This is particularly useful when extracting the path or file
    name from a complete file name. For example, given a UNIX style file name
    such as cG"/usr/local/bin/me"cA the path can be obtained using cGset-variable
    %path &lef %pathfile &rsincA cG"/" %pathfilecA and the file name by using
    cGset-variable %file &rig %pathfile &rsincA cG"/" %pathfilecA


cEcESEE ALSO cEcA


    lslmOperating Modesle, lsIntroduction to Variable FunctionslmVariable Functionsle, lslm&sequal(4)le, lslm&rep(4)le.
!44 !jump
!44 !tjump
cEcENAME cEcA


|!jump
    !jump - Unconditional relative branch
|!tjump
    !tjump - conditional relative branch


cEcESYNOPSIS cEcA


    cD!jumpcA cCoffsetcA
    cD!tjumpcA cCconditioncA cCoffsetcA


cEcEDESCRIPTION cEcA


    Flow can be controlled within a MicroEmacs 2009 macro using the cD!jumpcA
    directive. It takes as a numerical argument cCoffsetcA. The cCoffsetcA is a signed
    relative displacement, it may be a literal numeric value, a variable or an
    evaluated expression (see lsIntroduction to Variable FunctionslmVariable Functionsle). The displacement to jump
    starts from the current cD!jumpcA line. (i.e. cD0 gotocA) would loop forever as it
    jumps to itself). Negative cCoffsetcA branches backwards, positive cCoffsetcA
    forwards.

    A conditional relative branch, with a numerical displacement is specified
    using cD!tjumpcA. This has an additional argument cCconditioncA which is evaluated
    and if TRUE (Non-zero) then the branch is taken. The cCconditioncA may be a
    variable or an evaluated expression.

    cD!jumpcA and cD!tjumpcA are fast equivalents of lslm!goto(4)le and lslm!tgoto(4)le,
    respectively. cD!jumpcA should be used with care as these calls are source
    sensitive and unexpected results may be obtained if the cCoffsetcA's are
    specified incorrectly.


cEcEWARNING cEcA


    Comments are not counted as valid lines within the relative displacement,
    these are stripped out when the macro is loaded. When using a relative
    branch ensure that ONLY the cCcodecA lines are counted.


cEcEEXAMPLE cEcA


    For some seriously dirty macro tricks then the cD!jumpcA directive becomes
    very useful. The following example is taken from the cDMetriscA macro (which
    is packed with goodies if you can find time to work out what it does !!).
    The following example uses the random number generator lslm$random(5)le to
    generate a random number which scaled and used as a cD!jumpcA offset, thereby
    creating a cCswitchcA type statement.
sB
        0 define-macro met-select-piece
            !jump &mul 5 &add 1 &div &mod $random 71 10
            set-variable :met-np1 " X "  ; 1st 3 lines are dummies to get offset right
            set-variable :met-np1 " X "
            set-variable :met-np1 " X "
            set-variable :met-np1 " X "
            set-variable :met-np1 " X "
            set-variable :met-np2 "XX "
            set-variable :met-np3 " X "
            set-variable :met-ncol %lyellow
            !return
            set-variable :met-np1 "XX "
            set-variable :met-np2 "XX "
            set-variable :met-np3 "   "
            set-variable :met-ncol %yellow
            !return
            set-variable :met-np1 "X  "
            set-variable :met-np2 "XX "
            set-variable :met-np3 " X "
            set-variable :met-ncol %lmagenta
            !return
            set-variable :met-np1 "  X"
            set-variable :met-np2 " XX"
            set-variable :met-np3 " X "
            set-variable :met-ncol %lgreen
            !return
            set-variable :met-np1 " X "
            set-variable :met-np2 " X "
            set-variable :met-np3 " XX"
            set-variable :met-ncol %magenta
            !return
            set-variable :met-np1 " X "
            set-variable :met-np2 " X "
            set-variable :met-np3 "XX "
            set-variable :met-ncol %green
            !return
            set-variable :met-np1 " X "
            set-variable :met-np2 " X "
            set-variable :met-np3 " X "
            set-variable :met-ncol %lblue
            !return
            set-variable :met-np1 " X "
            set-variable :met-np2 " X "
            set-variable :met-np3 "X X"
            set-variable :met-ncol %lred
        !emacro

sA

cEcESEE ALSO cEcA


    lsIntroduction to Variable FunctionslmVariable Fuctionsle, lslm!goto(4)le, lslm!if(4)le, lslm!repeat(4)le, lslm!return(4)le, lslm!tgoto(4)le,
    lslm!while(4)le.
! 4 SearchGroups
! 4 @s0
! 4 @s1
! 4 @s2
cEcENAME cEcA


    @s0, @s1, @s2, ... @s9 - Last search group values


cEcESYNOPSIS cEcA


    cD@s0cA - Last search's whole match string
    cD@s1cA - Last search's first group value
    cD@s2cA - Last search's second group value
    ...
    cD@s9cA - Last search's nineth group value


cEcEDESCRIPTION cEcA


    The search group variables cD@scAcCncA return the string matches of the last
    regular expression search i.e. lslmsearch-forward(2)le (in lslmmagic(2m)le mode) or
    lslmsearch-buffer(2)le.

    cD@s0cA returns the whole of the matched string, cD@scAcCncA, cCncA = 1..9, returns the
    bracket matches corresponding to the group demarkation points indicated by
    cG\(cA and cG\)cA in the search regular expression.


cEcEDIAGNOSTICS cEcA


    An error is generated if an attempt is made to access these variables and
    the last search failed or the last search did not have the specified
    group.

    The value returned for an unused group, e.g. @s2 for the regex string
    "cG\(a\)\|\(b\)cA" if "cGacA" was matched, is an empty string ("").


cEcEEXAMPLE cEcA


    The following macro code gives a simple example of their potential use:
sB
        forward-search "Token *{\\(Start\\|End\\)}"
        !if $status
            ml-write "[found \"%s\"]" @s0
            !if &seq @s1 "Start"
               .
               .

sA

cEcENOTES cEcA


    Remember that the regular expression escape character '\' has to be
    duplicated within a macro file as '\' is also the macro file escape
    sequence.


cEcESEE ALSO cEcA


    lslmmagic(2m)le, lslmsearch-buffer(2)le, lslmsearch-forward(2)le.
! 4 @fs
! 4 @fss
cEcENAME cEcA


|@fs
    @fs - Frame store variable
|@fss
    @fss - Frame store scheme variable
$a


cEcESYNOPSIS cEcA


    cD@fscA cCrowcA cCcolumncA
    cD@fsscA cCrowcA cCcolumncA


cEcEDESCRIPTION cEcA


    The frame store variable cD@fscA permits macros to obtain the character
    currently being drawn on the screen at the specified location. If the
    given value of cCrowcA or cCcolumncA is out range, i.e. less than zero or greater
    than or equal to the screen size (see lslm$frame-width(5)le) then the value
    returned is the empty string (i.e. cG""cA).

    The frame store scheme variable cD@fsscA operates in the same way as cD@fscA but
    returns the hilighting scheme number as opposed to the character.

    These variables cannot be set and are only updated during a screen update,
    this means that macros that change the cursor position need to redraw the
    screen before using this variable (see lslmscreen-update(2)le).


cEcEEXAMPLE cEcA


    The following example gets the word under the current mouse position, this
    may not be the current cursor position:
sB
        define-macro word-under-mouse
            set-variable #l0 $mouse-y
            set-variable #l1 $mouse-x
            !if &not &inw @fs #l0 #l1
                ml-write "[mouse not over a word]"
                !return
            !endif
            set-variable #l2 @fs #l0 #l1
            set-variable #l1 &sub #l1 1
            !if &inw @fs #l0 #l1
                set-variable #l2 &cat @fs #l0 #l1 #l2
                !jump -3
            !endif
            set-variable #l1 $mouse-x
            set-variable #l1 &add #l1 1
            !if &inw @fs #l0 #l1
                set-variable #l2 &cat #l2 @fs #l0 #l1
                !jump -3
            !endif
            ml-write &spr "[mouse is over the word \"%s\"]" #l2
        !emacro

sA
    Knowledge of the display scheme as returned by the cD@fsscA variable is a
    little more obscure than the previous example. This variable is currently
    used to determine if there is a spelling error under the cursor position.
    When lslmauto-spell(3)le is enabled then spelling errors are hilighted in a
    different colour, return of the lshilight(2)lmhilightingle scheme allows the caller to
    determine that there is a spelling error at the current position, this
    could also be applied to collapsed regions etc. The following example is
    taken from cGmouseosd.emfcA to determine if there is a spelling error at the
    mouse position.
sB
        set-variable #l0 &band $mouse-pos 15
        !if &equ #l0   0
            ; Text window - must goto the original position or cut etc wont work - must dup the position
            0 show-region
            set-variable #l2 $result
            set-variable #l0 20
            osd 27 5  "D"
            !if &seq $buffer-input "auto-spell-input"
                !if &equ @fss $mouse-y $mouse-x .scheme.spell-error
                    auto-spell-test
                    !if &seq &lef $result 1 "E"
                        set-position "\x83"
                        set-variable .auto-spell-osd.word &rig $result 1
                        osd 27 5  "M" "Auto Spell" .osd.spell-auto auto-spell-osd
                        set-variable #l0 &add #l0 1
                    !endif
                !endif
            !endif
            goto-position "\x82"
            ....

sA

cEcESEE ALSO cEcA


    lslm$frame-width(5)le, lslmscreen-update(2)le, lsMacroArguments(4)lmMacroArgumentsle, lsMacroNumericArguments(4)lmMacroNumericArgumentsle,
    lslmdefine-macro(2)le.
! 4 &opt
cEcENAME cEcA


    &opt - MicroEmacs optional feature test


cEcESYNOPSIS cEcA


    cD&optcA cCstrcA


cEcEDESCRIPTION cEcA


    This function can be used to test the availability of optional features in
    the current session of MicroEmacs. Some features, like spelling checker
    support, are a compilation option, other options like mouse support may
    also be unavailable on some platforms. The cD&optcA function can be used by
    macros to check that required base functionality is available.

    The function returns cG1cA in the given feature "cCstrcA" is supported, otherwise
    it returns cG0cA if the feature is unknown or not supported in the running
    version.


cEcENOTES cEcA


    Optional components of MicroEmacs 2009 are enabled/disabled at compile
    time, most options are configured by cGMEOPT_cAcC<NAME>cA cG#definecA's within the
    source file cGemain.hcA. Following is a complete list of options, giving the
    cDoptcA string and cG#definecA label:

    abb - MEOPT_ABBREV
        Abbreviation functionality (see lslmexpand-abbrev(2)le).

    cal - MEOPT_CALLBACK
        Callback and idle event handling (see lslmcreate-callback(2)le).

    fen - MEOPT_FENCE
        Fence matching (see lslmfence(2m)le).

    cli - MEOPT_CLIENTSERVER
        Client/server support (see lsClient-Server(2)lmClient-Serverle).

    col - MEOPT_COLOR
        All color support (making hilighting redundent etc, see lslmadd-color(2)le).

    cry - MEOPT_CRYPT
        File encryption (see lslmcrypt(2m)le mode).

    deb - MEOPT_DEBUGM
        Macro debugging (see lslm$debug(5)le).

    dir - MEOPT_DIRLIST
        Directory listing when loading a directory (see lslmfile-browser(3)le and
        lslmdir(2m)le mode ).

    ext - MEOPT_EXTENDED
        Miscellaneous more advanced commands and features such as
        lslmappend-buffer(2)le.

    fho - MEOPT_FILEHOOK
        File type auto-detection and configuration (see lslmadd-file-hook(2)le).

    fra - MEOPT_FRAME
        Multiple frames (Internal or external, see opt "cDmwfcA" and command
        lslmcreate-frame(2)le).

    has - MEOPT_CMDHASH
        Use a hash table for rapid command name lookup.

    hil - MEOPT_HILIGHT
        Hilight and user definable indentation rules (see lslmhilight(2)le and
        lslmindent(2)le).

    hsp - MEOPT_HSPLIT
        Horizontal window splitting (see lslmsplit-window-horizontally(2)le).

    ipi - MEOPT_IPIPES
        Interactive pipes (see lslmipipe-shell-command(2)le).

    ise - MEOPT_ISEARCH
        Incremental search (see lslmisearch-forward(2)le).

    lbi - MEOPT_LOCALBIND
        Buffer, message-line and OSD local binding overrides (see
        lslmbuffer-bind-key(2)le).

    mag - MEOPT_MAGIC
        Regular expression search engine (see lslmmagic(2m)le mode).

    mou - MEOPT_MOUSE
        Mouse support (see lslm$mouse(5)le).

    mwf - MEOPT_MWFRAME
        Multiple window frame support (see opt "cDfracA").

    nar - MEOPT_NARROW
        Buffer narrowing (see lslmnarrow-buffer(2)le).

    nex - MEOPT_FILENEXT
        Location list stepping (see lslmget-next-line(2)le).

    osd - MEOPT_OSD
        On Screen Display GUI support (see lslmosd(2)le).

    pok - MEOPT_POKE
        Direct screen poking (see lslmscreen-poke(2)le).

    pos - MEOPT_POSITION
        Position storing and returning (see lslmset-position(2)le).

    pri - MEOPT_PRINT
        Printing support (see lslmprint-buffer(2)le).

    rcs - MEOPT_RCS
        File Revision Control Support (see lslm$rcs-co-com(5)le).

    reg - MEOPT_REGISTRY
        Internal registry and history support (see lslmread-registry(2)le).

    scr - MEOPT_SCROLL
        Window scroll-bar support.

    soc - MEOPT_SOCKET
        URL support, FTP and HTTP via sockets (see lslmfind-file(2)le).

    spa - MEOPT_SPAWN
        External process launching (see lslmshell-command(2)le).

    spe - MEOPT_SPELL
        Spelling checker support (see lslmspell(2)le).

    tag - MEOPT_TAGS
        Tags support (see lslmfind-tag(2)le).

    tim - MEOPT_TIMSTMP
        File timestamping on save (see lslmtime(2m)le mode).

    typ - MEOPT_TYPEAH
        Input detect or 'type-ahead' for background processing support.

    und - MEOPT_UNDO
        Undo support (see lslmundo(2)le).

    wor - MEOPT_WORDPRO
        Word-processor style commands like lslmfill-paragraph(2)le (see
        lslmforward-paragraph(2)le).


cEcEEXAMPLE cEcA


    The following example checks for URL support and if not available it pops
    up an error:
sB
        !if &not &opt "soc"
            osd-dialog "Opt Test" "Error: No URL support!" "  &OK  "
        !endif

sA

cEcESEE ALSO cEcA


    lsBuild(2)lmBuilding MicroEmacsle.
! 4 HistoryGroupVariables
! 4 @h0
! 4 @h1
! 4 @h2
! 4 @h3
! 4 @h4
cEcENAME cEcA


    @h0, @h1, @h2, ... @h4 - History Group Variables.


cEcESYNOPSIS cEcA


    cD@h0cA cCindexcA - General history string
    cD@h1cA cCindexcA - Buffer history string
    cD@h2cA cCindexcA - Command history string
    cD@h3cA cCindexcA - File history string
    cD@h4cA cCindexcA - Search history string


cEcEDESCRIPTION cEcA


    The history group variables cD@hcAcCncA cCindexcA return the strings in the history
    buffer ad a given cCindexcA. There are 5 history buffers, cCncA, as follows:-

    cG0cA - General history string
    cG1cA - Buffer history string
    cG2cA - Command history string
    cG3cA - File history string
    cG4cA - Search history string

    Each history buffer contains 20 slots which contain the history
    information. The history slot is selected with the cCindexcA argument which is
    valid in the range cG0..19cA, index cG0cA is the most recent history slot in the
    history group.

    The history slots are automatically modified on the entry of a new
    command, search string etc.

    cD@hcAcCncA cCindexcA returns the whole of the history string for a given slot.


cEcEDIAGNOSTICS cEcA


    An error is generated if an attempt is made to access these variables and
    history buffer identifier cCncA or the cCindexcA is out of range.


cEcEEXAMPLE cEcA


    The last search history may be extracted as follows:-
sB
        set-variable #l1 @h4 0
        !force search-backward #l1
        !if &not $status
            ; Not found
        !else
            ; Found
        !endif

sA

cEcENOTES cEcA


    cD@hcAcCncA was first introduced in the January 2004 release.


cEcESEE ALSO cEcA


    lslmread-session(3)le, lslmsave-session(3)le.
!44 &bstat
cEcENAME cEcA


    &bstat - Retrieve current buffer statistic


cEcESYNOPSIS cEcA


    cD&bstatcA cC<stat>cA


cEcEDESCRIPTION cEcA


    cD&bstatcA returns the specified cC<stat>cA on the current buffer. Valid cC<stat>cA
    values are:-

    cDocA
        Returns a non-zero value if the buffer is out of date (i.e. the
        original file has changed and is newer than the buffer.


cEcEEXAMPLE cEcA


    The following example uses cD&bstatcA to determine if the buffer is out of
    date and write a simple message:
sB
        !if &bstat o
          ml-write "Buffer out of date"
        !endif

sA

cEcESEE ALSO cEcA


    lsIntroduction to Variable FunctionslmVariable Functionsle, lslmfind-file(2)le, lslm&stat(4)le.
! 5 $auto-time
cEcENAME cEcA


    $auto-time - Automatic buffer save time
$a


cEcESYNOPSIS cEcA


    cD$auto-timecA cCsecondscA; Default is cG300cA seconds

    0 <= cCsecondscA <= t


cEcEDESCRIPTION cEcA


    Sets the number of seconds to wait until an edited buffer is auto-saved to
    temporary file to t seconds. A setting of 0 disables the auto-saving
    command. Auto-saving can be enabled and disabled on a per buffer basis
    using buffer mode lslmautosv(2m)le.

    The auto-save file naming convention is the same as the backup name only
    using hash ('cG#cA') instead of tilde ('cG~cA') and is automatically removed on
    saving a buffer.

    On unlimited length file name systems (UNIX), the following file naming
    conventions are used for file cGxxxxxcA:

        cGxxxxx -> xxxxx#cA

    On systems with an cGxxxxxxxx.yyycA file name (DOS etc), the following file
    naming conventions are used:

        cGxxxxxxxx     -> xxxxxxxx.###cA
        cGxxxxxxxx.y   -> xxxxxxxx.y##cA
        cGxxxxxxxx.yy  -> xxxxxxxx.yy#cA
        cGxxxxxxxx.yyy -> xxxxxxxx.yy#cA


cEcENOTES cEcA


    The user is warned to be extra careful if files ending in 'cG~cA' or 'cG#cA's are
    used, it is advisable to disable backup creation (see lslmglobal-mode(2)le) and
    auto-saving (cG$auto-time = 0cA). The author denies all responsibility (yet
    again) for any loss of data! Please be careful.

    Auto-save files of URL files (i.e. "cGftp://...cA" and "cGhttp://...cA") are
    written to the system's temporary directory. This avoids potentially slow
    auto-saves. This can however lead to recovery problems as the buffer name
    must be used to avoid auto-saving conflict with other buffers with the
    same base file name but different paths.


cEcESEE ALSO cEcA


    lslmautosv(2m)le, lslmbackup(2m)le, lslmbuffer-mode(2)le lslmfind-file(2)le, lslmftp(3)le.
! 5 $buffer-scheme
cEcENAME cEcA


    $buffer-scheme - Buffer color scheme.
$a


cEcESYNOPSIS cEcA


    cD$buffer-schemecA cCschemeNumcA; Default is cG0cA


cEcEDESCRIPTION cEcA


    cD$buffer-schemecA sets the current buffer's color scheme to cCschemeNumcA, where
    cCschemeNumcA is a color scheme defined with lslmadd-color-scheme(2)le, which
    identifies the foreground and background color schemes of the buffer. The
    color scheme is initialized to the global color scheme settings (see
    lslm$global-scheme(5)le) when the buffer is created.


cEcESEE ALSO cEcA


    lslm$buffer-hilight(5)le, lslm$cursor-color(5)le, lslm$trunc-scheme(5)le, lslm$global-scheme(5)le,
    lslm$ml-scheme(5)le, lslm$mode-line-scheme(5)le, lslm$scroll-bar-scheme(5)le, lslm$system(5)le.
! 5 $buffer-fhook
! 5 $buffer-dhook
! 5 $buffer-bhook
! 5 $buffer-ehook
cEcENAME cEcA


|$buffer-fhook
    $buffer-fhook - Buffer macro hook command name (buffer creation)
|$buffer-dhook
    $buffer-dhook - Buffer macro hook command name (buffer deletion)
|$buffer-bhook
    $buffer-bhook - Buffer macro hook command name (buffer current)
|$buffer-ehook
    $buffer-ehook - Buffer macro hook command name (buffer swapped)
$a


cEcESYNOPSIS cEcA


    cD$buffer-fhookcA cCFunctionNamecA
    cD$buffer-dhookcA cCFunctionNamecA
    cD$buffer-bhookcA cCFunctionNamecA
    cD$buffer-ehookcA cCFunctionNamecA


cEcEDESCRIPTION cEcA


    Sets the buffer create, delete, begin and end hook command which are
    executed:

    cDbuffer-fhookcA
        When the buffer is created.

    cDbuffer-dhookcA
        When the buffer is deleted.

    cDbuffer-bhookcA
        When the buffer becomes the current buffer.

    cDbuffer-ehookcA
        When the buffer is swapped out from being the current buffer.

    The variable cD$buffer-fhookcA is largely redundant as the file hook is
    executed only once and before it can be sent. Its main use is within
    macros which wish to ascertain what type of buffer it is executing on,
    i.e. if a command was to be executed only on c file then the follow
    ensures that this is the case:
sB
        !if &not &seq $buffer-fhook "fhook-cmode"
            !abort
        !endif

sA
    Where the command cCfhook-cmodecA is the c file hook.

    cDdhookscA are executed when a buffer is deleted, but before the contents of
    the buffer are lost. Note that dhooks will not be called if the buffer
    never becomes active, or if MicroEmacs 2009 quits due to the receipt of a
    panic signal.

    cDbhookscA and cDehookscA are usually used to set and restore global variables
    which require different setting in the current buffer.

    The order of The default settings of these variable are determined by the
    command lslmadd-file-hook(2)le.


cEcESEE ALSO cEcA


    lslmadd-file-hook(2)le.
! 5 $buffer-bname
! 5 $buffer-fname
cEcENAME cEcA


|$buffer-bname
    $buffer-bname - Name of the current buffer
|$buffer-fname
    $buffer-fname - Name of the current buffer's file name
$a


cEcESYNOPSIS cEcA


    cD$buffer-bnamecA cCBufferNamecA
    cD$buffer-fnamecA cCFileNamecA


cEcEDESCRIPTION cEcA


    cD$buffer-bnamecA the string name of the current buffer. Buffer names are
    unrestricted in length, but must be unique. By default the buffer name is
    derived from the buffer's file name without the path. But this can lead to
    conflicts, caused by identical file names but different paths. In these
    situations a counter is appended to the end of the buffer name and is
    incremented until a unique buffer name is created. For example:

        File Name               Buffer Name
        _______________________________________

        /etc/file.c             file.c
        /tmp/file.c             file.c<1>
        /usr/file.c             file.c<2>


    cD$buffer-fnamecA contains the name of the current buffer's file name complete
    with path.


cEcESEE ALSO cEcA


    lslmchange-buffer-name(2)le.
! 5 $buffer-hilight
cEcENAME cEcA


    $buffer-hilight - Define current buffer hilighting scheme.
$a


cEcESYNOPSIS cEcA


    cD$buffer-hilightcA cChilightNumcA; Default is cG0cA

    0 <= cChilightNumcA <= 255


cEcEDESCRIPTION cEcA


    cD$buffer-hilightcA Sets the current buffer's hi-lighting scheme (see
    lslmhilight(2)le for a full description of hi-lighting). The default setting is
    0 which specifies no hi-lighting, when set to a non-zero, the hi-light
    scheme of that number MUST already be defined.

    Terminals that cannot display color directly may still be able to take
    benefit from hi-lighting. A terminal that has fonts can use them in the
    same way using the lslmadd-color-scheme(2)le command. The hi-light scheme is
    also used in printing (see lslmprint-buffer(2)le). If, however, your terminal
    cannot display color in any way, it is recommended that hi-lighting is
    disabled (except when printing) as it does take CPU time.


cEcESEE ALSO cEcA


    lslmhilight(2)le, lslmprint-buffer(2)le, lslm$buffer-scheme(5)le, lslm$buffer-indent(5)le.
! 5 $buffer-input
cEcENAME cEcA


    $buffer-input - Divert buffer input through macro.
$a


cEcESYNOPSIS cEcA


    cD$buffer-inputcA cCcommandNamecA


cEcEDESCRIPTION cEcA


    cD$buffer-inputcA allows the buffer input mechanism to be diverted through a
    command macro defined by cCcommandNamecA. If this variable is set to a valid
    command, which may be a user defined macro, this command will be called
    instead. The command can access the actual key-code typed by the user via
    the command variable lslm@cc(4)le, e.g. the following macro prints out the name
    of the command that the user presses until the lslmabort-command(2)le is
    executed.
sB
        define-macro test-input
            ml-write &spr "Current command: %s" @cc
            !if &seq @cc "abort-command"
                set-variable $buffer-input ""
            !endif
        !emacro

        set-variable $buffer-input test-input

sA

cEcEWARNING cEcA


    Caution is advised when using this, if there is no way of reseting the
    variable then cDMicroEmacs 2009cA must be killed.


cEcESEE ALSO cEcA


    lslmabort-command(2)le, lslm@cc(4)le.
! 5 $buffer-ipipe
cEcENAME cEcA


    $buffer-ipipe - Divert buffer incremental pipe input through macro.
$a


cEcESYNOPSIS cEcA


    cD$buffer-ipipecA cCcommandNamecA


cEcEDESCRIPTION cEcA


    cD$buffer-ipipecA allows the buffer incremental pipe input mechanism to be
    diverted through a command macro defined by cCcommandNamecA. On a buffer
    running an lslmipipe-shell-command(2)le the command, set by this variable, will
    be called whenever new text has been inserted by the executing process.
    Two cCalpha-markscA will be set in the buffer, 'cGicA' denotes the start of the
    newly inserted text and 'cGIcA' denotes the end.


cEcESEE ALSO cEcA


    lslm$buffer-input(5)le, lslmgoto-alpha-mark(2)le, lslmipipe-shell-command(2)le.
! 5 $buffer-mask
cEcENAME cEcA


    $buffer-mask - Current buffer word class mask.
$a


cEcESYNOPSIS cEcA


    cD$buffer-maskcA cDstringcA; Default is cGluhcA


cEcEDESCRIPTION cEcA


    cD$buffer-maskcA sets the current buffer word class mask. MicroEmacs 2009 has
    an internal word lookup table which defines whether a given letter is
    considered to be part of a word. This functionality is used in many areas
    such as lslmforward-word(2)le, lslmforward-kill-word(2)le hilighting etc. The mask is
    composed with any combination of the following flags, the order in which
    the flags are specified is not important:

    cDlcA
        All lower case letters.

    cDucA
        All upper case letters.

    cDhcA
        All hexadecimal characters (used to include numerical digits).

    cDscA
        Spell extended characters, typically set to accent (cG'cA), hyphen (cG-cA) and
        period (cG.cA).

    cD1cA
        User set cD1cA, usually set to just underscore (cG_cA) for many system and
        programming files such as 'C'.

    cD2cA
        User set cD2cA, usually set to 'cG-cA', 'cG$cA', 'cG&cA', 'cG#cA', 'cG!cA', 'cG%cA', 'cG:cA' and 'cG@cA'
        for MicroEmacs files.

    cD3cA
        User set cD3cA, not usually defined.

    cD4cA
        User set cD4cA, not usually defined.

    The character sets may be modified using the lslmset-char-mask(2)le command.


cEcESEE ALSO cEcA


    lslmset-char-mask(2)le, lslmforward-word(2)le.
! 5 $buffer-mode-line
cEcENAME cEcA


    $buffer-mode-line - Buffer mode line string
$a


cEcESYNOPSIS cEcA


    cD$buffer-mode-linecA "cCstringcA"


cEcEDESCRIPTION cEcA


    Sets the buffer mode line, unique to this buffer, see lslm$mode-line(5)le use,
    description and syntax. If this variable is NOT set for a buffer and
    cD$mode-linecA is changed, then the buffer's mode line will also change to the
    new value. If this variable is set, then then buffer's mode line will be
    unaffected by any setting of cD$mode-linecA.


cEcESEE ALSO cEcA


    lslm$mode-line(5)le.
! 5 $osd-scheme
cEcENAME cEcA


    $osd-scheme - OSD color scheme
$a


cEcESYNOPSIS cEcA


    cD$osd-schemecA cCschemeNumcA; Default is cG1cA


cEcEDESCRIPTION cEcA


    cD$ml-schemecA defines the color scheme by default on an lslmosd(2)le dialog, the
    color scheme cCschemeNumcA identifies the foreground and background color and
    is defined by an invocation to lslmadd-color-scheme(2)le. Every osd dialog can
    over-ride this value by using the 'cCScA' flag.


cEcESEE ALSO cEcA


    lslmosd(2)le, lslmadd-color-scheme(2)le, lslm$global-scheme(5)le, lslm$ml-scheme(5)le,
    lslm$mode-line-scheme(5)le, lslm$scroll-bar-scheme(5)le, lslm$system(5)le.
! 5 $cursor-blink
! 5 $cursor-color
cEcENAME cEcA


|$cursor-blink
    $cursor-blink - Cursor blink rate
|$cursor-color
    $cursor-color - Cursor foreground color
$a


cEcESYNOPSIS cEcA


    cC$cursor-blinkcA cCintegercA; Default is cG0cA

    cC$cursor-colorcA cCcolorNumcA; Default is cG0cA

    0 <= cCcolorNumcA <= cCncA


cEcEDESCRIPTION cEcA


    cD$cursor-blinkcA sets the cursor's flash rate, i.e. the period in which the
    cursor is drawn, hidden and then redrawn. The default setting of 0
    disables cursor blinking. When set to a none zero value the variable is
    split into two componants, the first 16 bits, or lower short, sets the
    cursor visible time in milliseconds, and the higher short sets the hidden
    time. If the hidden time is set to 0 then the cursor will be hidden for
    the same length of time it is visible.

    The cursor blink rate can be setup in the platform section of
    lslmuser-setup(3)le.

    cD$cursor-colorcA sets the cursor's fore-ground color, and can greatly improve
    cursor visibility. cCcolorNumcA is a integer palette number created using
    lslmadd-color(2)le, the default is 0.


cEcEPLATFORM cEcA


    UNIX termcap interface does not support cD$cursor-colorcA.


cEcEEXAMPLE cEcA


    The following example sets the cursor visible time to 600 ms (0x258) and a
    hidden time to 200 ms (0xc8):
sB
        set-variable $cusror-blink 0x00c80258

sA

cEcESEE ALSO cEcA


    lslmuser-setup(3)le, lslmadd-color(2)le, lslm$global-scheme(5)le, lslm$ml-scheme(5)le,
    lslm$mode-line-scheme(5)le, lslm$system(5)le.
! 5 $debug
cEcENAME cEcA


    $debug - Macro debugging flag
$a


cEcESYNOPSIS cEcA


    cD$debugcA cCdebugLevelcA; Default is cG0cA

    -3 <= cCdebugLevelcA <= 3


cEcEDESCRIPTION cEcA


    cD$debugcA is used to control macro debugging, it is a bit based flag where:

    cG0x01cA
        Displays an error message when an un-handled exception is encountered,
        this is useful to locate problems in the macro code i.e. missing
        arguments etc. This setting may be used in normal running and macro
        execution is halted when an error is encountered, it is non-intrusive
        up until the point of failure. Enabling slightly slows execution but
        is not typically noticeable on modern processors.

    cG0x02cA
        Setting this bit enables the macro debugger. With macro debugging
        enabled, before a line of macro code is executed the line and its
        location is first print on the message line with a prompt allowing the
        user to view variables, abort execution, dive into sub macros etc. The
        behaviour of the macro debugger can be altered by bits cG0x04cA and cG0x08cA.

    cG0x04cA
        When set all macro lines encountered are printed. When this bit is not
        set only the lines of code that are executed are printed, i.e. if a
        false cD!ifcA was encountered the lines within the cD!ifcA would not be
        printed. Problems arise with cD!elifcA and cD!elsecA lines and this bit is not
        set as the cD!elifcA and cD!elsecA lines are never printed.

    cG0x08cA
        When set the debug prompt is disabled so the macro line is printed on
        the message line and then immediately executed. This allows the user
        to see the execution flow of the macro code while still executing the
        code at a reasonable pace.

    cG0x10cA
        Setting this bit has no immediate effect. However as soon as the key
        bound to lslmabort-command(2)le (typically "cGC-gcA") is pressed the macro
        debugger is enabled, i.e. bit cG0x02cA is set. This can be invaluable when
        tracing problems, for example the following macro code will loop
        infinitely:-
sB
            !repeat
                beginning-of-line
                backward-char
                !force forward-line
            !until &not $status

sA
        This is a fairly obvious bug, but if buried in a thousand lines of
        macro code it could be very difficult to spot and to find it during
        execution would be very tedious if not impossible. But by setting
        cD$debugcA to cG0x10cA the macro can be executed as normal and as soon as the
        macro is stuck the user can simply press "cGC-gcA" to start macro
        debugging at the current execution point.

        Note that the "cGC-gcA" which triggers the macro debugger is discarded so
        it does not cause the current command to abort.

    cG0x20cA
        Setting this bit is similar to cG0x10cA except the macro debugger is
        enabled by the ringing of the bell. When some commands fail they
        always print an error message and ring the bell as the error needs
        handling (e.g. missing argument in a cD!ifcA statement). However if the
        macro has been called with a cD!forcecA the execution will not be aborted
        so tracing this issue could be difficult without this setting.


cEcESEE ALSO cEcA


    lslmexecute-file(2)le.

    lsmacroWriting(4)lmWriting MicroEmacs Macrosle
    lsMicroEmacs - Macro Language GlossarylmMacro Glossaryle
    lsmacroDebugging(4)lmMacro Debugging - A Crash Coursele
    lsmacroOverview(4)lmMicroEmacs Macro Language at a Glancele
! 5 $fill-eos
! 5 $fill-eos-len
cEcENAME cEcA


|$fill-eos
    $fill-eos - Paragraph filling; end of sentence fill characters
|$fill-eos-len
    $fill-eos-len - Paragraph filling; end of sentence padding length
$a


cEcESYNOPSIS cEcA


    cD$fill-eoscA "cCstringcA"; Default is "cG.!?cA"

    cD$fill-eos-lencA cCintegercA; Default is cG1cA
    0 <= cCintegercA <= cCncA


cEcEDESCRIPTION cEcA


    cD$fill-eoscA defines the end of sentence character set. Sentences ending in
    these characters are padded with additional cCend-of-sentencecA spaces, as
    defined by cD$fill-eos-lencA.

    cD$fill-eos-lencA sets the number of spaces inserted after a full stop during
    paragraph filling. The default is 1 space.


cEcESEE ALSO cEcA


    lslmfill-paragraph(2)le.
! 5 $show-modes
cEcENAME cEcA


    $show-modes - Select buffer modes to display
$a


cEcESYNOPSIS cEcA


    cD$show-modescA "cCbit-stringcA"; Default is "cGcA"


cEcEDESCRIPTION cEcA


    cD$show-modescA defines which buffer modes are displayed on the mode-line. The
    index into the string matches lslm$mode-chars(5)le.


cEcESEE ALSO cEcA


    lsuser-setup(3)lm$user-setup(3)le, lslm$mode-chars(5)le, lslm$mode-line(5)le.
! 5 $file-template
cEcENAME cEcA


    $file-template - Regular expression file search string
$a


cEcESYNOPSIS cEcA


    cD$file-templatecA "cCstringcA"; Default is ""


cEcEDESCRIPTION cEcA


    cD$file-templatecA defines a regular expression search string used to identify
    a file in the lslmgrep(3)le and lslmcompile(3)le buffers. The format of the string is
    the same as magic mode search strings (see lslmsearch-forward(2)le).


cEcEEXAMPLE cEcA


    A UNIX file name may be considered to contain any ASCII character except a
    space or a 'cG:cA' (used as a divider in many programs). Thus cD$file-templatecA
    should be:
sB
        set-variable $file-template "[!-9;-z]+"

sA
    This will correctly identify "cGfoo.ccA" in the following example.

        foo.c: 45:      printf("hello world\n") ;


cEcESEE ALSO cEcA


    lslm$line-template(5)le, lslmcompile(3)le, lslmget-next-line(2)le, lslmgrep(3)le,
    lslmsearch-forward(2)le.
! 5 $fill-col
! 5 $buffer-fill-col
cEcENAME cEcA


|$fill-col
    $fill-col - Global paragraph mode; right fill column
|$buffer-fill-col
    $buffer-fill-col - Buffer paragraph mode; right fill column
$a


cEcESYNOPSIS cEcA


    cD$fill-colcA cCcolumnNumbercA
    cD$buffer-fill-colcA cCcolumnNumbercA

    -1 <= cCcolumnNumbercA <= 32767 the default is cG78cA.


cEcEDESCRIPTION cEcA


    The cDfill-colcA variables specify the position of the right text margin, or
    fill column, when used with lslmfill-paragraph(2)le.

    cD$fill-colcA defines the global default fill column number, all new buffers
    that are subsequently created assume a fill column value of cD$fill-colcA.
    cCcolumnNumbercA defaults to 78 when undefined. This value is used in
    conjunction with lslmjustify(2m)le and lslmwrap(2m)le modes.

    cD$buffer-fill-colcA specifies the fill column value to use in a buffer, a
    value of cD$fill-colcA is used as a default when the buffer is created.
    Modification of the cD$buffer-fill-colcA causes the buffer fill column
    position to be modified, this does not affect any other buffer. The value
    is typically set by the cDfhook-xxxcA macro when initializing a buffer using
    the lslanguageTemplates(2)lmLanguage Templatesle. cD$buffer-fill-colcA may also be modified from
    lslmbuffer-setup(3)le.


cEcESEE ALSO cEcA


    lslm$buffer-fill-mode(5)le, lslm$fill-mode(5)le, lslmbuffer-mode(2)le, lslmbuffer-setup(3)le,
    lslmfill-paragraph(2)le, lslmjustify(2m)le, lslmwrap(2m)le.
! 5 $box-chars
cEcENAME cEcA


    $box-chars - Characters used to draw lines
$a


cEcESYNOPSIS cEcA


    cD$box-charscA "cCstringcA"; Default is "cG|+++++++++-cA"


cEcEDESCRIPTION cEcA


    cD$box-charscA is a fixed length string that defines the set of characters
    used to render lines to the screen. lsosd(2)lmOsd(2)le, lslmdirectory-tree(2)le,
    lslmlist-registry(2)le and many macros use these characters as a platform
    independent method of drawing lines. The characters have fixed indices
    defined as follows:-

    Index 0
        Line joining north to south (vertical line).

    Index 1
        Line joining south to east.

    Index 2
        Line joining south to west.

    Index 3
        Line joining north to east.

    Index 4
        Line joining north to west.

    Index 5
        Line joining east to south to west.

    Index 6
        Line joining north to east to south.

    Index 7
        Line joining north to east to south to west.

    Index 8
        Line joining north to south to west.

    Index 9
        Line joining north to east to south.

    Index 10
        Line joining east to west.


cEcEEXAMPLE cEcA


    The cD$box-charscA is typically platform dependent, it's setting is determined
    by the characters available in character set of the hosting platform.
    MS-DOS and Microsoft Windows environments might use a string such as:-

        "\xB3\xDA\xBF\xC0\xD9\xC2\xC3\xC5\xB4\xC1\xC4"


    X-Windows environments might use a string such as:-

        "\x19\x0D\x0C\x0E\x0B\x18\x15\x0F\x16\x17\x12"


    Both utilize platform specific characters.


cEcESEE ALSO cEcA


    lsosd(2)lmOsd(2)le, lslmdirectory-tree(2)le, lslmlist-registry(2)le lslm$window-chars(5)le.
! 5 $pause-time
! 5 $fmatchdelay
cEcENAME cEcA


    $pause-time - Length of time to pause for user
$a


cEcESYNOPSIS cEcA


    cD$pause-timecA cCmillisecondscA; Default is cG2000cA

    0 <= cCmillisecondscA <= cCtcA


cEcEDESCRIPTION cEcA


    Defines the number of milliseconds to pause, allowing the user to see some
    information. The pause time is used predominantly by the fence match
    operation, determining the time that the opening fence is displayed, see
    lslmfence(2m)le mode.

    The cD$pause-timecA is also used during the printing of some error messages on
    the message-line. These errors are typically important ones that should
    not be ignored so the system pauses to ensure the user has enough time to
    read them.


cEcENOTES cEcA


    The variable name was changed from cD$fmatchdelaycA in December 2004.


cEcESEE ALSO cEcA


    lslmfence(2m)le.
! 5 $global-scheme
cEcENAME cEcA


    $global-scheme - Default global buffer color scheme.
$a


cEcESYNOPSIS cEcA


    cG$global-schemecA cGschemeNumcA; Default is cG0cA


cEcEDESCRIPTION cEcA


    cD$global-schemecA defines the default buffer color scheme to cCschemeNumcA, a
    color scheme defined by lslmadd-color-scheme(2)le.


cEcESEE ALSO cEcA


    lslmadd-color(2)le, lslmadd-color-scheme(2)le, lslm$buffer-hilight(5)le, lslm$buffer-scheme(5)le,
    lslm$cursor-color(5)le, lslm$trunc-scheme(5)le, lslm$ml-scheme(5)le, lslm$osd-scheme(5)le,
    lslm$mode-line-scheme(5)le, lslm$scroll-bar-scheme(5)le, lslm$system(5)le.
! 5 %xgrep-com
cEcENAME cEcA


    %xgrep-com - Grep command line
$a


cEcESYNOPSIS cEcA


    cD%xgrep-comcA "cCstringcA"; Default is "cGgrep cA"


cEcEDESCRIPTION cEcA


    Sets the command line used to execute a cDgrep(1)cA system command. The output
    of the lslmxgrep(3)le execution should include both file and line number
    information so that the command lslmget-next-line(2)le can be used properly.
    This is not defined by default and the cDxgrepcA command will not execute
    until it is defined.

    cDgrep(1)cA is typically used with the cD-ncA option which produced line numbering
    information which drives the lslmget-next-line(2)le command.


cEcEEXAMPLE cEcA


    The following example shows how the cDxgrepcA strings are defined.
sB
        set-variable %xgrep-com "grep -n "
        0 add-next-line "*grep*"
        add-next-line "*grep*" "%f:%l:"

sA
    This definition corresponds to a cDgrepcA output such as:-

        m5var000.5:13:Sets the  number of seconds to wait
        m5var000.5:14:temporary file to t seconds. A
        m5var000.5:15:Note than the  temporary
        m5var000.5:17:saving a buffer.  Backup  files are
        m5var000.5:24:On unlimited  length  file  name  systems


    where cDgrepcA produces file and line number information for every match.

    Use lslmadd-next-line(2)le to define the line pattern produced by cDgrepcA. Some
    versions of cDgrepcA place the file name on a single line matches within the
    file occur on subsequent lines. In this case additional cCadd-next-linecA
    patterns may be defined to cater for the cDgrepcA output as follows:
sB
        set-variable %xgrep-com "grep /n "
        0 add-next-line "*grep*"
        add-next-line "*grep*" "File: %f:"
        add-next-line "*grep*" "%l:"

sA
    This definition would be used with a cDgrepcA output such as:-

        File:m5var000.5:
        13:Sets the  number of seconds to wait
        14:temporary file to t seconds. A
        15:Note than the  temporary
        17:saving a buffer.  Backup  files are
        24:On unlimited  length  file  name  systems
        File:m5var001.5:


cEcENOTES cEcA


    cDgrep(1)cA is a standard utility on UNIX systems. For Windows 95/NT a version
    of GNU cDgrepcA may be found at:

        cC<ftp.winsite.com/ftp/pub/pc/winnt/misc/gnugrep.zip>cA

    For MS-DOS users, a DJGPP port of cDgrepcA is also available on the net. A
    commercial version of cDgrepcA is also available from MKS.

    The MicroEmacs 2009 built in lslmgrep(3)le provides similar functionality and
    does not rely on an external program.


cEcESEE ALSO cEcA


    lslmadd-next-line(2)le, cDgrep(1)cA, lslmgrep(3)le, lslmxgrep(3)le, lslmrgrep(3)le, lslmadd-next-line(2)le.
! 5 $home
cEcENAME cEcA


    $home - Users `home' directory location
$a


cEcESYNOPSIS cEcA


    cD$homecA cCdirectorycA


cEcEDESCRIPTION cEcA


    cD$homecA contains the pathname of the users home directory. The file naming
    convention utilizes tilde ('cG~cA') to identify the users home directory
    (cG$HOMEcA). When entering a file name:

        ~/xxx    -> $home/xxx
        ~yyy/xxx -> $home/../yyy/xxx


    On most systems this is automatically set to the environment variable
    "HOME" if it is defined. On systems (i.e. Microsoft Windows or MS-DOS)
    where there may be no home defined then the system user directory is used
    by default. The value may be explicitly redefined by the user in the
    start-up file to be a different location. If cD$homecA is re-defined then
    ensure that a trailing directory separator is included at the end of the
    pathname.

    'cG~cA' may be used in pathname definitions in the macro files, files but must
    be specified as 'cG~cA', it is perhaps better to use cD$homecA.


cEcESEE ALSO cEcA


    lslm$user-path(5)le, lslm$user-name(5)le, lslm$progname(5)le, lslm$MENAME(5)le, lslm$MEINSTALLPATH(5)le,
    lsIntroduction to Variable FunctionslmVariable Functionsle.
! 5 $scroll
cEcENAME cEcA


    $scroll - Screen scroll control
$a


cEcESYNOPSIS cEcA


    cG$scrollcA cCscrollNumcA; Default is cG1cA

    0 <= cCscrollNumcA <= n


cEcEDESCRIPTION cEcA


    cD$scrollcA controls the horizontal and vertical scrolling method used to
    display long lines and buffers. The variable is split into two componants,
    the first nibble (cG0x0fcA) sets the horizontal scroll, and the second nibble
    (cG0xf0cA) sets the vertical. For the purpose of documentation these parts are
    kept separate, but when setting the variable a single combined value must
    be given.

    The horizontal settings are defined as follows:

    cG0x00cA
        Scroll method 0 will only scroll the current line, this is the fastest
        method in execution time.

    cG0x01cA
        Scroll method 1 (the default) will scroll the whole page horizontally
        when the lslmscroll-left(2)le and lslmscroll-right(2)le commands are used.
        However, when the current line must be scrolled to display the cursor
        due to a lslmforward-char(2)le type cursor movement, only the current line
        is scrolled and the rest are reset.

    cG0x02cA
        Scroll method 2 always scrolls the whole page horizontally, keeping
        the cursor in the current column range. If the cursor moves out of
        this range then all the page is scrolled to the new position. This is
        particularly useful when editing long lined tables.

    cG0x03cA
        Scroll method 3 fixes the scroll column using the cDscroll-leftcA and
        cDscroll-rightcA functions. If the current cursor position is not visible
        in the column range then only the current line is scrolled to the new
        position.

    The vertical settings are defined as follows:

    cG0x00cA
        Scroll method 0 (the default) will scroll the current line to the
        middle of the current window whenver it is moved off screen, this is
        the fastest method in execution time.

    cG0x10cA
        Scroll method 1 will scroll the current line to the the top of the
        window whenver the current line is moved off the screen using
        lslmbackward-line(2)le and to the bottom of the window when lslmforward-line(2)le
        is used. This creates the effect of a smooth scroll.


cEcEEXAMPLE cEcA


    The following example sets the scrolling method to be the default
    horizontally (cG0x01cA) and smooth method (cG0x10cA) vertically :
sB
        set-variable $scroll 0x11

sA

cEcESEE ALSO cEcA


    lslmscroll-left(2)le, lslmforward-line(2)le, lslm$window-x-scroll(5)le, lslm$window-y-scroll(5)le.
! 5 $fill-mode
! 5 $buffer-fill-mode
cEcENAME cEcA


|$fill-mode
    $fill-mode - Global paragraph mode; justification method
|$buffer-fill-mode
    $buffer-fill-mode - Buffer paragraph mode; justification method
$a


cEcESYNOPSIS cEcA


    cD$fill-modecA cCjustificationcA
    cD$buffer-fill-modecA cCjustificationcA

    cCjustificationcA cGbcA | cGccA | cGlcA | cGncA | cGocA | cGrcA | cGBcA | cGCcA | cGLcA | cGNcA | cGRcA the default is cGNcA


cEcEDESCRIPTION cEcA


    The cDfill-colcA variables specify the text justification modes for text
    filling of lslmfill-paragraph(2)le.

    cD$fill-modecA defines the global default justification mode i.e.
    cCleftcA/cCrightcA/cCbothcA/... The default value is cCnonecA cCautomaticcA (cDNcA). The modes
    available are:-

    cDbcA Both
        Enables left and right margin justification.

    cDccA Center
        Enables center justification.

    cDlcA Left
        Enables left justification.

    cDncA None
        No filling is performed, adjacent lines are not merged into a single
        line. This subtly different from cCleftcA justification which fills lines
        to the lslm$fill-col(5)le.

    cDocA One Line
        Enables the filling of the paragraph to a single line. Typically used
        to prepare a file for transfer to a word processing package.

    cDrcA Right
        Enables right justification.

    cDBcA Both (automatic)
        Automatically determines the mode, defaulting to left and right (both)
        justification.

    cDCcA Center (automatic)
        Automatically determines the mode, defaulting to center justification.

    cDLcA Left (automatic)
        Automatically determines the mode, defaulting to left justification.

    cDNcA None (automatic)
        Automatically determines the mode, defaults to cCbothcA and not cCnonecA.

    cDRcA Right (automatic)
        Automatically determines the mode, defaulting to right justification.

    cD$buffer-fill-modecA specifies the fill mode value to use in a buffer, a
    value of cD$fill-modecA is used as a default when the buffer is created.
    Modification of the cD$buffer-fill-modecA causes the buffer fill mode to be
    modified, this does not affect any other buffer. The value is set by the
    cDfhook-xxxcA macro when initializing a buffer using the lslanguageTemplates(2)lmLanguage Templatesle.
    cD$buffer-fill-modecA may also be modified from lslmbuffer-setup(3)le.

    The buffer lines are automatically justified only when the justification
    mode lslmjustify(2m)le is enabled. Justification is performed between the left
    and right margins, defined as 0 and lslm$buffer-fill-col(5)le respectively.


cEAutomatic Filling cA


    Automatic filling is performed when the mode cD$buffer-fill-modecA is
    specified in upper case. The format of the line (and adjacent lines) is
    interrogated and an cCinformedcA guess is made as to the expected formating
    which is then adopted. The criteria for automatic formatting is defined as
    follows:-

    cCcentercA
        If the left and right margins contain the same amount of white space
        +/-1 character then the paragraph is centered.

    cCrightcA
        If the text commences past half of the lslm$buffer-fill-col(5)le (i.e. first
        half of the line comprises white space) AND the line extends to, or
        past, the cG$buffer-fill-colcA then the paragraph is assumed to be right
        justified.

    cCnonecA
        If the text commences in column 0 and occupies less than half of the
        line then the paragraph is assumed to be not justified. (i.e. left
        justified, but consecutive lines of the paragraph are not filled)

    cCdefaultcA
        If none of the above criteria are met then the default mode is
        adopted, as determined by the lower-case value of the
        cD$buffer-fill-modecA value.


cEcESEE ALSO cEcA


    lslm$buffer-fill-col(5)le, lslm$fill-col(5)le, lslmbuffer-mode(2)le, lslmbuffer-setup(3)le,
    lslmfill-paragraph(2)le, lslmjustify(2m)le.
! 5 $line-template
cEcENAME cEcA


    $line-template - Command line regular expression search string
$a


cEcESYNOPSIS cEcA


    cD$line-templatecA "cCstringcA"; Default is ""


cEcEDESCRIPTION cEcA


    cD$line-templatecA defines a regular expression search string used to identify
    a line number in the lslmgrep(3)le and lslmcompile(3)le buffers. The format of the
    string is the same as magic mode search strings (see lslmsearch-forward(2)le).


cEcEEXAMPLE cEcA


    The line number may be considered to contain any numeric number, thus
    cD$line-templatecA is defined as:
sB
        set-variable $line-template "[0-9]+"

sA
    This correctly identifies "45" in the following cD*grep*cA output example:

        foo.c: 45:      printf("hello world\n") ;


cEcESEE ALSO cEcA


    lslm$file-template(5)le, lslmcompile(3)le, lslmget-next-line(2)le, lslmgrep(3)le,
    lslmsearch-forward(2)le.
! 5 $ml-scheme
cEcENAME cEcA


    $ml-scheme - Message line color scheme
$a


cEcESYNOPSIS cEcA


    cD$ml-schemecA cCschemeNumcA; Default is cG0cA


cEcEDESCRIPTION cEcA


    cD$ml-schemecA defines the color scheme to be used on the message line, the
    color scheme cCschemeNumcA identifies the foreground and background color and
    is defined by an invocation to lslmadd-color-scheme(2)le.

    The background color is always defined by lslm$global-scheme(5)le.


cEcESEE ALSO cEcA


    lslm$global-scheme(5)le, lslm$osd-scheme(5)le, lslm$mode-line-scheme(5)le,
    lslm$scroll-bar-scheme(5)le, lslm$system(5)le, lslmadd-color-scheme(2)le.
! 5 $mode-line
cEcENAME cEcA


    $mode-line - Mode line format
$a


cEcESYNOPSIS cEcA


    cD$mode-linecA "cCstringcA"; Default is "cG%s%r%u me (%e) - %l %b (%f) cA"


cEcEDESCRIPTION cEcA


    cD$mode-linecA defines the format of the mode line printed for every window,
    where the character following a percent ('cG%cA') has the following effect:-

        cGDcA Prints the current day.
        cGMcA Prints the current month.
        cGYcA Prints the current year (2 digits).
        cGycA Prints the current year (4 digits).
        cGbcA Prints the current buffer's name.
        cGccA Prints the current buffer's column number.
        cGecA Prints the current buffer's editing modes.
        cGfcA Prints the current buffer's file name.
        cGhcA Prints the current hour of the day.
        cGkcA Prints the current keyboard macro status.
        cGlcA Prints the current buffer's line number.
        cGmcA Prints the current minute of the hour.
        cGncA Prints the current buffer's total number of lines.
        cGrcA Prints the current root user status (UNIX only).
        cGscA Prints the horizontal window split character.
        cGucA Prints the current buffer's (un)changed or view mode flag.
        cG%cA Prints a percentage escape character.
        cG-cA Prints a literal minus character ('cG-cA') - see NOTES.
        cG*cA All other characters are printed literally.


cEcENOTES cEcA


        * Refer to lslm$window-chars(5)le for the characters utilized in the mode
          line. Typically a the 'cG-cA' character is changed to a 'cG=cA' if it is the
          current window. If a 'cG-cA' is always required, use "cG%-cA".
        * A buffer can have its own mode-line, and be uneffected be the global
          mode line, see lslm$buffer-mode-line(5)le.


cEcESEE ALSO cEcA


    lslm$buffer-mode-line(5)le, lslm$mode-line-scheme(5)le, lslm$window-chars(5)le.
! 5 $mode-line-scheme
cEcENAME cEcA


    $mode-line-scheme - Mode line color scheme
$a


cEcESYNOPSIS cEcA


    cD$mode-line-schemecA cCschemeNumcA; Default is cG1cA


cEcEDESCRIPTION cEcA


    Sets the window mode-line color scheme, defining the foreground and
    background colors. The cCschemeNumcA is defined by a previous invocation to
    lslmadd-color-scheme(2)le.


cEcESEE ALSO cEcA


    lslmadd-color-scheme(2)le, lslm$global-scheme(5)le, lslm$ml-scheme(5)le,
    lslm$scroll-bar-scheme(5)le, lslm$system(5)le.
! 5 $mouse-x
! 5 $mouse-y
cEcENAME cEcA


|$mouse-x
    $mouse-x - Mouse X (horizontal) position
|$mouse-y
    $mouse-y - Mouse Y (vertical) position
$a


cEcESYNOPSIS cEcA


    cD$mouse-xcA cCintegercA

    0 <= cCintegercA <= ls$frame-depth(5)lm$frame-widthle - 1

    cD$mouse-ycA cCintegercA

    0 <= cCintegercA <= ls$frame-depth(5)lm$frame-depthle - 1


cEcEDESCRIPTION cEcA


    cD$mouse-xcA and cD$mouse-ycA are automatically set to the position of the mouse
    at the last mouse event, where an event is a button press or release.
    Initialized to 0,0. The top left character of the screen is coordinate 0,0
    bottom right is ls$frame-depth(5)lm$frame-widthle, ls$frame-depth(5)lm$frame-depthle.


cEcENOTES cEcA


    These variables can not be set. Any attempt to set them will result in an
    error.


cEcESEE ALSO cEcA


    lslmset-cursor-to-mouse(2)le, lslm$mouse-pos(5)le, lslm$cursor-x(5)le, lslm$frame-depth(5)le,
    lslm$frame-width(5)le.
! 5 $platform
cEcENAME cEcA


|$platform
    $platform - MicroEmacs host platform identifier
|%platform
    %platform - MicroEmacs host platform type identifier
$a


cEcESYNOPSIS cEcA


    cD$platformcA "cCstringcA"; Default is platform specific
    cD%platformcA "cCstringcA"; Default is platform specific


cEcEDESCRIPTION cEcA


    The cD$platformcA variable is a fixed ASCII string used to identify the
    current working platform, attempts to set this variable result in an error
    returned from lslmset-variable(2)le.

    Possible values are:

    "cDaixcA"
        All IBM AIX O/S.

    "cDdoscA"
        All IBM-PCs and compatibles running MS-DOS.

    "cDfreebsdcA"
        All FreeBSD O/S.

    "cDhpuxcA"
        All Hewlett Packard's with HP-UX O/S.

    "cDirixcA"
        All Silicon Graphics (SGI) IRIX platforms 4.x, 5.x, 6.x.

    "cDlinuxcA"
        All LINUX O/S.

    "cDsunoscA"
        All Sun's with SUNOS O/S.

    "cDunixwr1cA"
        PC based UNIX platform (Consensus and Unixware).

    "cDwin32cA"
        Microsoft Windows based systems including Windows 3.x (with Win32s),
        Windows '95 and NT.

    cD$platformcA is often used in cD.emfcA files to allow portability of macro files
    across platforms, allowing macro files to perform platform specific
    operations. lslm$system(5)le is also often used for this purpose as its value is
    easier to assess.

    cD%platformcA is created at start-up when cGme.emfcA is executed, its value is
    identical to cD$platformcA except when the platform is a console in which case
    a 'cGccA' is appended to the $platform value, e.g. for MicroEmacs running a
    termcap version on LINUX the value will be "cGlinuxccA". The variable is used
    when the console and window based versions need to be distinguish, e.g.
    some of the lsuser-setup(3)lmuser-setuple settings.


cEcEEXAMPLE cEcA


    The following example is taken from the cDme.emfcA file which uses the
    cD$platformcA variable to load the platform specific initialization files.
sB
        ;
        ; load in the platform specific stuff
        execute-file $platform

sA
    This could be more explicitly done by:
sB
        ;
        ; load in the platform specific stuff
        !if   &seq $platform "dos"            ; is it an IBM-PC running dos ?
            execute-file "dos"
        !elif &seq $platform "irix"           ; is it an sgi ?
            execute-file "irix"
        !elif &seq $platform "hpux"           ; is it an hp ?
            execute-file "hpux"
            .
            .
        !endif

sA

cEcENOTES cEcA


    The cD$platformcA variable can not be set. Any attempt to set it will result
    in an error.


cEcESEE ALSO cEcA


    lslm$system(5)le, lslmset-variable(2)le.
! 5 $random
cEcENAME cEcA


    $random - Generate a random number
$a


cEcESYNOPSIS cEcA


    cG$randomcA cCintegercA

    0 <= cCintegercA <= 65535


cEcEDESCRIPTION cEcA


    The cD$randomcA variable returns a unique random number in the range 0 - cCncA on
    reference to the variable.

    The random number is derived from the system's random number generator
    (the quality of which is often dubious so try to avoid using the bottom
    bits). Setting this variable with any value resets the random sequence
    using the system time as the seed.

    The range of the random number generator is system dependent. The value is
    typically capped using the lslm&mod(4)le arithmetic operator.


cEcEEXAMPLE cEcA


    The variable may be assigned to generate a new seed as follows:-
sB
        set-variable $random 0        ; Set it so we get a new seed

sA
    The returned value is used with the cD&modcA operator to limit the value to a
    desired range:-
sB
        set-variable %random0to9 &mod $random 10

sA

cEcESEE ALSO cEcA


    lslm&mod(4)le.
! 5 $rcs-file
! 5 $rcs-ci-com
! 5 $rcs-cif-com
! 5 $rcs-co-com
! 5 $rcs-cou-com
! 5 $rcs-ue-com
cEcENAME cEcA


|$rcs-file
    $rcs-file - RCS (and SCCS) file name
|$rcs-ci-com
    $rcs-ci-com - RCS (and SCCS) check in command
|$rcs-cif-com
    $rcs-cif-com - RCS (and SCCS) check in first command
|$rcs-co-com
    $rcs-co-com - RCS (and SCCS) check out command
|$rcs-cou-com
    $rcs-cou-com - RCS (and SCCS) check out unlock command
|$rcs-ue-com
    $rcs-ue-com - RCS (and SCCS) unedit file command
$a


cEcESYNOPSIS cEcA


    cD$rcs-filecA "cCstringcA"; Default is ""
    cD$rcs-ci-comcA "cCstringcA"; Default is ""
    cD$rcs-cif-comcA "cCstringcA"; Default is ""
    cD$rcs-co-comcA "cCstringcA"; Default is ""
    cD$rcs-cou-comcA "cCstringcA"; Default is ""
    cD$rcs-ue-comcA "cCstringcA"; Default is ""


cEcEDESCRIPTION cEcA


    RCS (Revision Control System) and SCCS (Source Code Control System) are
    programmers source code history data-bases. RCS introduces a system in
    which only one programmer can edit a source file at any one time,
    enforcing some form of stability in the global environment. The fact that
    this interface was developed for the RCS system is irrelevant, and should
    be usable under any other control systems such as SCCS.

    When using RCS, finding a file (see lslmfind-file(2)le) checks for the existence
    of the actual file. If this is not found then it checks for the existence
    of an RCS cD$rcs-filecA variable, and if present then it constructs the RCS
    file name and checks for its existence. If this file does not exist then
    it really is a new file and an new buffer is created. If the file does
    exist then the file is checked out using the cD$rcs-co-comcA which executes to
    create a file with the original file name, ready for loading.

    cD$rcs-filecA is the name of the file when it is fully check in, as opposed to
    when it is ready to be viewed or edited. In RCS, this is usually in the
    cGRCScA directory with an appended "cG,vcA", i.e. for the file cGfoo.ccA in the cG/testcA
    directory, when fully checked in, the file will not be found at
    "cG/test/foo.ccA", but at "cG/test/RCS/foo.c,vcA". When testing for an RCS file,
    the file name is split into two parts, the path name and the file name,
    the path is always inserted at the start, and the file name can inserted
    in the rcs string by using the special "cG%fcA" token, thus if cD$rcs-filecA is
    set to "cGRCS/%f,vcA", the RCS file name is constructed from "cG/test/cA" + "cGRCS/cA"
    + "cGfoo.ccA" + "cG,vcA".

    If the RCS file is found then the cD$rcs-co-comcA (RCS cDCcAheck cDOcAut cDCOMcAmand)
    which is a simple system command line with the exception for cG%fcA which is
    replaced by the file name, is executed. This is expected to create the
    file (with the correct file name) ready for viewing.

    Once a file is loaded, then the lslmrcs-file(2)le command has one of two
    effects:-

        If the file is in view mode then the cD$rcs-cou-comcA (RCS cDCcAheck cDOcAut
        cDUcAnlock cDCOMcAmand) is executed (system command line using the "%f" as the
        file name). If the RCS file does not exist then is simply toggles the
        view mode, allowing editing.

        If the file is not in view mode MicroEmacs attempts to check the file
        back into RCS using either cD$rcs-ci-comcA (if the RCS file already
        exists) or the the cD$rcs-cif-comcA (RCS cDCcAheck cDIcAn cDFcAirst cDCOMcAmand). The "cG%fcA"
        is again used for the file name, the "cG%mcA" can also be used to get a
        comment from the user at check in time which will be inserted (without
        quotes) into the cD$rcs-ci-comcA command line. For example, one possible
        cD$rcs-ci-comcA setting is "cGci -m\"%m\" %fcA" which uses the cDci(1)cA program
        with the cD-mcA option to give a check in message.

    If cDrcs-filecA is given a negative argument instead of checking in or out the
    current buffer's file it executes the command specified by cD$rcs-ue-comcA to
    unedit or abort any changes made to the file. After the command has been
    executed the file is reloaded.


cEcENOTES cEcA


    The RCS variables are by default undefined and must be explicitly enabled
    in the start-up files.


cEcEEXAMPLE cEcA


    The following are typical variable definitions for the RCS interface:-
sB
        set-variable $rcs-file     "RCS/%f,v"
        set-variable $rcs-co-com   "co %f"
        set-variable $rcs-cou-com  "co -l %f"
        set-variable $rcs-ci-com   "ci -u -m\"%m\" %f"

sA
    Note that the cD$rcs-cif-comcA variable is usually left unassigned and
    cD$rcs-ci-comcA is used by default.

    The following are typical variable definitions for the SCCS interface:-
sB
        set-variable $rcs-file     "SCCS/s.%f"
        set-variable $rcs-co-com   "sccs get %f"
        set-variable $rcs-cou-com  "sccs edit %f"
        set-variable $rcs-ci-com   "sccs delget -y\"%m\" %f"
        set-variable $rcs-ci-com   "sccs create %f"
        set-variable $rcs-ue-com   "sccs unedit %f"

sA
    The following variable definitions can be used for MicroSoft's Visual
    Source Safe:-
sB
        set-variable $rcs-file    "%f"
        set-variable $rcs-cou-com "ss.exe checkout %f"
        set-variable $rcs-co-com  "ss.exe checkout %f"
        set-variable $rcs-ci-com  "ss.exe checkin %f \"-c%m\""

sA
    The above definitions can check a file out for edit and commit changes
    back.


cEcESEE ALSO cEcA


    lslmfind-file(2)le, lslmrcs-file(2)le.
! 5 $frame-depth
! 5 $frame-width
! 5 $screen-depth
! 5 $screen-width
cEcENAME cEcA


|$frame-depth
    $frame-depth - Number of lines on the current frame canvas
|$frame-width
    $frame-width - Number of columns on the current frame canvas
$a


cEcESYNOPSIS cEcA


    cD$frame-depthcA cCintegercA

    3 <= cCintegercA <= 400

    cD$frame-widthcA cCintegercA

    8 <= cCintegercA <= 400


cEcEDESCRIPTION cEcA


    These variables allow the viewable size of the current frame canvas to be
    determined.

    cD$frame-depthcA identifies depth of the current frame given as the number of
    character lines. This is the whole frame width, not just what is currently
    visible. The value returned is in the range 3 - cCncA, cCncA is system dependent
    but no greater than 400.

    cD$frame-widthcA identifies the width of the current frame as the number of
    character columns. The value returned is in the range 8 - cCncA, cCncA is system
    dependent but no greater than 400.


cEcENOTES cEcA


    The name of these variables changed from cD$screen-depthcA and cD$screen-widthcA
    due to the support for multiple frames introduced in April 2002.


cEcESEE ALSO cEcA


    lslmchange-frame-depth(2)le, lslmchange-frame-width(2)le.
! 5 $mouse-pos
cEcENAME cEcA


    $mouse-pos - Mouse position information
$a


cEcESYNOPSIS cEcA


    cD$mouse-poscA cCintegercA


cEcEDESCRIPTION cEcA


    cD$mouse-poscA is generated by invocation of the command
    lslmset-cursor-to-mouse(2)le. The variable is set to a value that indicates the
    position of the mouse within a window. The values to the mouse
    intersection are interpreted as follows:-

    cD0 - Text areacA
        Intersection with the window text area.

    cD1 - Message LinecA
        Intersection with the message line.

    cD2 - Mode LinecA
        Intersection with the mode line.

    cD3 - Horizontal SeparatorcA
        Intersection with the horizontal window separator. This value is only
        set if a scroll bar is not present.

    cD4 - Up ArrowcA
        Intersection with the scroll bar up-arrow character.

    cD5 - Upper ShaftcA
        Intersection with the scroll bar upper shaft (above the scroll box).

    cD6 - Scroll BoxcA
        Intersection with the scroll bar scroll box.

    cD7 - Lower ShaftcA
        Intersection with the scroll bar lower shaft (below the scroll box).

    cD8 - Down ArrowcA
        Intersection with the scroll bar down-arrow character.

    cD9 - CornercA
        Intersection with the window corner, that is the character at the
        intersection of the scroll bar (or separator) and the mode line.

    cD10 - Menu LinecA
        Intersection with the menu line.

    cD255 - ErrorcA
        The position of the mouse could not be determined. This value should
        not arise, if it does then it is an indication that the window
        structure is probably corrupted. A lslmdelete-other-windows(2)le is
        suggested or rapid exit from the editor after a lslmsave-some-buffers(2)le
        command to save any edits (latter option is preferred).

    cDBit 4 - 2nd ColumncA
        Bit 4 (16) is set if 2 character column scroll bar or vertical window
        separator is in effect and the cursor exists in the second column This
        value is bitwise OR'ed with the aforementioned intersection values.


cEcEEXAMPLE cEcA


    The following macro can be used to print out the current position of the
    mouse, try binding the macro to the "cGmouse-movecA" key:
sB
        define-macro print-mouse-position
            !force set-cursor-to-mouse
            set-variable #l0 &band $mouse-pos 15
            !if &equ #l0 0
                ml-write "Mouse in text window"
            !elif &equ #l0 1
                ml-write "Mouse on message line"
            !elif &equ #l0 2
                ml-write "Mouse on Mode line"
            !elif &and &gre #l0 2 &les #l0 10
                ml-write "Mouse on scroll bar"
            !elif &equ #l0 10
                ml-write "Mouse on corner"
            !elif &equ #l0 11
                ml-write "Mouse on menu line"
            !endif
        !emacro

        global-bind-key print-mouse-position mouse-move

sA
    cD$mouse-poscA is utilized by the mouse picking code, found in macro file
    cGmouse.emfcA.


cEcESEE ALSO cEcA


    lslm$mouse-x(5)le, lslm$mouse-y(5)le, lslmset-cursor-to-mouse(2)le,
    lslmset-scroll-with-mouse(2)le.
! 5 %compile-com
cEcENAME cEcA


    %compile-com - Default system compile command line
$a


cEcESYNOPSIS cEcA


    cD%compile-comcA "cCstringcA"; Default is "cGmakecA"


cEcEDESCRIPTION cEcA


    Sets the default command-line inserted into the message line when the
    lslmcompile(3)le command is executed. cD%compile-comcA does not need to be defined
    to run the cDcompilecA command.


cEcESEE ALSO cEcA


    lslmcompile(3)le, lslm%xgrep-com(5)le.
! 5 $status
cEcENAME cEcA


    $status - Macro command execution status
$a


cEcESYNOPSIS cEcA


    cD$statuscA cCbooleancA

    cCbooleancA cGTRUEcA (1) | cGFALSEcA (0)


cEcEDESCRIPTION cEcA


    cD$statuscA contains the return status of the last command executed (cGTRUEcA or
    cGFALSEcA). cD$statuscA is generally used with the ls!force(4)lm!forcele directives in macros.


cEcENOTES cEcA


    This variable can not be set, any attempt to set it will result in an
    error.


cEcEEXAMPLE cEcA


    The following example shows how the variable is used within a macro
    construct, it converts all tab characters to their SPACE equivalent.
sB
        ;
        ; tabs-to-spaces.
        ; Convert all of the tabs to spaces.
        define-macro tabs-to-spaces
            ; Remember line
            set-variable #l0 $window-line
            beginning-of-buffer
            !force search-forward "\t"
            !while $status
                set-variable #l1 $window-acol
                backward-delete-char
                &sub #l1 $window-acol insert-space
                !force search-forward "\t"
            !done
            goto-line #l0
            screen-update
            ml-write "[Converted tabs]"
        !emacro

sA
    In this case cD$statuscA monitors the lssearch-forward(2)lmsearch-forwardle command which is
    searching for a tab character. The command returns a status value of cGTRUEcA
    if a tab is found, otherwise cGFALSEcA.

    The cD!forcecA statement prevents the macro from terminating when a cGFALSEcA
    condition is detected, if omitted the macro would terminate with an error
    as soon as the cGFALSEcA status is encountered. The definition of
    lslmtabs-to-spaces(3)le can be found in format.emf.


cEcESEE ALSO cEcA


    lslmexecute-file(2)le, lslm!force(4)le, lslm$result(5)le, lslmtabs-to-spaces(3)le.
! 5 $result
cEcENAME cEcA


    $result - Various command return values
$a


cEcESYNOPSIS cEcA


    cD$resultcA cCreturnValuecA


cEcEDESCRIPTION cEcA


    cD$resultcA is used to return the results of several commands:

    lslmbuffer-info(2)le cD$resultcA is set to the same output string as printed to the
    message-line by this command.

    lslmchange-font(2)le
        cD$resultcA is used to return the user select font when hte windows font
        selection dialog is used (Windows systems only).

    lslmcount-words(2)le
        cD$resultcA is set to the same output string as printed to the
        message-line by this command.

    lslmfile-op(2)le
        cD$resultcA is used to return an error code when the command fails.

    lslmfind-registry(2)le
        cD$resultcA is used to return the name of a registry child node given the
        parent and index from the user.

    lslmmark-registry(2)le
        cD$resultcA is used to return the full name of the given registry node.

    lslmreplace-string(2)le
        lslmquery-replace-string(2)le

        cD$resultcA is used to return the number of substitutions, the final
        replace mode ('a' for all, 'l' for last or 'q' for query) and the
        replace with string in a list.

    lslmosd(2)le

        cD$resultcA is used to give and return information to osd item commands,
        information depends on the type of cDosdcA item.

    lslmosd-dialog(3)le
        lslmosd-xdialog(3)le

        cD$resultcA is used to return the button pressed by the user.

    lslmshell-command(2)le

        cD$resultcA is set to the exit status of the cDsystemcA call. The combination
        of cDshell-commandcA calls and return value checking can be used in a
        variety of ways, for example, to test the existence of a file:
sB
        set-variable %filename @ml"Enter file name"
        shell-command &cat "test -f " %filename
        !if &equ $result 0
            ml-write "file exists"
        !else
            ml-write "file does not exists"
        !endif

sA
    lslmshow-region(2)le

        cD$resultcA is set to the current status of the region when an argument of
        cC0cA is given to cDshow-regioncA.

    lslmspell(2)le

        cD$resultcA is used to return information on the current word, the
        information depends on the argument given to cDspellcA.

    lslm$file-names(5)le

        cD$resultcA is set to the absolute path of the cD$file-namescA query directory
        when the variable is set.

    For more information see the help pages on referenced commands and
    variables.


cEcENOTES cEcA


    The current value of cD$resultcA is lost on the next command call which uses
    it. As a call to lslmcreate-callback(2)le can cause the execution of a macro to
    interrupt another which is waiting for user input, the value of cD$resultcA
    should be copied before getting user input.


cEcESEE ALSO cEcA


    lslmbuffer-info(2)le, lslmchange-font(2)le, lslmcount-words(2)le, lslmfile-op(2)le,
    lslmfind-registry(2)le, lslmmark-registry(2)le, lslmquery-replace-string(2)le, lslmosd(2)le,
    lslmshell-command(2)le, lslmshow-region(2)le, lslmspell(2)le, lslm$file-names(5)le.
    lslmcreate-callback(2)le, lslm$status(5)le.
! 5 $tab-width
cEcENAME cEcA


    $tab-width - Global tab character width
$a


cEcESYNOPSIS cEcA


    cD$tab-widthcA cCintegercA; Default is cG8cA

    -0 < cCintegercA <= cCncA


cEcEDESCRIPTION cEcA


    cD$tab-widthcA defines the default width of a tab character specified in
    spaces. The default value is used when new files are loaded and created
    and seeds the variable lslm$buffer-tab-width(5)le.

    Setting tabs to arbitrary widths is possible in MicroEmacs 2009 but you
    must be aware of a subtle difference that it makes to your file and hence
    to your editing. When you start MicroEmacs 2009, the tab width is set to
    the default (usually every 8th column) for the tab character (cGCTRL-IcA). As
    long as you stay with the default, every time you insert the tab
    character, a CTRL-I get inserted. Hence, you logically have a single
    character which might appear to be several spaces on the screen (or the
    output) depending upon the column location of the tab character. This
    means that to remove the spacing you have to delete a cCsinglecA character --
    the tab character.

    On the other hand, the moment you explicitly set the tab interval (even if
    it is to the default value), MicroEmacs 2009 handles the tab character by
    expanding the character into the required number of spaces to move you to
    the appropriate column. In this case, to remove the spacing you have to
    delete the appropriate number of spaces inserted by M-e to get you to the
    right column.

    The operating mode of the tab expansion is controlled by the lslmtab(2m)le mode.


cEcENOTES cEcA


    The November 2004 version of MicroEmacs removed the existing variables
    cD$tabwidthcA and cD$tabsizecA which were ambiguous. The existing variable scope
    was global which caused problems when moving to buffers with different tab
    width properties. The variables have been replaced with cD$tab-widthcA and
    lslm$buffer-tab-width(5)le. The indentation which was previously controlled by
    the tab width has been replaced with lslm$indent-width(5)le and
    lslm$buffer-indent-width(5)le.


cEcESEE ALSO cEcA


    lslmbuffer-mode(2)le, lslmtab(2m)le, lslm$buffer-indent-width(5)le, lslm$buffer-tab-width(5)le,
    lslm$indent-width(5)le.
! 5 $buffer-tab-width
cEcENAME cEcA


    $buffer-tab-width - Buffer tab character interval
$a


cEcESYNOPSIS cEcA


    cD$buffer-tab-widthcA cGintegercA; Default is lslm$tab-width(5)le.

    -0 < cCintegercA <= cCncA


cEcEDESCRIPTION cEcA


    cD$buffer-tab-widthcA defines the width of a tab character in terms of
    displayable spaces, a tab character is typically 8 spaces. A tab character
    appearing in a buffer is rendered with up to cD$buffer-tab-widthcA spaces to
    take it to the next column boundary of modulo cD$buffer-tab-widthcA.

    Modification of the variable value causes the displayed tab width to
    change to the new value. The macro lslmtabs-to-spaces(3)le may be used to
    convert all tabs to spaces.

    When a buffer is created (file loading or creation) then the default value
    is taken from the lslm$tab-width(5)le variable.


cEcENOTES cEcA


    The indentation of a buffer is controlled by the lslm$buffer-indent-width(5)le
    and not the cD$buffer-tab-widthcA when automatic lslmindent(2)le is enabled.

    The November 2004 version of MicroEmacs removed the existing variables
    cD$tabwidthcA and cD$tabsizecA which were ambiguous. The existing variable scope
    was global which caused problems when moving to buffers with different tab
    width properties. The variables have been replaced with lslm$tab-width(5)le and
    cD$buffer-tab-widthcA. The indentation which was previously controlled by the
    tab width has been replaced with lslm$indent-width(5)le and
    lslm$buffer-indent-width(5)le.


cEcESEE ALSO cEcA


    lslm$buffer-indent-width(5)le, lslm$indent-width(5)le, lslm$tab-width(5)le, lslmbuffer-mode(2)le,
    lslmindent(2)le, lslmtab(2m)le, lslmtabs-to-spaces(3)le.
! 5 %tag-file
! 5 %tag-template
! 5 %tag-option
cEcENAME cEcA


|%tag-file
    %tag-file - Tags file name
|%tag-template
    %tag-template - Tag file search string
|%tag-option
    %tag-option - Tag file search option
$a


cEcESYNOPSIS cEcA


    cD%tag-filecA "cCfileNamecA"
    cD%tag-templatecA "cCstringcA"
    cD%tag-optioncA "cCstringcA"


cEcEDESCRIPTION cEcA


    The cD%tag-filecA and cD%tag-templatecA variables must be defined for lslmfind-tag(2)le
    to work, they define the information required to locate tag references.

    cD%tag-filecA is the name of the tag file to be used, usually set to "cDtagscA".
    cD%tag-templatecA is a regular expression search string used to identify tags
    in a tag file. For example, a tag usually consists of a name "cG%[^\t]cA"
    followed by a tab "cG\tcA" followed by the file name that contains the
    function "cG%[^\t]cA" followed by another tab, followed by the search string
    and end of line "cG%[^\n]\ncA", i.e.
sB
        set-variable %tag-template  "%[^\t]\t%[^\t]\t%[^\n]\n"

sA
    This would match a cDvi(1)cA tag string definition, as created by the UNIX
    utility cDctags(1)cA. The tags file typically contains entries such as:-

        $auto-time    m5var000.5 /^.XI $auto-time - "Automatic buffer"$/
        $buffer-bhook m5var002.5 /^.XI $buffer-bhook - "Buffer macro"$/
        $buffer-ehook m5var002.5 /^.XI $buffer-ehook - "Buffer macro"$/


    The cDtag-templatecA definition is modified to match the output of the
    cDctags(1)cA utility. The format of the tags file may differ from platform to
    platform, typically the differences are encountered in the line contents
    field which is usually defined as cG/ .... /cA for a forward search tag and cG?
    .... ?cA for a reverse search tag. Note that a tag's search string typically
    starts with the character 'cG^cA' and ends with 'cG$cA' which indicate the start
    and end of the line. The variable fields are expected to be in
    conventional order of cClabelcA, cCfilenamecA and cClineTextcA.

    cD%tag-optioncA is a user defined variable that modifies the behavior of
    lslmfind-tag(2)le. This is defined as a string, where each character identifies
    an option, when undefined then default behavior is assumed. The options
    are defined as:-

    cDmcA - Enable multiple tags support
        Allows a single tag to be present multiple times in the tag file,
        typically used when a function is defined multiple times. When enabled
        cDfind-tagcA can be used to loop through all definitions of a given tag.

    cDrcA - recursive tags file
        By default, the cDtagscA file is assumed to reside in the current
        directory location. The cDrcA option enables an ascending search up the
        directory hierarchy from the current directory position in search of a
        recursively generated tags file.

    cDccA - Continue recursive tag search
        Used in conjunction with flag cDrcA; when not specified, the recursive
        searching of a tag stops at the first tag file found, regardless of
        whether the given tag was located in the found tag file. If this flag
        is given and the tag was not found in the first tag file, the
        recursive search continues. This allows local tag files to be created
        and regularly maintained, yet still being able to access a higher
        level tag file when required.

    Modifications to this variable should be made in the cCusercA.emf file, e.g.
    To enable multi recursive ascent tag searching define:-
sB
        set-variable %tag-option  "mrc"

sA

cEcENOTES cEcA


    Note that GNU Emacs uses it's own tag file format generated by cDetags(1)cA
    which does not contain the appropriate information to drive the MicroEmacs
    2009 cDfind-tagcA command.

    The above settings should support the extended version 2 tag file format
    which has an extra tag type field at the end of each line.


cEcESEE ALSO cEcA


    cDctags(1)cA, lslmctags(3f)le, lslmfind-tag(2)le, cDvi(1)cA.
! 5 $timestamp
cEcENAME cEcA


    $timestamp - Time stamp string
$a


cEcESYNOPSIS cEcA


    cD$timestampcA "cCstringcA"; Default is "cG<%Y%M%D.%h%m>cA"


cEcEDESCRIPTION cEcA


    cD$timestampcA defines the file time-stamping string. MicroEmacs 2009 searches
    for, and modifies, the string to the current time and date whenever the
    file is saved (written to disk) and lslmtime(2m)le mode is enabled.

    Time stamp string is defined, by default, as "cG<%Y%M%D.%h%m>cA". The first
    occurrence of the string in the file is up-dated with the time and date
    information when the buffer is written. The cD$timestampcA string may contain
    any text, and includes the following, magic characters escaped by a
    percentage (`cG%cA') character:-

        cGDcA - Day.
        cGMcA - Month.
        cGYcA - Year.
        cGhcA - Hour.
        cGmcA - Minute.
        cGscA - Second.

    The format string may be redefined into any format. The 'cG%cA' character has
    to be delimited by another 'cG%cA' if it is to be used in the text (i.e.
    "cG%%cA").

    The year component (cG%YcA) may be a 2 or 4 digit string, depending whether it
    includes the century. When the time stamping searches for the cG%YcA component
    it searches for either variant and replaces appropriately.


cEcEEXAMPLE cEcA


    The startup file may define the time stamp required as follows:-
sB
        set-variable $timestamp "Last Modified : %Y/%M/%D %h:%m:%s"

sA
    Time stamping is performed on the string :-

        Last Modified : 90/11/23 10:12:01


    Where the time stamp is modified according to the file (buffer) type then
    the time stamp string may be modified within the buffer hooks. This allows
    different files to utilize different time stamping strings. The following
    example shows how the entry and exit buffer hooks are defined to modify
    the string:
sB
        0 define-macro bhook-nroff
            set-variable .timestamp $timestamp
            ; Buffer specific time stamp string.
            set-variable $timestamp "[%Y/%M/%D %h:%m:%s]"
        !emacro
        0 define-macro ehook-nroff
            ; Restore the existing time stamp.
            set-variable $timestamp .bhook-nroff.timestamp
        !emacro

sA
    On entry to the buffer (buffer becomes current) the buffer hook
    cDbhook-nroffcA is executed which stores the current setting and then modifies
    the time stamp string. On exit from the buffer the buffer hook cDehook-nroffcA
    is executed restoring the time stamp string.


cEcESEE ALSO cEcA


    lslmbuffer-mode(2)le lslmtime(2m)le.
! 5 $window-mode-line
! 5 $window-scroll-bar
cEcENAME cEcA


|$window-mode-line
    $window-mode-line - Window mode line position
|$window-scroll-bar
    $window-scroll-bar - Window scroll bar (or separator) position
$a


cEcESYNOPSIS cEcA


    cD$window-mode-linecA cCintegercA

    1 <= cCintegercA <= ls$frame-depth(5)lm$frame-depthle - 2

    cD$window-scroll-barcA cCintegercA

    0 <= cCintegercA <= ls$frame-depth(5)lm$frame-widthle - 1


cEcEDESCRIPTION cEcA


    cD$window-mode-linecA stores the screen line of the current windows mode-line,
    where screen lines are counted from 0 at the top of the screen. Often used
    in conjunction with lslmset-cursor-to-mouse(2)le and lslm$mouse-y(5)le to add more
    complex mouse functionality.

    cD$window-scroll-barcA stores the screen position of the right-hand horizontal
    window separator line or scroll-bar (see lslmsplit-window-horizontally(2)le and
    lslm$scroll-bar(5)le). A value of greater than lslm$frame-width(5)le indicates that
    there is no right-hand separator column or scroll bar present. Often used
    in conjunction with lslm$mouse-x(5)le.


cEcEEXAMPLE cEcA


    In the following example the position of the mouse is checked to see if it
    is on the mode line of the window, if so then a different action is taken.
sB
        set-cursor-to-mouse
        ;   If we are on the mode line then interpret position of
        ;   the cursor on line to control the screen.
        !if &equal $window-mode-line $mouse-y
            !if &less $mouse-x "2"
                menu-main     ; Inform buffer to pop up menu.
            !elif &equal $mouse-x "2"
                delete-window
            !elif &equal $mouse-x "3"
                delete-other-windows
            !elif &equal $mouse-x "4"
                backward-page
            !elif &equal $mouse-x "5"
                forward-page
            !elif &equal $mouse-x "6"
                recenter
            !elif &equal $mouse-x "7"
                undo
            !endif
        !else
            .....
        !endif

sA

cEcESEE ALSO cEcA


    lslm$mode-line(5)le, lslm$mouse-x(5)le, lslm$mouse-y(5)le, lslm$scroll-bar(5)le, lslm$mouse-pos(5)le,
    lslmset-cursor-to-mouse(2)le, lslmsplit-window-horizontally(2)le.
! 5 $system
cEcENAME cEcA


    $system - System configuration variable
$a


cEcESYNOPSIS cEcA


    cD$systemcA cCbitmaskcA; Default is system dependent


cEcEDESCRIPTION cEcA


    The cD$systemcA is used to define and configure the MicroEmacs environment, it
    is a bit based flag where:-

    cD0x001cA
        This bit is set if MicroEmacs is running in Console mode. On UNIX
        systems the default is to use X whenever possible, in which case this
        bit will be clear. If X is not used then a TERMCAP base interface is
        used instead and this bit will be set (see notes below on how to set
        which interface to use). On all other systems this bit will be clear.

    cD0x002cA
        If this bit is set then the current system supports definable RGB
        colors allowing any color to be created and used in a lsadd-color(2)lmcolor schemele.
        This bit cannot be set, typically Windows and UNIX X-Windows systems
        support this.

    cD0x004cA
        If this bit is set then the current system supports ANSI colors (8
        colors, black, red, green, yellow, blue, magenta, cyan & white), bits
        0x002 and 0x004 are mutually exclusive. On UNIX systems if the TERMCAP
        interface is being used then this bit can be changed to (de)select the
        used of color. Many unix terminals do not support color so this should
        be set appropriately. On all other systems this bit cannot be changed
        and MS-DOS is currently the only other system to use ANSI colors.

    cD0x008cA
        If this bit is set then the current system supports Extended ANSI
        colors, brighter versions of the 8 ANSI colors doubling the number of
        colors available to 16. On UNIX systems if the TERMCAP interface is
        being used then this bit can be changed to (de)select the used of bold
        with color to create this extended color set for foreground colors.
        But many UNIX terminals do not support this use of color with the bold
        font so this should be set appropriately. On all other systems this
        bit cannot be changed and MS-DOS is currently the only other system to
        support this.

    cD0x010cA
        If this bit is set then the current system supports the use of fonts
        (bold, italic, light and underline). Whether these fonts can be
        successfully utilized depends upon the platform and the system font
        being used, for UNIX TERMCAP systems it will also depend on the
        terminal being used. This option is not supported on MS_DOS.

    cD0x020cA
        When this bit is set the cursor is always shown in OSD (main menu)
        dialogs, this helps to improve navigation of dialogs ion systems with
        limited colors.

    cD0x080cA
        This bit is set if the current system is a UNIX based system such as
        LINUX or HPUX. This bit cannot be altered, its use is within macros.

    cD0x100cA
        This bit is set if the current system is a Microsoft based system such
        as DOS or Windows '95. This bit cannot be altered, its use is within
        macros.

    cD0x200cA
        If this bit is set then the current system uses the concept of drives
        (i.e. cGc:/cA on DOS systems). This bit cannot be altered, its use is
        within macros.

    cD0x400cA
        If this bit is set then a DOS style cG8.3cA file naming system should be
        used (i.e. "cGBBBBBBBB.XXXcA"), otherwise an unlimited file name length is
        used. This effects the backup and auto-save file names generated by
        MicroEmacs, the bit can be altered on systems that support unlimited
        file name length.

    cD0x800cA
        If this bit is set then the current system supports and uses
        lslmipipe-shell-command(2)le when required. For systems such as DOS which
        cannot support ipipes, this bit will be clear and cannot be altered.
        For systems which do support ipipes, this bit can be cleared to
        disable their use.

    cD0x1000cA
        If this bit set, the then execution of the lslmtab(2)le command (bound to
        cGtabcA) always checks and adjusts the indentation of the current line
        when the current buffer has an lsindent(2)lmindentationle method. If the bit is clear
        then the cGtabcA may only checks the indentation when the cursor is in
        column zero depending on the setting of bit cD0x200000cA.

    cD0x2000cA
        If this bit is set the main menu Alt hot-key bindings are enabled.
        These are dynamic bindings automatically generated from the main menu.
        Typically the first item in the main menu is "cGFilecA" with a hot key of
        'cDFcA', with this bit set 'cGA-fcA' will open this menu item. Note that
        global and local key bindings override these. Also see bit cD0x4000cA.

    cD0x4000cA
        If this bit is set the Alt key acts as a lsprefix(2)lmprefix 1le modifier key. By
        default 'cGA-ncA' is not bound, with this bit set the key is inferred to
        'cGesc ncA' which is bound to cDforward-paragraphcA. Note that global, local
        and menu hot-key bindings override these. Also see bit 0x2000.

    cD0x8000cA
        If this bit is set the lsundo(2)lmundole history is kept after a save allowing the
        lslmundo(2)le command to back-up changes beyond the last save. When clear
        the undo history is discarded after the buffer is saved.

    cD0x10000cA
        Enable box character rendering fix, supported on Win32 and XTerm
        interfaces only. Windows ANSI fonts and many XTerm ISO-8859-1 fonts do
        not have well formed box characters which are used by lslmosd(2)le and other
        commands to create a better looking interface. When this bit is
        enabled MicroEmacs traps the printing of characters with an ASCII
        value of less than 32 and renders them directly. Following is a table
        of supported characters, other characters in the range of cG0x00cA to cG0x1fcA
        not listed are rendered as a space:

            cG0x08cA
                Special Character; Backspace

            cG0x09cA
                Special Character; Tab

            cG0x0bcA
                Box Character; Bottom right

            cG0x0ccA
                Box Character; Top right

            cG0x0dcA
                Box Character; Top left

            cG0x0ecA
                Box Character; Bottom left

            cG0x0fcA
                Box Character; Center cross

            cG0x10cA
                Arrows; Right

            cG0x11cA
                Arrows; Left

            cG0x12cA
                Box Character; Horizontal line

            cG0x15cA
                Box Character; Left Tee

            cG0x16cA
                Box Character; Right Tee

            cG0x17cA
                Box Character; Bottom Tee

            cG0x18cA
                Box Character; Top Tee

            cG0x19cA
                Box Character; Vertical Line

            cG0x1ecA
                Arrows; Up

            cG0x1fcA
                Arrows; Down

    cD0x20000cA
        Enables the client server, default is disabled (UNIX and Win32 NT or
        Win95+ platforms only). When enabled a hidden "cG*server*cA" buffer is
        created which monitors commands written to the server, the socket
        "cG/tmp/mesrvcAcDuidcA" on UNIX systems and the command input file
        "cD$TEMPcAcG/mecAcD$MENAMEcAcG.cmdcA" on Win32 systems. Commands can be written out
        using the command lslmipipe-write(2)le while in the "*server*" buffer, the
        command is written to the same socket on UNIX systems and to the
        response file and response file "cD$TEMPcAcG/mecAcD$MENAMEcAcG.rspcA" on Win32
        systems. This functionality is used by the cD-mcA and cD-ocA lsme(1)lmcommand-linele
        options and by the lsmemsdev(1)lmMicroSoft DevStudiole interface.

    cD0x40000cA
        Enables the capture of the Alt space key ("cGA-spacecA"), default is
        enabled (Win32 platform only). In the Windows environment the Alt
        Space key is used to activate the main window's pull down menu at the
        top left. if this bit is set MicroEmacs captures this key and executes
        it as normal, thereby disabling this standard windows binding.

    cD0x80000cA
        Enables the drawing of visible white spaces, i.e. space, tab and
        new-line characters. When disabled (default) white spaces are drawn
        using spaces ('cG cA') which means the user cannot distinguish between a
        tab and spaces or determine the last character of the line by merely
        looking at the display. When enabled MicroEmacs uses visible
        characters to draw the white spaces, the characters used are set with
        the variable lslm$window-chars(5)le.

    cD0x100000cA
        Enables hiding MicroEmacs generated backup files. On Windows and Dos
        platforms the Hidden file attribute is used to hide the file, whereas
        on UNIX the backup file name is prepended with a 'cG.cA'.

    cD0x200000cA
        If this bit set, the then execution of the lslmtab(2)le command (bound to
        cGtabcA) checks and adjusts the indentation of the current line when the
        cursor is in column zero and current buffer has an lsindent(2)lmindentationle method.
        The setting of this bit has no effect if bit cD0x1000cA is set. If this
        and bit cD0x1000cA are clear then the cGtabcA will not check the indentation.

    cD0x400000cA
        When this bit is set the external clipboard (Windows & XTerm
        platforms) will never be set to empty, if the current yank buffer is
        the empty string the cut buffer will be set to a space (i.e. " ").
        This feature has been added to avoid problems with other software
        (e.g. cDexceed(1)cA which can crash if given an empty cut buffer).

    cD0x800000cA
        When this bit is set all use of the external clipboard (Windows &
        XTerm platforms) is disabled, this means that MicroEmacs will not
        attempt to retrieve or set the content of the system clipboard.

    cD0x1000000cA
        When this bit is set the cG-pcA or cG-PcA option was used on the command line
        (see lslmme(1)le). This bit can be used by macros to determine how to
        function, see lslmfiletype(3f)le for an example of its use.


cEcEEXAMPLE cEcA


    The follow example works out the current buffer's backup file name using
    cD$systemcA to determine the naming system being used by MicroEmacs:-
sB
        set-variable #l0 &stat "a" $buffer-fname
        ; Is an 8.3 dos style naming system being used?
        !if &band $system 0x400
            !if &not &set #l1 &sin "." #l0
                set-variable #l1 &cat #l0 ".~~~"
            !elif &gre &set #l1 &sub &len #l0 #l1 2
                set-variable #l1 &cat &lef #l0 &sub &len #l0 1 "~"
            !else
                set-variable #l1 &spr "%s%n" #l0 &sub 3 #l1 "~"
            !endif
        !elif $kept-versions
            set-variable #l1 &cat #l0 ".~0~"
        !else
            set-variable #l1 &cat #l0 "~"
        !endif

sA
    The following macro can be used to toggle the visible drawing of white
    spaces:
sB
        define-macro toggle-visible-white-spaces
            set-variable $system &bxor $system 0x80000
            screen-update
        !emacro

sA

cEcENOTES cEcA


    Most of the cD$systemcA functionality can be set using the lsuser-setup(3)lm$user-setup(3)le
    dialog.


cEUNIX X verses Termcap cA


    By default, on X supporting systems MicroEmacs creates a new X window.
    This feature may be disabled in one of two ways:

        * The environment variable cG$TERMcA is set to "cGvt...cA", in this case it is
          assumed that the machine is a server, and the host cannot support X.
        * The cG-ncA option is used on the command line (see lslmme(1)le) to disable the
          windowing interface.

    If X is disabled then the cDtermcapcA interface is used instead, still
    allowing the use of colors through the ANSI standard, or the use of fonts
    (see bits cD0x004cA and cD0x008cA).

    X provides the following features over and above a cDtermcapcA based version
    of MicroEmacs 2009:

        * R,G,B style color creator giving access to up to 256 different
          colors for the ultimate hilighting schemes (see bit cD0x002cA and
          lslmadd-color(2)le).
        * Full mouse support, allowing user definable bindings to every mouse
          event (see lslmglobal-bind-key(2)le).
        * Copy from and pasting to X's selection buffer (see lslmyank(2)le).


cEcESEE ALSO cEcA


    lslmuser-setup(3)le, lslm$mouse(5)le, lslm$platform(5)le, lslmadd-color(2)le, lslmadd-color-scheme(2)le,
    lslmipipe-shell-command(2)le, lslm$global-scheme(5)le.
! 5 $window-col
! 5 $window-acol
! 5 $window-aline
! 5 $window-eline
! 5 $window-line
! 5 $window-mark-col
! 5 $window-mark-line
! 5 $window-wcol
! 5 $window-wline
cEcENAME cEcA


|$window-col
    $window-col - Window cursor column (no expansion)
|$window-line
    $window-line - Window cursor line (with narrows)
|$window-acol
    $window-acol - Window cursor actual column (expansion)
|$window-aline
    $window-aline - Window cursor actual line (ignore narrows)
|$window-aline
    $window-eline - Window end line
|$window-mark-col
    $window-mark-col - Window mark column
|$window-mark-line
    $window-mark-line - Window mark line
$a


cEcESYNOPSIS cEcA


    cD$window-colcA cCintegercA [0 <= cCintegercA <= 65535]
    cD$window-linecA cCintegercA [1 <= cCintegercA <= n]
    cD$window-acolcA cCintegercA [0 <= cCintegercA <= n]
    cD$window-alinecA cCintegercA [1 <= cCintegercA <= n]
    cD$window-elinecA cCintegercA [1 <= cCintegercA <= n]
    cD$window-mark-colcA cCintegercA [0 <= cCintegercA <= 65535]
    cD$window-mark-linecA cCintegercA [1 <= cCintegercA <= n]


cEcEDESCRIPTION cEcA


    cD$window-colcA is defined as the current position of the cursor in the
    current line in the current window. Column zero is the left hand edge.
    This differs from cD$window-acolcA in that TAB and special characters only
    count for 1 character. cD$window-colcA is valid in the range 0 - cCncA.

    cD$window-acolcA is defined as the current column of the cursor in the current
    window. Column zero is the left hand edge. This differs from cD$window-colcA
    in that tab and special characters may not count for 1 character.

    cD$window-linecA is defined as the current buffer line number the cursor is on
    in the current window. Line numbering starts from 1. cD$window-linecA is valid
    in the range 1 - cCncA.

    cD$window-alinecA is identical to cD$window-linecA except when the current buffer
    contains narrowed out sections before the current line. In this case
    cD$window-linecA will be set to the line number without counting the number of
    lines in the narrow, whereas cD$window-alinecA will return the current line
    number including all lines narrowed out before it. When this variable is
    set, the line required may lie in a narrowed out section in which case the
    narrow is automatically removed. See lslmnarrow-buffer(2)le for more information
    on narrowing.

    cD$window-elinecA is the end line of the window, that is the line number of
    the last line of the buffer showing in the window. This is a useful value
    for mouse operations when the position of the mouse may be tested to
    ensure that the mouse position is within the valid text region of the
    buffer.

    cD$window-mark-linecA is the current buffer line number of the mark position
    of lslmset-mark(2)le in the current window. Line numbering starts from 1.
    cD$window-mark-linecA is valid in the range 1 - cCncA.

    cD$window-mark-colcA is the current buffer column of the mark position of
    lslmset-mark(2)le in the current window. Note that this is the actual column
    position in the line which may be different from the window column
    position as TAB and special characters only count as a single character.


cEcENOTES cEcA


    Variable cD$window-wcolcA was renamed to cD$window-acolcA in June 2000. Variable
    cD$window-wlinecA was also removed and a new variable cD$window-y-scrollcA
    introduced at this time. The following macro code can be used to calculate
    the value of the original cD$window-wlinecA variable:

    cD$window-mark-linecA and cD$window-mark-colcA first appeared in the 2006 release
    of MicroEmacs.
sB
        &sub &sub $window-line $window-y-scroll 1

sA

cEcESEE ALSO cEcA


    lslm$frame-depth(5)le, lslm$window-depth(5)le, lslm$window-width(5)le, lslm$window-y-scroll(5)le,
    lslmnarrow-buffer(2)le.
! 5 %ftp-flags
! 5 %http-flags
cEcENAME cEcA


|%ftp-flags
    %ftp-flags - "Configure the FTP console"
|%http-flags
    %http-flags - "Configure the HTTP console"
$a


cEcESYNOPSIS cEcA


    cD%ftp-flagscA "[cGccA|cGscA|cGpcA]" ; Default is undefined.
    cD%http-flagscA "[cGccA|cGscA|cGpcA]" ; Default is undefined.


cEcEDESCRIPTION cEcA


    The cD%ftp-flagscA and cD%http-flagscA modify the behavior of the editor during
    FTP and HTTP file transfers, respectively. (see lslmftp(3)le and lslmfind-file(2)le).

    By default, the flags are disabled, the facilities outlined below are
    enabled by setting the variable in the user configuration. The flag values
    for both flags are defined as follows:-

    cDccA
        Create a console buffer (cG*ftp-console*cA for ftp, cG*http-console*cA for
        http) into which the FTP/HTTP command interactions with the remote
        server are logged.

    cDscA
        Show the console whenever a FTP/HTTP operation is performed. The
        console is popped into the display pane and shows the current
        interaction status.

    cDpcA
        Show the download progress within the console window ('cG#cA' for every
        2Kb downloaded)

    Typically the following flags are enabled in the cCusercA.emf file:-
sB
        set-variable %ftp-flags "csp"
        set-variable %http-flags "csp"

sA
    Once familiar with this facility the console pop-up becomes inconvenient
    and the flags are typically reduced to:-
sB
        set-variable %ftp-flags "cp"
        set-variable %http-flags "cp"

sA
    This disables the pop-up feature of the console. Enabling the limited flag
    set allows some post mortem debugging to be performed if anything goes
    wrong. The console buffers are manually selected when these flags are set.


cEcENOTES cEcA


    Note that ftp and http facilities are available on UNIX by default, but
    must be compiled in for Windows versions.


cEcESEE ALSO cEcA


    lslm%http-proxy-addr(5)le, lslmfind-file(2)le, lslmftp(3)le.
! 5 $scroll-bar-scheme
cEcENAME cEcA


    $scroll-bar-scheme - Scroll bar color scheme
$a


cEcESYNOPSIS cEcA


    cD$scroll-bar-schemecA cCschemeNumcA; Default is cG1cA


cEcEDESCRIPTION cEcA


    Sets the horizontal window scroll bar color scheme, assigning the
    foreground, background and selection colors which are used to render the
    vertical separator / scroll bars (see lslmadd-color-scheme(2)le. The separator
    is rendered in reverse video, i.e. the foreground color of the color
    scheme is used as the background color, and vice versa.

    The separator is rendered in the standard colors when the associated
    buffer is not active, and in the current color when the buffer is active.

    The scroll-bar is the window separator constructed by
    lslmsplit-window-horizontally(2)le or when the scroll bars are enabled via
    lslm$scroll-bar(5)le.


cEcESEE ALSO cEcA


    lslm$global-scheme(5)le, lslm$ml-scheme(5)le, lslm$mode-line-scheme(5)le, lslm$scroll-bar(5)le,
    lslm$system(5)le, lslm$window-chars(5)le, lslmsplit-window-horizontally(2)le.
! 5 $window-chars
cEcENAME cEcA


    $window-chars - Character set used to render the windows
$a


cEcESYNOPSIS cEcA


    cD$window-charscA "cCstingcA"; Default is
    "cG=-#*%=^|#|v*==^^||##||vv**|<-#->*||<<--##-->>** x*[]>\.$$\cA"


cEcEDESCRIPTION cEcA


    cD$window-charscA is a fixed length string that defines the set of characters
    used to render the windows. The characters have fixed indices defined as
    follows:-

    Index 0
        The active window mode line separator character, This replaces all
        cCIndex 1cA characters when the window is current. Default is 'cD=cA'.

    Index 1
        The inactive window mode line separator character. This character is
        replaced by cCIndex 0cA characters when the window becomes current.
        Default is 'cD-cA'.

    Index 2
        UNIX based platforms only. The cDrootcA or cDsuperusercA indicator character
        that appears on the mode line. Default is 'cD#cA'.

    Index 3
        The buffer changed indicator character that appears on the mode line.
        Default is 'cD*cA'.

    Index 4
        The buffer in lslmview(2m)le mode indicator character that appears in the
        mode line. Default is 'cD%cA'.

    Index 5
        Single column vertical scroll bar split window horizontally character.
        Default is 'cD=cA'.

    Index 6
        Single column vertical scroll bar up-arrow character. Default is 'cD^cA'.

    Index 7
        Single column vertical scroll bar upper-shaft character. Default is
        'cD|cA'.

    Index 8
        Single column vertical scroll box character. Default is 'cD#cA'.

    Index 9
        Single column vertical scroll bar lower-shaft character. Default is
        'cD|cA'.

    Index 10
        Single column vertical scroll bar down-arrow character. Default is
        'cDvcA'.

    Index 11
        Single column vertical scroll bar corner character. Default is 'cD*cA'.

    Index 12-13
        Double column vertical scroll bar split window horizontally character.
        Default is 'cD==cA'.

    Index 14-15
        Double column vertical scroll bar up-arrow characters. Default is "cD^cA".

    Index 16-17
        Double column vertical scroll bar upper-shaft characters. Default is
        "cD||cA".

    Index 18-19
        Double column vertical scroll box characters. Default is "cD##cA".

    Index 20-21
        Double column vertical scroll bar lower-shaft characters. Default is
        "cD||cA".

    Index 22-23
        Double column vertical scroll bar down-arrow characters. Default is
        "cDvvcA".

    Index 24-25
        Double column vertical scroll bar corner characters. Default is "cD**cA".

    Index 26-32
        Single column horizontal scroll bar. Default is "cD|<-#->*cA".

    Index 33-46
        Double column horizontal scroll bar. Default is "cD||<<--##-->>**cA".

    Index 47
        Osd title bar blank character. Default is 'cD cA'.

    Index 48
        Osd title bar right corner kill character. Default is 'cDxcA'.

    Index 49
        Osd dialog bottom right corner resize character. Default is 'cD*cA'.

    Index 50-53
        Osd button characters. 50 & 52 are used for a normal button, default
        is 'cD cAcCButtoncAcD cA'. 51 & 53 are used for the current default button,
        default is 'cD>cAcCButtoncAcD<cA'.

    Index 54
        Displayed tab character (used when lslm$system(5)le bit 0x80000 is set).
        Default is 'cD>cA'.

    Index 55
        Displayed new-line character (used when lslm$system(5)le bit 0x80000 is
        set). Default is 'cD\cA'.

    Index 56
        Displayed space character (used when lslm$system(5)le bit 0x80000 is set).
        Default is 'cD.cA'.

    Index 57
        Displayed truncated text to left character (used when the current line
        is scrolled to the right). Default is 'cD$cA'.

    Index 58
        Displayed truncated text to right character (used when the current
        line is longer than the window width). Default is 'cD$cA'.

    Index 59
        Inserted end of wrapped line character in an lslmipipe-shell-command(2)le
        buffer. Default is 'cD\cA'.


cEcEEXAMPLE cEcA


    The cD$window-charscA is typically platform dependent, it's setting is
    determined by the characters available in character set of the hosting
    platform. MS-DOS and Microsoft Windows use an OEM font might use the
    following value:

        "=-#*%=\C^\xB1 \xB1\C_\CD==\C^\C^\xB1\xB1  \xB1\xB1\C_\C_\C[
        \CZ|\CQ\xB1 \xB1\CP\CD||\CQ\CQ\xB1\xB1  \xB1\xB1\CP\CP\C[
        \CZ x*  >\\.$$\\"


    This utilizes character-set specific characters to render some of the
    window components.


cEcENOTES cEcA


        * lslm$scroll-bar(5)le allows the scroll box to be rendered in reverse video
          allowing a space to be used for the scroll box.
        * Use lslminsert-symbol(3)le to determine the displayable characters on the
          host platform.
        * The use of MicroEmacs's extended character set on Windows and XTerm
          platforms can greatly improve the look and usability of MicroEmacs,
          see the Extend Char Set option in the Platform page of lslmuser-setup(3)le
          and bit cG0x10000cA of variable lslm$system(5)le.


cEcESEE ALSO cEcA


    lslmsplit-window-horizontally(2)le, lslminsert-symbol(3)le, lslm$box-chars(5)le,
    lslm$global-scheme(5)le, lslm$mode-line(5)le, lslm$mode-line-scheme(5)le, lslm$scroll-bar(5)le,
    lslm$scroll-bar-scheme(5)le, lslm$system(5)le.
! 5 $window-depth
! 5 $window-width
cEcENAME cEcA


|$window-depth
    $window-depth - Number of text lines in a window
|$window-width
    $window-width - Number of character columns in a window
$a


cEcESYNOPSIS cEcA


    cD$window-depthcA cCintegercA

    1 <= cCintegercA <= ls$frame-depth(5)lm$frame-depthle

    cD$window-widthcA cCintegercA

    0 <= cCintegercA <= ls$frame-depth(5)lm$frame-widthle - 1


cEcEDESCRIPTION cEcA


    cD$window-depthcA returns the depth (height) of the current window, excluding
    the mode line, specified in text lines. (i.e. the number of lines of text
    in the window). The returned value is an integer in the range:

        cD0cA - ( ls$frame-depth(5)lm$frame-depthle - cD3cA )

    cD$window-widthcA returns the width, in characters, of the current window. The
    returned value is an integer in the range:

        cD0cA - ls$frame-depth(5)lm$frame-widthle.


cEcENOTES cEcA


    These variables can not be set, any attempt to set them results in an
    error.


cEcESEE ALSO cEcA


    lslm$frame-depth(5)le, lslm$frame-width(5)le, lslm$window-scroll-bar(5)le,
    lslm$window-mode-line(5)le,
! 5 $fill-bullet
! 5 $fill-bullet-len
cEcENAME cEcA


|$fill-bullet
    $fill-bullet - Paragraph filling bullet character set
|$fill-bullet-len
    $fill-bullet-len - Paragraph filling bullet search depth
$a


cEcESYNOPSIS cEcA


    cD$fill-bulletcA "cCstringcA"; Default is "cG*)].-cA"
    cD$fill-bullet-lencA cClengthcA; Default is cG5cA

    0 <= cClengthcA <= ls$fill-col(5)lm$buffer-fill-colle


cEcEDESCRIPTION cEcA


    cD$fill-bulletcA contains the set of characters which are classified as bullet
    markers for lslmfill-paragraph(2)le. If these characters are encountered in the
    first cD$fill-bullet-lencA characters of the paragraph AND the character is
    followed by a cGSPACEcA or a cGtabcA character then the user is given the option
    to indent to the right of the bullet.

    cD$fill-bullet-lencA determines the maximum depth into the paragraph (in
    characters) the filling routines should search for a bullet character. The
    default value is 15. Note that the paragraph starts at the first non-white
    space character. e.g. to detect "cGxviii) cA" as a bullet then the bullet
    length must be set to at least 6 to detect the bullet character "cG)cA".


cEcEEXAMPLE cEcA


    Examples of filled bullet paragraphs are shown as follows, based on the
    default cD$fill-bulletcA character set.

        a) This is an  example of a  fill-paragraph.  The  closing
           bracket is classified as a bullet character and filling
           optionally takes place to the right of the bullet.

        a] Another paragraph

        *  A bullet paragraph

        1. A numbered paragraph.

        item - A dashed bullet.


cEcESEE ALSO cEcA


    lslm$buffer-fill-col(5)le, lslm$buffer-fill-mode(5)le, lslm$fill-col(5)le, lslm$fill-ignore(5)le,
    lslm$fill-mode(5)le, lslmfill-paragraph(2)le, lslmjustify(2m)le.
! 5 $fill-ignore
cEcENAME cEcA


    $fill-ignore - Ignore paragraph filling character(s)
$a


cEcESYNOPSIS cEcA


    cD$fill-ignorecA "cCstringcA"; Default is "cG>_@cA"


cEcEDESCRIPTION cEcA


    cD$fill-ignorecA describes a set of characters used by lslmfill-paragraph(2)le which
    disable paragraph filling when they appear at the start of a paragraph. An
    obvious example is an inserted mail message which is usually quoted with
    "cG>cA" characters. Any attempt to fill the paragraph causes cDfill-paragraphcA to
    skip to the end of it.


cEcEEXAMPLE cEcA


    This is an example of an ignored paragraph when encountered by
    cDfill-paragraphcA with the default ignore character set.

        > This is an example of a paragraph that
        > is ignored.


cEcESEE ALSO cEcA


    lslm$buffer-fill-col(5)le, lslm$buffer-fill-mode(5)le, lslm$fill-bullet(5)le, lslm$fill-col(5)le,
    lslm$fill-mode(5)le, lslmfill-paragraph(2)le, lslmjustify(2m)le.
! 5 $scroll-bar
cEcENAME cEcA


    $scroll-bar - Scroll bar configuration
$a


cEcESYNOPSIS cEcA


    cD$scroll-barcA "cCbitmaskcA"; Default is platform specific


cEcEDESCRIPTION cEcA


    cD$scroll-barcA defines the configuration of the scroll bar and/or the
    horizontal window separator for both main text windows and lslmosd(2)le dialogs.
    The variable is interpreted as a bit mask and defines which components of
    the scroll bar (or separator) should be rendered in a window. The
    characters used to render the scroll bar or separator are defined by
    lslm$window-chars(5)le. The bit mask is defined as follows:-

    cD0x001cA - Vertical Scroll Bar Width
        Bit 0 controls the width of the vertical scroll bar (or separator). A
        value of 0 corresponds to a single column width, a value of 1 is a
        double column width.

    cD0x002cA - Upper end cap
        Bit 1 set indicates that the scroll bar has an upper end cap. This is
        the up arrow character at the top of a scroll bar.

    cD0x004cA - Lower end cap
        Bit 2 set indicates that the scroll bar has a lower end cap. This is
        the down arrow character at the bottom of a scroll bar.

    cD0x008cA - Corner
        Bit 3 set indicates that separate corner character is used at the
        intersection of the mode line and the separator.

    cD0x010cA - Scroll Box Enable
        Bit 4 determines if the scroll bar has a scrolling box, when the bit
        is set each scroll bar will have a scroll box. When clear, scroll bars
        are rendered according to bits 0-3 & 7 only and the main area of the
        bar is left empty.

    cD0x020cA - Reverse Video Box
        Bit 5 when set enables the scroll box to be rendered in reverse video,
        that is the background and foreground/hilight scroll colors are
        interchanged. This bit is typically set on X-Window platforms allowing
        the scroll box to comprise of cGSPACEcA characters allowing a solid box to
        be rendered in the foreground color.

        Bit 5 is only enacted if scroll boxes are enabled.

    cD0x040cA - Horizontal Scroll Bar Width
        Bit 6 controls the width of the horizontal scroll bar, used only by
        lslmosd(2)le. A value of 0 corresponds to a single column width, a value of
        1 is a double column width.

    cD0x080cA - Splitter
        Bit 7 set indicates that the scroll bar has a splitter. This is the
        split bar character at the top of a scroll bar.

    cD0x100cA - Enable window Scroll Bars
        When Bit 8 is clear, scroll bars are not present on windows. If a
        horizontal split has been performed then the window separator is
        rendered plain. This is useful when performance is important, as
        scroll bars require constant up-date.

    cD0x200cA - Horizontal Scroll Bar Width
        Bit 9 enables scroll bars, when the bit is set each window is assigned
        a scroll bar in the right-hand column(s) of the window with a scroll
        box.


cEcESEE ALSO cEcA


    lslm$mouse-pos(5)le, lslm$scroll-bar-scheme(5)le, lslmset-scroll-with-mouse(2)le,
    lslm$window-chars(5)le.
! 5 $line-scheme
cEcENAME cEcA


    $line-scheme - Set the current line color scheme
$a


cEcESYNOPSIS cEcA


    cD$line-schemecA cCschemeNumcA; Default is cG-1cA


cEcEDESCRIPTION cEcA


    cD$line-schemecA sets the color scheme to be used for the current line of the
    current window. The given cCschemeNumcA can be any scheme number previously
    defined by the function lslmadd-color-scheme(2)le.

    A line's $line-scheme setting is removed by setting the variable to -1.

    A $line-scheme setting takes precedence over the buffer's color scheme (
    lslm$buffer-scheme(5)le) and the buffer's hilighting scheme (
    lslm$buffer-hilight(5)le).


cEcEEXAMPLE cEcA


    lslmc-hash-eval(3)le greys out lines of text by doing:
sB
        set-variable $line-scheme %lblack

sA
    The lines are rest by doing
sB
        set-variable $line-scheme -1

sA
    The lslmgdb(3)le interface hilights the current line of source by doing:
sB
        set-variable $line-scheme %yellow-lblack

sA

cEcENOTES cEcA


    Due to line storage restrictions, only 15 different color schemes can be
    used in a buffer at any one time. When the 16th color scheme is used it
    replaces the first color scheme, all lines using the first color scheme
    will be colored using the new color scheme.


cEcESEE ALSO cEcA


    lslmadd-color-scheme(2)le, lslmc-hash-eval(3)le, lslm$buffer-hilight(5)le,
    lslm$buffer-scheme(5)le, lslm$line-flags(5)le, lslm$mode-line-scheme(5)le,
    lslm$scroll-bar-scheme(5)le, lslm$system(5)le.
! 5 $search-path
cEcENAME cEcA


    $search-path - MicroEmacs search path


cEcESYNOPSIS cEcA


    cD$search-pathcA cCstringcA

    cC[Microsoft Windows/MS-DOS]cA
    cD$search-pathcA cC<path1>cAcD;cAcC<path2>cAcD;cA....cD;cAcC<pathn>cA

    cC[UNIX]cA
    cD$search-pathcA cC<path1>cAcD:cAcC<path2>cAcD:cA....cD:cAcC<pathn>cA


cEcEDESCRIPTION cEcA


    cD$search-pathcA is automatically determined by MicroEmacs when it
    initializes. The variable identifies the directory paths which are
    searched to locate editor specific files. The variable may contain
    multiple search paths each separated by the platform path separator
    (semi-colon ('cD;cA') on Microsoft Windows or MS-DOS environments and a colon
    ('cD:cA') on UNIX environments). Where multiple search paths are defined then
    they are searched in a left to right order.

    cD$search-pathcA is determined at run-time and is fixed once the editor
    starts. The value of the search path is determined from a number of
    different sources in a platform specific manner as follows:-

        * Built in pathnames - On UNIX platforms then preset search paths are
          built into the executable i.e. cG/opt/jasspacA, cG/usr/local/jasspacA etc.
        * The users home directory, taken from the cG/etc/passwdcA under UNIX and
          from the shell environment under Microsoft Windows.
        * The location of the executable, typically only used under Microsoft
          Windows and MS-DOS environments where the concept of standard
          installation locations is vague.
        * The environment variable lslm$MEUSERPATH(5)le which identifies the
          preferred user directory location, overriding any home directory
          location specified by the system.
        * The environment variable lslm$MEINSTALLPATH(5)le which identifies the
          installation directory of the standard macros overriding any built
          in search path(s).
        * The environment variable lslm$MEPATH(5)le which absolutely overrides any
          search paths with a user defined path where lslm$MEUSERPATH(5)le is not
          defined.
        * The command line option cD-ucA cCuser-namecA to lslmme(1)le which overrides the
          user name found by the system.
        * The environment variable lslm$MENAME(5)le which overrides the user name
          found by the system.

    The search paths are generally ordered from highest priority to lowest
    priority and typically arranged in the order:-

        cD$search-path=cAcC<user>cA:cC<company>cA:cC<me>cA

    where cC<user>cA represents the users path(s); cC<company>cA is the company file
    path(s) (e.g. company wide template files) and cC<me>cA path(s) which contain
    the standard MicroEmacs 2009 files.

    This would correspond to a typical directory installation, of user cDfoocA on
    UNIX such as:

    cG/usr/foo/.jassa          cA- User files.
    cG/usr/local/jasspa/companycA - Company wide files
    cG/usr/local/jasspa/macros cA- MicroEmacs installation directory


cEcEUSAGE cEcA


    The current working directory is always checked first for the location of
    any file.

    cD$search-pathcA is used to locate all macro files, and other files located
    with operators such as lslm&find(4)le.

    Users should not modify this variable directly, the external
    aforementioned environment variables should be used to affect any desired
    changes.


cEcENOTES cEcA


    The search path operation was revised in the MicroEmacs 2004 release and
    operates differently from earlier releases.


cEcESEE ALSO cEcA


    lslmme(1)le, lslmexecute-file(2)le, lslm&find(4)le. lslm$home(5)le, lslm$progname(5)le, lslm$user-name(5)le,
    lslm$user-path(5)le, lslm$MEINSTALLPATH(5)le, lslm$MENAME(5)le, lslm$MEPATH(5)le, lslm$MEUSERPATH(5)le,
    lsIntroduction to Variable FunctionslmVariable Functionsle.
! 5 $file-ignore
cEcENAME cEcA


    $file-ignore - File extensions to ignore
$a


cEcESYNOPSIS cEcA


    cD$file-ignorecA "cCstringcA"; Default is ""


cEcEDESCRIPTION cEcA


    cD$file-ignorecA specifies a space separated list of file endings which the
    file completion is to ignore. This is used by any function which prompts
    the user for a file name, such as lslmfind-file(2)le. A file ending in this case
    is NOT the extension but the last cCncA characters where cCncA is the number of
    characters in the specified ignore file.


cEcEEXAMPLE cEcA


    To ignore all files which have the extension "cGocA", using:
sB
        set-variable $file-ignore "o"

sA
    would not only ignore "cGfoo.ocA", but also "cGfoo.oocA", "cGfoo.pocA" and "cGfoocA" as
    well as any file that ends in an "cGocA". What is really required is
sB
        set-variable $file-ignore ".o"

sA
    It is useful to ignore the "cG./cA" and "cG../cA" directories so that a directory
    containing one file will auto-complete to that one file. This is achieved
    by using:
sB
        set-variable $file-ignore "./"

sA
    To ignore MicroEmacs 2009 backup files ("cG~cA"), C object files ("cG.ocA"), "cG./cA"
    and "cG../cA" directories try using:
sB
        set-variable $file-ignore "~ .o ./"

sA

cEcENOTES cEcA


    The file completion only completes further than the first non-unique point
    in the current list of possibles if and only if it can ignore all but one
    file, so if the current directory contains:

        ./ ../ foo foo.c foo.c~ foo.o


    using the above ignore list, completing with "" has no effect as "cGfoocA" and
    "cGfoo.ccA" cannot be ignored; completing with "cGfoo.cA" will however complete to
    "cGfoo.ccA".


cEcESEE ALSO cEcA


    lslmfind-file(2)le.
! 5 $show-region
cEcENAME cEcA


    $show-region - Enable the hilighting of regions
$a


cEcESYNOPSIS cEcA


    cD$show-regioncA cCflagcA; Default is cG1cA


cEcEDESCRIPTION cEcA


    cD$show-regioncA enables or disables the current region hilighting, normally
    associated with mouse interaction in a buffer. Region hilighting occurs
    between the cCmarkcA (see lslmset-mark(2)le) and cCpointcA (current cursor) positions
    within the current buffer. An argument cCncA of 0 disables region hilighting,
    an argument of 1 enables region hilighting between the two positions. If
    it is set to 3 then region hilighting will be enabled and a defined region
    (created using lslmcopy-region(2)leor lslmyank(2)le) will continue to be hilighted
    until the region is changed.

    A defined region can be redisplayed (if still valid) using the command
    lslmshow-region(2)le. The color of the region hilighting is defined by
    lslmadd-color-scheme(2)le and is determined by lslm$buffer-scheme(5)le,
    lslm$global-scheme(5)le or lslm$buffer-hilight(5)le.


cEcESEE ALSO cEcA


    lslmshow-region(2)le, lslm$buffer-hilight(5)le, lslm$buffer-scheme(5)le, lslm$global-scheme(5)le,
    lslm$buffer-scheme(5)le, lslmadd-color-scheme(2)le, lslmset-mark(2)le.
! 5 $time
cEcENAME cEcA


    $time - The current system time
$a


cEcESYNOPSIS cEcA


    cD$timecA "cCstringcA"


cEcEDESCRIPTION cEcA


    cD$timecA is a constantly changing variable which is set to the current system
    time. The format of cD$timecA is "cGYYYYCCCMMDDWhhmmssSSScA", where:-

    cDYYYYcA
        The current year (full 4 digits so should be millennium bug free).

    cDCCCcA
        Day of the year (0-366).

    cDMMcA
        The month of the year (1-12).

    cDDDcA
        The day of the month (1-31).

    cDWcA
        The day of the week (0-6 Sunday=0).

    cDhhcA
        The hour (0-23).

    cDmmcA
        The minute (0-59).

    cDsscA
        The second (0-59).

    cDSSScA
        The millisecond (0-999).

    cD$timecA can be set to an integer value which is a time offset in seconds,
    for example if the following was executed;-
sB
        set-variable $time "3600"
        ml-write &cat "$time is " $time
        set-variable $time "0"

sA
    The written time would one hour ahead of the system time.


cEcEEXAMPLE cEcA


    The following macro times the time taken to execute a user command:-
sB
        define-macro time
            !force set-variable #l2 @1
            !if &not $status
                set-variable #l2 @ml00 "Time command"
            !endif
            set-variable #l0 $time
            !force execute-line #l2
            set-variable #l1 $time
            set-variable #l2 &add &mid #l0 16 2 &mul 60 &add &mid #l0 14 2 &mul 60 &mid #l0 12 2
            set-variable #l3 &add &mid #l1 16 2 &mul 60 &add &mid #l1 14 2 &mul 60 &mid #l1 12 2
            !if &les &set #l4 &sub &rig #l1 18 &rig #l0 18 0
                set-variable #l2 &add #l2 1
                set-variable #l4 &add 1000 #l4
            !endif
            ml-write &spr "Command took %d sec %d msec" &sub #l3 #l2 #l4
        !emacro

sA
    lslmtime(3)le is a macro defined in misc.emf.

    lslmorganizer(3)le uses cD$timecA to work out the current month.


cEcESEE ALSO cEcA


    lslmtime(3)le, lslmorganizer(3)le.
! 5 $buffer-names
cEcENAME cEcA


    $buffer-names - Filtered buffer name list


cEcESYNOPSIS cEcA


    cD$buffer-namescA cCBufferNamecA


cEcEDESCRIPTION cEcA


    cD$buffer-namescA must first be set to the required filter string, if the
    variable is evaluated before it is initialized the value will be set to
    "cCABORTcA" and the command will fail. The filter takes the form of a lsRegularExpressions(2)lmregexle.

    Once initialized, evaluating cD$buffer-namescA returns the name of the next
    buffer which matches the filter until no more buffers are found, in which
    case an empty string is returned.


cEcEEXAMPLE cEcA


    The following example prints out the name of all buffers to the massage
    line one at a time. Note that lslm&set(4)le is used on the lslm!while(4)le statement
    to avoid evaluating cD$buffer-namescA twice per loop.
sB
        set-variable $buffer-names ".*"
        !while &not &seq &set #l0 $buffer-names ""
            100 ml-write &cat "buffer: " #l0
        !done

sA
    The following example is the same except it lists only the buffers which
    are not directory listings
sB
        set-variable $buffer-names ".*[^/]"
        !while &not &seq &set #l0 $buffer-names ""
            100 ml-write &cat "buffer: " #l0
        !done

sA

cEcENOTES cEcA


    The list of buffers is evaluated when the variable is initialized, buffers
    created after the initialization will not be included in the list.

    Deleting buffers which are in the list, before they are evaluated, will
    have undefined effects.


cEcESEE ALSO cEcA


    lslmlist-buffers(2)le, lslm$buffer-bname(5)le, lslm$file-names(5)le, lslm$command-names(5)le,
    lslm$mode-names(5)le, lsRegularExpressions(2)lmRegular Expressionsle.
! 5 $command-names
cEcENAME cEcA


    $command-names - Filtered command name list


cEcESYNOPSIS cEcA


    cD$command-namescA cCCommandNamecA


cEcEDESCRIPTION cEcA


    cD$command-namescA must first be initialized to the required filter string, if
    the variable is evaluated before it is initialized the value will be set
    to "cCABORTcA" and the command will fail. The filter takes the form of a
    lsRegularExpressions(2)lmregexle.

    Once initialized, evaluating cD$command-namescA returns the name of the next
    command which matches the filter until no more commands are found, in
    which case an empty string is returned.


cEcEEXAMPLE cEcA


    The following example prints out the name of all commands to the massage
    line one at a time. Note that lslm&set(4)le is used on the lslm!while(4)le statement
    to avoid evaluating cD$command-namescA twice per loop.
sB
        set-variable $command-names ".*"
        !while &not &seq &set #l0 $command-names ""
            100 ml-write &cat "command: " #l0
        !done

sA
    The following example is an alternative implementation of
    lslmcommand-apropos(2)le.
sB
        define-macro alt-commad-apropos
            set-variable #l1 @ml "Apropos string"
            set-variable $command-names &cat &cat ".*" #l1 ".*"
            !force 0 delete-buffer "*commands*"
            1 popup-window "*commands*"
            !while &not &seq &set #l0 $command-names ""
                insert-string &spr "    %s\n" #l0
            !done
            beginning-of-buffer
            -1 buffer-mode "edit"
            1 buffer-mode "view"
        !emacro

sA

cEcENOTES cEcA


    cD$command-namescA does not differentiate between built in commands and
    macros.

    The list of commands is evaluated when the variable is initialized, macros
    created after the initialization will not be included in the list.


cEcESEE ALSO cEcA


    lslmlist-commands(2)le, lslmcommand-apropos(2)le, lslm$buffer-names(5)le, lslm$file-names(5)le,
    lslm$mode-names(5)le, lslm$variable-names(5)le, lsRegularExpressions(2)lmRegular Expressionsle.
! 5 .calc.result
cEcENAME cEcA


    .calc.result - Last calc calculation result
$a


cEcESYNOPSIS cEcA


    cD.calc.resultcA cCintegercA


cEcEDESCRIPTION cEcA


    cD.calc.resultcA is used to store the result of the last calculation made by
    lslmcalc(3)le.

    The "cCLRcA" (Last Result) in the next calculation is substituted with this
    value.


cEcESEE ALSO cEcA


    lslmcalc(3)le.
! 5 $file-names
cEcENAME cEcA


    $file-names - Filtered file name list


cEcESYNOPSIS cEcA


    cD$file-namescA cCFileNamecA


cEcEDESCRIPTION cEcA


    cD$file-namescA must first be initialized to the required filter string, if
    the variable is evaluated before it is initialized the value will be set
    to "cCABORTcA" and the command will fail.

    The filter takes the form of a lsRegularExpressions(2)lmregexle. The filter string should also
    contain the path to the required directory, the path many not contain
    wild-cards. If no path is specified the the path of the current buffers
    file name is taken, if the current buffer has no file name then the
    current working directory is used.

    On initialization, lslm$result(5)le is set to the absolute path of the directory
    being evaluated.

    Once initialized, evaluating cD$file-namescA returns the name of the next
    buffer which matches the filter until no more buffers are found, in which
    case an empty string is returned.


cEcEEXAMPLE cEcA


    The following example creates a list of all files in the current directory
    to a fixed buffer "cC*files*cA". Note that lslm&set(4)le is used on the lslm!while(4)le
    statement to avoid evaluating cD$file-namescA twice per loop.
sB
        set-variable $file-names ".*"
        !force 0 delete-buffer "*files*"
        1 popup-window "*files*"
        insert-string &spr "Directory listing of %s\n\n" $result
        !while &not &seq &set #l0 $file-names ""
            insert-string &spr "    %s\n" #l0
        !done
        beginning-of-buffer
        -1 buffer-mode "edit"
        1 buffer-mode "view"

sA

cEcENOTES cEcA


    Unlike MS-DOS and Windows systems, to match every file a filter of just
    "cC*cA" is required. A filter of "cC*.*cA" only matches file names with a 'cC.cA' in
    them.

    The list of files is evaluated when the variable is initialized, files
    created after the initialization will not be included in the list.


cEcESEE ALSO cEcA


    lslm$result(5)le, lslmfind-file(2)le, lslm$buffer-fname(5)le, lslm$buffer-names(5)le,
    lslm$command-names(5)le, lslm$mode-names(5)le, lsRegularExpressions(2)lmRegular Expressionsle.
! 5 $mode-names
cEcENAME cEcA


    $mode-names - Filtered mode name list


cEcESYNOPSIS cEcA


    cD$mode-namescA cCModeNamecA


cEcEDESCRIPTION cEcA


    cD$mode-namescA must first be initialized to the required filter string, if
    the variable is evaluated before it is initialized the value will be set
    to "cCABORTcA" and the command will fail. The filter takes the form of a
    lsRegularExpressions(2)lmregexle.

    Once initialized, evaluating cD$mode-namescA returns the name of the next mode
    which matches the filter until no more modes are found, in which case an
    empty string is returned.


cEcEEXAMPLE cEcA


    The following example prints out the name of all modes to the massage line
    one at a time. Note that lslm&set(4)le is used on the lslm!while(4)le statement to
    avoid evaluating cD$mode-namescA twice per loop.
sB
        set-variable $mode-names "*"
        !while &not &seq &set #l0 $mode-names ""
            100 ml-write &cat "mode: " #l0
        !done

sA

cEcESEE ALSO cEcA


    lslmbuffer-mode(2)le, lslm&bmode(4)le, lslm$buffer-names(5)le, lslm$command-names(5)le, lsRegularExpressions(2)lmRegularln
    lnExpressionsle.
! 5 $progname
cEcENAME cEcA


    $progname - Program file name
$a


cEcESYNOPSIS cEcA


    cD$prognamecA cCstringcA


cEcEDESCRIPTION cEcA


    cD$prognamecA contains the absolute file and path to the MicroEmacs 2009
    binary file currently being executed. This value is typically used by
    macros to spawning another MicroEmacs 2009 sessions and to determine where
    MicroEmacs 2009 is being executed from.


cEcEEXAMPLE cEcA


    The following example is used to spawn of another MicroEmacs 2009 command
    to create a C-tags file:-

        shell-command &cat $progname " \"@ctags\" *.c *.h"


cEcESEE ALSO cEcA


    lslmme(1)le, lslmshell-command(2)le, lslm$search-path(5)le, lslm$user-name(5)le, lslm$user-path(5)le.
! 5 $find-words
cEcENAME cEcA


    $find-words - Filtered word list


cEcESYNOPSIS cEcA


    cD$find-wordscA cCwordcA


cEcEDESCRIPTION cEcA


    cD$find-wordscA must first be initialized to the required filter string, if
    the variable is evaluated before it is initialized the value will be set
    to "cCABORTcA" and the command will fail.

    The filter string can contain wild-card characters compatible with most
    file systems, namely:-

    cD?cA
        Match any character.

    cD[abc]cA
        Match character only if it is cCacA, cCbcA or cCccA.

    cD[a-d]cA
        Match character only if it is cCacA, cCbcA, cCccA or cCdcA.

    cD[^abc]cA
        Match character only if it is not cCacA, cCbcA or cCccA.

    cD*cA
        Match any number of characters.

    Note that these are not the same characters used by lslmexact(2m)le mode.

    Once initialized, evaluating cD$find-wordscA returns the next word found in
    the main spell dictionaries which matches the filter until no more words
    are found, in which case an empty string is returned.


cEcEEXAMPLE cEcA


    The following example finds all the words with "cCfoocA" in it (e.g.
    "cCfootnotecA"), printing them to the massage line one at a time. Note that
    lslm&set(4)le is used on the lslm!while(4)le statement to avoid evaluating cD$find-wordscA
    twice per loop.
sB
        set-variable $find-words "*foo*"
        !while &not &seq &set #l0 $find-words ""
            100 ml-write &cat "Word: " #l0
        !done

sA

cEcENOTES cEcA


    The order of the words is undefined.

    Due to the way words are derived, it is possible to have two or more
    copies of a word in the dictionary. If this is a matching word cD$find-wordscA
    will return the word two or more times.


cEcESEE ALSO cEcA


    lslmspell(2)le.
! 5 $variable-names
cEcENAME cEcA


    $variable-names - Filtered variable name list


cEcESYNOPSIS cEcA


    cD$variable-namescA cCVariableNamecA


cEcEDESCRIPTION cEcA


    cD$variable-namescA must first be initialized to the required filter string,
    if the variable is evaluated before it is initialized the value will be
    set to "cCABORTcA" and the command will fail.

    The filter string can contain wild-card characters compatible with most
    file systems, namely:-

    cD?cA
        Match any character.

    cD[abc]cA
        Match character only if it is cCacA, cCbcA or cCccA.

    cD[a-d]cA
        Match character only if it is cCacA, cCbcA, cCccA or cCdcA.

    cD[^abc]cA
        Match character only if it is not cCacA, cCbcA or cCccA.

    cD*cA
        Match any number of characters.

    Note that these are not the same characters used by lslmexact(2m)le mode.

    Once initialized, evaluating cD$variable-namescA returns the name of the next
    variable which matches the filter until no more variables are found, in
    which case an empty string is returned.


cEcEEXAMPLE cEcA


    The following example prints out the name of all variables to the massage
    line one at a time. Note that lslm&set(4)le is used on the lslm!while(4)le statement
    to avoid evaluating cD$variable-namescA twice per loop.
sB
        set-variable $variable-names "*"
        !while &not &seq &set #l0 $variable-names ""
            100 ml-write &cat "variable: " #l0
        !done

sA

cEcENOTES cEcA


    The list of variables is evaluated when the variable is initialized,
    variables defined after the initialization will not be included in the
    list. The list can contain the current buffer's buffer variables (See
    lslmVariables(4)le for more information on the different types of variables).

    Using lslmunset-variable(2)le to delete a variable which are in the list, before
    it has be evaluated, will have undefined effects.


cEcESEE ALSO cEcA


    lslmlist-variables(2)le, lslm$command-names(5)le.
! 5 $temp-name
cEcENAME cEcA


    $temp-name - Temporary file name
$a


cEcESYNOPSIS cEcA


    cD$temp-namecA cCFileNamecA


cEcEDESCRIPTION cEcA


    cD$temp-namescA is automatically set to a nonexistent file name in the systems
    temporary file directory. On UNIX systems the temporary directory is fixed
    to "cG/tmp/cA", on other systems the temporary directory is set by the cD$TEMPcA
    environment variable.


cEcEEXAMPLE cEcA


    The following example uuencodes a given file into a temporary file and
    then inserts this file into the current buffer.
sB
        set-variable #l0 @ml04 "Uuencode and insert file"
        set-variable #l1 $temp-name
        !force shell-command &spr "uuencode %s < %s > %s" #l0 #l0 #l1
        insert-file #l1
        !force shell-command &cat "rm " #l1

sA

cEcENOTES cEcA


    This variable can not be set, any attempt to set it will result in an
    error.

    The returned file name is not guaranteed to be unique between calls, only
    that the file does not currently exist.


cEcESEE ALSO cEcA


    lslmshell-command(2)le, lslmfile-op(2)le.
! 5 $buffer-fmod
! 5 $global-fmod
cEcENAME cEcA


|$buffer-fmod
    $buffer-fmod - Buffer file modes (or attributes)
|$global-fmod
    $global-fmod - Global file modes (or attributes)
$a


cEcESYNOPSIS cEcA


    cD$buffer-fmodcA cCFileModecA
    cD$global-fmodcA cCFileModecA


cEcEDESCRIPTION cEcA


    cD$buffer-fmodcA is bit based variable setting the buffers file system modes
    or attributes. If the buffer was loaded from an existing file then the
    value of cD$buffer-fmodcA is taken directly from the file. But if the buffer
    was created then the buffer inherits the default file modes, cD$global-fmodcA,
    which is determined from the users umask on UNIX or a default on others.

    The definition of the file mode bits are platform specific and are
    considered independently, as follows:


cEUNIX cA


    The file modes of Unix are the standard read, write and execute
    permissions for user, group and global. See cDchmod(1)cA for a full
    description of their use and effect.

    The variable is displayed in octal.


cEMicrosoft Windows and DOS cA


    On Microsoft platforms each file attribute (see cDattrib(1)cA) is assigned a
    bit, on windows 95 and NT the new file attributes such as compressed are
    also represented. The bits are assigned as follows

        Bit     Attrib Flag     Attribute
        0x001       R           Read Only
        0x002       H           Hidden
        0x004       S           System
        0x010                   Directory
        0x020       A           Archive
        0x080                   Normal
        0x100                   Temporary
        0x800                   Compressed


cEcEEXAMPLE cEcA


    The following example changes the $buffer-fmod so that the file will be
    executable (UNIX only), useful when writing a shell script.
sB
        set-variable $buffer-fmod 0775

sA

cEcESEE ALSO cEcA


    lslmcr(2m)le, lslmlf(2m)le, lslmctrlz(2m)le, lslmauto(2m)le.
! 5 $delay-time
! 5 $repeat-time
cEcENAME cEcA


|$delay-time
    $delay-time - Mouse time event delay time
|$repeat-time
    $repeat-time - Mouse time event repeat time
$a


cEcESYNOPSIS cEcA


    cD$delay-timecA cCmillisecondscA; Default is cG500cA
    cD$repeat-timecA cCmillisecondscA; Default is cG25cA

    10 <= cCmillisecondscA <= t


cEcEDESCRIPTION cEcA


    cD$delay-timecA sets the time waited between the user picking a mouse button
    and the generation of a cGmouse-time-?cA key event.

    When user presses the left button (say) a cGmouse-pick-1cA key event is
    generated, If this key is bound then the command it is bound to is
    executed. If the user then holds down the button for cD$delay-timecA or more
    milliseconds then MicroEmacs checks the binding of the special
    cGmouse-time-1cA key, if this pseudo key is bound then the command it is bound
    to will be executed.

    If the user continues to hold down the button for a further cD$repeat-timecA
    milliseconds another cDmouse-time-1cA key event will be generated. A
    cDmouse-time-1cA key event will be generated after every cD$repeat-timecA
    milliseconds until the user releases the button, at which point a
    cGmouse-drop-1cA key event is generated.


cEcEEXAMPLE cEcA


    The following example implements the vertical scroll-bar up and down
    scrolling arrows for a buffer window:-
sB
        define-macro mouse-pick-command
            set-cursor-to-mouse
            !if &equ &band $mouse-pos 15 5
                ml-write "Mouse on up-arrow"
                1 scroll-up
                1 global-bind-key scroll-up "mouse-time-1"
            !elif &equ &band $mouse-pos 15 9
                ml-write "Mouse on down-arrow"
                1 scroll-down
                1 global-bind-key scroll-down "mouse-time-1"
            !endif
        !emacro

        define-macro mouse-drop-command
            !force global-unbind-key "mouse-time-1"
        !emacro

        global-bind-key mouse-pick-command "mouse-pick-1"
        global-bind-key mouse-drop-command "mouse-drop-1"

sA

cEcESEE ALSO cEcA


    lslm$idle-time(5)le, lslmset-cursor-to-mouse(2)le, lslm$mouse-pos(5)le.
! 5 $idle-time
cEcENAME cEcA


    $idle-time - System idle event delay time
$a


cEcESYNOPSIS cEcA


    cD$idle-timecA cCmillisecondscA; Default is cG1000cA

    10 <= cCmillisecondscA <= t


cEcEDESCRIPTION cEcA


    cD$idle-timecA sets the time waited between the last user event and the
    generation of a cGidle-pickcA key event. When user input stops for cD$idle-timecA
    milliseconds MicroEmacs checks the binding of the special cGidle-pickcA key,
    if this pseudo key is bound then the command it is bound to will be
    executed. MicroEmacs will then cycle, generating a cGidle-pickcA every
    cD$idle-timecA milliseconds until user activity starts. At this point a
    cGidle-dropcA key event is generated, if this pseudo key is bound then the
    command it is bound to will be executed.

    This system is useful for things which can be done in the background.


cEcEEXAMPLE cEcA


    The following example is taken from cGssaver.emfcA and implements a simple
    screen saver:-
sB
        set-variable %screen-saver 0
        define-macro screen-saver
            !if &not &pinc %screen-saver 1
                !if &seq @cck "idle-pick"
                    ; default is to switch on in 5 minutes time
                    &cond @? @# 300000 create-callback screen-saver
                !else
                    !if &seq @cck "callback"
                        @# create-callback screen-saver
                    !elif @?
                        ; user has suppled argument, install or remove
                        !if &gre @# 0
                            &mul @# 60000 global-bind-key screen-saver "idle-pick"
                        !else
                            !force global-unbind-key "idle-pick"
                        !endif
                        set-variable %screen-saver &sub %screen-saver 1
                        !return
                    !endif
                    set-variable @# $frame-depth
                    !while &dec @# 1
                        2 screen-poke @# 0 $global-scheme &spr "%n" $frame-width " "
                    !done
                    0 screen-poke 0 0 $global-scheme &spr "%n" $frame-width " "
                    -1 show-cursor
                    ; must set this to stop recursion when waiting for a key!
                    set-variable %screen-saver 0
                    set-variable @# @cg
                    set-variable %screen-saver 1
                    1 show-cursor
                    screen-update
                    0 ml-write
                !endif
            !endif
            set-variable %screen-saver &sub %screen-saver 1
        !emacro

sA

cEcENOTES cEcA


    Care must be taken to ensure that a recursive loop is not created,
    consider the following example:-
sB
        define-macro bored
            !if &iseq @mc1 "Are you bored (y/n)? " "nNyY" "y"
                ml-write "Play a silly game!"
            !endif
        !emacro
        global-bind-key bored idle-pick

sA
    If this was executed MicroEmacs would very quickly crash! As soon as a
    second past cDboredcA would execute, which will prompt the user and wait for
    input. If a second passes without input cDboredcA will be executed again and
    again and again until stack memory runs out! To avoid this cGidle-pickcA
    should be unbound before waiting for user input, i.e.:-
sB
        define-macro bored
            global-unbind-key idle-pick
            !if &iseq @mc1 "Are you bored (y/n)? " "nNyY" "y"
                ml-write "Play a silly game!"
            !endif
            global-bind-key bored idle-pick
        !emacro
        global-bind-key bored idle-pick

sA

cEcESEE ALSO cEcA


    lslm$delay-time(5)le.
! 5 $mouse
cEcENAME cEcA


    $mouse - Mouse configuration variable
$a


cEcESYNOPSIS cEcA


    cD$mousecA cCbitmaskcA; Default is system dependent


cEcEDESCRIPTION cEcA


    The cD$mousecA is used to define and configure the MicroEmacs mouse support,
    it is a bit based flag where:-

    cD0x00fcA
        Defines the number of button the mouse has, only values 1, 2 & 3 are
        useful. By default MicroEmacs uses the system information to determine
        the number of buttons on the mouse, this is not fool proof so the user
        can set these bits to the appropriate number if the initial value is
        incorrect.

    cD0x010cA
        If set the mouse is enabled, if clear the mouse will not function. On
        systems which do not support mice (such as UNIX Termcap) this bit will
        be clear and can not be altered.

    cD0x020cA
        If set the buttons are reversed, i.e. the left button becomes the
        right and vice versa. By default this bit is clear.

    cD0xf0000cA
        Defines the current mouse icon to used, valid values are as follows:

            cD0x00000cA - Set mouse to default icon.
            cD0x10000cA - Set mouse to arrow icon.
            cD0x20000cA - Set mouse to text I-beam icon.
            cD0x30000cA - Set mouse to crosshair icon.
            cD0x40000cA - Set mouse to the grab icon.
            cD0x50000cA - Set mouse to the wait icon.
            cD0x60000cA - Set mouse to the stop icon.

        This feature is not supported on some systems and on others some icons
        are not obvious due to platform limitations.


cEcEEXAMPLE cEcA


    The following example checks that the mouse is currently available, if
    not, it aborts.
sB
        !if &not &band $mouse 0x10
            ml-write "[Mouse support is not currently available]"
            !abort
        !endif

sA

cEcENOTES cEcA


    The mouse can be easily configured using lslmuser-setup(3)le.


cEcESEE ALSO cEcA


    lslmuser-setup(3)le, lslm$system(5)le, lslm$platform(5)le.
! 5 $kept-versions
cEcENAME cEcA


    $kept-versions - Number of backups to be kept
$a


cEcESYNOPSIS cEcA


    cD$kept-versionscA cCintegercA; Default is 0

    0 <= cCintegercA <= n


cEcEDESCRIPTION cEcA


    cD$kept-versionscA allows the user to specify the number of backup versions
    that are required for each file. For file "cGXXXXcA", each backup version is
    renamed to "cGXXXX.~?~cA", where cG?cA is the backup number. If cD$kept-versionscA is
    set to 0 this feature is disabled and the default single backup file is
    created.

    The most recent backup will always be cG.~0~cA and the last version will be
    cG.~n~cA where cGncA is cD$kept-versionscA - 1. when the file is next saved the cG.~0~cA
    backup file is moved to cG.~1~cA, cG.~1~cA to cG.~2~cA etc, backup cG.~n~cA is removed.
    Evidently if cD$kept-versionscA it set to a large number this can effect
    performance.


cEcERESTRICTIONS cEcA


    cD$kept-versionscA may only be used when DOS file name restrictions are not
    enabled. This means that some systems (such as DOS) cannot use this
    functionality, see lslm$system(5)le for more information. Backup files are only
    created when buffer mode lslmbackup(2m)le is enabled.


cEcENOTES cEcA


    This feature is not supported when writing ftp files, a single backup file
    is created when backup files are enabled.


cEcESEE ALSO cEcA


    lslm$system(5)le, lslmautosv(2m)le, lslmbackup(2m)le, lslmftp(3)le, lslmsave-buffer(2)le.
! 5 $buffer-indent
cEcENAME cEcA


    $buffer-indent - Current buffer indentation scheme.
$a


cEcESYNOPSIS cEcA


    cD$buffer-indentcA cCindentNumcA; Default is cG0cA

    0 <= cCindentNumcA <= 255


cEcEDESCRIPTION cEcA


    cD$buffer-indentcA sets the current buffers indentation scheme. cCindentNumcA is
    the identity of the indentation scheme, as defined by lslmindent(2)le, which is
    typically the same value as the buffers hilighting scheme number (see
    lslm$buffer-hilight(5)le).

    The default setting is 0 which specifies no indentation scheme is present.
    When non-zero, the value identifies the indentation scheme.

    A buffer assigned an indentation method, MicroEmacs performs automatic
    line re-styling, by moving the left indentation, according to the defined
    indentation method. The cGtabcA key is typically disabled. This behavior can
    be altered using bit cG0x1000cA of the lslm$system(5)le variable, which can be
    changed using lslmuser-setup(3)le.

    The use of tab characters to create the required indentation is determined
    by the setting of the buffers lslmtab(2m)le mode. If the mode is disabled tab
    characters are used wherever possible, otherwise spaces are always used.


cEcENOTES cEcA


    The commands lslmrestyle-region(3)le and lslmrestyle-buffer(3)le use the indentation
    method when defined.

    The buffer indentation scheme is typically assigned in the cCfhookcA macro,
    see lslanguageTemplates(2)lmLanguage Templatesle.


cEcEEXAMPLE cEcA


    The following example sets up an indentation scheme for a buffer within
    the cCfhookcA macro.
sB
        !if &sequal .hilight.foo "ERROR"
            set-variable .hilight.foo &pinc .hilight.next 1
        !endif

        ....

        ; Define the indentation scheme
        0 indent  .hilight.foo 2 10
        indent .hilight.foo n "then" 4
        indent .hilight.foo s "else" -4
        indent .hilight.foo o "endif" -4

        ....

        ; File hook - called when new file is loaded.
        define-macro fhook-foo
            ; if arg is 0 this is a new file so add template
            !if &not @#
                etfinsrt "foo"
            !endif
            ; Assign the hilighting
            set-variable $buffer-hilight .hilight.foo
            ; Assign the buffer indentation
            set-variable $buffer-indent .hilight.foo
            ; Set the abbreviation file
            buffer-abbrev-file "foo"
            ; Temporary comment to make sure that it works.
            ml-write "Loaded a foo file"
        !emacro

sA
    This provides an indentation of the form:-

        if condition
        then
            XXXX
        else
            if condition
            then
                XXXX
            endif
        endif


cEcESEE ALSO cEcA


    lslmindent(2)le, lslmtab(2m)le, lslm$system(5)le, lslmuser-setup(3)le, lslmrestyle-buffer(3)le,
    lslmrestyle-region(3)le, lslm$buffer-hilight(5)le.
! 5 $MENAME
! 5 $LOGNAME
cEcENAME cEcA


|$MENAME
    $MENAME - MicroEmacs user name
|$LOGNAME
    $LOGNAME - System user name (UNIX)
$a


cEcESYNOPSIS cEcA


    cD$MENAMEcA cCstringcA;

    cD$LOGNAMEcA cCstringcA


cEcEDESCRIPTION cEcA


    cD$MENAMEcA is an environment variable which may be used to initialize the
    MicroEmacs 2009 environment for a given user. At start-up, if cD$MENAMEcA is
    defined then the user's configuration and history file "cGnamecAcC.erfcA" is
    located and read, where cGnamecA is the variable value. The environment
    variable is used to initialise the lslm$user-name(5)le variable.

    Where the user name has been specified on the command line using the cD-ucA
    option to lslmme(1)le then the environment variable is ignored and cD-ucA option
    takes precedence.

    The user configuration and session file has many uses, see lslmuser-setup(3)le
    and lslmread-session(3)le for more information.


cEMicrosoft Windows Environments cA


    Within Microsoft Windows environments, if cClogincA is enabled then the users
    login name is automatically used as the first choice login name. No
    environment variables need to be set. If login is not enabled then one of
    the aforementioned methods should be used.


cEMicrosoft Windoes cA


    In Microsoft Windows environments, cD$LOGNAMEcA is sometimes defined.


cEcENOTES cEcA


    The three variables must be defined before start-up for them to have any
    effect.


cEcESEE ALSO cEcA


    lslmme(1)le, lslmuser-setup(3)le, lslmread-session(3)le, lslm$user-name(5)le, lslm$user-path(5)le,
    lslm$MEPATH(5)le.
! 5 $recent-keys
cEcENAME cEcA


    $recent-keys - Recent key history.
$a


cEcESYNOPSIS cEcA


    cD$recent-keyscA cCstringcA


cEcEDESCRIPTION cEcA


    cD$recent-keyscA is a system variable that displays the last 100 keys entered
    into the system in reverse order. This variable is typically used to solve
    keyboard mapping problems when keys are not bound etc. allowing a visual
    inspection of the input into the editor.

    The variable may only be set to the empty string (cC""cA), emptying the list.


cEcESEE ALSO cEcA


    lslmbuffer-bind-key(2)le, lslmglobal-bind-key(2)le, lslmlist-variables(2)le,
    lslmtranslate-key(2)le.
! 5 $cursor-x
! 5 $cursor-y
cEcENAME cEcA


|$cursor-x
    $cursor-x - Cursor X (horizontal) position
|$cursor-y
    $cursor-y - Cursor Y (vertical) position
$a


cEcESYNOPSIS cEcA


    cD$cursor-xcA cCintegercA

    0 <= cCintegercA <= ls$frame-depth(5)lm$frame-widthle - 1

    cD$cursor-ycA cCintegercA

    0 <= cCintegercA <= ls$frame-depth(5)lm$frame-depthle - 1


cEcEDESCRIPTION cEcA


    cD$cursor-xcA and cD$cursor-ycA are automatically set to the position of the
    cursor at the last screen update (i.e. the variables are not updated
    between screen updates). The top left character of the screen is
    coordinate 0,0 bottom right is ls$frame-depth(5)lm$frame-widthle, ls$frame-depth(5)lm$frame-depthle.


cEcENOTES cEcA


    These variables can not be set. Any attempt to set them will result in an
    error.


cEcESEE ALSO cEcA


    lslm$mouse-x(5)le, lslm$frame-depth(5)le, lslm$frame-width(5)le.
! 5 %http-proxy-addr
! 5 %http-proxy-port
cEcENAME cEcA


|%http-proxy-addr
    %http-proxy-addr - Set HTTP proxy server address
|%http-proxy-port
    %http-proxy-port - Set HTTP proxy server port
$a


cEcESYNOPSIS cEcA


    cD%http-proxy-addrcA "cCproxy-addrcA"
    cD%http-proxy-portcA "cCport-numbercA"; Default is cG80cA


cEcEDESCRIPTION cEcA


    If the cD%http-proxy-addrcA variable is set all HTTP file loading requests,
    using commands like lslmfind-file(2)le, are sent via the given proxy server.
    cD%http-proxy-portcA should be set to the proxy servers port number,
    defaulting to cG80cA if not set. These variables are typically set in your
    cG<user>.emfcA setup file, e.g.:
sB
        set-variable %http-proxy-addr "proxy.foobar.com"
        set-variable %http-proxy-port "8080"

sA

cEcENOTES cEcA


    Note that http is available on UNIX by default, but must be compiled in
    for win32 versions.


cEcESEE ALSO cEcA


    lslm%http-flags(5)le, lslmfind-file(2)le, lslmftp(3)le.
! 5 $trunc-scheme
cEcENAME cEcA


    $trunc-scheme - Truncation color scheme.
$a


cEcESYNOPSIS cEcA


    cD$trunc-schemecA cCschemeNumcA; Default is cG0cA


cEcEDESCRIPTION cEcA


    cD$trunc-schemecA sets the color scheme used when drawing a line truncation
    indicator. The left truncation character (usually a 'cG$cA' char) drawn at the
    start of the line indicates that the line has been scrolled to the right
    and therefore the start of the line has been truncated. A right truncation
    char (also usually a 'cG$cA') drawn at the end of the line indicates the
    remainder of the line is too long to fit onto the width of the window so
    the end has been truncated and the indicator drawn.

    The cCschemeNumcA selected must be a color scheme defined with
    lslmadd-color-scheme(2)le, which identifies the foreground and background color
    schemes. A hilight scheme can define its own truncation color scheme, see
    lslmhilight(2)le for more information.


cEcENOTES cEcA


    The truncation characters used are set by the lslm$window-chars(5)le variable.


cEcESEE ALSO cEcA


    lslm$buffer-scheme(5)le, lslm$global-scheme(5)le, lslmadd-color-scheme(2)le, lslmhilight(2)le,
    lslm$window-chars(5)le.
! 5 $window-x-scroll
! 5 $window-xcl-scroll
! 5 $window-y-scroll
cEcENAME cEcA


|$window-x-scroll
    $window-x-sroll - Current window X scroll
|$window-xcl-scroll
    $window-xcl-sroll - Current window current line X scroll
|$window-y-scroll
    $window-y-sroll - Current window Y scroll
$a


cEcESYNOPSIS cEcA


    cD$window-x-srollcA cCintegercA
    cD$window-xcl-srollcA cCintegercA

    0 <= cCintegercA <= 65535

    cD$window-y-srollcA cCintegercA

    0 <= cCintegercA <= n


cEcEDESCRIPTION cEcA


    cD$window-x-srollcA defines the horizontal scroll position in the current
    window for all lines except the current line, cD$window-xcl-srollcA defines
    the scroll position for the current line. The variables set how many
    characters are scrolled off the left hand edge of the current window, the
    variables are indirectly set by commands such as lslmscroll-left(2)le,
    lslmforward-char(2)le etc.

    cD$window-y-srollcA defines the vertical scroll position in the current
    window. It sets the number of lines are scroll up off the top of the
    current window, it is indirectly set by commands such as lslmscroll-up(2)le,
    lslmforward-line(2)le etc.


cEcEEXAMPLE cEcA


    The following example first stores the current window's buffer position
    and the window layout. The middle 'cG...cA' section could be replaced with
    macro code performing any number of operations before the last section
    which restores the initial position:
sB
            set-variable #l0 $window-line
            set-variable #l1 $window-col
            set-variable #l2 $window-xcl-scroll
            set-variable #l3 $window-x-scroll
            set-variable #l4 $window-y-scroll
                .
                .
                .
            set-variable $window-line #l0
            set-variable $window-col #l1
            set-variable $window-xcl-scroll #l2
            set-variable $window-x-scroll #l3
            set-variable $window-y-scroll #l4

sA

cEcENOTES cEcA


    If these variables are set by the user or a macro the value is validated
    against the lslm$scroll(5)le method and the current cursor position which may
    lead to the variable being reset if found to be invalid. For example, if
    the current line is 10 when the cD$window-y-scrollcA is set to 20 the variable
    will be reset to 0 as a value of 20 will mean the current line is not
    displayed in the current window.


cEcESEE ALSO cEcA


    lslmscroll-left(2)le, lslmscroll-up(2)le, lslm$scroll(5)le, lslm$window-line(5)le, lslm$window-col(5)le,
    lslm$window-acol(5)le.
! 5 $buffer-backup
! 5 $MEBACKUPPATH
! 5 $MEBACKUPSUB
cEcENAME cEcA


    $buffer-backup - Buffer backup file name
$a


cEcESYNOPSIS cEcA


    cD$buffer-backupcA cCFileNamecA


cEcEDESCRIPTION cEcA


    cD$buffer-backupcA is automatically set to the file name the current buffer's
    file would be backed up to if required. If the current buffer has no file
    name the variable will be set to "".

    The value depends on whether DOS compliant file names are being used (see
    lslm$system(5)le), whether multiple backups are being kept (see
    lslm$kept-versions(5)le) and the setting of the environment variables
    cD$MEBACKUPPATHcA and cD$MEBACKUPSUBcA. The variable does not take into
    consideration the current setting of the buffer's lslmbackup(2m)le mode which
    determine whether a backup will be made.

    The environment variable cD$MEBACKUPPATHcA can be used to change the location
    of the backup files, it can also be used to prepend the backup filename
    with a string. cD$MEBACKUPPATHcA can specify an absolute path (e.g.
    "cGc:/temp/mebackup/cA") or a relative path (e.g. "cGmebackup/cA" which will move
    all backup files into a sub-directory automatically in the files
    directory).

    The trailing 'cG/cA' is important as the file name is simple appended, i.e. is
    creating a backup for "c:/foo/bar.txt" and $MEBACKUPPATH is set the
    "backup" the backup file name will be "c:/foo/backupbar.txt".

    The environment variable cD$MEBACKUPSUBcA can be used to substitute strings
    within the backup filename for another. The format of the value is a list
    of cDsed(1)cA string substitutions, i.e.

        $MEBACKUPSUB="s/from1/to1/ s/from2/to2/ s/fr..."


    The 3 divide characters do not have to be '/'s, they can be any character
    as long as they are the same, e.g. "sXfrom1Xto1X". When define MicroEmacs
    performs a simple search for string "cGfrom1cA" (i.e. no regex support) and
    replaces any match with the string "cGto1cA" etc.


cEcEEXAMPLE cEcA


    The following example compares the differences between the current version
    and the bucked up version using the lslmdiff(3)le macro. The cDdiff-changescA macro
    is defined in cGtools.emfcA.
sB
        define-macro diff-changes
            !if &seq $buffer-fname ""
                ml-write "[Current buffer has no file name]"
                !abort
            !endif
            !if &bmod "edit"
                !if &iseq @mc1 "Save buffer first [y/n]? " "nNyY" "y"
                    save-buffer
                !endif
            !endif
            ; get the real file name - this only has effect on unix, copes with symbolic links
            set-variable #l0 &stat "a" $buffer-fname
            ; get the backup name
            set-variable #l1 $buffer-backup
            diff #l1 #l0
        !emacro

sA

cEcENOTES cEcA


    The variable cD$buffer-backupcA can not be set, any attempt to set it will
    result in an error.

    On Windows and DOS platforms if the $MEBACKUPPATH and $MEBACKUPSUB
    variables are used all remaining 'cG:cA' characters are changed to 'cG/cA's as
    these are illegal in the middle of a filename.


cEcESEE ALSO cEcA


    lslmbackup(2m)le, lslm$system(5)le, lslm$kept-versions(5)le.
! 5 $version
cEcENAME cEcA


    $version - MicroEmacs version date-code
$a


cEcESYNOPSIS cEcA


    cD$versioncA "cCYYYYMMDDcA"


cEcEDESCRIPTION cEcA


    cD$versioncA is a system variable which is defined as the MicroEmacs build
    date code. This value is fixed at compile time and cannot be changed. The
    variable may be used in macros to identify incompatibility issues.


cEcEEXAMPLE cEcA


    Given a macro that only operates with a MicroEmacs executable built on or
    after 1st August 2001 then this macro should check that cG$versioncA is not
    less than cG20010801cA. The check may be performed as follows:
sB
        !if &les $version "20010801"
            ml-write "[Error: MicroEmacs executable is incompatible]"
            !abort
        !endif

sA

cEcENOTES cEcA


    This variable was introduced in 2001-08-01, evaluating this variable on an
    earlier version of MicroEmacs would return the string "cGERRORcA" unless an
    environment variable $version has been defined. "cGERRORcA" evaluates to cG0cA
    hence the test still operates correctly.

    This variable is used in the macro file cGme.emfcA to check for any macro -
    executable incompatibility issues.
! 5 $window-flags
cEcENAME cEcA


    $window-flags - Current window setup flags
$a


cEcESYNOPSIS cEcA


    cD$window-flagscA cCbitmaskcA; Default is cG0cA


cEcEDESCRIPTION cEcA


    The cD$window-flagscA variable is used to set or get various behavioural
    characteristic settings of the current window, it is a bit based flag
    where:

    cD0x001cA
        If set the width of the window is locked, calls to
        lslmresize-all-windows(2)le will maintained the width of this window
        whenever possible.

    cD0x002cA
        If set the depth of the window is locked, calls to
        lslmresize-all-windows(2)le will maintained the depth of this window
        whenever possible.

    cD0x004cA
        If set the buffer being displayed by the window is locked, the user
        can still manually change the buffer being displayed (by using
        commands like lslmfind-buffer(2)le) but commands that pop-up buffers (such
        as lslmhelp(2)le or lslmfind-tag(2)le) will not use this window.

    cD0x008cA
        When set the command lslmcompare-windows(2)le will ignore this window.

    cD0x010cA
        When set the commands like lslmprevious-window(2)le and lslmnext-window(2)le will
        skip this window unless the numeric argument given to the command is
        used to override the flag setting.

    cD0x020cA
        When set the command lslmdelete-other-windows(2)le will not delete this
        window unless the numeric argument given to the command is used to
        override the flag setting.

    cD0x040cA
        When set the command lslmdelete-window(2)le will not delete this window
        unless the numeric argument given to the command is used to override
        the flag setting.

    cD0x080cA
        When set the window cannot be split using either the
        lslmsplit-window-horizontally(2)le or lslmsplit-window-vertically(2)le commands.

    cD0x100cA
        If not set the window cannot be deleted if it is the only window
        without this bit set. This more esoteric feature is utilized by the
        toolbar, all toolbar windows have this bit set which means that the
        main user window cannot be delete.


cEcENOTES cEcA


    The $window-flags setting is not preserved during a window splitting
    operation (i.e. using a command like lslmsplit-window-vertically(2)le) as the
    persistence of these settings can lead to unexpected behaviour.

    The toolbar uses bit 0x1000 to indicate that the window is displaying a
    toolbar tool, this bit should not be used by users and its value should be
    maintained.


cEcESEE ALSO cEcA


    lslmnext-window(2)le, lslmdelete-other-windows(2)le, lslmcompare-windows(2)le.
! 5 $line-flags
cEcENAME cEcA


    $line-flags - Current buffer line flags
$a


cEcESYNOPSIS cEcA


    cD$line-flagscA cCbitmaskcA; No default


cEcEDESCRIPTION cEcA


    The cD$line-flagscA variable is used to retrieve or define the behavioral
    settings of the current line in the buffer. This variable is a bit flag,
    the length of the bit flag is variable. In smaller builds of MicroEmacs
    where features have been disabled then the field is only 8 bits wide, in a
    normal build then the full 16 bits are present.

    cD0x0001cA
        The line has changed as a result of an edit and has not been
        re-displayed. The flag is cleared when the change has been displayed.
        This bit is read only.

    cD0x0002cA
        The line contains an alpha mark defined by lslmset-alpha-mark(2)le. This bit
        is read only.

    cD0x0004cA
        The line contains a narrow region, set by lslmnarrow-buffer(2)le. This bit
        is read only.

    cD0x0008cA
        The line contains some other type of anchor. This bit is read only.

    cD0x0010cA
        The line should be saved without a new-line or nil termination
        character.

    cD0x0020cA
        The line is a mark-up line used for annotation and should not be saved
        on a write operation. This bit permits lines in a buffer to be
        inserted for display or annotation purposes which are automatically
        discarded when the buffer is written to file. Mark-up lines are
        sometimes used by the buffer folding and collapsing to annotate folds.

    cD0x0040cA
        The line is protected. A protected line may be deleted or edited
        however it is not possible to split or join a protected line with any
        other line. This is used by the folding or collapse mechanisms to
        protect lsnarrow-buffer(2)lmnarrrowle regions from editing operations.

    cD0x0080-0x0800cA
        User defined. Users may use the upper most bits from left to right.
        JASSPA may use more bits in future releases which shall be consumed
        from the lower bits, right to left.

    cD0xf000cA
        The shifted lslm$line-scheme(5)le setting. A value of zero indicates that
        there is no line scheme in effect on the line.

    Where a bit flag is defined as read only then an attempt by the user to
    set a read-only bit then the bit setting is ignored, any remaining
    writable bits are set as requested.


cEcEEXAMPLE cEcA


    Refer to the file cGfold.emfcA for examples of the use of cD$line-flagscA.


cEcENOTES cEcA


    cD$line-flagscA was first introduced in MicroEmacs '04.


cEcESEE ALSO cEcA


    lslmnarrow-buffer(2)le, lslmset-alpha-mark(2)le, lslmset-variable(2)le, lslm$buffer-hilight(5)le,
    lslm$buffer-scheme(5)le lslm$line-scheme(5)le.
! 5 $frame-id
cEcENAME cEcA


    $frame-id - Current frame identity


cEcESYNOPSIS cEcA


    cD$frame-idcA


cEcEDESCRIPTION cEcA


    cD$frame-idcA retrieves the identity of the current frame, this is a integer
    value (1..n) that is automatically allocated when the frame was created
    using lslmcreate-frame(2)le.

    The cD$frame-idcA is guaranteed to be unique and is typically used in macros
    to locate a previously created frame.


cEcESEE ALSO cEcA


    lslmcreate-frame(2)le, lslmdelete-frame(2)le, lslmnext-frame(2)le, lslm$window-id(5)le.
! 5 $window-id
cEcENAME cEcA


    $window-id - Current window identity


cEcESYNOPSIS cEcA


    cD$window-idcA


cEcEDESCRIPTION cEcA


    cD$window-idcA retrieves the identity of the current window, this is a integer
    value (1..n) that is automatically allocated when a window is created
    using lslmsplit-window-horizontally(2)le or lslmsplit-window-vertically(2)le.

    The cD$window-idcA is guaranteed to be unique and is typically used in macros
    to locate a previous window.


cEcESEE ALSO cEcA


    lslmnext-window(2)le, lslmsplit-window-horizontally(2)le, lslmsplit-window-vertically(2)le,
    lslm$frame-id(5)le.
! 5 $user-name
cEcENAME cEcA


    $user-name - MicroEmacs user name


cEcESYNOPSIS cEcA


    cD$user-namecA


cEcEDESCRIPTION cEcA


    cD$user-namecA is the name of the MicroEmacs user. The name is used for
    identifying user configuration files such as cC$user-namecAcD.emfcA and
    cC$user-namecAcD.erfcA, the start-up lsUserProfiles(2)lmuserle macro file and lslmerf(8)le registry file that
    contains saved user preferences.

    The cD$user-namecA is determined as follows, in order of precedence:

        * The lslmme(1)le command line option cD-ucA cCusernamecA.
        * The environment variable ls$MENAME(5)lmMENAME(5)le (alternatively via cG$LOGNAMEcA on
          Microsoft Windows platforms ONLY).
        * The name determined from the system. On UNIX then the cG/etc/passwdcA
          entry is used, on MicroSoft Windows then the login name is used.
        * When no other name is located then cGusercA is used (MS-DOS and
          Microsoft Windows environments running without a login mechanism).

    For most conventional cClogincA systems then the correct login name is
    retrieved and it is not necessary to over-ride the name, unless a special
    configuration of MicroEmacs is being used.


cEcENOTES cEcA


    The user should not attempt to write to cD$user-namecA, the variable should be
    controlled through the aforementioned techniques.

    cD$user-namecA was first introduced into MicroEmacs in the 2004 release.


cEcESEE ALSO cEcA


    lslmme(1)le, lslm$home(5)le, lslm$search-path(5)le, lslm$user-path(5)le, lslm$MENAME(5)le, lslmemf(8)le,
    lslmerf(8)le.
! 5 $user-path
cEcENAME cEcA


    $user-path - MicroEmacs user directory


cEcESYNOPSIS cEcA


    cD$user-pathcA


cEcEDESCRIPTION cEcA


    cD$user-pathcA is the name of the MicroEmacs user directory where user
    configuration files such as ls$user-name(5)lm$user-namelecD.emfcA, ls$user-name(5)lm$user-namelecD.erfcA and personal
    spelling dictionaries are stored. This is an absolute directory path and
    is always terminated with a directory separator character 'cG/cA'.

    The value of the variable is determined when the editor is started as
    follows:

        * The environment variable lslm$MEUSERPATH(5)le is defined, the cD$user-pathcA
          is set to this value. If the environment cD$MEUSERPATHcA is defined
          without a trailing 'cG/cA' then it is automatically added.
        * The environment variable lslm$MEPATH(5)le is defined and lslm$MEUSERPATH(5)le is
          undefined. The first directory in the cD$MEPATHcA variable is used as
          the cD$user-pathcA directory.
        * The directory is determined from the system:
        cDUNIXcA: the home directory from cG/etc/passwdcA entry is used and appended
        with cG.jasspacA i.e. cG$HOME/.jasspacA, if the sub-directory ls$user-name(5)lm$user-namele is
        detected in this directory then it is used instead
        (cG$HOME/.jasspa/$user-namecA).
        cDMicrosoft WindowscA: the user application data directory is obtained
        from the system and appended with cGjasspacA i.e. cG$APPDATA/jasspacA. If the
        sub-directory ls$user-name(5)lm$user-namele is detected in this directory then it is used
        instead (cG$APPDATA/jasspa/$user-namecA).
        cDMS-DOScA and older versions of cDMicrosoftcA cDWindowscA without cCInternetcA
        cCExplorercA cC4.0cA then a sub-directory ls$user-name(5)lm$user-namele of the program directory
        lslm$progname(5)le is used.

    For most conventional cClogincA systems then the correct user path is
    retrieved and it is not necessary to over-ride the pathname, unless a
    special configuration of MicroEmacs is being used. Where the user
    directory is to be manually specified then lslm$MEUSERPATH(5)le is the preferred
    method.


cEcENOTES cEcA


    The user should not attempt to write to cD$user-pathcA, the variable should be
    controlled through the aforementioned techniques.


cEcESEE ALSO cEcA


    lslmme(1)le, lslm$home(5)le, lslm$progname(5)le lslm$search-path(5)le, lslm$user-name(5)le,
    lslm$MEINSTALLPATH(5)le, lslm$MENAME(5)le, lslm$MEPATH(5)le, lslm$MEUSERPATH(5)le, lslmemf(8)le, lslmerf(8)le.
! 5 $MEINSTALLPATH
! 5 $MEPATH
! 5 $MEUSERPATH
cEcENAME cEcA


|$MEINSTALLPATH
    $MEINSTALLPATH - MicroEmacs system macros search path
|$MEPATH
    $MEPATH - MicroEmacs search path
|$MEUSERPATH
    $MEUSERPATH - MicroEmacs user directory
$a


cEcESYNOPSIS cEcA


    cC[Microsoft Windows/MS-DOS]cA
    cD$MEINSTALLPATHcA cC<path1>cAcD;cAcC<path2>cAcD;cA....cD;cAcC<pathn>cA
    cD$MEPATH=cA cC<path1>cAcD;cAcC<path2>cAcD;cA....cD;cAcC<pathn>cA
    cD$MEUSERPATHcA cC<path>cA

    cC[UNIX]cA
    cD$MEINSTALLPATHcA cC<path1>cAcD:cAcC<path2>cAcD:cA....cD:cAcC<pathn>cA
    cD$MEPATH=cA cC<path1>cAcD:cAcC<path2>cAcD:cA....cD:cAcC<pathn>cA
    cD$MEUSERPATHcA cC<path>cA


cEcEDESCRIPTION cEcA


    These environment variables control the run-time search paths for
    MicroEmacs and affect the operation of lslm$search-path(5)le and lslm$user-path(5)le,
    the macro search path and user macro directory respectively.

    cD$MEINSTALLPATHcA is an environment variable that overrides any internally
    defined search path for MicroEmacs system macros and defines the root
    directory(s) of the MicroEmacs system macros. The presence of the
    environment variable affects lslm$search-path(5)le.

    The environment variable cD$MEINSTALLPATHcA is ignored if cD$MEPATHcA is defined.
    The search path is always included after any user path defined by
    lslm$user-name(5)le.

    cD$MEUSERPATHcA is an environment variable that defines the users private
    directory where user configuration files such as ls$user-name(5)lm$user-namelecD.emfcA,
    ls$user-name(5)lm$user-namelecD.erfcA and personal spelling dictionaries are stored. This is an
    absolute directory path. The environment variable sets the MicroEmacs
    variable lslm$user-name(5)le.

    cD$MEPATHcA is an environment variable that may be used to define the absolute
    search path for MicroEmacs macro files and affects the setting of
    cD$search-pathcA. The path should include the system macros location(s) and
    should include the user directory location lslm$user-path(5)le as the first path
    when the environment variable lslm$MEUSERPATH(5)le is not defined. If
    cD$MEUSERPATHcA is defined then this path name appears before the cD$MEPATHcA
    variable to define the user directory location. cD$MEPATHcA is not searching,
    so ALL all directories to be searched must be included in the path
    specification.

    lslm$MEUSERPATH(5)le is the preferred method used to defined the user directory.


cESearch Paths cA


    MicroEmacs needs to know the installation directory location(s) of its
    macro files when it executes, this includes both user defined and system
    macros. MicroEmacs performs a searching operation of well-known directory
    locations where it may expect to find these macros at start up, the
    locations that it has found are saved in macro variables lslm$user-path(5)le and
    lslm$search-path(5)le and are used to subsequently locate files thereafter. The
    environment variables defined here allow that default search process to be
    modified by the user or system administrator.

    Directories are specified as cCsearchingcA if a search operation is performed.
    The following sub-directories of a base directory are searched for the
    existence of subdirectories:

        cC.cA - root directory.
        ls$user-name(5)lm$user-namele - private user directory.
        cCcompanycA - company files.
        cCmacroscA - JASSPA standard macros.
        cCspellingcA - spelling dictionaries.

    MicroEmacs performs a searching operation on some directories to locate
    information. Generally, if the directory exists then it is included in the
    search path, otherwise it is excluded. Any subdirectories that are found
    are added in the order presented above. The ls$search-path(5)lm$search-pathle is ONLY evaluated
    at start-up therefore directories created after MicroEmacs is running are
    not detected until the editor is closed down and re-started.


cEUNIX cA


    The defined search paths for UNIX are defined as follows:-

    Default install directories:-

        cC/opt/jasspacA - searching (SunOS, HP-UX, AIX and IRIX only)
        cC/usr/share/jasspacA - searching
        cC/usr/local/share/jasspacA - searching (BSD systems only)
        cC/usr/local/jasspacA - searching

    The default user location is defined as follows.

        cC$(passwd-home)/.jasspacA - searching

    MicroEmacs searches for user defined configuration files in this directory
    and will write new user configuration files to this directory. The
    behaviour of the search may be over-ridden by setting some environment
    variables.

    cG$MEUSERPATHcA - not searching
        Specified as a single pathname and redefines the cC$user-pathcA where user
        macros are placed, this overrides the cC$(passwd-home)/.jasspacA directory
        location.

    cG$MEINSTALLPATHcA - searching
        Specified as multiple pathname components and overrides the default
        install directory location (i.e. cG/usr/local/jasspacA, etc. Typically
        used when the system macro directory has been install in another
        location that is not included in the default search path. This does
        not affect the user directory location.

    cG$MEPATHcA - not searching
        Overrides the cC$(passwd-home)/.jasspacA and default search paths
        (including cG$MEINSTALLPATHcA), MicroEmacs will use this directory as the
        search path. The user directory is assumed to be the FIRST directory
        path in the string unless the cG$MEUSERPATHcA environment variable is
        defined which specifies the user path.


cEMicrosoft Windows cA


    he defined search paths for WINDOWS are defined as follows:-

        Default search locations:-

        cCExecutable directory locationcA - searching

    The default user location is defined as follows. MicroEmacs searches for
    user defined configuration files in this directory and will write new user
    configuration files to this directory.

        cC$APPDATA\jasspacA - not searching

    If the system does not define a user application data location (cDWin95cA and
    cDWin32scA) then a directory ls$user-name(5)lm$user-namele or the executable location is used.

    The behaviour may be over-ridden by setting the environment variables as
    follows:

    cG$MEUSERPATHcA - not searching
        Specified as a single pathname and redefines the users home directory,
        this overrides the cC$APPDATA\jasspacA directory location.

    cG$MEINSTALLPATHcA - searching
        Specified as multiple pathname components and overrides the default
        install directory location. Typically used when the macro directory
        has been install in another location that is not in the same directory
        as the executable. This does not affect the user directory location.

    cG$MEPATHcA - not searching
        Overrides the cC$APPDATA\jasspacA and default search paths. MicroEmacs
        will use the FIRST directory path as the ls$user-path(5)lm$user-pathle unless cG$MEUSERPATHcA
        is defined.


cEMS-DOS cA


    MS-DOS does not include a concept of a user name or user directory.

        Default search locations:-

        cCExecutable directory locationcA - searching

    If a sub-directory exists at the executable location with name ls$user-name(5)lm$user-namele
    then this is used as ls$user-path(5)lm$user-pathle, otherwise the execution directory
    location is used.

    The behaviour may be over-ridden using the environment variables.

    cG$MEUSERPATHcA - not searching
        Specified as a single pathname and redefines the ls$user-path(5)lm$user-pathle overriding
        the cCexecutablecA directory location.

    cG$MEINSTALLPATHcA - searching
        Specified as multiple pathname components and overrides the default
        executable directory location. Typically used when the macro directory
        has been installed at a different location that is not in the same
        directory as the executable. This does not affect the user directory
        location.

    cG$MEPATHcA - not searching
        Overrides the cCExecutable...cA and default search paths (including
        cG$MEINSTALLPATHcA). MicroEmacs will use FIRST directory path as the
        ls$user-path(5)lm$user-pathle unless cG$MEUSERPATHcA is defined.


cEcESEE ALSO cEcA


    lslmme(1)le, lslm$home(5)le, lslm$progname(5)le lslm$search-path(5)le, lslm$user-name(5)le, lslmemf(8)le,
    lslmerf(8)le.
! 5 $indent-width
! 5 $buffer-indent-width
cEcENAME cEcA


|$indent-width
    $indent-width - Global indentation width in characters
|$buffer-indent-width
    $buffer-indent-width - Buffer indentation width in characters
$a


cEcESYNOPSIS cEcA


    cD$indent-widthcA
    cD$buffer-indent-widthcA


cEcEDESCRIPTION cEcA


    cD$indent-widthcA defines the default indentation width assumed by the editor,
    this defines the number of characters the lslmindent(2)le command should use for
    indenting text. Once the value is set then all new buffers that are
    subsequently created assume an indent value of cD$indent-widthcA. The default
    value when omitted is 4 characters.

    cD$buffer-indent-widthcA specifies the indent to use in a buffer, the value of
    cD$indent-widthcA is used as a default when the buffer is created.
    Modification of the cD$buffer-indent-widthcA value causes the buffer
    indentation width to be modified. The value is typically set by the
    cDfhook-xxxcA macro when initializing a buffer using the lslanguageTemplates(2)lmLanguage Templatesle.


cEcENOTES cEcA


    cD$buffer-indent-widthcA and cD$indent-widthcA were introduced into MicroEmacs in
    November 2004.


cEcESEE ALSO cEcA


    lslmindent(2)le.
    lslanguageTemplates(2)lmLanguage Templatesle.
! 5 $mode-chars
cEcENAME cEcA


    $mode-chars - Mode characters


cEcESYNOPSIS cEcA


    cD$mode-charscA


cEcEDESCRIPTION cEcA


    cD$mode-charscA is a read-only variable that returns a string that contains
    all of the buffer mode characters. The variable is typically used in the
    macros to determine the integer value of a buffer mode, the string is
    defined as follows:

        AaBbcYzdDeEfHIJkMnNOPQrSTtU12345678VW


    The index into the string matches lslm$show-modes(5)le.


cEcESEE ALSO cEcA


    lslm$show-modes(5)le.
! 5 $quiet
cEcENAME cEcA


    $quiet - Quiet mode control variable


cEcESYNOPSIS cEcA


    cD$quietcA


cEcEDESCRIPTION cEcA


    cD$quietcA is variable that controls the audible and visual warnings. When the
    variable is set to 0 then quiet mode is disabled, when set to 1 then quiet
    mode is enabled.

    When quiet mode is enabled, visual warnings are given instead of the
    default audible warning. This mode can only be globally changed, an error
    will occur if an attempt is made to change the mode for a buffer.

    The default state is on, so users of MicroEmacs can relax in the knowledge
    that they will not annoy other people when things go wrong.

    When disabled the system bell is rung when required, otherwise the usual
    visual warning is the "[BELL]" string, printed on the bottom right hand
    side.


cEcESEE ALSO cEcA


    lslm!bell(4)le.
! 8 eaf
cEcENAME cEcA


    eaf - MicroEmacs abbreviation file format


cEcESYNOPSIS cEcA


    cC<pattern> <insertionString>cA
    cC<pattern> <insertionString>cA
    cC<pattern> <insertionString>cA
    cC<pattern> <insertionString>cA


cEcEDESCRIPTION cEcA


    The MicroEmacs 2009 abbreviation file, typically given the extension cD.eafcA,
    defines a set of shorthand expansion strings which are used by the command
    lslmexpand-abbrev(2)le. lslmbuffer-abbrev-file(2)le defines the abbreviation file.

    The abbreviation file line based, with one abbreviation per line, with no
    intervening blank lines. Each line comprises of two columns, the first
    column cC<pattern>cA identifies the source pattern to be expanded, the second
    column cC<insertionString>cA defines the replacement text. The two text
    columns are separated by a space character.

    When lslmexpand-abbrev(2)le is invoked and the expansion cC<pattern>cA is
    recognized, then cC<pattern>cA is deleted from the buffer and replaced with
    cC<insertionString>cA.

    The fields are defined as follows:-

    cC<pattern>cA
        The source pattern to be expanded. The data commences in text column 0
        and spans to the first white space character (cGSPACEcA or cGtabcA). The
        pattern may not include any white space characters.

    cC<insertionString>cA
        The replacement string exists from the first non-white space character
        following the cC<pattern>cA to the end of the line. The replacement string
        may include special tokens, delimited by a backslash ('cG\cA') character
        which are interpreted as follows:-

        cD\bcA Move cursor backwards
            A positioning control. Allows the cursor to be moved backwards 1
            character.

        cD\dcA Delete cGtabcA backwards
            Back tab. Deletes a tab character backwards.

        cD\m"cAcC<string>cAcD"cA Macro execution
            Takes the remainder of the line as a keyboard macro definition.
            The macro cCstringcA is generated using lslminsert-macro(2)le and must be
            contained in double quotes. When invoked the keyboard macro is
            executed and the appropriate text is inserted into a buffer. This
            is typically only used for more complex operations.

        cD\pcA Position
            The resultant position of the cursor following the expansion. If
            the cursor position is not specified, the cursor is placed at the
            end of the expansion string by default.

        cD\rcA Carriage Return (Newline)
            A newline in the replacement text. Note while lslmindent(2m)le is
            enabled a sequence a single "\r" retains the indent on the next
            line, however a sequence of two "\r\r" characters does not retain
            the tab position and returns the cursor to the start of the second
            line. If blank lines are required retaining tab positioning then a
            keyboard macro string should be used instead. (see "\m" above).

        cD\tcA Tab
            A cGtabcA character in the replacement text.


cEcEEXAMPLE cEcA


    The following example provides abbreviations for the 'C' programming
    language, found in file cDc.eafcA. All cursor positions in the examples are
    shown by cD<@>cA.

        #i #include <\p>\r
        #d #define \p
        if if(\p)\r{\r\r}\r
        ef else if(\p)\r{\r\r}\r
        el else\r{\r\p\r}\r
        wh while(\p)\r{\r\r}\r
        sw switch(\p)\r{\rcase :\rdefault :\r}\r


    Given that the abbreviation file has been declared then expansion of:

        #d<@>       =>      #define <@>

        if<@>       =>      if(<@>)
                            {

                            }

        sw<@>       =>      switch(<@>)
                            {
                            case :
                            default :
                            }


    Note, in all of the examples, the abbreviation replacement strings specify
    a resultant cursor position, typically where the next edit will take
    place.

    The macros may alternatively be defined using keyboard macros. The
    aforementioned macros could have been re-written with the following
    definitions which are equivalent:-

        #i \m"#include <\CX\CAP>\CM\CXaP\CX)"
        #d \m"#define \CX)"
        if \m"if(\CX\CAP)\CM{\CM}\CXaP\CX)"
        ef \m"else if(\CX\CAP)\CM{\CM\CM}\CM\CXaP\CX)"
        el \m"else\CM{\CM\CX\CAP\CM}\CM\CXaP\CX)"
        wh \m"while(\CX\CAP)\CM{\CM\CM}\CM\CXaP\CX)"
        sw \m"switch(\CX\CAP)\CM{\CMcase :\CMdefault:\CM}\CM\CXaP\CX)"


    Within a macro, the cursor positioning is generally achieved by setting a
    mark where the resultant cursor is to be positioned (see lslmset-mark(2)le),
    when the macro is finished then an lslmexchange-point-and-mark(2)le is initiated
    to move the cursor to the correct position; alternatively a sequence of
    cursor movements may be used.

    The "\b" and "\d" are typically used for positioning the cursor on
    subsequent lines. "\d" is the inverse of "\t". Consider the following
    Pascal definition for an cCelsecA, cCbegincA and cCendcA sequence:-

        el else\rbegin\r\t\p;\r\dend;


    with lslmindent(2m)le mode enabled generates:-

                else
                begin
                    <@>;
                end;


    Similarly the "\b" is typically used when lslmindent(2m)le is enabled, but when
    the tab spacing is known. Consider the following example used in the
    MicroEmacs 2009 cD.emfcA files to define a help entry. In this case the indent
    is known to be 5 characters. Hence to move the cursor back 5 characters
    then a sequence of cD\bcA's are used:-

        !h def .. \rSEE ALSO\r     <cross references>\r\b\b\b\b\b!ehelp


    the expansion in this case is:-

        define-help "<@>"

        ...

        SEE ALSO
             <cross references>
        !ehelp


cEcEFILES cEcA


    The default abbreviation files are located in the MicroEmacs 2009 cChomecA
    directory.

    User's may specify their own abbreviation files by shadowing the cChomecA
    directory file with their own file located in a personal MicroEmacs 2009
    directory. See lslm$user-path(5)le.


cEcESEE ALSO cEcA


    lslmexpand-abbrev(2)le, lslmbuffer-abbrev-file(2)le, lslmglobal-abbrev-file(2)le,
    lslmiso-accents-mode(3)le, lslm$user-path(5)le.
! 8 etf
cEcENAME cEcA


    etf - MicroEmacs template file format


cEcESYNOPSIS cEcA


    cC<Free Form Text>cA


cEcEDESCRIPTION cEcA


    The MicroEmacs 2009 template file, typically given the extension cD.etfcA, is
    a file template for a new file and defines common text that is
    automatically included when a new file is created.

    The file inclusion is usually performed by macro lslmetfinsrt(3)le, called from
    the lsfileHooks(2)lmFile Hooksle. The template file has no specific format, although
    cDetfinsrtcA replaces key strings with relevant information.


cEcEEXAMPLE cEcA


    The template file is inserted with the file hooks. If a file hook is
    called with an argument of cG0cA then the buffer has been created and the
    template file is inserted.
sB
        define-macro fhook-c
            ; if arg is 0 this is a new file so add template
            !if &not @#
                ; Is it an include h file or a c file?
                !if &seq &mid $buffer-bname &rsin "." $buffer-bname 1 "h"
                    etfinsrt "h"
                !else
                    etfinsrt "c"
                !endif
            !endif
            1 buffer-mode "time"
            .
            .
        !emacro

sA
    See lslmetfinsrt(3)le for more information on how the template file is located
    and inserted into the buffer.

    The default MicroEmacs 2009 'C' mode template is defined as follows, but
    may be replaced with any other text:-

        /* -*- C -*- ****************************************************************
         *
         *     Copyright $YEAR$ $COMPANY_NAME$.
         *         All Rights Reserved
         *
         *
         *  System        :
         *  Module        :
         *  Object Name   : m8fil001.8
         *  Created By    : $USER_NAME$
         *  Created       : $ASCII_TIME$
         *  Last Modified : <090829.1633>
         *
         *  Description
         *
         *  Notes
         *
         *  History
         *
         ****************************************************************************
         *
         *  Copyright (c) $YEAR$ $COMPANY_NAME$.
         *
         *  All Rights Reserved.
         *
         * This  document  may  not, in  whole  or in  part, be  copied,  photocopied,
         * reproduced,  translated,  or  reduced to any  electronic  medium or machine
         * readable form without prior written consent from $COMPANY_NAME$.
         *
         ****************************************************************************/

        static const char rcsid[] = "@(#) : $Id$";



cEcEFILES cEcA


    The default template files are located in the MicroEmacs 2009 cChomecA
    directory.

    User's may specify their own template files by shadowing the cChomecA
    directory file with their own file located in a personal MicroEmacs 2009
    directory. See lslm$user-path(5)le.


cEcESEE ALSO cEcA


    lsfileHooks(2)lmFile Hooksle.
    lslmetfinsrt(3)le, lslm&find(4)le, lslm$user-path(5)le.
! 8 edf
cEcENAME cEcA


    edf - MicroEmacs spelling dictionary file


cEcESYNOPSIS cEcA


    cDlsdmenus.edfcA
    cCusercAcD.edfcA


cEcEDESCRIPTION cEcA


    The spelling dictionary files are given the extension cD.edfcA. These are
    binary files read by MicroEmacs 2009 and cannot be edited directly.

    MicroEmacs 2009 is supplied with a dictionaries for various languages. It
    is recommended that these dictionaries are not modified, a personal
    dictionary is used and modified instead.

    A personal dictionary, cCusercAcD.edfcA, is automatically created in the users
    directory for additional spelling information.


cEcEFILES cEcA


    The standard dictionary files lsdmcC<language><country>cAcD.edfcA are located in
    the MicroEmacs 2009 cChomecA directory.

    User's may create their own dictionary files by shadowing the cChomecA
    directory file with their local dictionary(s) located in a personal
    MicroEmacs 2009 directory. See lslm$search-path(5)le.


cEcESEE ALSO cEcA


    lslmspell(2)le, lslmadd-dictionary(2)le, lslm$search-path(5)le.
! 8 emf
cEcENAME cEcA


    emf - MicroEmacs macro file


cEcESYNOPSIS cEcA


cEcEDESCRIPTION cEcA


    The MicroEmacs 2009 macro files are ASCII text files, given the file
    extension cD.emfcA. A number of special macro files exist as follows:-

    cDme.emfcA
        The start-up macro file. This file is the first macro file to be
        invoked and is used to bootstrap MicroEmacs 2009 into the correct
        configuration.

    cDhkcAcC<name>cAcD.emfcA
        Macro files prefixed with cDhkcA generally denote lsfileHooks(2)lmFile Hookle macro files
        which are automatically invoked when known file types are loaded.

    cC<logname>cAcD.emfcA
        The users start-up configuration file, typically used to configure the
        environment with the users preferences.

    cC*cAcDterm.emfcA
        Platform specific configuration files, used to configure the
        environment for a specific platform.

    Macro files may be any name, the more prominent macro files are:-

    cDcolor.emfcA
        Color definitions for the buffers.

    cDmouse.emfcA
        Mouse interaction macros.

    cDosd.emfcA
        OSD Menu configuration file.


cEcEFILES cEcA


    The default start-up file cDme.emfcA is located in the MicroEmacs 2009 cChomecA
    directory lslm$user-path(5)le.

    User's may create their own start-up and files in their local MicroEmacs
    2009 directory. The users start-up file is called ls$user-name(5)lm$user-namelecD.emfcA, and may
    be used to execute other macro files defined by the user.


cEcESEE ALSO cEcA


    lsfileHooks(2)lmFile Hooksle, lslmemftags(3f)le, lslm$user-path(5)le, lslmexecute-file(2)le.

    lsmacroWriting(4)lmWriting MicroEmacs Macrosle
    lsMicroEmacs - Macro Language GlossarylmMacro Glossaryle
    lsmacroDebugging(4)lmMacro Debugging - A Crash Coursele
    lsmacroOverview(4)lmMicroEmacs Macro Language at a Glancele
! 8 erf
cEcENAME cEcA


    erf - MicroEmacs registry file


cEcESYNOPSIS cEcA


    cC; Comment to the end of the linecA
    cC<command>cA ::= cD"cAcC<identifier>cAcD"cA [ cD=cA cD"cAcC<string>cAcD"cA ][ cD{cA cC<command>cA cD}cA ] *


cEcEDESCRIPTION cEcA


    MicroEmacs 2009 registry files are ASCII text files, given the file
    extension cD.erfcA. The registry file is a simple syntax that allows an
    cCidentifiercA to be associated with a cCstringcA. The cCidentifierscA are unique and
    allow a cCstringcA value to be found when a search for a cCidentifiercA is made.
    The cCstringcA component is optional.

    The syntax allows the cCidentifiercA's to be hierarchically nested, children
    of the cCidentifiercA node are enclosed in a set of curly braces cD{cA ... cD}cA. The
    enclosure itself comprises a number of cCidentifierscA, which may have their
    own enclosures, and so on.

    The backslash character `cG\cA' is the escape character, the following
    sequences of escape character are recognized:-

        cG\\cA - Literal backslash
        cG\"cA - Double quote (used within a quoted string)
        cG\ncA - New line character.
        cG\tcA - Tab character.

    The semi-colon character `cG;cA' introduces a comment which exists to the end
    of the line.


cEcEEXAMPLE cEcA


    The following is an example of a registry file:-

        ; -!- erf -!-
        ; Comment on this line
        "dos"
        {
            "file-ignore" = "~ ./ .o"
            "font" = "85"
            "mail-dir" = "c:/mail/"
            "mail-send" = "echo from \"%f\" file \"%o\""
            "mail-src" = "c:/mail/jon"
            "nested"="value"
            {
                "foo"="bar"
            }
        }


    The history file cCusername.erfcA is a good example of the use of the
    registry. This file retains historical session information in The history
    registry file is automatically written at the end of a editing session
    when the editor is closed down (or may be saved explicitly using
    lslmsave-session(3)le).

    Every user should have their own personal history file in their personal
    MicroEmacs directory. The history file is located from the MicroEmacs 2009
    search path defined by lslm$user-path(5)le, and is named by the variable
    lslm$user-name(5)le.


cEcENOTES cEcA


        * The registry files are not currently written with a backup.
        * Special care should be taken when editing registry files when they
          are loaded into MicroEmacs. It is recommended that the registry file
          is not loaded as a registry item when editing the registry text
          file.

    To edit the history registry file within MicroEmacs then the following
    sequence of steps should be followed:-

        * Save the current session lslmsave-session(3)le.
        * Load the history registry file cCusernamecA.erf.
        * Edit the file.
        * Save edits back to the file.
        * Re-install the history lslmread-session(3)le. This flushes the current
          session and restores it from the file. The new edits should now be
          in the registry.
        * Examine the loaded registry using lslmlist-registry(2)le.


cEcESEE ALSO cEcA


    lslmlist-registry(2)le, lslmread-registry(2)le, lslmread-session(3)le, lslmsave-session(3)le,
    lslm$user-name(5)le, lslm$user-path(5)le.
! 8 ehf
cEcENAME cEcA


    ehf - MicroEmacs help file


cEcESYNOPSIS cEcA


    cD!cAcC<helpTag>cA
    cC<Text Description>cA
    ...
    cD|cAcC<helpId>cA
    cC<Text Description Line>cA
    ...
    cD$cAcC?cA
    ...
    cC<Text Description>cA
    cD!cAcC<helpTag>cA
    cD!cAcC<helpTag>cA
    cC<Text Description>cA
    ...


cEcEDESCRIPTION cEcA


    The on-line help information is retained in the file cDme.ehfcA, this is an
    ASCII text file which holds all of the on-line help information. The help
    file comprises of formatted text cC<Text Description>cA which is literally
    displayed to the user when help information is requested. Each text
    description is delimited into pages with a cD!cAcC<helpTag>cA which identifies the
    block of text with a help label.

    The cD!cAcC<helpTag>cA is placed before the text description and is identified by
    a exclamation mark (`cD!cA') placed at the beginning of the line. The
    cC<helpTag>cA is the identifying name used by the help system and takes the
    following form:

        cGLSSNNNN...cA

    Where:

    cDLcA
        Is the length of the "cGNNNN...cA" name which must be matched, a value of
        'cG cA' indicates that the whole name must be matched, otherwise the value
        must be in the range 'cG1cA' - 'cG9cA' indicating the number of characters to
        be match.

    cDSScA
        Is the section number of the page, the first character should be a
        numeric (i.e. 'cG3cA' for a macro) and the second is an optional section
        letter. A value of 'cG cA' indicates no section number and/or letter.

    cDNNNN...cA
        The page name, the length is unlimited but must be on one line.

    Multiple cC<helpTag>cA's may be associated with a common text description by
    proceeding a block of text with multiple tags, each on a separate line,
    with no intervening non-tag lines (i.e. lines that do not commence with
    cD!cA).

    The cC<Text Description>cA that follows is the text associated with the tag.
    When the help system is invoked with the tag then the text is displayed.
    There are 2 types of internal command lines, lines starting with a 'cG|cA'
    indicate that the following line should only be displayed if the requested
    help page is cC<helpId>cA, where cC<helpId>cA is the the name used in the
    cC<helpTag>cA. This is a useful mechanism for pages with multiple cC<helpTag>cAs.

    Lines which contain just "cG$?cA" are MicroEmacs command lines where cG?cA can be:

    cGacA
        For a command help page display any global key bindings, for variables
        display its current value.

    MicroEmacs uses a special hilighting scheme to control color schemes and
    hyper-text links, the special embedded tags all start with and escape
    character (0x1b or 'cG^[cA') and are defined as follows:

    cG^[c?cA
        Tag used to change color where cG?cA can be:
            cGA  cAwhite, used for main text.
            cGB  cAred, used for underlining.
            cGC  cAgreen, used for italic font.
            cGD  cAcyan, used for bold font.
            cGE  cAlight yellow, used for a header.
            cGF  cAlight red, used for and image link.

    cG^[s?cA
        Tag used to change hilighting scheme where cG?cA can be:
            cGA  cANormal ehf hilight.
            cGB  cAMicroEmacs macro (or emf) hilighting.
        Note that other tags can only be used in the normal ehf hilighting
        scheme.

    cG^[ls<link>^[lm<name>^[lecA
        Used to create hyper-links, cG<link>cA is the help link name which can be
        omitted if it is the same as cG<name>cA. cG<name>cA should not contain any
        other tags, it is automatically displayed in the magenta color scheme.


cEcENOTES cEcA


    When the help system is invoked for the first time, cDme.ehfcA is loaded into
    internal memory and fragmented into labeled pages using the cC<helpTag>cA
    information. Hence, any edits made to cDme.emfcA are not visible in the help
    system until the next session.

    Macros and alike may add additional help information to the internal help
    database at run-time using the lslmdefine-help(2)le command.

    The help hilighting is applied to the help buffer from the hilighting
    macro's defined in cDhkhelp.emfcA. The hilighting is NOT part of the help
    file.

    Special hilighting keys may be included in cDme.ehfcA provided that they are
    interpreted by the help hilighting defined in cDhkehf.emfcA.

    cC<Text Description>cA lines cannot commence with cD!cA, cD|cA or cD$cA in the first
    column.


cEcEEXAMPLE cEcA


    The following help entry defines the help for lslmglobal-mode(2)le,
    lslmadd-global-mode(3)le and lslmdelete-global-mode(3)le. It uses most features
    mentioned, namely multiple link names, color and scheme changes and
    several hyper-text links:

        ! 2 global-mode
        ! 3 add-global-mode
        ! 3 delete-global-mode
        ^[cE^[cENAME ^[cE^[cA


        |global-mode
            global-mode - Change a global buffer mode
        |add-global-mode
            add-global-mode - Set a global buffer mode
        |delete-global-mode
            delete-global-mode - Remove a global buffer mode
        $a


        ^[cE^[cESYNOPSIS ^[cE^[cA


            ^[cCn^[cA ^[cDglobal-mode^[cA "^[cCmode^[cA" (^[cDesc m^[cA)
            ^[cDadd-global-mode^[cA "^[cCmode^[cA"
            ^[cDdelete-global-mode^[cA "^[cCmode^[cA"


        ^[cE^[cEDESCRIPTION ^[cE^[cA


            ^[cDglobal-mode^[cA changes the state of one of the hereditary
            global modes. A buffer's modes are initialized to the global
            modes when first created. This command is very useful in changing
            some of the default behavior such as case sensitive searching (see
            the example below). See ^[ls^[lmOperating Modes^[le for a full list
            and description of modes. Also see ^[ls^[lmbuffer-mode(2)^[le for a
            full description of the use of the argument ^[cCn^[cA.

            The ^[ls^[lminfo(2)^[le command gives a list of the current global
            and buffer modes.

            ^[cDadd-global-mode^[cA and ^[cDdelete-global-mode^[cA are macros
            defined in me3_8.emf which use global-mode to add or remove a global
            mode. They are defined for backward compatibility and for ease of
            use; they are simple macros, add-global-mode is defined as follows:
        ^[sB
                define-macro add-global-mode
                    ; Has the require mode been given as an argument, if so add it
                    !force 1 global-mode @1
                    !if &not $status
                        ; No - use 1 global-mode to add a mode
                        !nma 1 global-mode
                    !endif
                !emacro

        ^[sA

        ^[cE^[cEEXAMPLE ^[cE^[cA


            The following example globally disables ^[ls^[lmexact(2m)^[le and
            ^[ls^[lmmagic(2m)^[le modes, if these lines are copied to the user
            setup file then are searches will be simple and case insensitive by
            default:
        ^[sB
                -1 global-mode "exact"
                -1 global-mode "magic"

        ^[sA

        ^[cE^[cENOTES ^[cE^[cA


            Globally adding ^[ls^[lmbinary(2m)^[le and ^[ls^[lmcrypt(2m)^[le
            modes is strongly discouraged as any file loaded would be assigned
            these modes. Instead the use of commands ^[ls^[lmfind-bfile(3)^[le
            and ^[ls^[lmfind-cfile(3)^[le are recommended.

            ^[ls^[lmauto(2m)^[le, ^[ls^[lmautosv(2m)^[le, ^[ls^[lmbackup(2m)^[le,
            ^[ls^[lmexact(2m)^[le, ^[ls^[lmmagic(2m)^[le, ^[ls^[lmquiet(2m)^[le,
            ^[ls^[lmtab(2m)^[le and ^[ls^[lmundo(2m)^[le modes are present on all
            platforms by default. On Windows and DOS platforms ^[ls^[lmcr(2m)^[le
            is also present and on DOS ^[ls^[lmctrlz(2m)^[le is also present.


        ^[cE^[cESEE ALSO ^[cE^[cA


            ^[ls^[lmOperating Modes^[le, ^[ls^[lmbuffer-mode(2)^[le,
            ^[ls^[lmfind-bfile(3)^[le, ^[ls^[lmfind-cfile(3)^[le,
            ^[ls^[lminfo(2)^[le.


cEcEFILES cEcA


    The help file cDme.ehfcA is located in the MicroEmacs 2009 cCmacroscA directory
    and should exist on the lslm$search-path(5)le.


cEcESEE ALSO cEcA


    lslmdefine-help(2)le, lslm$search-path(5)le.
! 8 me32.ini
cEcENAME cEcA


    me32.ini - Microsoft Window's Initialization (ini) File


cEcESYNOPSIS cEcA


    cD;cA cCComments commence with a semi-coloncA

    cD[Location]cA
    cDexecA=cC<executablePathname>cA

    cD[Defaults]cA
    cDmeinstallpath=cAcC<directoryPath>cA;cC<directoryPath>cA; ... ;cC<directoryPath>cA
    cDmepath=cAcC<directoryPath>cA;cC<directoryPath>cA; ... ;cC<directoryPath>cA
    cDmeuserpath=cAcC<directoryPath>cA
    cDmename=cAcC<username>cA
    cDgeometry=cAcC<width>cAcDxcAcC<depth>cA+cC<xoffset>cA+cC<yoffset>cA
    cDenvironmentVariable=cAcC<value>cA
    cDenvironmentVariable=cAcC<value>cA
    ...
    cDenvironmentVariable=cAcC<value>cA

    cD[cAcC<userName>cAcD]cA
    cDmeinstallpath=cAcC<directoryPath>cA;cC<directoryPath>cA; ... ;cC<directoryPath>cA
    cDmepath=cAcC<directoryPath>cA;cC<directoryPath>cA; ... ;cC<directoryPath>cA
    cDmeuserpath=cAcC<directoryPath>cA
    cDgeometry=cAcC<width>cAcDxcAcC<depth>cA+cC<xoffset>cA+cC<yoffset>cA
    cDmename=cAcC<username>cA
    cDenvironmentVariable=cAcC<value>cA
    cDenvironmentVariable=cAcC<value>cA
    ...
    cDenvironmentVariable=cAcC<value>cA

    cD[cAcC<userName>cAcD]cA
    cDmeinstallpath=cAcC<directoryPath>cA;cC<directoryPath>cA; ... ;cC<directoryPath>cA
    cDmepath=cAcC<directoryPath>cA;cC<directoryPath>cA; ... ;cC<directoryPath>cA
    ...


cEcEPLATFORM cEcA


    cDMicrosoft Windows environments onlycA


cEcEDESCRIPTION cEcA


    cDme32.inicA is the Microsoft Windows configuration file, located in the
    windows directory (typically cDC:\WindowscA or cDC:\WINNTcA), the cDme32.inicA file is
    primarily used to counteract the deficiencies of Windows shell environment
    (as compared with UNIX) with respect to the initialization of environment
    variables. The cDme32.inicA file is comparable to the UNIX cC.XdefaultscA and
    cC.profilecA files.

    The configuration file is split into two sections, a cDDefaultscA section,
    which defines system settings and a cDUsercA section which define settings on
    a per user basis. Both sections allow environment variables to be defined
    for export. The cCdefaultscA section is executed first and then the cCusercA
    section which matches the users name. The format of both sections is
    identical.


cESection Keywords cA


    The keywords identified in each section are defined as follows:-

    cDmepathcA
        Equivalent to the setting of the variable lslm$MEPATH(5)le to define the
        directory (or folder) location of the MicroEmacs 2009 default
        configuration files. If the assignment string is empty then any
        previous value is removed.

    cDmeinstallpathcA
        Equivalent of setting the environment variable lslm$MEINSTALLPATH(5)le to
        define the directory (or folder) location of the macros directory. If
        the assignment string is empty then any previous value is removed.

    cDmenamecA
        The MicroEmacs lslm$user-name(5)le to use rather than the login name. If the
        assignment string is empty then any previous value is removed.

    cDmeuserpathcA
        The value of lslm$user-path(5)le. If the assignment string is empty then any
        previous value is removed.

    cDgeometrycA=cC<width>cAcDxcAcC<depth>cA+cC<xoffset>cA+cC<yoffset>cA
        The geometry of the window the width and height are specified in
        character, the position of the window is specified as an offset. If
        the assignment string is empty then any previous preset value is
        removed.

    All other variables (except those commencing with cGmsdevcA which are reserved
    for lslmmemsdev(1)le) are pushed into the environment as environment variables
    which are made during the editing session.


cELocation Section cA


    The location section, labeled cD[Location]cA, identifies the location of
    MicroEmacs 2009, and is typically used by other components to find and
    launch MicroEmacs. The section includes the following keys:-

    cDexecA
        The absolute pathname to the MicroEmacs 2009 executable image.
        External programs such as lslmmemsdev(1)le may use this entry to find the
        executable. This section may be omitted.


cEDefaults Section cA


    The default section, labeled cD[MeYYMMDD]cA or cD[Defaults]cA define the global
    variable settings for all users. The dated form is searched for first, the
    date corresponds to the specific version of MicroEmacs as displayed by
    lslmabout(2)le. When omitted then the cD[Defaults]cA section is used. Either, or
    both sections may be omitted.


cEUser Section cA


    The cDUser SectioncA is executed after the cDDefaults SectioncA. The cDUser SectioncA
    uses the lslm$user-name(5)le which is defined as follows:-

        * The environment variable lslm$MENAME(5)le
        * The cClogin namecA under Windows '95 or NT. If the cClogin namecA is defined
          then the variable lslm$user-name(5)le is set to this value.
        * The environment variable lslm$LOGNAME(5)le if the cClogin namecA cannot be
          located.

    A single user section is executed that corresponds to the user. If the
    system does not use a login system then a cDmenamecA entry may be placed in
    the defaults section to force a name.

    A cDmenamecA entry appearing in the cCusercA section is used to change the login
    name to a more sensible name when the user login and MicroEmacs user files
    use different names.


cEcEEXAMPLE cEcA


    The following is an example of the cDme32.inicA file, there is no login and a
    user cCJohn DoecA defines his MicroEmacs user name:

        ; External locater for the executable
        [Location]
        exe=c:\Program Files\JASSPA\MicroEmacs\me32.exe
        ;
        ; Default global section
        [Defaults]
        ; mepath
        ; The location of the MicroEmacs common files.
        meinstallpath=d:\jasspa
        mename=john
        ;
        ; User John Doe
        [john]
        ; meuserpath - The location of the users MicroEmacs directory.
        meuserpath=d:\jasspa\john
        ; Define some environment variables.
        INFOPATH=c:\info


    Note that multiple users share the same cDme32.inicA file, each user may
    include their own configuration settings which may be interrogated in the
    configuration files. In the following example a user cCJohn DoecA with login
    name of cCjohndoecA uses private configuration files called cCjohncA:

        ; External locater for the executable
        [Location]
        exe=c:\Program Files\JASSPA\MicroEmacs\me32.exe
        ;
        ; Defaults for RC4 Release
        [Me040201]
        meinstallpath=d:\jasspa_rc4
        ;
        ; Default global section
        [Defaults]
        ; mepath
        ; The location of the MicroEmacs common files.
        meinstallpath=d:\jasspa
        ; Define some environment variables.
        INFOPATH=c:\info
        ;
        ; User John Doe
        [johndoe]
        ; meuserpath - The location of the users MicroEmacs directory.
        meuserpath=d:\jasspa\john
        ; mename - Use "john" instead of "johndoe"
        mename=john
        ; Define startup screen size.
        geometry=110x50+70+30
        ;
        ; User Jane Doe
        [janedoe]
        meuserpath=d:\jasspa\janedoe


cEcESEE ALSO cEcA


    lslmuser-setup(3)le, ls$MEINSTALLPATH(5)lm$MEINSTALL_PATH(5)le lslm$MENAME(5)le, lslm$MEPATH(5)le, lslm$MEUSERPATH(5)le,
    lslm$user-name(5)le, lslm$user-path(5)le, lslmemf(8)le.
! 8 .Xdefaults
cEcENAME cEcA


    .Xdefaults - UNIX Window Manager defaults file


cEcESYNOPSIS cEcA


    cDMicroEmacs.font:cA cCfontcA
    cDMicroEmacs.geometry:cA cCchar-widthcAcDxcAcCchar-heightcA [cD+-cA]cCxoffsetcA [cD+-cA]cCyoffsetcA
    cDMicroEmacs.name:cA cCnamecA
    cDMicroEmacs.iconname:cA cCnamecA


cEcEPLATFORM cEcA


    cDUNIX environments onlycA


cEcEDESCRIPTION cEcA


    cD.XdefaultscA is the UNIX X-Windows configuration file that permits some of
    the X-Windows start up settings to be configured. The file is typically
    loaded into the X database when the Window Manager starts and the values
    are read from the database by MicroEmacs at start up, over-riding any
    internal defaults.

    The cD.XdefaultscA file is used by other applications and MicroEmacs may be
    added to the end of any existing file.

    The values interpreted by MicroEmacs are defined as follows:

    cDMicroEmacs.font:cA cCfontcA
        Specifies the font to use.

    cDMicroEmacs.geometry:cA cCchar-widthcAcDxcAcCchar-heightcA [cD+-cA]cCxoffsetcA [cD+-cA]cCyoffsetcA
        The geometry of the X-Window at start-up. cCchar-widthcA and cCchar-heightcA
        define the width and depth of the frame specified in characters of the
        current font. cCxoffsetcA and cCyoffsetcA specify the position of the wind
        with respect to the top left of the screen, defaults are used when
        specified as 0.

    cDMicroEmacs.name:cA cCnamecA
        Over-rides the name prefix used in the X-Window title bar, by default
        this is specified as cCMicroEmacscA.

    cDMicroEmacs.iconname:cA cCnamecA
        Over-rides the name prefix used in a X-Window iconic display, by
        default this is specified as cCMicroEmacscA.


cEcEEXAMPLE cEcA


    The following is an example of the cD.XdefaultscA file:-

        !######################################################################
        !#                                                                    #
        !# Defaults for MicroEmacs startup                                    #
        !#                                                                    #
        !######################################################################
        !# MicroEmacs.font: <fontname>
        !# Set the default font.
        MicroEmacs.font: -*-lucidatypewriter-medium-r-*-*-*-*-*-*-m-*-*-*
        !# MicroEmacs.font: -*-clean-medium-r-*-*-*-130-*-*-*-*-*-*

        !# MicroEmacs.geometry: <char-width>x<char-height> {+/-}<xoffset> {+-}<yoffset>
        !# Set up the default screen size and position.
        !# 102x65 characters please, 30 pixels from top left
        MicroEmacs.geometry: 102x65 30 30

        !# MicroEmacs.name: <name>
        !# The name displayed in the title bar format is <name>: <file>
        MicroEmacs.name: JASSPAs MicroEmacs

        !# MicroEmacs: <icon-name>
        !# The name displayed when MicroEmacs is iconized
        MicroEmacs.iconname: JASSPAs MicroEmacs


cEcENOTES cEcA


    The cD.XdefaultscA file is typically read once at login and and any changes to
    the files are not enacted until the Window Manager is re-started or a new
    login session commences.

    The settings in the cD.XdefaultscA may be subsequently overridden by the
    settings defined in lslmuser-setup(3)le.


cEcESEE ALSO cEcA


    lslmuser-setup(3)le.
! 8 esf
cEcENAME cEcA


    esf - MicroEmacs session file


cEcEDESCRIPTION cEcA


    MicroEmacs 2009 session files are ASCII text files that retain all the
    buffer context for a previous editing session.

    Every user has their own personal session file in their personal
    MicroEmacs directory. The session file is located from the MicroEmacs 2009
    search path defined by lslm$user-path(5)le, and is named by the variable
    lslm$user-name(5)le.


cEcESEE ALSO cEcA


    lslmlist-registry(2)le, lslmread-registry(2)le, lslmread-session(3)le, lslmsave-session(3)le,
    lslm$user-name(5)le, lslm$user-path(5)le.
! 9 c
! 9 cc
! 9 h
! 9 cpp
! 9 def
! 9 l
! 9 y
! 9 i
! 9 rc
cEcESYNOPSIS cEcA


    C, C++ - C and C++ programming language templates


cEcEFILES cEcA


    cDhkc.emfcA - C programming language hook definition
    cDhkcpp.emfcA - C++ programming language hook definition

    cDc.etfcA - C programming language template file
    cDh.etfcA - C programming language header template file
    cDcpp.etfcA - C++ programming language template file
    cDhpp.etfcA - C++ programming language header template file


cEcEEXTENSIONS cEcA


    cD.ccA, cD.hcA, cD.defcA - ANSI C
    cD.cppcA, cD.cccA, cD.hppcA, cD.rccA cD.CcA cC(UNIX only)cA - C++ programming language
    cD.lcA - LEX
    cD.ycA - YACC
    cD.icA - C (or C++) pre-processed file (i.e. output from pre-processor).
    cD.rccA - Microsoft Developer resource file.


cEcEMAGIC STRINGS cEcA


    cD-*- c -*-cA
        Recognized by GNU and MicroEmacs. Denotes a 'C' programming type file,
        may be used in cD.ccA, cD.defcA and cD.hcA files.

    cD-*- c++ -*-cA
        Recognized by GNU and MicroEmacs. Denotes a C++ programming type file,
        may be used in cD.ccA, cD.defcA and cD.hcA files.


cEcEDESCRIPTION cEcA


    The cDCcA and cDC++cA file type templates offer the most sophisticated editing
    features within the MicroEmacs 2009 environment.

    cDGeneral EditingcA
        On creating a new file, a new header is automatically included into
        the file. lslmtime(2m)le is by default enabled, allowing the modification
        time-stamp to be maintained in the header.

    cDHilightingcA
        The hilighting features allow commands, variables, logical,
        preprocessor definitions, comments, strings and characters of the
        language to be differentiated and rendered in different colors.

    cDAuto LayoutcA
        The C-Mode indentation mode of lslmindent(2)le performs automatic layout of
        the text.

        lslmrestyle-region(3)le and lslmrestyle-buffer(3)le are available to reformat
        (re-layout) selected sections of the buffer, or the whole buffer,
        respectively.

        Comments may be formatted using cGesc ocA, which reformats the comments
        according to the current fill paragraph. If a comment commences with
        cG/***...cA then the comment is automatically formatted to a box. If the
        comment commentces with cG/**cA then the comment is assumed to be a cCJavacA
        cCDoccA comment.

    cDTagscA
        A C-tags file may be generated within the editor using the cDToolscA -> cDC
        ToolscA -> cDCreate Tag FilecA. lslmfind-tag(2)le takes the user to the file using
        the tag information.

        On invoking the tag generator then the user is presented with a dialog
        box which specifies the generation option of the tags file. The base
        directory of the tags file search and tagging options may be specified
        to locate all of the definitions within the code space.

        The cDtagscA file is extremely useful where the user is dealing with
        inherited source code spread over multiple directories. Generation of
        a recursive tag file with all searching options enabled allows labels
        to be located extremely rapidly (certainly faster than IDE
        environments).

    cDFolding and Information HidingcA
        Generic folding is enabled within the C and C++ files. The folds occur
        about braces cD{cA...cD}cA located on the left-hand margin. lslmcollapse-all(3)le
        (un)folds all regions in the file, lslmcollapse-current(3)le (un)folds the
        current region. Note that folding does not operate on K&R style code.

        The cDToolscA -> cDC ToolscA menu allows cG#definecA's to be evaluated within the
        buffer. Where the state of a cG#ifcA is established to be false (using the
        cG#definecA information) then the disabled region of code is grayed out
        indicating which regions of the code are active.

    cDWorking EnvironmentcA
        lslmcompile(3)le may be invoked to rebuild the source, the user is prompted
        to save any files.

        lslmrcs-file(2)le is automatically invoked if an RCS file is detected, the
        normal check-in/out operations may be performed through the editor.

    cDShort CutscA
        The short cut keys used within the buffer are:-

        cDC-c C-ccA - Comment out the current line.
        cDC-c C-dcA - Uncomment the current line.
        cDC-c C-ecA - Comment to the end of the line with stars (*).
        cDA-C-icA - Restyle the current region.
        cDesc qcA - Format a comment.
        cDesc ocA - Format a comment.
        cDf2cA - (un)fold the current region
        cDf3cA - (un)fold all regions

    cDAdditional Commands cA
        A number of additional commands are available as follows:-

                * lslmc-slashify(3)le - Append backslash to end of lines of region.
                * lslmc-deslashify(3)le - Remove backslash to end of lines of
                  region.
                * lslmc-to-cpp-convert(3)le - Convert a C file to C++
                * lslmc-hash-eval(3)le - Evaluate C/C++ cG#definecAs.
                * lslmc-hash-del(3)le - Remove C/C++ cG#definecA evaluation.
                * lslmc-hash-set-define(3)le - Set a C/C++ cG#definecA.
                * lslmc-hash-unset-define(3)le - Unset a C/C++ cG#definecA


cEcENOTES cEcA


    If the default language is C++, rather than 'C' the order of the file
    hooks should be over-ridden in the users local setup, using:-
sB
        add-file-hook ".c "                                  fhook-c
        add-file-hook ".cc .cpp .hpp .rc .h .def .l .y .i"   fhook-cpp

sA
    This defaults all cD.hcA and cD.defcA files etc. to be C++ rather than C.

    The hilighting is typically extended using a file cDmyc.emfcA (or cDmycpp.emfcA)
    i.e. to include the usual extended types of cDint32cA etc, cDmyc.emfcA might be
    defined as:-
sB
        hilight .hilight.c 1 "uint8"    .scheme.type
        hilight .hilight.c 1 "int8"     .scheme.type
        hilight .hilight.c 1 "uint16"   .scheme.type
        hilight .hilight.c 1 "int16"    .scheme.type
        hilight .hilight.c 1 "uint32"   .scheme.type
        hilight .hilight.c 1 "int32"    .scheme.type
        hilight .hilight.c 1 "float32"  .scheme.type
        hilight .hilight.c 1 "float64"  .scheme.type

sA

cEcEBUGS cEcA


    The 'C' and 'C++' templates have been throughly used, there are no known
    issues with the templates.

    The cD.rccA hilighting is a little bogus and should not really be mapped onto
    cD.cppcA. Do not attept to re-style.


cEcESEE ALSO cEcA


    lslmc-deslashify(3)le, lslmc-slashify(3)le, lslmc-to-cpp-convert(3)le, lslmcollapse-all(3)le,
    lslmcollapse-current(3)le, lslmcompile(3)le, lslmctags(3f)le, lslmfind-tag(2)le, lslmrcs-file(2)le,
    lslmrestyle-buffer(3)le, lslmrestyle-region(3)le, lslmtime(2m)le.

    lsMicroEmacs - Supported File TypeslmSupported File Typesle
! 9 ehf
cEcESYNOPSIS cEcA


    ehf - MicroEmacs 2009 help file


cEcEFILES cEcA


    cDhkehf.emfcA - MicroEmacs 2009 help file.


cEcEEXTENSIONS cEcA


    cD.ehfcA, cD*help*cA


cEcEDESCRIPTION cEcA


    The cDehfcA file type template performs the hilighting of the help file. The
    cDehfcA file is a computer generated file and uses special embedded text
    markers to indicate the required color scheme.

    The macro file includes special macros to locate help information.


cEcESEE ALSO cEcA


    lslmhelp(2)le.

    lsMicroEmacs - Supported File TypeslmSupported File Typesle
! 9 emf
cEcESYNOPSIS cEcA


    emf - MicroEmacs 2009 Macro File


cEcEFILES cEcA


    cDhkemf.emfcA - MicroEmacs 2009 Macro File hook definition
    cDemf.etfcA - Template file


cEcEEXTENSIONS cEcA


    cD.emfcA - MicroEmacs 2009 Macro File


cEcEDESCRIPTION cEcA


    The cDemfcA file type template handles the hilighting of the MicroEmacs 2009
    macro files.

    cDGeneral EditingcA
        On creating a new file, a new header is automatically included into
        the file. lslmtime(2m)le is by default enabled, allowing the modification
        time-stamp to be maintained in the header.

    cDHilightingcA
        The hilighting features allow commands, variables, logical, comments,
        strings and characters of the language to be differentiated and
        rendered in different colors.

    cDAuto LayoutcA
        The lsindent(2)lmindentation mechanismle is enabled which performs performs automatic
        layout of the text. lslmrestyle-region(3)le and lslmrestyle-buffer(3)le are
        available to reformat (re-layout) selected sections of the buffer, or
        the whole buffer, respectively.

    cDTagscA
        A C-tags file may be generated within the editor using the cDToolscA ->
        cDEmf-ToolscA -> cDCreate Tag FilecA. lslmfind-tag(2)le takes the user to the file
        using the tag information.

    cDFolding and Information HidingcA
        Generic folding is enabled within the cDemfcA files. The folds occur about
        cDdefine-macrocA and cD!emacrocA text located on the left-hand margin.
        lslmcollapse-all(3)le (un)folds all regions in the file, lslmcollapse-current(3)le
        (un)folds the current region.

    cDShort CutscA
        The short cut keys used within the buffer are:-

        cDC-c C-ccA - Comment out the current line.
        cDC-c C-dcA - Uncomment the current line.
        cDC-c esc esc cA- Command complete.
        cDA-C-icA - Restyle the current region.
        cDf2cA - (un)fold the current region
        cDf3cA - (un)fold all regions


cEcEBUGS cEcA


    No bugs reported


cEcESEE ALSO cEcA


    lslmcollapse-all(3)le, lslmcollapse-current(3)le, lslmemftags(3f)le, lslmfind-tag(2)le, lslmindent(2)le,
    lslmrestyle-buffer(3)le, lslmrestyle-region(3)le, lslmtime(2m)le.

    lsMicroEmacs - Supported File TypeslmSupported File Typesle
! 9 txt
! 9 doc
cEcESYNOPSIS cEcA


    txt, doc - Plain text document file


cEcEFILES cEcA


    cDhkdoc.emfcA - Plain text hook definition


cEcEEXTENSIONS cEcA


    cD.txtcA - ASCII plain text file
    cD.doccA - ASCII plain text document file


cEcEDESCRIPTION cEcA


    The cDdoccA file type template handles the hilighting and text formating of a
    plain text file. Within the text document justification and word wrapping
    are typically enabled. The template allows the user to format text as
    left, right, center or no justification.

    cDAuto LayoutcA
        The automatic layout of the text is restricted to justification and
        wrapping and the detection of bulleted lists. ls$fill-bullet(5)lmfill-bullet(5)le may be
        used to determine the character set used for bullet points, on
        encountering a bullet the left-hand justification might be modified.

    cDFormatting rulescA
        The default mode of operation is automatic mode which attempts to
        retain the document style whenever a paragraph is re-formatted. This
        allows rapid entry of text into a reasonable format with no special
        formating character embedded in the text.

        The automatic formatting rules used by lslmfill-paragraph(2)le in an
        automatic text mode are defined as follows:-

        Text on column 0
            Text appearing in the first column is always assumed to be left
            justified, and non-wrapping, provided that the text does not
            extend to the ls$fill-col(5)lmbuffer fill columnle. This is typically used for
            headers and addresses.

        Text on right edge
            Text ending at the right edge (the lslm$buffer-fill-col(5)le), which
            commences from more that 50% of the page width is assumed to be
            right justified, non-wrapping. Typically used for addresses.

        Text centered
            Text which is centered on the page is assumed to be centered, this
            is non-wrapping.

        Indented
            All other text, not covered by the cases above is assumed to be
            available for filling. In this case the text is filled by the
            paragraph and left/right justification is applied, the fill
            default may be changed with lslm$buffer-fill-mode(5)le and changed with
            lslmbuffer-setup(3)le.

    cDShort CutscA
        The short cut keys used within the buffer are:-

        cDC-c C-hcA - Help information on current mode.
        cDC-c C-scA - Spell the buffer.
        cDC-c C-bcA - Fill both; perform left and right justification on the
        margins.
        cDC-c C-bcA - Fill center; center the text on the current line.
        cDC-c C-lcA - Fill left; fill the text on the paragraph (ragged right
        edge).
        cDC-c C-rcA - Fill right; place text on right margin.
        cDC-c C-ocA - Reduce a paragraph to a single line.
        cDC-c acA - Move to automatic formatting mode (default).
        cDC-c lcA - Change mode to left formating
        cDC-c rcA - Change mode to right formating
        cDC-c rcA - Change mode to both formating
        cDC-c ccA - Change mode to center formating
        cDC-c ncA - Change mode to no formating


cEcENOTES cEcA


    To move text to a word processor then it is advised that all paragraphs
    are reduced to single lines, leading white space should be deleted (any
    possibly blank lines) and then import to the word processor. This saves
    considerable time as the word processor styles may be applied without
    handling spaces and band end of line characters.


cEcEMAGIC STRINGS cEcA


    cD-!- document -!-cA
        MicroEmacs specific tag, recognizes the file as a plain text document.
        No hilighting of the document is performed.

    cD-!- document; sectioned -!-cA
        MicroEmacs specific tag, recognizes the file as a document that
        contains sections. A crude section hilighting is enabled as follows:-

        Lines commencing with cD>cA are assumed to be comments, typically used at
        the head of the document .

            > -!- document; sectioned -!-
            >
            > Author:       My Self
            > Created:      11/11/97
            > Modified:     <211197.1003>
            > Location:     /xx/yy/zz.doc


        All lines commencing with start (cG*cA) are assumed to be bullet lists.
        Bullet is hilighted.

        All lines commencing with cG[a-zA-Z])cA or cG[0-9])cA are assumed to be minor
        sections. The section number is hilighted. e.g.:

            a) text
            1) text


        All text in single or double quotes is hilighted, assumed to be
        literal text. and are hilighted i.e. This is a cD"double quote"cA or cD'a'cA
        single quote.

        Lines commencing with underscore (cG_cA) are hilighted to the end.
        typically used as demarcation breaks or for section underlining

    cD-!- Document; pseudo-code -!-cA
        The document contains pseudo code, and the pseudo code is hilighted.
        The pseudo-code tokens are defined as follows:-

        cD//cA introduces a comment to the end of the line.

        Command words comprise:-
            cGBEGINcA, cGBREAKcA, cGCASEcA, cGCLEARcA, cGCONTINUEcA, cGDOcA, cGDONEcA, cGELIFcA, cGELSEcA, cGENDcA,
            cGENDIFcA, cGFORcA, cGFUNCTIONcA, cGGOTOcA, cGIFcA, cGONEVENTcA, cGONINTERRUPTcA, cGPROCEDUREcA,
            cGREPEATcA, cGRETURNcA, cGSETcA, cGSWITCHcA, cGTHENcA, cGTOcA, cGUNTILcA, cGWHILEcA,

        Pseudo logical operators include
            cGANDcA, cGFALSEcA, cGMODcA, cGNOTcA, cGORcA, cGTRUEcA, cGXORcA,

    cD-!- document; sectioned; pseudo-code -!-cA
        A combination of both of the above.


cEcEBUGS cEcA


    The automatic mode sometimes mistakes an indented paragraph for a centered
    paragraph. This only typically occurs when the first line of the paragraph
    is not filled to the right. When the formatting error occurs, simply pad
    the line out so that it extends past the fill column and re-apply the
    formatting.

    Unfortunately there is nothing that can be done to alleviate this problem,
    but it occurs infrequently.


cEcESEE ALSO cEcA


    lslm$buffer-fill-col(5)le, lslm$buffer-fill-mode(5)le, lslm$fill-col(5)le, lslm$fill-mode(5)le,
    lslmbuffer-setup(3)le, lslmfill-paragraph(2)le, lslmspell-buffer(3)le.

    lsMicroEmacs - Supported File TypeslmSupported File Typesle
! 9 latex
! 9 bib
! 9 tex
! 9 sty
cEcESYNOPSIS cEcA


    latex - TeX Documentation


cEcEFILES cEcA


    cDhklatex.emfcA - Tex File hook definition
    cDlatex.etfcA - Template file
    cDhkbibtex.emfcA - TeX Bibliography Files


cEcEEXTENSIONS cEcA


    cD.texcA - TeX Documentation
    cD.bibcA - TeX Bibliography Files
    cD.stycA - TeX Style file


cEcEDESCRIPTION cEcA


    The cDlatexcA file type template handles the hilighting of the TeX files. The
    hilighting is minimal, hilighting the key words and comments.

    cDGeneral EditingcA
        On creating a new file, a new header is automatically included into
        the file. lslmtime(2m)le is by default enabled, allowing the modification
        time-stamp to be maintained in the header.

    cDHilightingcA
        The hilighting emphasizes the Tex embedded command strings and
        comments. No special recognition of the command strings is performed.

    cDOutline HilightingcA
        The LaTeX content may be viewed with synthetic hilighting such that
        headers, text in bold and italic are displayed, removing the LaTeX
        control sequences.

    cDFolding and Information HidingcA
        Generic folding is enabled, the folds occur about cD\section{...}cA and
        cD\subsection{...}cA constructs. lslmcollapse-all(3)le (un)folds all regions in
        the file, lslmcollapse-current(3)le (un)folds the current region.

    cDSpellingcA
        Buffer spell checking is LaTeX aware.

    cDList ItemscA
        Item listing is available and the key constructs of the file may be
        listed in the cCitem-listcA.

    cDBuffer CommandscA
        cDlatex-verifycA verifies the syntax of the (La)TeX from the current
        position forward, reporting braces that are not matched.

    cDShort CutscA
        The short cut keys used within the buffer are:-

        cDC-c C-ccA - Comment out the current line.
        cDC-c C-dcA - Uncomment the current line.
        cDC-c C-ecA - Comment to the end of the line with hash (%).
        cDC-c C-ocA - Format a comment
        cDf2cA - (un)fold the current region
        cDf3cA - (un)fold all regions
        cDf6cA - List items.
        cDesc f6cA - Close list items window.

        The command cDlatex-compilecA is available within the buffer which invokes
        an external process to build the text.


cEcEBUGS cEcA


    No bugs reported


cEcESEE ALSO cEcA


    lslmtime(2m)le.

    lsMicroEmacs - Supported File TypeslmSupported File Typesle
! 9 makefile
cEcESYNOPSIS cEcA


    makefile - Make file


cEcEFILES cEcA


    cDhkmake.emfcA - Make file hook definition
    cDmake.etfcA - Template file


cEcEEXTENSIONS cEcA


    cDMakefilecA, cDmakefilecA, cD.makcA - Makefiles.


cEcEMAGIC STRINGS cEcA


    cD-!- makefile -!-cA
        Recognized by MicroEmacs only, defines the file to be a makefile.


cEcEDESCRIPTION cEcA


    The cDmakecA file type template handles the hilighting of the makefile files.

    cDGeneral EditingcA
        On creating a new file, a new header is automatically included into
        the file. lslmtime(2m)le is by default enabled, allowing the modification
        time-stamp to be maintained in the header.

        By default, cGTABcA's are enabled as this is the syntactical feature of
        the file.

    cDHilightingcA
        The hilighting emphasizes the keywords and comments within the
        makefile. No special support for Microsoft cDnmake(1)cA is provided
        because of the number of oddities in their implementation of make.


cEcEBUGS cEcA


    No attempt is made to hilight any embedded shell commands.


cEcESEE ALSO cEcA


    lslmimakefile(9)le, lslmtime(2m)le.

    lsMicroEmacs - Supported File TypeslmSupported File Typesle
! 9 imakefile
cEcESYNOPSIS cEcA


    imakefile - Make file


cEcEFILES cEcA


    cDhkimake.emfcA - Imakefile hook definition
    cDimake.etfcA - Template file


cEcEEXTENSIONS cEcA


    cDImakefilecA, cDimakefilecA - Imakefiles.


cEcEDESCRIPTION cEcA


    The cDImakefilecA file type template handles the hilighting of the Imakefile
    files.

    cDGeneral EditingcA
        On creating a new file, a new header is automatically included into
        the file. lslmtime(2m)le is by default enabled, allowing the modification
        time-stamp to be maintained in the header.

        By default, cGTABcA's are enabled as this is the syntactical feature of
        the file.

    cDHilightingcA
        The hilighting emphasizes the keywords and comments within the
        Imakefile.


cEcEBUGS cEcA


    No attempt is made to hilight any embedded shell commands.


cEcESEE ALSO cEcA


    lslmmakefile(9)le, lslmtime(2m)le.

    lsMicroEmacs - Supported File TypeslmSupported File Typesle
! 9 bat
! 9 btm
cEcESYNOPSIS cEcA


    bat, btm - MS-DOS batch files


cEcEFILES cEcA


    cDhkdos.emfcA - MS-DOS hook definition


cEcEEXTENSIONS cEcA


    cD.batcA - MS-DOS Batch file
    cD.btmcA - 4-DOS Batch file


cEcEMAGIC STRINGS cEcA


    cD-!- msdos -!-cA
        Recognized by MicroEmacs only. Denotes a MS-DOS batch file.


cEcEDESCRIPTION cEcA


    The cDdoscA file type templates provide simple hilighting of a MS-DOS batch
    file. The template provides minimal hilighting support of both standard
    and 4-DOS batch files.

    The cCMagic StringcA may be used within the cDconfig.syscA file to force
    hilighting of the MS-DOS configuration file.


cEcEBUGS cEcA


    None reported.


cEcESEE ALSO cEcA


    lslmini(9)le.

    lsMicroEmacs - Supported File TypeslmSupported File Typesle
! 9 ini
! 9 hpj
! 9 reg
! 9 rgy
cEcESYNOPSIS cEcA


    ini, hpj, reg, rgy - MS-Windows initialization and registry files


cEcEFILES cEcA


    cDhkini.emfcA - MS-Windows initialization and registry files.


cEcEEXTENSIONS cEcA


    cD.inicA - MS-Windows Initialization File
    cD.hpjcA - MS-Windows Help Project File
    cD.regcA - Registry File
    cD.rgycA - (Other) registry File


cEcEDESCRIPTION cEcA


    The cDinicA file type templates provide simple hilighting of MS-Windows
    initialization and registry files. The file format is similar to a number
    of other registry type files which are also over-loaded into the same
    template.

    cDHilightingcA
        The template provides minimal hilighting , but allows the different
        components of the file to be differentiated.

    cDFolding and Information HidingcA
        Generic folding is enabled within the ini files. The folds occur about
        lines with leading square brackets cD[cA...cD[cA located on the left-hand
        margin. lslmcollapse-all(3)le (un)folds all regions in the file,
        lslmcollapse-current(3)le (un)folds the current region.


cEcEBUGS cEcA


    None reported.


cEcESEE ALSO cEcA


    lslmbat(9)le.

    lsMicroEmacs - Supported File TypeslmSupported File Typesle
! 9 f
! 9 f77
! 9 f90
cEcESYNOPSIS cEcA


    f, f77, f90 - Fortran files


cEcEFILES cEcA


    cDhkf90.emfcA - Fortran hook definition
    cDf90.etfcA - Fortran 90 template file.
    cDf.etfcA - Fortran (77) template file.


cEcEEXTENSIONS cEcA


    cD.fcA - Fortran file
    cD.f77cA - Fortran 77 file
    cD.f90cA - Fortran 90 file


cEcEDESCRIPTION cEcA


    The cDf90cA file type templates provide simple hilighting of Fortran 77 and
    Fortran 90 files, the template provides minimal hilighting of both
    language syntaxes, which are overloaded into the same file.

    The major difference between the file types, apart from the new reserved
    words, is the comments. In Fortran 90 comments are introduced with cD!cA,
    while the other types use a cDccA in column 0.


cEcEBUGS cEcA


    The Fortran hilight file is in it's infancy and a number of it's tokens
    may be misplaced.


cEcESEE ALSO cEcA


    lsMicroEmacs - Supported File TypeslmSupported File Typesle
! 9 p
! 9 pas
cEcESYNOPSIS cEcA


    p, pas - Pascal files


cEcEFILES cEcA


    cDhkpascal.emfcA - Pascal hook definition
    cDpascal.etfcA - Pascal template file.


cEcEEXTENSIONS cEcA


    cD.pcA, cD.pascA - Pascal file


cEcEDESCRIPTION cEcA


    The cDpascalcA file type template provides simple hilighting of Pascal files,
    the template provides minimal hilighting.


cEcEBUGS cEcA


    None reported.


cEcESEE ALSO cEcA


    lsMicroEmacs - Supported File TypeslmSupported File Typesle
! 9 rul
cEcESYNOPSIS cEcA


    rul - Install Shield Rules


cEcEFILES cEcA


    cDhkrul.emfcA - Install Shield hook definition
    cDrul.etfcA - Install Shield template file.


cEcEEXTENSIONS cEcA


    cD.rulcA - Install Shield Rules file


cEcEDESCRIPTION cEcA


    The cDrulcA file type template provides simple hilighting of Install Shield
    Rules files.

    cDHilightingcA
        The hilighting features allow commands, variables, logical, comments,
        strings and characters of the language to be differentiated and
        rendered in different colors.

    cDAuto LayoutcA
        The lsindent(2)lmindentation mechanismle is enabled which performs automatic layout
        of the text. lslmrestyle-region(3)le and lslmrestyle-buffer(3)le are available to
        reformat (re-layout) selected sections of the buffer, or the whole
        buffer, respectively.

    cDFolding and Information HidingcA
        Generic folding is enabled within the rul file. The folds occur about
        the keywords cDfunctioncA...cDendcA located on the left-hand margin.
        lslmcollapse-all(3)le (un)folds all regions in the file, lslmcollapse-current(3)le
        (un)folds the current region.

    cDShort CutscA
        The short cut keys used within the buffer are:-

        cDC-c C-ccA - Comment out the current line.
        cDC-c C-dcA - Uncomment the current line.
        cDC-c C-ecA - Comment to the end of the line with stars (*).
        cDf2cA - (un)fold the current region
        cDf3cA - (un)fold all regions


cEcEBUGS cEcA


    None reported.


cEcESEE ALSO cEcA


    lslmcollapse-all(3)le, lslmcollapse-current(3)le, lslmindent(2)le, lslmrestyle-buffer(3)le,
    lslmrestyle-region(3)le.

    lsMicroEmacs - Supported File TypeslmSupported File Typesle
! 9 bnf
cEcESYNOPSIS cEcA


    bnf - Backus-Naur Form


cEcEFILES cEcA


    cDhkbnf.emfcA - Backus-Naur Form hook definition


cEcEEXTENSIONS cEcA


    cD.bnfcA - Backus-Naur Form file


cEcEDESCRIPTION cEcA


    The cDbnfcA file type template provides simple hilighting of text presented in
    Backus-Naur Form. The hilighting allows the components of the BNF to be
    differentiated quickly.

    The syntactical tokens that are hilighted are:-

    cD<cAcC[a-zA-Z]cA.*cD>cA
        Component language identifiers.

    cD| { } ::=cA
        Meta symbols of the BNF format.


cEcEBUGS cEcA


    None reported.


cEcESEE ALSO cEcA


    lsMicroEmacs - Supported File TypeslmSupported File Typesle
! 9 sql
cEcESYNOPSIS cEcA


    sql - SQL files


cEcEFILES cEcA


    cDhksql.emfcA - SQL hook definition
    cDsql.etfcA - SQL template file.


cEcEEXTENSIONS cEcA


    cD.sqlcA - SQL file


cEcEDESCRIPTION cEcA


    The cDsqlcA file type template provides simple hilighting of SQL files, the
    template provides minimal hilighting.


cEcEBUGS cEcA


    None reported.


cEcESEE ALSO cEcA


    lsMicroEmacs - Supported File TypeslmSupported File Typesle
! 9 vhdl
cEcESYNOPSIS cEcA


    vhdl - VHDL hardware simulation files


cEcEFILES cEcA


    cDhkvhdl.emfcA - VHDL hook definition
    cDvhdl.etfcA - VHDL template file.


cEcEEXTENSIONS cEcA


    cD.vhdlcA, cD.vhdcA - VHDL file


cEcEDESCRIPTION cEcA


    The cDvhdlcA file type template provides simple hilighting of VHDL files, the
    template provides minimal hilighting.


cEcEBUGS cEcA


    None reported. Template could probably benifit from some form of auto
    indentation.


cEcESEE ALSO cEcA


    lsMicroEmacs - Supported File TypeslmSupported File Typesle
! 9 awk
! 9 gawk
! 9 nawk
cEcESYNOPSIS cEcA


    awk - AWK files


cEcEFILES cEcA


    cDhkawk.emfcA - AWK hook definition
    cDawk.etfcA - AWKL template file.


cEcEEXTENSIONS cEcA


    cD.awkcA - AWK file
    cD.gawkcA - GNU AWK file
    cD.nawkcA - New AWK file


cEcEMAGIC STRINGS cEcA


    cD#![ \t]*/.*awkcA
        MicroEmacs 2009 recognises the magic string on the first line of the
        file used to locate the executable. The awk files may be extensionless
        and are still recognised.


cEcEDESCRIPTION cEcA


    The cDawkcA file type template provides simple hilighting of AWK files, the
    template provides minimal hilighting.


cEcEBUGS cEcA


    None reported. Template could probably benifit from some form of auto
    indentation.


cEcESEE ALSO cEcA


    lsMicroEmacs - Supported File TypeslmSupported File Typesle
! 9 fvwm
! 9 fvwmrc
cEcESYNOPSIS cEcA


    fvwm, fvwmrc - FVWM Window manager configuration files


cEcEFILES cEcA


    cDhkfvwm.emfcA - FVWM configuration file hook definition


cEcEEXTENSIONS cEcA


    cD.fvwmcA, cD.fvwmrccA - FVWM configuration file


cEcEMAGIC STRINGS cEcA


    cD-!- fvwm -!-cA
        The embedded fvwm string may be used with later versions of fvwm which
        use a different file extension to force the hilighting of the file.


cEcEDESCRIPTION cEcA


    The cDfvwmcA file type template provides simple hilighting of the FVWM files,
    the template provides minimal hilighting.


cEcEBUGS cEcA


    None reported.


cEcESEE ALSO cEcA


    lsMicroEmacs - Supported File TypeslmSupported File Typesle
! 9 sh
! 9 ksh
! 9 csh
! 9 zsh
! 9 login
! 9 profile
! 9 tcshrc
cEcESYNOPSIS cEcA


    *sh - UNIX shell files


cEcEFILES cEcA


    cDhkshell.emfcA - UNIX shell file hook definition


cEcEEXTENSIONS cEcA


    cD.shcA - Bourne shell file
    cD.kshcA - Korn shell file
    cD.cshcA - C-Shell file
    cD.zshcA - Z-Shell file
    cD.logincA - Shell user login file
    cD.profilecA - Shell user profile
    cD.tcshrccA - T-Shell start up file


cEcEMAGIC STRINGS cEcA


    cD#![ \t]*/.*shcA
        MicroEmacs 2009 recognizes the magic string on the first line of the
        file used to locate the executable. The shell files may be extension
        less and are still recognized. Note that this is the typical method of
        identifying shell files and will recognize other files not mentioned
        above i.e. cDbashcA shells.


cEcEDESCRIPTION cEcA


    The cDshellcA file type template provides simple hilighting of the shell
    files.


cEcEBUGS cEcA


    None reported.

    There is a heavy bias towards Bourne, Korn and Zsh shells. The author is
    not a csh shell user so has probably missed a lot of csh features.


cEcESEE ALSO cEcA


    lslmfvwm(9)le.

    lsMicroEmacs - Supported File TypeslmSupported File Typesle
! 9 java
! 9 jav
cEcESYNOPSIS cEcA


    java - Java programming language templates


cEcEFILES cEcA


    cDhkjava.emfcA - Java programming language hook definition
    cDjava.etfcA - Java programming language template file


cEcEEXTENSIONS cEcA


    cD.javacA, cD.javcA - Java


cEcEDESCRIPTION cEcA


    The cDjavacA file type templates share much with the lslmc(9)le template
    definitions, utilising the electric 'C' features for automatic layout of
    text.

    cDGeneral EditingcA
        On creating a new file, a new header is automatically included into
        the file. lslmtime(2m)le is by default enabled, allowing the modification
        time-stamp to be maintained in the header.

    cDHilightingcA
        The hilighting features allow commands, variables, logical,
        preprocessor definitions, comments, strings and characters of the
        language to be differentiated and rendered in different colors.

    cDAuto LayoutcA
        The C-Mode lslmindent(2)le performs automatic layout of the text.

        lslmrestyle-region(3)le and lslmrestyle-buffer(3)le are available to reformat
        (re-layout) selected sections of the buffer, or the whole buffer,
        respectively.

        Comments may be formatted using cGesc ocA, which reformats the comments
        according to the current fill paragraph. If a comment commences with
        cG/***...cA then the comment is automatically formatted to a box.

    cDFolding and Information HidingcA
        Generic folding is enabled within the Java files. The folds occur
        about braces cD{cA...cD}cA located on the left-hand margin. lslmcollapse-all(3)le
        (un)folds all regions in the file, lslmcollapse-current(3)le (un)folds the
        current region. Note that folding does not operate on K&R style code,
        with the trailing open brace.

    cDTagscA
        A c-tags file may be generated within the editor using the cDToolscA ->
        cDJava-ToolscA -> cDCreate Tag FilecA. lslmfind-tag(2)le takes the user to the file
        using the tag information.

        On invoking the tag generator then the user is presented with a dialog
        box which specifies the generation option of the tags file. The base
        directory of the tags file search and tagging options may be specified
        to locate all of the definitions within the code space.

        The cDtagscA file is extremely useful where the user is dealing with
        inherited source code spread over multiple directories. Generation of
        a recursive tag file with all searching options enabled allows labels
        to be located extremely rapidly (certainly faster than IDE
        environments).

    cDFolding and Information HidingcA
        Generic folding is enabled within the C and C++ files. The folds occur
        about braces cD{cA...cD}cA located on the left-hand margin. lslmcollapse-all(3)le
        (un)folds all regions in the file, lslmcollapse-current(3)le (un)folds the
        current region. Note that folding does not operate on K&R style code.

        The cDToolscA -> cDC-ToolscA menu allows cG#definecA's to be evaluated within the
        buffer. Where the state of a cG#ifcA is established to be false (using the
        cG#definecA information) then the disabled region of code is grayed out
        indicating which regions of the code are active.

    cDWorking EnvironmentcA
        lslmcompile(3)le may be invoked to rebuild the source, the user is prompted
        to save any files.

        lslmrcs-file(2)le is automatically invoked if an RCS file is detected, the
        normal check-in/out operations may be performed through the editor.

    cDShort CutscA
        The short cut keys used within the buffer are:-

        cDC-c C-ccA - Comment out the current line.
        cDC-c C-dcA - Uncomment the current line.
        cDC-c C-ecA - Comment to the end of the line with stars (*).
        cDA-C-icA - Restyle the current region.
        cDesc qcA - Format a comment.
        cDesc ocA - Format a comment.
        cDf2cA - (un)fold the current region
        cDf3cA - (un)fold all regions


cEcENOTES cEcA


    The hilighting is typically extended using a file cDmyjava.emfcA


cEcESEE ALSO cEcA


    lslmc(9)le, lslmcollapse-all(3)le, lslmcollapse-current(3)le, lslmcompile(3)le, lslmfind-tag(2)le,
    lslmfind-tag(2)le, lslmjavatags(3f)le, lslmrcs-file(2)le, lslmrestyle-buffer(3)le,
    lslmrestyle-region(3)le, lslmtime(2m)le.

    lsMicroEmacs - Supported File TypeslmSupported File Typesle
! 9 tcl
! 9 tk
! 9 wish
cEcESYNOPSIS cEcA


    tcl, tk - TCL Programming language templates


cEcEFILES cEcA


    cDhktcl.emfcA - TCL/TK programming language hook definition
    cDtcl.etfcA - TCL/TK programming language template file


cEcEEXTENSIONS cEcA


    cD.tclcA, cD.tkcA - TCL/TK file


cEcEMAGIC STRINGS cEcA


    cD^#![ \t]*/.*wishcA
        MicroEmacs 2009 recognizes the magic string on the first line of the
        file used to locate the executable. The tcl files may be extension
        less and are still recognized.


cEcEDESCRIPTION cEcA


    The cDtclcA provides hilighting and automatic formatting features, in addition
    to a number of tools to handle the file type.

    cDGeneral EditingcA
        On creating a new file, a new header is automatically included into
        the file. lslmtime(2m)le is by default enabled, allowing the modification
        time-stamp to be maintained in the header.

    cDHilightingcA
        The hilighting features allow commands, variables, logical,
        preprocessor definitions, comments, strings and characters of the
        language to be differentiated and rendered in different colors.

    cDAuto LayoutcA
        The lsindent(2)lmindentation mechanismle is enabled which performs automatic layout
        of the text. lslmrestyle-region(3)le and lslmrestyle-buffer(3)le are available to
        reformat (re-layout) selected sections of the buffer, or the whole
        buffer, respectively.

    cDTagscA
        A C-tags file may be generated within the editor using the cDToolscA ->
        cDTcl-ToolscA -> cDCreate Tag FilecA. lslmfind-tag(2)le takes the user to the file
        using the tag information.

    cDFolding and Information HidingcA
        Generic folding is enabled within the C and C++ files. The folds occur
        about braces cD{cA...cD}cA located on the left-hand margin. lslmcollapse-all(3)le
        (un)folds all regions in the file, lslmcollapse-current(3)le (un)folds the
        current region. Note that folding does not operate on K&R style code.

    cDShort CutscA
        The short cut keys used within the buffer are:-

        cDC-c C-ccA - Comment out the current line.
        cDC-c C-dcA - Uncomment the current line.
        cDC-c C-ecA - Comment to the end of the line with stars (*).
        cDA-C-icA - Restyle the current region.
        cDf2cA - (un)fold the current region
        cDf3cA - (un)fold all regions


cEcESEE ALSO cEcA


    lslmcollapse-all(3)le, lslmcollapse-current(3)le, lslmfind-tag(2)le, lslmindent(2)le,
    lslmrestyle-buffer(3)le, lslmrestyle-region(3)le, lslmtcltags(3f)le, lslmtime(2m)le.

    lsMicroEmacs - Supported File TypeslmSupported File Typesle
! 9 asn.1
cEcESYNOPSIS cEcA


    asn.1 - ASN.1 File


cEcEFILES cEcA


    cDasn1.emfcA - asn.1 file hook definition
    cDans1.etfcA - Template file


cEcEEXTENSIONS cEcA


    cDasn1cA - ASN.1 files.


cEcEMAGIC STRINGS cEcA


    cD-!- asn.1 -!-cA
        Recognized by MicroEmacs only, defines the file to be a asn.1.


cEcEDESCRIPTION cEcA


    The cDasn1cA file type template handles the hilighting of the asn.1 files.

    cDGeneral EditingcA
        On creating a new file, a new header is automatically included into
        the file. lslmtime(2m)le is by default enabled, allowing the modification
        time-stamp to be maintained in the header.

        By default, cGTABcA's are enabled as this is the syntactical feature of
        the file.

    cDHilightingcA
        The hilighting emphasizes the keywords and comments within the asn.1.


cEcEBUGS cEcA


    None reported.


cEcESEE ALSO cEcA


    lslmtime(2m)le.

    lsMicroEmacs - Supported File TypeslmSupported File Typesle
! 9 erf
cEcESYNOPSIS cEcA


    erf - MicroEmacs registry file


cEcEFILES cEcA


    cDhkerf.emfcA - MicroEmacs registry file.


cEcEEXTENSIONS cEcA


    cD.erfcA, cD*registry*cA


cEcEDESCRIPTION cEcA


    The cDerfcA file type template performs the hilighting of the registry file.

    cDHilightingcA
        The hilighting features allows components of the language to be
        differentiated and rendered in different colors.

    cDAuto LayoutcA
        The lsindent(2)lmindentation mechanismle is enabled which performs automatic layout
        of the text. lslmrestyle-region(3)le and lslmrestyle-buffer(3)le are available to
        reformat (re-layout) selected sections of the buffer, or the whole
        buffer, respectively.


cEcESEE ALSO cEcA


    lslmlist-registry(2)le, lslmerf(8)le.

    lsMicroEmacs - Supported File TypeslmSupported File Typesle
! 9 man
cEcESYNOPSIS cEcA


    man - UNIX Manual page


cEcEFILES cEcA


    cDhkman.emfcA - UNIX manual page hook definition


cEcEEXTENSIONS cEcA


    cD.mancA - UNIX manual page file


cEcEDESCRIPTION cEcA


    The cDmancA provides the hilighting of UNIX manual pages, generally acquired
    through the lslmman(3)le command, via a pipe. cCmancA references within the
    displayed manual page may be accessed using the mouse in a hypertext
    fashion.

    cDHilightingcA
        The hilighting commands recognize the manual page cCboldcA and cCunderlinecA
        character sequences and transpose these into the appropriate character
        hilighting. The hilighting sequences are generally unpleasant because
        they also remove the characters for display.

        The multitude of different platforms causes problems as different
        vendors produce different character sequences for cCboldcA/cCitaliccA text,
        hence on some platforms it may be necessary to add additional
        hilighting rules to cater for any local variations.

    cDShort CutscA
        Selecting a link node within the manual page using the mouse (i.e. a
        reference to another manual page) then MicroEmacs 2009 attempts to
        find the manual page in the text and invokes lslmman(3)le to render the
        page. This provides a crude hyper text mechanism simply using the
        manual page information itself.
            The lslmman-clean(3)le command can be used to remove all of the
            hilighting characters from the current manual page. This is the
            typical method of reducing a manual page to plain text.


cEcESEE ALSO cEcA


    lslmman(3)le, lslmman-clean(3)le,

    lsMicroEmacs - Supported File TypeslmSupported File Typesle
! 9 vrml
cEcESYNOPSIS cEcA


    vrml - VRML File


cEcEFILES cEcA


    cDhkvrml.emfcA - VRML File hook definition


cEcEEXTENSIONS cEcA


    cC<none>cA - Uses the cCMagic StringcA only.


cEcEMAGIC STRINGS cEcA


    cD#VRMLcA
        A generic tag that appears on the first line at the top of a cDVRMLcA (or
        cDwrlcA) file. MicroEmacs automatically recognises the tag and adopts the
        appropriate mode.


cEcEDESCRIPTION cEcA


    The cDvrmlcA file type template handles the hilighting of cDVRMLcA files.

    cDHilightingcA
        The hilighting features allow commands, variables, logical, comments,
        strings and characters of the language to be differentiated and
        rendered in different colors.

    cDAuto LayoutcA
        The lsindent(2)lmindentation mechanismle is enabled which performs automatic layout
        of the text. lslmrestyle-region(3)le and lslmrestyle-buffer(3)le are available to
        reformat (re-layout) selected sections of the buffer, or the whole
        buffer, respectively.

    cDShort CutscA
        The short cut keys used within the buffer are:-

        cDA-C-tabcA - Restyle a region.


cEcEBUGS cEcA


    No bugs reported


cEcESEE ALSO cEcA


    lslmindent(2)le, lslmrestyle-buffer(3)le, lslmrestyle-region(3)le.

    lsMicroEmacs - Supported File TypeslmSupported File Typesle
! 9 perl
! 9 pl
! 9 pm
cEcESYNOPSIS cEcA


    perl - Practical Extraction and Report Language File.


cEcEFILES cEcA


    cDhkperl.emfcA - Practical Extraction and Report Language file hook definition
    cDperl.etfcA - Practical Extraction and Report Language header template file.
    cDperl.eafcA - Practical Extraction and Report Language abbreviation file.


cEcEEXTENSIONS cEcA


    cD.plcA, cD.pmcA - Perl file


cEcEMAGIC STRINGS cEcA


    cD#![ \t]*/.*perlcA
        MicroEmacs 2009 recognizes the magic string on the first line of the
        file used to locate the executable. The Perl files may be
        extension-less and are still recognized.

    cD# -*- perl -*-cA
        MicroEmacs 2009 recognizes the standard GNU Emacs magic string on the
        first line of the file. The Perl files may be extension-less and are
        still recognized.


cEcEDESCRIPTION cEcA


    The cDperlcA file type template provides the hilighting, indentation and tools
    definitions for a perl file.

    File recognition is performed using the standard file extension cD.plcA, cD.pmcA
    or by the magic string.

    cDGeneral EditingcA
        On creating a new file, a new header is automatically included into
        the file. lslmtime(2m)le is by default enabled, allowing the modification
        time-stamp to be maintained in the header.

    cDHilightingcA
        The hilighting features allow commands, variables, logical, comments,
        strings and characters of the language to be differentiated and
        rendered in different colors.

    cDAuto LayoutcA
        The lsindent(2)lmindentation mechanismle is enabled which performs automatic layout
        of the text. lslmrestyle-region(3)le and lslmrestyle-buffer(3)le are available to
        reformat (re-layout) selected sections of the buffer, or the whole
        buffer, respectively.

    cDFolding and Information HidingcA
        Generic folding is enabled within perl files. The folds occur about
        cCsubcA...cD}cA located on the left-hand margin. lslmcollapse-all(3)le (un)folds all
        regions in the file, lslmcollapse-current(3)le (un)folds the current region.

    cDShort CutscA
        The short cut keys used within the buffer are:-

        cDC-c C-ccA - Comment out the current line.
        cDC-c C-dcA - Uncomment the current line.
        cDC-c esc esc cA- Command complete.
        cDA-C-icA - Restyle the current region.
        cDf2cA - (un)fold the current region
        cDf3cA - (un)fold all regions

    cDDebuggingcA
        Debugging a perl script can be done inside MicroEmacs by using the
        lslmperldb(3)le command.


cEcEBUGS cEcA


    The flexibility of the perl language does cause some hilighting anomalies
    from time to time, typically with unbalanced quote characters. Most of the
    common exceptions have been caught, however there are a few syntax
    sequences that involve quotation marks that can cause problems.


cEcESEE ALSO cEcA


    lslmcollapse-all(3)le, lslmcollapse-current(3)le, lslmindent(2)le, lslmperldb(3)le,
    lslmrestyle-buffer(3)le, lslmrestyle-region(3)le, lslmtime(2m)le.

    lsMicroEmacs - Supported File TypeslmSupported File Typesle
! 9 html
! 9 htm
cEcESYNOPSIS cEcA


    html - HyperText Markup Language File.


cEcEFILES cEcA


    cDhkhtml.emfcA - HyperText Markup Language file hook definition


cEcEEXTENSIONS cEcA


    cD.htmcA, cD.htmlcA - HyperText Markup Language File.
    cD.htpcA - cC[Special]cA Super HTML Preprocessor file.
    cD.htscA - cC[Special]cA Super HTML file.


cEcEMAGIC STRINGS cEcA


    cD<html>cA
        MicroEmacs 2009 recognizes the magic string on any of the first 4
        lines of the file. The HTML files may be extension-less and are still
        recognized.


cEcEDESCRIPTION cEcA


    The cDhtmlcA file type template provides simple hilighting of HTML files.
    Additionally, MicroEmacs 2009 is capable of rendering simple HTML files
    (without graphic content) into the current buffer and follow the hyper
    text links. The JASSPA HTML documentation may be viewed in this way.

    cDGeneral EditingcA
        HTML files may be edited or processed and rendered into the buffer.
        The cDUse Author ModecA option in the lslmbuffer-setup(3)le dialog determines
        the edit mode on loading a HTML file; when set to 'cGNcA' the page is
        rendered, 'cGYcA' and the raw HTML file is presented. The default state is
        'cGYcA'.

    cDHilightingcA
        The hilighting features allow commands, variables, logical,
        preprocessor definitions, comments, strings and characters of the
        language to be differentiated and rendered in different colors.

    cDShort CutscA
        The short cut keys used within the buffer are:-

        cDC-c C-hcA - Help information.
        cDC-c C-acA - Toggle the HTML author status.
        cDhtml-spell-check-wordcA - spell check the current word.

    cDRendered ModecA
        In the non-author mode, the HTML file is extracted and rendered to the
        buffer. The hypertext links may be followed by selecting them with the
        mouse or using the cG<RETURN>cA key.

        The rendered mode is typically used to check HTML text after it has
        been authored from the editor. The rendered mode only caters for
        regular HTML 2.0 text. It does not handle tables or frames etc. cC(use a
        browser)cA.

        Toggling between rendered and authoring mode, then the buffer should
        be killed as the translation is only performed when the file is read.

        The non-author mode can be permanently enabled by setting the cDUse
        Author ModecA option in the lslmbuffer-setup(3)le dialog to 'cGNcA'. When set to N
        any HTML files loaded are automatically processed, and rendered
        according to their HTML content.


cEcENOTES cEcA


    The lsprint-buffer(2)lmprintle driver may be used to generate HTML from the contents of the
    buffer. Select the printer destination as cCbuffercA, and cCHTMLcA as the driver.
    The buffer being printed is converted to HTML and dumped in the print
    buffer.

    cD.htscA and cD.htpcA are computer generated extended HTML files used in the
    MicroEmacs 2009 documentation system.


cEcEBUGS cEcA


    None reported.


cEcESEE ALSO cEcA


    lslmprint-buffer(2)le, lslmbuffer-setup(3)le.

    lsMicroEmacs - Supported File TypeslmSupported File Typesle
! 9 nroff
! 9 troff
! 9 0-9
! 9 tni
! 9 so
! 3 tex2nr
! 3 aman
cEcESYNOPSIS cEcA


    0-9, tni, so - UNIX t/nroff file.


cEcEFILES cEcA


    cDhknroff.emfcA - UNIX t/nroff file.
    cDnroff.etfcA - UNIX t/nroff template file
    cDntags.emfcA - t/nroff tags generator macro definition.


cEcEEXTENSIONS cEcA


    cD1cA, cD2cA, cD3cA, cD4cA, cD5cA, cD6cA, cD7cA, cD8cA, cD9cA - UNIX t/nroff files.
    cDtnicA, cDsocA - UNIX t/nroff include files.
    cDsmcA - cC[Special]cA Superman t/nroff file.


cEcEMAGIC STRINGS cEcA


    cD-*- nroff -*-cA
        Recognized by GNU and MicroEmacs. Denotes a t/nroff type file, may be
        used in cD.1cA/cD.9cA, cD.tnicA and cD.socA files.


cEcEDESCRIPTION cEcA


    The cDnroffcA file type templates handle UNIX n/troff type files.

    cDGeneral EditingcA
        On creating a new file, a new header is automatically included into
        the file. lslmtime(2m)le is by default enabled, allowing the modification
        time-stamp to be maintained in the header.

    cDHilightingcA
        The hilighting features allow commands, variables, logical,
        preprocessor definitions, comments, strings and characters of the
        language to be differentiated and rendered in different colors.

    cDTagscA
        A C-tags file may be generated within the editor using the cDToolscA ->
        cDNroff-ToolscA -> cDCreate Tag FilecA. lslmfind-tag(2)le takes the user to the file
        using the tag information. The tags are generated using the cD.XIcA
        keyword, this may not be standard for all nroff pages.

    cDFolding and Information HidingcA
        Generic folding is enabled within the C and C++ files. The folds occur
        about sections cD.ScA[cDHScA]...cD.ScA[cDHScA] located on the left-hand margin.
        lslmcollapse-all(3)le (un)folds all regions in the file, lslmcollapse-current(3)le
        (un)folds the current region. Note that folding does not operate on
        K&R style code.

    cDToolscA
        The nroff buffer provides a facility to toggle the hilighting of the
        buffer on and off. If font change inserts are used (cD\fBcA, cD\fRcA, etc),
        then the enclosed cDboldcA and cCitaliccA regions are hilighted, hiding the
        escape sequences. This allows the nroff text to be viewed in a more
        representative rendered format.

        The local buffer command cDamancA invokes, the following command sequence
        (defined in cGhkmancA) to render a nroff cDmancA file into a buffer window;-

            soelim <file> | tbl -TX | neqn | nroff -man | col -x


        The command cDtex2nrcA attempts to convert a lslmlatex(9)le file into an nroff
        file. The cClatexcA escape sequences are converted into their nroff
        equivalents. The command is only made available when an Nroff file is
        loaded (as the command is defined in the cGhknroff.emfcA file).

    cDShort CutscA
        The short cut keys used within the buffer are:-

        cDC-c C-scA - Insert a font size escape character cD\S0cA.
        cDC-c C-rcA - Insert a roman font escape character cD\fRcA.
        cDC-c C-bcA - Insert a bold font escape character cD\fBcA.
        cDC-c C-icA - Insert a italic font escape character cD\fIcA.
        cDC-c C-ccA - Insert a courier font escape character cD\fCcA.
        cDC-c C-pcA - Insert a previous font escape character cD\fPcA.
        cDesc ocA, cDesc qcA - lslmfill-paragraph(2)le fills paragraph to next cG.XXcA command.
        cDC-c bcA - Bold region by inserting cD\fBcA .. cD\fRcA.
        cDC-c ccA - Courier region by inserting cD\fCcA .. cD\fRcA.
        cDC-c ccA - Italic region by inserting cD\fIcA .. cD\fRcA.
        cDC-c C-hcA - Toggle hilighting on/off.
        cDC-c C-&cA - Adds nroff padding cD\f&cA about words.
        cDC-x C-&cA - Removes nroff padding cD\f&cA about words.
        cDesc hcA - Nroff help.

        cDf2cA - (un)fold the current region
        cDf3cA - (un)fold all regions


cEcEBUGS cEcA


    The nroff language template is heavily biased towards the cDmancA macros only
    and includes all of the extension macros used for generating the JASSPA
    hypertext documentation.

    The template in the current form has been used entirely by JASSPA in
    generating all of the documentation (cDHTMLcA, cDWinhelpcA, cDehfcA, cDPostScriptcA) used
    by MicroEmacs 2009. It does not include all of the troff/nroff keywords,
    or keywords for any of the standard macro packages.

    The JASSPA documentation preparation tools are proprietary and have not
    been made publicly available.


cEcESEE ALSO cEcA


    lslmcollapse-all(3)le, lslmcollapse-current(3)le, lslmfill-paragraph(2)le, lslmfind-tag(2)le,
    lslmntags(3f)le, lslmtime(2m)le.

    lsMicroEmacs - Supported File TypeslmSupported File Typesle
! 9 info
cEcESYNOPSIS cEcA


    info - GNU Info File.


cEcEFILES cEcA


    cDinfo.emfcA - Info macro file.


cEcEEXTENSIONS cEcA


    No fixed extension, the root of the cCinfocA tree is specified by
    cG$INFOPATHcA/dir. The default search paths on different platforms are:-

        cGc:/infocA - MS-DOS and MS-Windows (all).
        cG/usr/local/infocA - All UNIX platforms.


cEcEDESCRIPTION cEcA


    The GNU cCinfocA files are handled by the command lslminfo(3)le which starts the
    info reader. This reads the initial info file cGdircA and initializes the cCinfocA
    file traversal. Where the cCinfocA directory is not in the aforementioned
    locations then the cG$INFOPATHcA environment variable should specify the base
    directory.

    The standard cCinfocA navigation keys are in effect within the cCinfocA buffers.
    The cCmousecA may also be used to select the next info page.


cEcEBUGS cEcA


    There is no support within MicroEmacs 2009 to regenerate the cCinfocA tags and
    indexes.


cEcESEE ALSO cEcA


    lslminfo(3)le.

    lsMicroEmacs - Supported File TypeslmSupported File Typesle
! 9 cbl
cEcESYNOPSIS cEcA


    cbl - Cobol (85) files


cEcEFILES cEcA


    cDhkcobol.emfcA - Cobol (85) hook definition
    cDcobol.etfcA - Cobol (85) template file.


cEcEEXTENSIONS cEcA


    cD.cblcA - Cobol file


cEcEMAGIC STRINGS cEcA


    cD-*- cobol -*-cA
        Recognized by MicroEmacs and GNU Emacs, defines the file to be a cobol
        file.


cEcEDESCRIPTION cEcA


    The cDcblcA file type templates provide simple hilighting of Cobol 85 files,
    the template provides minimal hilighting the language syntax.


cEcENOTES cEcA


    No special language features are provided within the language syntax
    definition.


cEcEBUGS cEcA


    The Fortran hilight file is in it's infancy and a number of it's tokens
    may be misplaced.


cEcESEE ALSO cEcA


    lsMicroEmacs - Supported File TypeslmSupported File Typesle
! 9 x86
cEcESYNOPSIS cEcA


    x86 - Intel .x86 Assembler File


cEcEFILES cEcA


    cDhkasmx86.emfcA - Intel .x86 Assembler hook definition
    cDasmx86.etfcA - Intel .x86 Assembler template file.


cEcEEXTENSIONS cEcA


    cD.x86cA - Intel .x86 Assembler File


cEcEMAGIC STRINGS cEcA


    cD-!- asmx86 -!-cA
        Recognized by MicroEmacs only, defines the file to be a Intel x86
        assembler file.


cEcEDESCRIPTION cEcA


    The cDx86cA file type template provides simple hilighting of Intel x86
    assembler files.

    cDHilightingcA
        The hilighting features allow commands, variables, logical, comments,
        strings and characters of the language to be differentiated and
        rendered in different colors.

    cDAuto LayoutcA
        The lsindent(2)lmindentation mechanismle is enabled which performs automatic layout
        of the text. lslmrestyle-region(3)le and lslmrestyle-buffer(3)le are available to
        reformat (re-layout) selected sections of the buffer, or the whole
        buffer, respectively.

    cDShort CutscA
        The short cut keys used within the buffer are:-

        cDC-c C-ccA - Comment out the current line.
        cDC-c C-dcA - Uncomment the current line.


cEcEBUGS cEcA


    None reported.


cEcESEE ALSO cEcA


    lslmindent(2)le, lslmrestyle-region(3)le lslmrestyle-buffer(3)le lslmasm(9)le

    lsMicroEmacs - Supported File TypeslmSupported File Typesle
! 9 asm
! 9 s
cEcESYNOPSIS cEcA


    asm, s - Assembler File


cEcEEXTENSIONS cEcA


    cD.scA - Platform specific assembler file.
    cD.asmcA - Platform specific assembler file.


cEcEDESCRIPTION cEcA


    The standard assembler file extensions cD.scA and cD.asmcA are by default not
    bound to any hook functions as they are platform specific. The user should
    define a default binding for the assembler file types as appropriate to
    the current platform and assembler development. i.e. for the Windows
    environment the lslmx86(9)le file type would be conditionally bound to the file
    e.g.
sB
        !if &seq $platform "win32"
            add-file-hook ".s .asm"             fhook-asmx86
        !endif

sA

cEcESEE ALSO cEcA


    lslmx86(9)le.
    lsfileHooks(2)lmFile Hooksle, lsMicroEmacs - Supported File TypeslmSupported File Typesle.
! 9 vb
! 9 bas
! 9 cls
cEcESYNOPSIS cEcA


    bas, cls - Visual Basic file


cEcEFILES cEcA


    cDhkvb.emfcA - Visual Basic macro file.


cEcEEXTENSIONS cEcA


    cD.bascA, cD.clscA


cEcEMAGIC STRINGS cEcA


    cD-!- msvb -!-cA


cEcEDESCRIPTION cEcA


    The cDVisual BasiccA template performs the hilighting of Visual Basic files.
    The file type is recognised by the standard extension, or by the inclusion
    of the magic string.

    cDHilightingcA
        The hilighting features allows components of the language to be
        differentiated and rendered in different colors.

    cDAuto LayoutcA
        The lsindent(2)lmindentation mechanismle is enabled which performs automatic layout
        of the text. lslmrestyle-region(3)le and lslmrestyle-buffer(3)le are available to
        reformat (re-layout) selected sections of the buffer, or the whole
        buffer, respectively. The default indentation setting is 2.


cEcESEE ALSO cEcA


    lsMicroEmacs - Supported File TypeslmSupported File Typesle
! 9 m4
cEcESYNOPSIS cEcA


    me - M4 Macro Processor


cEcEFILES cEcA


    cDhkm4.emfcA - M4 macro processor macro file.
    cDm4.etfcA - M4 macro processor header template file.


cEcEEXTENSIONS cEcA


    cD.m4cA


cEcEDESCRIPTION cEcA


    The cDM4 macro processorcA template performs simple hilighting of cD.m4cA files.
    The file type is recognized by the standard extension only.

    cDHilightingcA
        The hilighting features allows components of the language to be
        differentiated and rendered in different colors.


cEcENOTES cEcA


    The M4 hilighting is minimal, no other features have been implemented.


cEcESEE ALSO cEcA


    lsMicroEmacs - Supported File TypeslmSupported File Typesle
! 9 python
! 9 py
cEcESYNOPSIS cEcA


    python - Python Language File.


cEcEFILES cEcA


    cDhkpython.emfcA - Python Language file hook definition


cEcEEXTENSIONS cEcA


    cD.pycA - Python file


cEcEMAGIC STRINGS cEcA


    cD^#![ \t]*/.*env[ \t]+pythoncA
        MicroEmacs 2009 recognizes the magic string on the first line of the
        file used to locate the executable. The Python files may be
        extension-less and are still recognized.


cEcEDESCRIPTION cEcA


    The cDpythoncA file type template provides simple hilighting of Python files,
    the template provides minimal hilighting.

    File recognition is performed using the standard file extension cD.pycA, or by
    the magic string.


cEcEBUGS cEcA


    There would appear to be too much applied hilighting in this file, it
    could probably do with rationalizing.


cEcESEE ALSO cEcA


    lsMicroEmacs - Supported File TypeslmSupported File Typesle
! 9 scheme
! 9 scm
! 9 sch
cEcESYNOPSIS cEcA


    scheme - Scheme File.


cEcEFILES cEcA


    cDhkscheme.emfcA - Scheme file hook definition


cEcEEXTENSIONS cEcA


    cD.scmcA, cD.schcA - Scheme file


cEcEDESCRIPTION cEcA


    The cDschemecA file type template provides simple hilighting of Scheme files,
    the template provides minimal hilighting.

    File recognition is performed using the standard file extensions cD.scmcA or
    cD.schcA.


cEcENOTES cEcA


    JASSPA have no idea as to the state of this file hook definition.


cEcESEE ALSO cEcA


    lsMicroEmacs - Supported File TypeslmSupported File Typesle
! 9 MetaFont
! 9 mp
! 9 mf
cEcESYNOPSIS cEcA


    MetaFont/MetaPost - Meta Font and Post File.


cEcEFILES cEcA


    cDhkmeta.emfcA - MetaFont/MetaPost file hook definition


cEcEEXTENSIONS cEcA


    cD.mfcA - MetaFont file
    cD.mpcA - MetaPost file


cEcEDESCRIPTION cEcA


    The cDMetacA file type template provides simple hilighting of cDMetaFontcA (cG.mfcA)
    and cDMetaPostcA (cG.mpcA) files, the template provides minimal hilighting. The
    same hilighting definition is used for both file types.

    File recognition is performed using the standard file extensions.


cEcENOTES cEcA


    JASSPA have no idea as to the state of this file hook definition.


cEcESEE ALSO cEcA


    lsMicroEmacs - Supported File TypeslmSupported File Typesle
! 9 texinfo
! 9 texi
cEcESYNOPSIS cEcA


    texinfo - GNU Texinfo documentation file.


cEcEFILES cEcA


    cDhktexi.emfcA - Texinfo file hook definition


cEcEEXTENSIONS cEcA


    cD.texicA - Texinfo file


cEcEMAGIC STRINGS cEcA


    cD-*- texinfo -*-cA
        Recognized by GNU Emacs and MicroEmacs.


cEcEDESCRIPTION cEcA


    The cDtexinfocA file type template provides simple hilighting of GNU cDTexinfocA
    files (cG.texicA), the template provides minimal hilighting.

    File recognition is performed using the standard file extensions, or the
    magic string.


cEcENOTES cEcA


    This template file could benefit from some of the cGhklatex.emfcA technology
    for generating the cCinfocA file.


cEcESEE ALSO cEcA


    lsMicroEmacs - Supported File TypeslmSupported File Typesle
! 9 wiki
cEcESYNOPSIS cEcA


    Wiki - GNU Wiki File.


cEcEFILES cEcA


    cDhkwiki.emfcA - GNU Wiki file hook definition


cEcEMAGIC STRINGS cEcA


    cD-[*!]-[ \t]*mode: wiki.*-[*!]-cA


cEcEDESCRIPTION cEcA


    The cDWikicA file type template provides a editing environment for GNU Wiki
    files. The template provide highlighting and an Edit and View mode to
    allow the Wiki contents to be viewed.

    File recognition is performed using the GNU Emacs magic string.


cEcESEE ALSO cEcA


    lsMicroEmacs - Supported File TypeslmSupported File Typesle
! 9 apache
! 9 httpd.conf
cEcESYNOPSIS cEcA


    Apache - Apache httpd.conf configuration file


cEcEFILES cEcA


    cDhkapache.emfcA - Apache httpd.conf configuration file


cEcEEXTENSIONS cEcA


    cDhttpd.confcA - Apache configuration file


cEcEDESCRIPTION cEcA


    The cDApachecA file type template provides simple highlighting of the Apache
    cGhttpd.confcA file.

    cDHilightingcA
        The hilighting features allow commands, variables and operators of the
        language to be differentiated and rendered in different colors.

        Comments may be formatted using cGesc ocA, which reformats the comments
        according to the current fill paragraph.

    cDFolding and Information HidingcA
        Generic folding is enabled, the folds occur about bracketed constructs
        cD<...>cA...cD</...>cA located on the left-hand margin. lslmcollapse-all(3)le
        (un)folds all regions in the file, lslmcollapse-current(3)le (un)folds the
        current region.

    cDList ItemscA
        Item listing is available and the key constructs of the file may be
        listed in the cCitem-listcA.

    cDShort CutscA
        The short cut keys used within the buffer are:-

        cDesc hcA - Key binding help information.
        cDC-c C-ccA - Comment out the current line.
        cDC-c C-dcA - Uncomment the current line.
        cDC-c C-ecA - Comment to the end of the line with hash (#).
        cDC-c C-ocA - Format a comment
        cDf2cA - (un)fold the current region
        cDf3cA - (un)fold all regions
        cDf6cA - List items.
        cDesc f6cA - Close list items window.


cEcESEE ALSO cEcA


    lsMicroEmacs - Supported File TypeslmSupported File Typesle
! 9 samba
! 9 smb.conf
cEcESYNOPSIS cEcA


    Samba - Samba smb.conf configuration file


cEcEFILES cEcA


    cDhksamba.emfcA - Samba smb.conf configuration file


cEcEEXTENSIONS cEcA


    cDsmb.confcA - Samba configuration file


cEcEDESCRIPTION cEcA


    The cDSambacA file type template provides simple highlighting of the Samba
    cGsmb.confcA file.

    cDHilightingcA
        The hilighting features allow commands, variables, operators and
        comments of the language to be differentiated and rendered in
        different colors.

        Comments may be formatted using cGesc ocA, which reformats the comments
        according to the current fill paragraph.

    cDFolding and Information HidingcA
        Generic folding is enabled, the folds occur about bracketed constructs
        cD<...>cA...cD</...>cA located on the left-hand margin. lslmcollapse-all(3)le
        (un)folds all regions in the file, lslmcollapse-current(3)le (un)folds the
        current region.

    cDList ItemscA
        Item listing is available and the key constructs of the file may be
        listed in the cCitem-listcA.

    cDShort CutscA
        The short cut keys used within the buffer are:-

        cDesc hcA - Key binding help information.
        cDC-c C-ccA - Comment out the current line.
        cDC-c C-dcA - Uncomment the current line.
        cDC-c C-ecA - Comment to the end of the line with hash (#).
        cDC-c C-ocA - Format a comment
        cDf2cA - (un)fold the current region
        cDf3cA - (un)fold all regions
        cDf6cA - List items.
        cDesc f6cA - Close list items window.


cEcESEE ALSO cEcA


    lsMicroEmacs - Supported File TypeslmSupported File Typesle
! 9 verilog
! 9 v
cEcESYNOPSIS cEcA


    Verilog - Verilog hardware description language


cEcEFILES cEcA


    cDhkverilg.emfcA - Verilog hardware description language hook definition


cEcEEXTENSIONS cEcA


    cD.vcA - Verilog file


cEcEDESCRIPTION cEcA


    The cDVerilogcA file type template provides simple highlighting of the Verilog
    hardware description language. cD.vcA files are automatically recognized as
    Verilog files.

    cDHilightingcA
        The hilighting features allow commands, variables and operators of the
        language to be differentiated and rendered in different colors.

    cDCommentscA
        Comments may be formatted using cGesc ocA, which reformats the comments
        according to the current fill paragraph.

    cDShort CutscA
        The short cut keys used within the buffer are:-

        cDesc hcA - Key binding help information.
        cDC-c C-ccA - Comment out the current line.
        cDC-c C-dcA - Uncomment the current line.
        cDC-c C-ecA - Comment to the end of the line with hash (#).
        cDC-c C-ocA - Format a comment


cEcESEE ALSO cEcA


    lsMicroEmacs - Supported File TypeslmSupported File Typesle
! 9 xml
! 9 xsl
! 9 xul
! 3 xml-forward-tag
! 3 xml-backward-tag
! 3 xml-goto-matching-tag
! 3 xml-verify
cEcESYNOPSIS cEcA


    xml - Extensible Markup Language File.


cEcEFILES cEcA


    cDhkxml.emfcA - Extensible Markup Language file hook definition


cEcEEXTENSIONS cEcA


    cD.xmlcA - Extensible Markup Language File.
    cD.xslcA - Extensible Stylesheet Language file.
    cD.xulcA - XML User Interface Language file.


cEcEMAGIC STRINGS cEcA


    cD<?xml>cA
        MicroEmacs 2009 recognizes the magic string on any of the first line
        of the file. The XML files may be extension-less and are still
        recognized.


cEcEDESCRIPTION cEcA


    The cDxmlcA file type template provides simple hilighting of XML files.

    cDGeneral EditingcA
        On creating a new file, a new header is automatically included into
        the file. lslmtime(2m)le is by default enabled, allowing the modification
        time-stamp to be maintained in the header.

    cDHilightingcA
        The hilighting features allow commands, variables, logical,
        preprocessor definitions, comments, strings and characters of the
        language to be differentiated and rendered in different colors.

    cDEmbedded LanguagescA
        Support is provided for embedded code fragments in Java and Visual
        Basic.

    cDFolding and Information HidingcA
        Generic folding is enabled, the folds occur about bracketed constructs
        cD<...>cA...cD</...>cA located on the left-hand margin. lslmcollapse-all(3)le
        (un)folds all regions in the file, lslmcollapse-current(3)le (un)folds the
        current region.

    cDBuffer CommandscA
        cDxml-forward-tagcA and cDxml-backward-tagcA are provided to advance to the
        next cG<..>cA tag in the buffer.

        cDxml-goto-matching-tagcA finds the tag that matches the current tag.

        cDxml-verifycA verifies the syntax of the XML reporting tags that are not
        matched in addition to syntax errors in the tag attributes.

    cDSpellingcA
        Buffer spell checking is XML aware.

    cDCompletioncA
        Completion is enabled, cG</cAcDesc esc cAwill expand to the closing tag for
        the last tag that remains open.

    cDShort CutscA
        The short cut keys used within the buffer are:-

        cDesc hcA - Key binding help information.
        cDC-c C-ccA - Comment out the current line.
        cDC-c C-dcA - Uncomment the current line.
        cDC-c C-ecA - Comment to the end of the line with hash (#).
        cDC-c C-ocA - Format a comment


cEcEBUGS cEcA


    None reported.


cEcESEE ALSO cEcA


    lsMicroEmacs - Supported File TypeslmSupported File Typesle
! 9 ruby
! 9 rb
cEcESYNOPSIS cEcA


    Ruby - Ruby programming language


cEcEFILES cEcA


    cDhkruby.emfcA - Ruby programming language file hook definition


cEcEEXTENSIONS cEcA


    cD.rbcA - Ruby programming language


cEcEMAGIC STRINGS cEcA


    cD#![ \t]*/.*rubycA
        MicroEmacs 2009 recognizes the magic string on any of the first line
        of the file.

    cD-[*!]-[ \t]*ruby.*-[*!]-cA
        GNU Emacs magic string.

    The ruby files may be extension-less and are still recognized.


cEcEDESCRIPTION cEcA


    The cDrubycA file type template provides simple highlighting of Ruby files.

    cDGeneral EditingcA
        On creating a new file, a new header is automatically included into
        the file. lslmtime(2m)le is by default enabled, allowing the modification
        time-stamp to be maintained in the header.

    cDHighlightingcA
        The highlighting features allow commands, variables, logical,
        preprocessor definitions, comments, strings and characters of the
        language to be differentiated and rendered in different colors.

    cDFolding and Information HidingcA
        Generic folding is enabled, the folds occur about cDmodulecA and cDclasscA
        definitions located on the left-hand margin. lslmcollapse-all(3)le (un)folds
        all regions in the file, lslmcollapse-current(3)le (un)folds the current
        region.

    cDList ItemscA
        Item listing is available and the key constructs of the file may be
        listed in the cCitem-listcA.

    cDIndentationcA
        Automatic indentation is provided, including a buffer re-style.

    cDShort CutscA
        The short cut keys used within the buffer are:-

        cDesc hcA - Key binding help information.
        cDC-c C-ccA - Comment out the current line.
        cDC-c C-dcA - Uncomment the current line.
        cDC-c C-ecA - Comment to the end of the line with hash (#).
        cDC-c C-ocA - Format a comment
        cDf2cA - (un)fold the current region
        cDf3cA - (un)fold all regions
        cDf6cA - List items.
        cDesc f6cA - Close list items window.


cEcEBUGS cEcA


    In line redirection (i.e. cG<< EOLcA) can cause rendering and indent
    anomalies.

    The block documentation remains under indent control, this should be
    disabled.


cEcESEE ALSO cEcA


    lsMicroEmacs - Supported File TypeslmSupported File Typesle
! 9 ada
! 9 adb
! 9 ads
cEcESYNOPSIS cEcA


    Ada - Ada programming language


cEcEFILES cEcA


    cDhkada.emfcA - Ada programming language file hook definition


cEcEEXTENSIONS cEcA


    cD.adacA, cD.adbcA, cD.adscA - Ada programming language


cEcEDESCRIPTION cEcA


    The cDadacA file type template provides simple highlighting of Ada files.

    cDHighlightingcA
        The highlighting features allow commands, variables, logical,
        preprocessor definitions, comments, strings and characters of the
        language to be differentiated and rendered in different colors.

    cDShort CutscA
        The short cut keys used within the buffer are:-

        cDesc hcA - Key binding help information.
        cDC-c C-ccA - Comment out the current line.
        cDC-c C-dcA - Uncomment the current line.
        cDC-c C-ecA - Comment to the end of the line with hash (#).
        cDC-c C-ocA - Format a comment


cEcESEE ALSO cEcA


    lsMicroEmacs - Supported File TypeslmSupported File Typesle
! 9 php
! 9 php3
! 9 php4
! 9 phphtml
cEcESYNOPSIS cEcA


    php - PHP: Hypertext Preprocessor Language File.


cEcEFILES cEcA


    cDhkphp.emfcA - PHP: Hypertext Preprocessor file hook definition


cEcEEXTENSIONS cEcA


    cD.phpcA, cD.php3cA, cD.php4cA, cD.phphtmlcA - PHP: Hypertext Preprocessor Language
    Language File.


cEcEDESCRIPTION cEcA


    The cDphpcA file type template provides simple hilighting of the Open Source
    general-purpose scripting language PHP files. PHP is typically used
    embedded within lslmhtml(9)le files.

    cDList ItemscA
        Item listing is available and the key constructs of the file may be
        listed in the cCitem-listcA.

    cDShort CutscA
        The short cut keys used within the buffer are:-

        cDesc hcA - Key binding help information.
        cDC-c C-ccA - Comment out the current line.
        cDC-c C-dcA - Uncomment the current line.
        cDC-c C-ecA - Comment to the end of the line with hash (#).
        cDC-c C-ocA - Format a comment
        cDf6cA - List items.
        cDesc f6cA - Close list items window.


cEcEBUGS cEcA


    None reported.


cEcESEE ALSO cEcA


    lsMicroEmacs - Supported File TypeslmSupported File Typesle
! 9 asp
cEcESYNOPSIS cEcA


    asp - Active Server Pages.


cEcEFILES cEcA


    cDhkasp.emfcA - Active Server Pages file hook definition


cEcEDESCRIPTION cEcA


    The cDaspcA file type template provides simple hilighting of Active Server
    Pages embedded within lslmhtml(9)le files.


cEcESEE ALSO cEcA


    lsMicroEmacs - Supported File TypeslmSupported File Typesle
! 9 cfml
! 9 cfm
! 9 cfc
cEcESYNOPSIS cEcA


    cfm - ColdFusion Markup Language.


cEcEFILES cEcA


    cDhkcfm.emfcA - ColdFusion file hook definition.
    cDhkcfms.emfcA - ColdFusion script file hook definition.


cEcEDESCRIPTION cEcA


    The cDcmfcA file type template provides simple hilighting and indentation of
    Adobe Macromedia ColdFusion pages embedded within lslmhtml(9)le files. The
    keywords from cDColdFusion MX 7cA are supported.

    The template supports highlighting and indention of the tags cG<cfxxx>cA in
    addition to cG<cfscript>cA blocks and cG<cfquery>cA SQL blocks.


cEcESEE ALSO cEcA


    lslmhtml(9)le, lsMicroEmacs - Supported File TypeslmSupported File Typesle
! 9 jst
cEcESYNOPSIS cEcA


    jst - JASSPA Structured Text


cEcEFILES cEcA


    cDhkjst.emfcA - Jasspa structured text file hook definition.


cEcEDESCRIPTION cEcA


    JASSPA Structured Text (cDjstcA) is an ASCII text format which includes some
    reserved text constructs that allow quite complex word processor type
    documents to be constructed with the minimal amount of additional
    annotation and which remains readable in its raw ASCII form. The
    motivation for doing this is to quickly construct documents and notes for
    publication whilst editing within MicroEmacs.

    cDJSTcA is a richer mark-up than the simpler lslmdoc(9)le file type.

    The main requirements of JST are:

        * Easy to remember.
        * Easily readable and can be highlighted well in MicroEmacs.
        * Well defined, i.e. not ambiguous so formating errors can be
          generated.
        * Extendable.
        * May be automatically reformatted.
        * Handle things like figure references and internal anchor and
          references.
        * Html and LaTeX output, possibly rtf and text.

    The syntax definition used by JST is defined in the next section.

    The JST template extensions include a number of converters that will
    syntax check the text and then format and export the text to a new
    presentation format that may be imported into a word processor or used
    directly in the generated form.


cEcEBASIC SYNTAX cEcA


    The syntax of JST reserves basic character sequences which may be
    unambiguously interpreted into document styling. The basic syntax set
    allows a simple formatted document to be produced with the minimal amount
    of work from the author.

    JST supports more advanced extensions which allow tables and hypertext
    tags to be defined, these are discussed in the cDAdvancedcA cDSyntaxcA section
    later.


cEQuoting cA


    To ensure that all characters may be input as typed then there is no
    single escape character. The character sequence cD&[cAcC<char>cAcD]cA may be used to
    escape a character cC<char>cA. Our experience is that escaping is not usually
    necessary.


cEBasic Styling cA


    The basic character styling is performed with a pair of escape characters
    at the start and end of a string sequence. The style end token does not
    have to appear on the same line as the start token and an error is
    reported if the sequence is not closed properly. Composite styles may be
    built buy combining the different tokens by inclusion of a new style
    within another style block. Where styles are nested then they should be
    closed in the reverse order that they were opened.

    cG""Raw Text""cA
        A pair of double quotes surrounding a text block is treated as
        verbatim and is not subject to escaping, that is the character format
        characters are not translated.

    cD**Bold Text**cA
        A pair of star characters denote a emboldened text region.

    cC//Italic Text//cA
        A forward slash pair denotes an italic text region.

    cD__Underline Text__cA
        A underscore pair denotes an underlined region.

    cG@@Mono Text@@cA
        A pair of at symbols denotes a fixed text region rendered in a fixed
        width font.

    ``Superscript Text``
        A pair of grave accents denotes superscript text region.

    ,,Subscript Text,,
        A pair of commas denotes a subscript text region.

    Styles may be nested i.e. cG//Italic **Bold Italic** Italic Again//cA To get
    raw text with a double quote use: cG""raw with a &["]" in it""cA


cEStyling Paragraphs and Blocks cA


    Blocks of text may be demarked by a single token at the start of the line.
    A exclamation mark 'cG!cA' at the start of a paragraph may be followed by one
    or more style letters to enable the style for the paragraph, for
    consistency with the in-line tokens then double characters may be used.

        !* As an example this baragraph is bold as it started with a '!*'.


    produces

        cDAs an example this baragraph is bold as it started with a '!*'.cA

    The exclamation mark may be followed by multiple different styles which
    are applied together. e.g.

        !"@ This paragraph  started with '!"@' so it is quoted and mono-spaced
        style, i.e. @@, "" or ** is ignored.


    You can enable a style over a block of text by using a 'cG!cA' style
    definition with no further text to the right. The block is terminated by a
    'cG!end!cA' or 'cG>end>cA' tag on its own line. It is recommended that you insert
    a blank line before and after the 'cG!end!cA' definition so that it does not
    affect the filling of the following paragraph.

        !end!


    Paragraphs may be associated with a literal block of text from a different
    programming language. These are introduced with a 'cG>type>cA' tag and end
    with a 'cG>end>cA' tag. The tag types that are currently supported include:

        cGemf   cA - JASSPA MicroEmacs Macro file.
        cGpseudocA - Pseudo code block.
        cGbnf   cA - BNF block.
        cGc     cA - ANSI C code block.
        cGcpp   cA - C++ code block.
        cGperl  cA - Perl code block.
        cGtcl   cA - TCL code block.
        cGshell cA - UNIX shell block.
        cGjava  cA - Java code block.
        cGini   cA - MS-DOS/Windows .ini code block
        cGphp   cA - PHP code block.
        cGmake  cA - Makefile fragment.

    The aforementioned blocks support syntax language highlighting and
    indentation. As an example:

            Some example 'C' code:
            >c>
            /* This is C code */
            int main (int argc, char *argv[])
            {
                printf ("Hello World\n");
                return 0;
            }
            >end>


cEJustification of Paragraphs and Blocks cA


    A paragraph is a block of text delimited by an empty line, by default all
    paragraphs are left justified. Where the layout of the paragraph is
    literal and should not be re-formatted then the paragraph should be
    proceeded by a 'cG>cA' symbol e.g.

        > This paragraph will not be reformatted
        because it starts with a '>', the
        output will respect the position of the new lines.


    Paragraphs may be center justified with a leading 'cG>ccA' e.g.

        >c This is centered text


    With centered text then the indentation of the 'cG>ccA' centers the text from
    the indent position. e.g.

                >c Note the initial indent level is important
                as the text is
                centered w.r.t. the remainder.


    Text may be right justified with a leading 'cG>rcA'.


cEIndentation cA


    Indentation is implicitly defined by the indentation of the first line of
    the paragraph, each paragraph is effectively independent with respect to
    determining the indentation level.

    The indentation level is defined to be the the column of the first
    non-white-space character of the first line divided by the cCIndentcA cCWidthcA
    (see indent-setup) rounded up. For example this the first non-white of
    this paragraph is the 'F' at column 4, with an indent width of 4 (the
    default) this is a an indent level of 1.

    A line starting with 6 spaces so it has an indent level of 2 (6/4 == 1.5
    which is rounded up to 2). Rounding up allows item lists to work with
    little effort, without introducing ambiguity, for example.

    The indentation of a code fragment or literal text block are determined by
    the indentation of the initial style tag, for example:

            >"@
            >c>
            int myVariable ;
            >end>
        >end>


    The code block is indented from the left paragraph by the starting block
    indent.


cEHeadings cA


    Headings may be defined and commence with a equals ('cG=cA') character as the
    first character of the line. The number of equals determines the heading
    level.

        = Top Level Heading
        == Sub-heading
        === Sub-sub-heading


    The position of the heading may be controlled and may be left, centered or
    right justified using cGlcA, cGccA or cGrcA respectively. Left justified is the
    default when not defined.

        =c Centered Top Level Heading
        ==r Right justified sub-heading


cEItem Lists cA


    Items lists are bullet or number lists of items which are introduced by a
    cCformatCharcAcD.cA to start the list, subsequent list items are introduced with a
    period 'cD.cA' character only or optionally with the bullet character. Where
    cCformatCharcA identifies the type of list as follows:

        cG*cA  - bullet list.
        cG1cA  - Numeric item list.
        cGacA  - Lowercase alphabetic list.
        cGAcA  - Uppercase alphabetic list.
        cGicA  - Roman numeral list.
        cGIcA  - Upper case Roman numeral list.
        cG:.cA - Text item list.

    Indentation and sub-paragraphs are supported within the paragraph. e.g.

         1. Start or a numbered list.

            Sub-paragraph of numbered list.

         2. 2nd item in numbered list

            *. Contained bullet list.

             . 2nd item of bullet list.

         . 3rd item in numbered list.


    The text item, or definition, requires some further explanation. This
    allows a definition item to be defined (e.g. glossary of terms at start of
    document or note points within a document). These are defined at column 0
    e.g.

        :. MyDefinition

           Description of the term.


cEcEADVANCED SYNTAX cEcA


    This section defiens the advanced syntax extensions of JST which allow
    more complex documents to be generated. These extensions may be used to
    author more complex documents for export.


cETables cA


    Quite complex tables may be supported through JST. A table is introduced
    with the closing square brace 'cD]cA character at the start of the line which
    define the ghlobal properties and dimensions of the table. Each entry in
    the table is introduced by 'cD]cA and is followed by the assigned content.

    The initial table definition has the syntax

        ]crh <# columns> <# rows>


    Where 'cDccA' and 'cDrcA' are optional and center or right justify the table, 'cDhcA'
    hides the table lines i.e. no border. The dimensions of the table then
    follow.

    A simple definition of a 3x2 table might be defined as:

        ] 3 2

        ] Row 1 col 1 content.

        ] Row 1 col 2 content.

        ] Row 1 col 3 content.

        ] Row 2 col 1 content.

        ] Row 2 col 2 content.

        ] Row 2 col 3 content.


    The content may include

        cG*.cA Use item lists
        cG. cA Like this
        cG!ccA Center text
        cG!rcA Right justify text
        cCalso embedded images, see later.cA
        Columns and rows may be joined both horizontally and vertically by
        specifying the join in the cell definition. 'cD]>'cA performs a horizontal
        cell join of two cells, a single 'cD>cA' should be added for each
        additional cell so 'cD]>>cA' joins 3 cells horizontally. A vertical join
        is similarly specified with 'cD]vcA'.

        ] 3 3

        ]>> Single top row with 3 columns joined content.

        ]v 2 rows joined in the first column content.

        ]> 2nd row 2nd and 3rd column joined content.

        ] 3rd row 2nd column content.

        ] 3rd row 3rd column content.


cESpecial Characters and Symbols cA


    Special characters are introduced with 'cD&[cAcCspecialcAcD]cA' and are defined as
    follows:

    cG&[nl]cA or cG&[new-line]cA
        Newline.

    cG&[np]cA or cG&[new-page]cA
        New page. This is not supported in HTML or text.

    cG&[nf]cA or cG&[new-file]cA
        New file, the effect is dependent on the output format:

        cDhtml cA
            Starts a new html file, typical use of this is when the first file
            contains the TOC with links to the subsequent files.

        cDlatex cA
            Just starts a new page, i.e. same as cD[[np]]cA.

        cDrtf cA
            Just starts a new page, i.e. same as cD[[np]]cA.

        cDtext cA
            Ignored.

    cG&[toc]cA
        Inserts an automatically generated table of contents.

    cG---cA
        Inserts a horizontal line. This must be the only text on the line.


cETags and Hyperlinks cA


    Most of the more complex formatting is performed with tags. The general
    format of a tag is defined as:

        cD&[cAcC<tag-id><options> <args>cAcD]cA

    If a argument contains a space or a 'cD]cA' then it must be quoted, e.g.:

        &[c this-is-okay]
        &[c "this is okay"]
        &[c "this [\"is\"] okay"]


    A tag may support numerous options, the order of the options is not
    important but the order of their arguments is as specified in the docs,
    not the order given with the tag therefore cD&[idw <image> <depth> <width>]cA
    is still cD&[iwd <image> <depth> <width>]cA. The text that actually appears in
    any generated document should not appear in a tag as the spelling check
    should skip the contents of a tag. This means that a link should take the
    HTML form of encasing the text label with start and end tags rather than
    being in the tag itself. One exception would be the setting of a variable.

    cDComment Tag cA
        Inserts a comment.

        cD&[ccA cC<0+args>cAcD]cA

        There may be any number of arguments, the whole tag is ignored. As the
        comment ends with a ']' and ']' char in the comment must be quoted,
        i.e.:

            &[c this is a comment with a "]" "char[23]" in it]


    cDAnchor Tag cA
        Internal document reference.

        cD&[acA cC<name>cAcD]cA

        An anchor tag can be placed anywhere and referenced by a link .

    cDForeground and Background Color Tag cA
        Modifies the color of the text foreground and background.

        cD&[fcA cC<color>cAcD]cA .... cD&[/f]cA

        Sets the current foreground color where cC<color>cA is either a direct
        HTML format color definition (e.g. "cG#ff0000cA" for cDredcA) or a previously
        defined color name.

        cD&[bcA cC<color>cAcD]cA .... cD&[/b]cA

        Sets similarly sets the current background color.

        A number of options are supported by the color tag as follows:

        cD&[fscA cC<name>cA cC<color>cAcD]cA
            Define color 'cC<name>cA' to be 'cC<color>cA', the cC<name>cA may be
            references in the cDfcA/cDbcA color references.

        cD&[fdcA cC<color>cAcD]cA
            Sets the default foreground color to cC<color>cA.

        cD&[bdcA cC<color>cAcD]cA
            Sets the default background color to cC<color>cA.

    cDLink Tag cA
        Link to another part of the document or URL.

        cD&[lcA cC<url>cAcD]cA .... cD&[/l]cA

        Creates a hyperlink with the text with 'cG....cA' going to the cC<url>cA, The
        format of the url uses the standard HTML syntax, a link starting with
        a hash 'cG#cA' is assumed to be local and a warning will be issued if the
        corresponding anchor point is not found. An error is generated if the
        cD&[/l]cA is missing.

        Urls appearing in the text like 'cGhttp://www.jasspa.comcA' are
        automatically turned into links. To avoid this quote the string, i.e.
        ""http://www.jasspa.com""

    cDImage Tag cA
        Insert an image in the document.

        cD&[icA cC<image-name>cAcD]cA

        Inserts an image cC<image-name>cA, for example cD&[i me.png]cA

        Additional options allow the depth and width of the image to be
        specified:

        cD&[idwcA cC<image-name> <depth> <width>cAcD]cA

        Where option cDdcA specifies the depth of image and cDwcA specifies the width
        of the image. e.g. cG&[iw test.jpg 60]cA. The size is given in pixels and
        the conversion variable 'cCimage-ppicA' is used to convert is a physical
        paper size. The width may also be specified as a percentage, e.g. cD50%cA.

    cDUse Tag cA
        Insert a file at the current point.
            cD&[ucA cC<file-name>cAcD]cA

        Inserts cC<file-name>cA into the current location and processes it as if
        part of the original docuement. e.g. cG&[ucA cGinsert.jst]cA inserts the file
        cCinsert.jstcA at the current position in the file.

    cDVariable Tag cA
        Insert a variable.

        cD&[vcA cC<variable-name>cAcD]cA

        Inserts the current value of variable cC<variable-name>cA, variable names
        may only contain alphanumeric characters and 'cG-cA'.

        The variable supports a set of simple options that allow the variable
        value to be manipulated prior to insertion e.g. for handling numbers
        etc. The option syntax is defined as follows:

        cD&[vdinrscA cC<variable-name>cA cC<value>cA cC<increment>cA cC<reference-name>cAcD]cA

        cDd cA
            Define the reference cC<reference-name>cA for the current value.

        cDi cA
            Pre-increment the variable value by cC<increment>cA prior to
            insertion.

        cDn cA
            Do not insert the variable value.

        cDr cA
            Insert the cC<reference-name>cA value.

        cDs cA
            Set the value to cC<value>cA first.

        As an example, consider the following sequence to implement figure
        labels and reference them:

            &[vsn figure 0]

            &[i figure1.jpg]
            Figure &[vid figure 1 figA] - my first figure

            some more text

            &[i figure2.jpg]
            Figure &[vid figure 1 figB] - my second figure

            To see  **figure &[vr figure  figA]** //my first  figure// and **figure
            &[vr figure figB]** //my second figure//.

            To see  **figure &[vr figure  figA]** //my first  figure// and **figure
            &[vr figure figB]** //my second figure//.


        An undefined variable has a value of "cGERRORcA", it can be defined by
        using either option 'cDscA' or 'cDicA' in which case the value is cG0cA, i.e. the
        following can be used

        cG= Chapter 1: Will be 1 at the top of the doccA

        A set of special variables are automatically defined:

        cDtitle cA
            The document title.

        cDauthor cA
            The author

        cDimage-ppi cA
            Image pixels per inch resolution setting, this is the resolution
            of the generated document in inches.

    cDOutput Dump Tag cA
        Dump output text.

        cD&[ocA cC<out-type> <raw-text>cAcD]cA

        Dumps cC<raw-text>cA into the output if the target output type is
        cC<out-type>cA, where cC<out-type>cA can be cDallcA, cDhtmlcA, cDlatexcA, cDrtfcA and cDtextcA.

    cDDump Tag cA
        Dumps the tag for processing.

        cD[dcA cC<out-type> <text>cAcD]cA

        This command is similar to Output Dump Tag except this is done first
        so the cC<text>cA is processed, this can be used to define output specific
        formatting, e.g. (note that the \ at the end of the line is used here
        to show that the content should be placed on a single line).

            &[d html "&[vsn large-font-start \"..html def..\"] \
                      &[vsn large-font-end \"..html def..\"]"]
            &[d latex "&[vsn large-font-start \"..latex def..\"] \
                       &[vsn large-font-end \"..latex def..\"]"]
            &[d text "&[vsn large-font-start \"\"]&[vsn large-font-end \"\"]"]


        so in the main body of the text:

            &[v large-font-start] Large Text &[v large-font-end]


        This is a complex concept and is beyond most users requirements, but
        making this kind of thing possible means that users should be able to
        do whatever they need to.


cEcETEMPLATE cEcA


    The template supports highlighting and indention including commands for
    exporting JST to another format:

    cDjst-to-htm cA
        Export the JST definition to an HTML file with cD.htmcA extension.

    cDjst-to-html cA
        Export the JST definition to an HTML file with cD.htmcA extension.

    cDjst-to-rtf cA
        Export the JST definition to an RTF file, for this export then the
        file name is cD.rtfcA but the content is HTML. cDWord(1)cA and cDStarOffice(1)cA
        know how to convert this when imported.

    cDjst-to-latex cA
        Convert to a LaTeX file format.


cEcEFILES cEcA


    JST is controlled by the macro files cGhkjst.emfcA which contains the basic
    template. cGjstutl.emfcA includes the utilities used for conversion to other
    formats.


cEcEINTERNAL FORMAT cEcA


    cDJSTcA uses an internal neutral format which is used in the conversion
    process, this allows different back end output format drivers to be
    written against the neutral format without dealing with the input syntax.
    This intermediate format is not visible to the user and does not exist in
    the output. The internal format is defined as follows:

    cD\bF?cA....cD\bf?cA
        Font style change where cD?cA is cDBcA,cDIcA,cDUcA,cDMcA,cDpcA,cDbcA).

    cD\bDD\bDFcAcC<color>cAcD\bDBcAcC<color>cAcD\bdDcA....cD\bDdcA
        Foreground or background color change where cC<color>cA = hexadecimal
        value cGRRGGBBcA. Note that cD\bDFcAcC<c>cA or cD\bDBcAcC<c>cA may be be omitted.

    cD\bITcAcC<image-name>cAcD\biTcA
        Insert an image without scaling.

    cD\bITcAcC<image-name>cAcD\bIDcAcC<depth>cAcD\biD\bIWcAcC<width>cAcD\biW\biTcA
        Insert an image with scaling.

    cD\bTAcAcC<anchor-name>cAcD\btAcA
        A local anchor label.

    cD\bTLcAcC<link-url>cAcD\btLcAcC<link-text>cAcD\bTlcA
        URL Link.

    cD\bTVcAcC<variable-name>cA_cC<variable-ref>cAcD\btVcA
        A variable name (temporary).

    cD\bSFcA
        Start new file.

    cD\bSLcA
        Start new line.

    cD\bSPcA
        Start new page.

    cD\bSNcA
        No-text symbol.

    cD\bSTcA
        Insert the table of content (temporary)

    cD\bPIcA
        Indent level.

    cD\bPTcA
        Indent tab level (used only in generated TOC).

    cD\bPBcA....cD\bpBcA
        Paragraph - justification both.

    cD\bPCcA....cD\bpCcA
        Paragraph - justification center.

    cD\bPFcA....cD\bpFcA
        Paragraph - File style block.

    cD\bPLcA....cD\bpLcA
        Paragraph - justification left.

    cD\bPNcA....cD\bpNcA
        Paragraph - justification none.

    cD\bPRcA....cD\bpRcA
        Paragraph - justification right.

    cD\bH#cA....cD\bh#cA
        Heading, e.g. cD\bH1cA....cD\bh1cA

    cD\bBIcAcD\bB?cA...cD\bb?cAcD\bB?cA...cD\bb?cAcD\bbIcA
        Item list start and end tags.

    cD\bBBcA....cD\bbBcA
        Bullet item.

    cD\bBN#cAcD\bBncA....cD\bbNcA
        Item # in numbered item list.

    cD\bBU#cAcD\bBucA....cD\bbUcA
        Item # in uppercase letter item list

    cD\bBL#cAcD\bBlcA....cD\bbLcA
        Item # in lowercase letter item list.

    cD\bBR#cAcD\bBrcA....cD\bbRcA
        Item # in uppercase roman numeral item list.

    cD\bBS#cAcD\bBscA....cD\bbScA
        Item # in lowercase roman numeral item list.

    cD\bCTcAcC<flags>cAcD\bCtcAcC<widths>cAcD\bctcA....cD\bcTcA
        Table - Entire table (contains rows).
        cC<flags>cA can be any of cDhcA, cDccA or cDrcA.
        cC<widths>cA is an ME list cG|no col|width table|width of col 1|width of col
        2|...|cA

    cD\bCRcA....cD\bcRcA
        Table - Row (contains columns)

    cD\bCCcA....cD\bcCcA
        Table - column (single cell)


cEcESEE ALSO cEcA


    lslmdoc(9)le, lsMicroEmacs - Supported File TypeslmSupported File Typesle
